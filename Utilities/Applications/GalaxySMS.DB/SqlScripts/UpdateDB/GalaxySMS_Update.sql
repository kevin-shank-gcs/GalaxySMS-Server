-- Script to be included in Sms Server Installation package to apply to the database
use GalaxySMS
go

IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[GCS].[gcsUser_BeforeIdentity]') AND type in (N'U'))
BEGIN
	DROP TABLE [GCS].[gcsUser_BeforeIdentity]
END
GO


CREATE OR ALTER FUNCTION dbo.[gcs_GetColumnDataType] (@schemaName nvarchar(65), @tableName nvarchar(65), @columnName nvarchar(65) )
RETURNS nvarchar(65)
as
begin
declare @dataType nvarchar(100)

	SELECT @dataType = DATA_TYPE
	FROM INFORMATION_SCHEMA.COLUMNS 
	WHERE TABLE_SCHEMA = @schemaName
	AND TABLE_NAME = @tableName 
	AND COLUMN_NAME = @columnName;

	return @dataType
end
go

GRANT EXECUTE ON dbo.[gcs_GetColumnDataType] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'dbo.[gcs_DeleteDefaultConstraint]') AND type in (N'P', N'PC'))
DROP PROCEDURE dbo.[gcs_DeleteDefaultConstraint]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [dbo].[gcs_DeleteDefaultConstraint]
	@schema_name [nvarchar](65),
	@table_name [nvarchar](65),
	@column_name [nvarchar](65)
WITH EXECUTE AS CALLER
AS
DECLARE @constraint_name nvarchar(255)
DECLARE @sql nvarchar(255)

  SELECT @constraint_name = sysobjects.name from sysobjects where sysobjects.id =
	(SELECT cdefault from syscolumns where syscolumns.name = @column_name AND 
	syscolumns.id = (SELECT sysobjects.id from sysobjects where sysobjects.name = @table_name AND 
	sysobjects.xtype = 'U') )
	AND sysobjects.xtype = 'D'
  BEGIN
--    print @table_name
--    print @COLUMN_NAME
    SET @sql = N'ALTER TABLE '
	if @schema_name is not null AND len(@schema_name) > 0
	BEGIN
		set @sql = @sql + @schema_name + '.'
	END
    SET @sql = @sql + @table_name
    SET @sql = @sql + N' DROP CONSTRAINT ' + @constraint_name
    print @sql
    execute sp_executesql @sql 
  END  
GO
ALTER AUTHORIZATION ON [dbo].[gcs_DeleteDefaultConstraint] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [dbo].[gcs_DeleteDefaultConstraint] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'dbo.[gcs_DeleteFKConstraint]') AND type in (N'P', N'PC'))
DROP PROCEDURE dbo.[gcs_DeleteFKConstraint]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [dbo].[gcs_DeleteFKConstraint]
	@schema_name [nvarchar](65),
	@table_name [nvarchar](65),
	@constraint_name [nvarchar](65)
WITH EXECUTE AS CALLER
AS
DECLARE @sql nvarchar(255)
	
  BEGIN
    SET @sql = N'ALTER TABLE '
	if @schema_name is not null AND len(@schema_name) > 0
	BEGIN
		set @sql = @sql + @schema_name + '.'
	END
    SET @sql = @sql + @table_name
    SET @sql = @sql + N' DROP CONSTRAINT ' + @constraint_name
    print @sql
	BEGIN TRY
	    execute sp_executesql @sql 

    END TRY
	BEGIN CATCH
		EXEC dbo.[gcs_GetErrorInfo] 0,1
    END CATCH;
  END  
GO
ALTER AUTHORIZATION ON [dbo].[gcs_DeleteFKConstraint] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [dbo].[gcs_DeleteFKConstraint] TO [public] AS [dbo]
GO

/****** Object:  StoredProcedure [dbo].[gcs_DeleteIndex]    Script Date: 8/31/2020 2:22:22 PM ******/

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'dbo.[gcs_DeleteIndex]') AND type in (N'P', N'PC'))
DROP PROCEDURE dbo.[gcs_DeleteIndex]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [dbo].[gcs_DeleteIndex]
	@schema_name [nvarchar](65),
	@table_name [nvarchar](65),
	@index_name [nvarchar](65)
WITH EXECUTE AS CALLER
AS
DECLARE @sql nvarchar(255)

  IF ( SELECT count(*) from sysindexes where sysindexes.name = @index_name AND
	sysindexes.id = 
	(SELECT sysobjects.id FROM sysobjects where sysobjects.name = @table_name AND sysobjects.xtype = 'U') ) = 1
  BEGIN
--    print @table_name
--    print @COLUMN_NAME
    SET @sql = N'DROP INDEX '
	if @schema_name is not null AND len(@schema_name) > 0
	BEGIN
		set @sql = @sql + @schema_name + '.'
	END
    SET @sql = @sql + @table_name
    SET @sql = @sql + N'.' + @index_name
    print @sql
    execute sp_executesql @sql 
  END  
GO
ALTER AUTHORIZATION ON [dbo].[gcs_DeleteIndex] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [dbo].[gcs_DeleteIndex] TO [public] AS [dbo]
GO

/****** Object:  StoredProcedure [dbo].[gcs_DeletePKConstraint]    Script Date: 8/31/2020 2:22:22 PM ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'dbo.[gcs_DeletePKConstraint]') AND type in (N'P', N'PC'))
DROP PROCEDURE dbo.[gcs_DeletePKConstraint]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [dbo].[gcs_DeletePKConstraint]
	@schema_name [nvarchar](65),
	@table_name [nvarchar](65),
	@constraint_name [nvarchar](65)
WITH EXECUTE AS CALLER
AS
DECLARE @sql nvarchar(255)

  IF ( SELECT count(*) from sysobjects where sysobjects.name = @constraint_name AND
	sysobjects.parent_obj = 
	(SELECT sysobjects.id FROM sysobjects where sysobjects.name = @table_name AND sysobjects.xtype = 'U')
	AND sysobjects.xtype = 'PK' ) = 1

  BEGIN
--    print @table_name
--    print @COLUMN_NAME
    SET @sql = N'ALTER TABLE '
	if @schema_name is not null AND len(@schema_name) > 0
	BEGIN
		set @sql = @sql + @schema_name + '.'
	END
    SET @sql = @sql + @table_name
    SET @sql = @sql + N' DROP CONSTRAINT ' + @constraint_name
    print @sql
    execute sp_executesql @sql 
  END  
GO
ALTER AUTHORIZATION ON [dbo].[gcs_DeletePKConstraint] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [dbo].[gcs_DeletePKConstraint] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'dbo.[gcs_DeleteTrigger]') AND type in (N'P', N'PC'))
DROP PROCEDURE dbo.[gcs_DeleteTrigger]
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [dbo].[gcs_DeleteTrigger]
	@schema_name [nvarchar](65),
--	@table_name [nvarchar](65),
	@trigger_name [nvarchar](65)
WITH EXECUTE AS CALLER
AS
DECLARE @sql nvarchar(255)
DECLARE @fullTriggerName nvarchar(1000)

set @fullTriggerName = @schema_name + '.' + @trigger_name
if exists (select 1
          from sysobjects
          where id = object_id(@fullTriggerName)
          AND type = 'TR')
	BEGIN
		SET @sql = N'drop trigger ' + @fullTriggerName
		    print @sql
		execute sp_executesql @sql 
	END
GO
ALTER AUTHORIZATION ON [dbo].[gcs_DeleteTrigger] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [dbo].[gcs_DeleteTrigger] TO [public] AS [dbo]
GO


CREATE OR ALTER FUNCTION [dbo].[TextToUniqueidentifier](@inputString nvarchar(100))
RETURNS uniqueidentifier WITH EXECUTE AS CALLER
AS 
BEGIN
DECLARE @uid uniqueidentifier = NULL
SET @uid = TRY_CAST(@inputString AS UNIQUEIDENTIFIER);

return @uid;
END
GO


/****** Object:  UserDefinedFunction [dbo].[fnSPLIT_UNIQUEIDENTIFIER]    Script Date: 8/31/2020 2:21:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER FUNCTION [dbo].[fnSPLIT_UNIQUEIDENTIFIER](@STRING [text], @DELIMITER [varchar](10))
RETURNS @VALUES TABLE (
	[UID_DATA] uniqueidentifier
) WITH EXECUTE AS CALLER
AS 
BEGIN

	DECLARE @CONTINUE CHAR(1)
	DECLARE @START_POS INT
	DECLARE @END_POS INT
	DECLARE @NEW_STRING VARCHAR(50)
	DECLARE @PAD TINYINT

	SELECT @CONTINUE = 'T', @START_POS = 1, @PAD = DATALENGTH(@DELIMITER)

	WHILE @CONTINUE = 'T'
	BEGIN
		SET @END_POS = CHARINDEX(@DELIMITER, @STRING, @START_POS)
		
		IF @END_POS = 0
		BEGIN
			SET @END_POS = DATALENGTH(@STRING) + 1
			SET @CONTINUE = 'F'

		END

		SET @NEW_STRING = RTRIM(LTRIM(SUBSTRING(@STRING, @START_POS, @END_POS - @START_POS)))

		IF dbo.TextToUniqueidentifier(@NEW_STRING) IS NOT NULL
		BEGIN
			INSERT INTO @VALUES SELECT @NEW_STRING
		END

		SET @START_POS = @END_POS + @PAD
	END

	RETURN

END
GO
ALTER AUTHORIZATION ON [dbo].[fnSPLIT_UNIQUEIDENTIFIER] TO  SCHEMA OWNER 
GO
GRANT SELECT ON [dbo].[fnSPLIT_UNIQUEIDENTIFIER] TO [public] AS [dbo]
GO








if dbo.fn_GCSDoesColumnExist('gcsApplication', 'Code') = 1
BEGIN
	ALTER TABLE GCS.gcsApplication DROP COLUMN Code
END
GO

if dbo.fn_GCSDoesColumnExist('gcsPermissionCategory', 'Code') = 1
BEGIN
	ALTER TABLE GCS.gcsPermissionCategory DROP COLUMN Code
END
GO

if dbo.fn_GCSDoesColumnExist('gcsPermission', 'Code') = 1
BEGIN
	ALTER TABLE GCS.gcsPermission DROP COLUMN Code
END
GO

CREATE OR ALTER FUNCTION [GCS].[fn_GetApplicationCode](@ApplicationId uniqueidentifier)
RETURNS nvarchar(max) WITH EXECUTE AS CALLER
AS 
BEGIN

	DECLARE @code nvarchar(max)
	DECLARE @appName nvarchar(65)

	select @appName = app.ApplicationName from GCS.gcsApplication app where app.ApplicationId = @ApplicationId

	set @appName = REPLACE(@appName, 'GalaxySMS', '')
	set @appName = REPLACE(@appName, ' ', '')
	set @appName = REPLACE(@appName, '.', '')
	set @appName = REPLACE(@appName, '/', '')
	set @appName = REPLACE(@appName, '-', '')

	RETURN @appName
END
GO
ALTER AUTHORIZATION ON [GCS].[fn_GetApplicationCode] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[fn_GetApplicationCode] TO [public] AS [dbo]
GO

if dbo.fn_GCSDoesColumnExist('gcsApplication', 'Code') = 0
BEGIN
	ALTER TABLE GCS.gcsApplication
	ADD Code as ([GCS].[fn_GetApplicationCode](ApplicationId))
END
go  


CREATE OR ALTER FUNCTION [GCS].[fn_GetPermissionCategoryCode](@PermissionCategoryId uniqueidentifier)
RETURNS nvarchar(max) WITH EXECUTE AS CALLER
AS 
BEGIN

	DECLARE @code nvarchar(max)
	DECLARE @appCode nvarchar(65)
	DECLARE @permCatName nvarchar(65)

	select @appCode = app.Code, @permCatName = pc.CategoryName from GCS.gcsPermissionCategory pc
	JOIN GCS.gcsApplication app on app.ApplicationId = pc.ApplicationId
	 where pc.PermissionCategoryId = @PermissionCategoryId

	set @permCatName = REPLACE(@permCatName, ' and ', '')
	set @permCatName = REPLACE(@permCatName, ' ', '')
	set @permCatName = REPLACE(@permCatName, '/', '')
	set @permCatName = REPLACE(@permCatName, '(', '')
	set @permCatName = REPLACE(@permCatName, ')', '')
	set @permCatName = REPLACE(@permCatName, '-', '')

	if LEN(@appCode) > 0
		set @code = @appCode + @permCatName
	ELSE
		set @code = @permCatName

	RETURN @code
END
GO
ALTER AUTHORIZATION ON [GCS].[fn_GetPermissionCategoryCode] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[fn_GetPermissionCategoryCode] TO [public] AS [dbo]
GO

if dbo.fn_GCSDoesColumnExist('gcsPermissionCategory', 'Code') = 0
BEGIN
	ALTER TABLE GCS.gcsPermissionCategory
	ADD Code as ([GCS].[fn_GetPermissionCategoryCode](PermissionCategoryId))
END
go  


CREATE OR ALTER FUNCTION [GCS].[fn_GetPermissionCode](@PermissionId uniqueidentifier)
RETURNS nvarchar(max) WITH EXECUTE AS CALLER
AS 
BEGIN

	DECLARE @code nvarchar(max)
	DECLARE @permCatCode nvarchar(65)
	DECLARE @permName nvarchar(65)

	select @permCatCode = pc.Code, @permName = p.PermissionName from GCS.gcsPermission p
	JOIN GCS.gcsPermissionCategory pc on pc.PermissionCategoryId = p.PermissionCategoryId
	 where p.PermissionId = @PermissionId

	set @permName = REPLACE(@permName, ' ', '')
	set @permName = REPLACE(@permName, '/', '')
	set @permName = REPLACE(@permName, '(', '')
	set @permName = REPLACE(@permName, ')', '')
	set @permName = REPLACE(@permName, '-', '')

	set @code = @permCatCode + @permName

	RETURN @code
END
GO
ALTER AUTHORIZATION ON [GCS].[fn_GetPermissionCode] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[fn_GetPermissionCode] TO [public] AS [dbo]
GO


if dbo.fn_GCSDoesColumnExist('gcsPermission', 'Code') = 0
BEGIN
	ALTER TABLE GCS.gcsPermission
	ADD Code as ([GCS].[fn_GetPermissionCode](PermissionId))
END
go    

--update GCS.gcsPermission p SET p.PermissionCode = (
--JOIN GCS.gcsPermissionCategory pc on pc.PermissionCategoryId = p.PermissionCategoryId WHERE pPermissionCode IS NULL

--if dbo.fn_GCSDoesColumnExist('gcsPermission', 'PermissionCode') = 1
--BEGIN
--	ALTER TABLE GCS.gcsPermission
--	ADD PermissionCode nvarchar(128) not null
--END
--go    

if dbo.gcs_GetColumnDataType( 'GCS', 'Person', 'ActivationDateTime') <> 'datetimeoffset'
begin
	alter table GCS.Person 
	alter column ActivationDateTime datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'PersonCredential', 'ActivationDateTime') <> 'datetimeoffset'
begin
	alter table GCS.PersonCredential 
	alter column ActivationDateTime datetimeoffset null
end
go

if dbo.gcs_GetColumnDataType( 'GCS', 'Person', 'ExpirationDateTime') <> 'datetimeoffset'
begin
	alter table GCS.Person 
	alter column ExpirationDateTime datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'PersonCredential', 'ExpirationDateTime') <> 'datetimeoffset'
begin
	alter table GCS.PersonCredential 
	alter column ExpirationDateTime datetimeoffset null
end
go

if dbo.gcs_GetColumnDataType( 'GCS', 'PersonCredential', 'BadgeLastPrinted') <> 'datetimeoffset'
begin
	alter table GCS.PersonCredential 
	alter column BadgeLastPrinted datetimeoffset null
end
go

if dbo.gcs_GetColumnDataType( 'GCS', 'PersonCredential', 'DossierLastPrinted') <> 'datetimeoffset'
begin
	alter table GCS.PersonCredential 
	alter column DossierLastPrinted datetimeoffset null
end
go

if dbo.gcs_GetColumnDataType( 'GCS', 'gcsUser', 'LastLoginDate') <> 'datetimeoffset'
begin
	alter table GCS.gcsUser 
	alter column LastLoginDate datetimeoffset null
end
go

if dbo.gcs_GetColumnDataType( 'GCS', 'gcsUser', 'LastPasswordResetDate') <> 'datetimeoffset'
begin
	alter table GCS.gcsUser 
	alter column LastPasswordResetDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'gcsUser', 'LockoutEnd') <> 'datetimeoffset'
begin
	alter table GCS.gcsUser 
	alter column LockoutEnd datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'gcsUser', 'IsLockedOutClearedDate') <> 'datetimeoffset'
begin
	alter table GCS.gcsUser 
	alter column IsLockedOutClearedDate datetimeoffset null
end
go


if dbo.fn_GCSDoesColumnExist('gcsUser', 'PasswordResetToken') = 0
BEGIN
	ALTER TABLE GCS.gcsUser
	ADD PasswordResetToken nvarchar(128) null
END
go    

if dbo.fn_GCSDoesColumnExist('gcsUser', 'PasswordResetTokenExpiration') = 0
BEGIN
	ALTER TABLE GCS.gcsUser
	ADD PasswordResetTokenExpiration datetimeoffset null
END
go    

exec dbo.gcs_DeleteDefaultConstraint 'GCS','gcsAuditXml', 'UpdateDateTime'
go

if dbo.gcs_GetColumnDataType( 'GCS', 'gcsAuditXml', 'UpdateDateTime') <> 'datetimeoffset'
begin
	alter table GCS.gcsAuditXml 
	alter column UpdateDateTime datetimeoffset null
end
go

alter table GCS.gcsAuditXml 
ADD CONSTRAINT DF_gcsAuditXml_UpdateDateTime DEFAULT SYSDATETIMEOFFSET() FOR UpdateDateTime
go


exec dbo.gcs_DeleteDefaultConstraint 'GCS','PersonClusterPermission', 'LastPanelImpactingChangeDate'
go

if dbo.gcs_GetColumnDataType( 'GCS', 'PersonClusterPermission', 'LastPanelImpactingChangeDate') <> 'datetimeoffset'
begin
	alter table GCS.PersonClusterPermission 
	alter column LastPanelImpactingChangeDate datetimeoffset null
end
go

alter table GCS.PersonClusterPermission 
ADD CONSTRAINT DF_PersonClusterPermission_LastPanelImpactingChangeDate DEFAULT SYSDATETIMEOFFSET() FOR LastPanelImpactingChangeDate
go


exec dbo.gcs_DeleteDefaultConstraint 'GCS','CredentialToLoadToCpu', 'LastCredentialChangeDate'
go

if dbo.gcs_GetColumnDataType( 'GCS', 'CredentialToLoadToCpu', 'LastCredentialChangeDate') <> 'datetimeoffset'
begin
	alter table GCS.CredentialToLoadToCpu 
	alter column LastCredentialChangeDate datetimeoffset not null
end
go

alter table GCS.CredentialToLoadToCpu 
ADD CONSTRAINT DF_CredentialToLoadToCpu_LastCredentialChangeDate DEFAULT SYSDATETIMEOFFSET() FOR LastCredentialChangeDate
go

exec dbo.gcs_DeleteDefaultConstraint 'GCS','CredentialToLoadToCpu', 'LastPersonalAccessGroupChangeDate'
go

if dbo.gcs_GetColumnDataType( 'GCS', 'CredentialToLoadToCpu', 'LastPersonalAccessGroupChangeDate') <> 'datetimeoffset'
begin
	alter table GCS.CredentialToLoadToCpu 
	alter column LastPersonalAccessGroupChangeDate datetimeoffset not null
end
go

alter table GCS.CredentialToLoadToCpu 
ADD CONSTRAINT DF_CredentialToLoadToCpu_LastPersonalAccessGroupChangeDate DEFAULT SYSDATETIMEOFFSET() FOR LastPersonalAccessGroupChangeDate
go


if dbo.gcs_GetColumnDataType( 'GCS', 'CredentialToLoadToCpu', 'LastCredentialLoadedDate') <> 'datetimeoffset'
begin
	alter table GCS.CredentialToLoadToCpu 
	alter column LastCredentialLoadedDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'CredentialToLoadToCpu', 'LastPersonalAccessGroupLoadedDate') <> 'datetimeoffset'
begin
	alter table GCS.CredentialToLoadToCpu 
	alter column LastPersonalAccessGroupLoadedDate datetimeoffset null
end
go

if dbo.gcs_GetColumnDataType( 'GCS', 'CredentialToLoadToCpu', 'LastForceLoadDate') <> 'datetimeoffset'
begin
	alter table GCS.CredentialToLoadToCpu 
	alter column LastForceLoadDate datetimeoffset null
end
go

exec dbo.gcs_DeleteDefaultConstraint 'GCS','CredentialToDeleteFromCpu', 'DeletedFromDatabaseDate'
go

if dbo.gcs_GetColumnDataType( 'GCS', 'CredentialToDeleteFromCpu', 'DeletedFromDatabaseDate') <> 'datetimeoffset'
begin
	alter table GCS.CredentialToDeleteFromCpu 
	alter column DeletedFromDatabaseDate datetimeoffset not null
end
go

alter table GCS.CredentialToDeleteFromCpu 
ADD CONSTRAINT DF_CredentialToDeleteFromCpu_DeletedFromDatabaseDate DEFAULT SYSDATETIMEOFFSET() FOR DeletedFromDatabaseDate
go

if dbo.gcs_GetColumnDataType( 'GCS', 'CredentialToDeleteFromCpu', 'DeletedFromCpuDate') <> 'datetimeoffset'
begin
	alter table GCS.CredentialToDeleteFromCpu 
	alter column DeletedFromCpuDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'InputDeviceLoadToCpu', 'LastForceLoadDate') <> 'datetimeoffset'
begin
	alter table GCS.InputDeviceLoadToCpu 
	alter column LastForceLoadDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'InputDeviceLoadToCpu', 'LastLoadedDate') <> 'datetimeoffset'
begin
	alter table GCS.InputDeviceLoadToCpu 
	alter column LastLoadedDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'OutputDeviceLoadToCpu', 'LastForceLoadDate') <> 'datetimeoffset'
begin
	alter table GCS.OutputDeviceLoadToCpu 
	alter column LastForceLoadDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'OutputDeviceLoadToCpu', 'LastLoadedDate') <> 'datetimeoffset'
begin
	alter table GCS.OutputDeviceLoadToCpu 
	alter column LastLoadedDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'AccessGroupLoadToCpu', 'LastForceLoadDate') <> 'datetimeoffset'
begin
	alter table GCS.AccessGroupLoadToCpu 
	alter column LastForceLoadDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'AccessGroupLoadToCpu', 'LastLoadedDate') <> 'datetimeoffset'
begin
	alter table GCS.AccessGroupLoadToCpu 
	alter column LastLoadedDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'AccessPortalLoadToCpu', 'LastForceLoadDate') <> 'datetimeoffset'
begin
	alter table GCS.AccessPortalLoadToCpu 
	alter column LastForceLoadDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'AccessPortalLoadToCpu', 'LastLoadedDate') <> 'datetimeoffset'
begin
	alter table GCS.AccessPortalLoadToCpu 
	alter column LastLoadedDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'AccessGroupAccessPortalLoadToCpu', 'LastForceLoadDate') <> 'datetimeoffset'
begin
	alter table GCS.AccessGroupAccessPortalLoadToCpu 
	alter column LastForceLoadDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'AccessGroupAccessPortalLoadToCpu', 'LastLoadedDate') <> 'datetimeoffset'
begin
	alter table GCS.AccessGroupAccessPortalLoadToCpu 
	alter column LastLoadedDate datetimeoffset null
end
go


if dbo.gcs_GetColumnDataType( 'GCS', 'GalaxyCpuConnection', 'LastConnectedTime') <> 'datetimeoffset'
begin
	alter table GCS.GalaxyCpuConnection 
	alter column LastConnectedTime datetimeoffset null
end
go

if dbo.gcs_GetColumnDataType( 'GCS', 'GalaxyCpuConnection', 'LastDisconnectedTime') <> 'datetimeoffset'
begin
	alter table GCS.GalaxyCpuConnection 
	alter column LastDisconnectedTime datetimeoffset null
end
go




exec dbo.gcs_DeleteDefaultConstraint 'GCS','BackgroundJobStateChange', 'ChangeDateTime'
go

if dbo.gcs_GetColumnDataType( 'GCS', 'BackgroundJobStateChange', 'ChangeDateTime') <> 'datetimeoffset'
begin
	alter table GCS.BackgroundJobStateChange
	alter column ChangeDateTime datetimeoffset not null
end
go

alter table GCS.BackgroundJobStateChange 
ADD CONSTRAINT DF_BackgroundJobStateChange_ChangeDateTime DEFAULT SYSDATETIMEOFFSET() FOR ChangeDateTime
go



EXEC dbo.gcs_DeleteDefaultConstraint 'GCS', 'Cluster', 'AccessRuleOverrideTimeout'
EXEC dbo.gcs_DeleteCheckConstraint 'GCS', 'Cluster', 'CKC_ACCESSRULEOVERRID_CLUSTER'

ALTER TABLE [GCS].[Cluster]
ALTER COLUMN [AccessRuleOverrideTimeout] [int] NOT NULL
GO

ALTER TABLE [GCS].[Cluster] ADD  DEFAULT ((0)) FOR [AccessRuleOverrideTimeout]
go

ALTER TABLE [GCS].[Cluster]  WITH CHECK ADD  CONSTRAINT [CKC_ACCESSRULEOVERRID_CLUSTER] CHECK  (([AccessRuleOverrideTimeout] IS NULL OR [AccessRuleOverrideTimeout]>=(0) AND [AccessRuleOverrideTimeout]<=(65535)))
go

EXEC dbo.gcs_DeleteDefaultConstraint 'GCS', 'Cluster', 'UnlimitedCredentialTimeout'
EXEC dbo.gcs_DeleteCheckConstraint 'GCS', 'Cluster', 'CKC_UNLIMITEDCREDENTI_CLUSTER'

ALTER TABLE [GCS].[Cluster]
ALTER COLUMN [UnlimitedCredentialTimeout] [int] NOT NULL
GO

ALTER TABLE [GCS].[Cluster] ADD  DEFAULT ((0)) FOR [UnlimitedCredentialTimeout]
GO

ALTER TABLE [GCS].[Cluster]  WITH CHECK ADD  CONSTRAINT [CKC_UNLIMITEDCREDENTI_CLUSTER] CHECK  (([UnlimitedCredentialTimeout]>=(0) AND [UnlimitedCredentialTimeout]<=(65535)))
GO


if dbo.fn_GCSDoesColumnExist('Cluster', 'Description') = 0
BEGIN
	ALTER TABLE GCS.Cluster
	ADD [Description] [nvarchar](1000) NULL;
END
GO

if dbo.fn_GCSDoesColumnExist('Cluster', 'CurrentTimeForCluster') = 1
BEGIN
	ALTER TABLE GCS.Cluster
	DROP COLUMN CurrentTimeForCluster
END
GO

CREATE OR ALTER PROCEDURE [dbo].[gcs_GetCurrentTimeForTimeZone]
	@timezoneId [nvarchar](65),
	@result [datetimeoffset] OUTPUT
WITH EXECUTE AS CALLER
AS
--declare @utzNow datetimeoffset
--set @utzNow = SYSUTCDATETIME()

--select @result = dateadd(MINUTE,datepart(tz, @utzNow AT Time Zone @timezoneId), @utzNow)
--	DECLARE @result as datetimeoffset
	declare @utzNow datetimeoffset
	set @utzNow = SYSUTCDATETIME()

	--select @result = dateadd(MINUTE,datepart(tz, @utzNow AT Time Zone @timezoneId), @utzNow)
	select @result = CONVERT(datetimeoffset, @utzNow AT Time Zone @timezoneId, 126)  

--SET @result = (SELECT GETUTCDATE() AT TIME ZONE @timezoneId)
GO
ALTER AUTHORIZATION ON [dbo].[gcs_GetCurrentTimeForTimeZone] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [dbo].[gcs_GetCurrentTimeForTimeZone] TO [public] AS [dbo]
GO

CREATE OR ALTER FUNCTION [dbo].[gcsfunc_GetCurrentTimeForTimeZone](@timezoneId [nvarchar](65))
RETURNS [datetimeoffset] WITH EXECUTE AS CALLER
AS 
BEGIN

	DECLARE @result as datetimeoffset
	declare @utzNow datetimeoffset
	set @utzNow = SYSUTCDATETIME()

	--select @result = dateadd(MINUTE,datepart(tz, @utzNow AT Time Zone @timezoneId), @utzNow)

	select @result = CONVERT(datetimeoffset, @utzNow AT Time Zone @timezoneId, 126)  
  
  RETURN @result
END
GO
ALTER AUTHORIZATION ON [dbo].[gcsfunc_GetCurrentTimeForTimeZone] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [dbo].[gcsfunc_GetCurrentTimeForTimeZone] TO [public] AS [dbo]
GO

if dbo.fn_GCSDoesColumnExist('Cluster', 'CurrentTimeForCluster') = 0
BEGIN
	ALTER TABLE GCS.Cluster
	ADD CurrentTimeForCluster AS ([dbo].[gcsfunc_GetCurrentTimeForTimeZone]([TimeZoneId]))
END
GO


if dbo.fn_GCSDoesColumnExist('CredentialToDeleteFromCpu', 'IsExtended') = 1
BEGIN
	ALTER TABLE GCS.CredentialToDeleteFromCpu
	DROP COLUMN [IsExtended]
END
GO


if dbo.fn_GCSDoesColumnExist('Credential', 'IsExtended') = 1
BEGIN
	ALTER TABLE GCS.Credential
	DROP COLUMN [IsExtended]
END
GO

if dbo.fn_GCSDoesColumnExist('PersonClusterPermission', 'IsExtended') = 1
BEGIN
	ALTER TABLE GCS.PersonClusterPermission
	DROP COLUMN [IsExtended]
END
GO

CREATE OR ALTER FUNCTION [GCS].[IsCredentialDataExtended] (@credentialData binary(32)) 
RETURNS bit
as
begin
	if @credentialData is null
		return 0;

	--declare @max48BitValue binary(32) = 0x0000000000000000000000000000000000000000000000000000ffffffffffff
	if @credentialData > 0x0000000000000000000000000000000000000000000000000000ffffffffffff
		return 1;
	return 0;
end
go

GRANT EXECUTE ON GCS.[IsCredentialDataExtended] TO public
GO



if dbo.fn_GCSDoesColumnExist('CredentialToDeleteFromCpu', 'IsExtended') = 0
BEGIN
	ALTER TABLE GCS.CredentialToDeleteFromCpu
	ADD [IsExtended] as GCS.[IsCredentialDataExtended] (CardBinaryData)
END
GO

if dbo.fn_GCSDoesColumnExist('Credential', 'IsExtended') = 0
BEGIN
	ALTER TABLE GCS.Credential
	ADD [IsExtended] as GCS.[IsCredentialDataExtended] (CardBinaryData)
END
GO

if dbo.fn_GCSDoesColumnExist('PersonClusterPermission', 'IsExtended') = 0
BEGIN
	ALTER TABLE GCS.PersonClusterPermission
	ADD [IsExtended] as GCS.[IsCredentialDataExtended] (CredentialBits)
END
GO

/* All Stored Procedures for table: Cluster */
/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.Cluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Cluster

if @PageSize = 0
	set @PageSize = 1

SELECT 
ClusterUid
,ClusterTypeUid
,ClusterNumber
,ClusterName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,EntityId
,SiteUid
,CredentialDataLengthUid
,TimeScheduleTypeUid
,IsActive
,AbaStartDigit
,AbaStopDigit
,AbaFoldOption
,WiegandStartBit
,WiegandStopBit
,CardaxStartBit
,CardaxStopBit
,LockoutAfterInvalidAttempts
,LockoutDurationSeconds
,AccessRuleOverrideTimeout
,UnlimitedCredentialTimeout
,TimeZoneId
,BinaryResourceUid
,CrisisActivateInputOutputGroupUid
,CrisisResetInputOutputGroupUid
,AccessPortalLockedLedBehaviorModeUid
,AccessPortalUnlockedLedBehaviorModeUid
,AccessPortalTypeUid
,TemplateAccessPortalUid
,AbaClipOption
,CurrentTimeForCluster
,ClusterGroupId
,COUNT(*) OVER() TotalRowCount
FROM GCS.Cluster
ORDER BY (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 0 THEN ClusterName end) asc,
         (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 1 THEN ClusterName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Cluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_ByClusterGroupId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_ByClusterGroupId]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_ByClusterGroupId]
@ClusterGroupId int,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Cluster

if @PageSize = 0
	set @PageSize = 1

SELECT 
ClusterUid
,ClusterTypeUid
,ClusterNumber
,ClusterName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,EntityId
,SiteUid
,CredentialDataLengthUid
,TimeScheduleTypeUid
,BinaryResourceUid
,IsActive
,AbaStartDigit
,AbaStopDigit
,AbaFoldOption
,AbaClipOption
,WiegandStartBit
,WiegandStopBit
,CardaxStartBit
,CardaxStopBit
,LockoutAfterInvalidAttempts
,LockoutDurationSeconds
,AccessRuleOverrideTimeout
,UnlimitedCredentialTimeout
,TimeZoneId
,CrisisActivateInputOutputGroupUid
,CrisisResetInputOutputGroupUid
,AccessPortalLockedLedBehaviorModeUid
,AccessPortalUnlockedLedBehaviorModeUid
,AccessPortalTypeUid
,TemplateAccessPortalUid
,CurrentTimeForCluster
,ClusterGroupId
,COUNT(*) OVER() TotalRowCount
FROM GCS.Cluster
WHERE 
ClusterGroupId = @ClusterGroupId 
ORDER BY (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 0 THEN ClusterName end) asc,
         (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 1 THEN ClusterName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_ByClusterGroupId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Cluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_ByClusterGroupIdAndNumber]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_ByClusterGroupIdAndNumber]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_ByClusterGroupIdAndNumber]
@ClusterGroupId int,
@ClusterNumber int
AS

declare @ret int;
select @ret = 0;

SELECT 
ClusterUid
,ClusterTypeUid
,ClusterNumber
,ClusterName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,EntityId
,SiteUid
,CredentialDataLengthUid
,TimeScheduleTypeUid
,BinaryResourceUid
,IsActive
,AbaStartDigit
,AbaStopDigit
,AbaFoldOption
,AbaClipOption
,WiegandStartBit
,WiegandStopBit
,CardaxStartBit
,CardaxStopBit
,LockoutAfterInvalidAttempts
,LockoutDurationSeconds
,AccessRuleOverrideTimeout
,UnlimitedCredentialTimeout
,TimeZoneId
,CrisisActivateInputOutputGroupUid
,CrisisResetInputOutputGroupUid
,AccessPortalLockedLedBehaviorModeUid
,AccessPortalUnlockedLedBehaviorModeUid
,AccessPortalTypeUid
,TemplateAccessPortalUid
,CurrentTimeForCluster
,ClusterGroupId
,COUNT(*) OVER() TotalRowCount
FROM GCS.Cluster
WHERE 
ClusterNumber = @ClusterNumber AND ClusterGroupId = @ClusterGroupId 

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_ByClusterGroupIdAndNumber] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Cluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_ByClusterNumber]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_ByClusterNumber]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_ByClusterNumber]
@ClusterNumber int,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Cluster

if @PageSize = 0
	set @PageSize = 1

SELECT 
ClusterUid
,ClusterTypeUid
,ClusterNumber
,ClusterName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,EntityId
,SiteUid
,CredentialDataLengthUid
,TimeScheduleTypeUid
,BinaryResourceUid
,IsActive
,AbaStartDigit
,AbaStopDigit
,AbaFoldOption
,AbaClipOption
,WiegandStartBit
,WiegandStopBit
,CardaxStartBit
,CardaxStopBit
,LockoutAfterInvalidAttempts
,LockoutDurationSeconds
,AccessRuleOverrideTimeout
,UnlimitedCredentialTimeout
,TimeZoneId
,CrisisActivateInputOutputGroupUid
,CrisisResetInputOutputGroupUid
,AccessPortalLockedLedBehaviorModeUid
,AccessPortalUnlockedLedBehaviorModeUid
,AccessPortalTypeUid
,TemplateAccessPortalUid
,CurrentTimeForCluster
,ClusterGroupId
,COUNT(*) OVER() TotalRowCount
FROM GCS.Cluster
WHERE 
ClusterNumber = @ClusterNumber
ORDER BY (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 0 THEN ClusterName end) asc,
         (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 1 THEN ClusterName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_ByClusterNumber] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Cluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_ByClusterTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_ByClusterTypeUid]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_ByClusterTypeUid]
@ClusterTypeUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1 
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Cluster

if @PageSize = 0
	set @PageSize = 1

SELECT 
ClusterUid
,ClusterTypeUid
,ClusterNumber
,ClusterName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,EntityId
,SiteUid
,CredentialDataLengthUid
,TimeScheduleTypeUid
,BinaryResourceUid
,IsActive
,AbaStartDigit
,AbaStopDigit
,AbaFoldOption
,AbaClipOption
,WiegandStartBit
,WiegandStopBit
,CardaxStartBit
,CardaxStopBit
,LockoutAfterInvalidAttempts
,LockoutDurationSeconds
,AccessRuleOverrideTimeout
,UnlimitedCredentialTimeout
,TimeZoneId
,CrisisActivateInputOutputGroupUid
,CrisisResetInputOutputGroupUid
,AccessPortalLockedLedBehaviorModeUid
,AccessPortalUnlockedLedBehaviorModeUid
,AccessPortalTypeUid
,TemplateAccessPortalUid
,CurrentTimeForCluster
,ClusterGroupId
,COUNT(*) OVER() TotalRowCount
FROM GCS.Cluster
WHERE 
ClusterTypeUid = @ClusterTypeUid
ORDER BY (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 0 THEN ClusterName end) asc,
         (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 1 THEN ClusterName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_ByClusterTypeUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Cluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Cluster

if @PageSize = 0
	set @PageSize = 1

SELECT 
ClusterUid
,ClusterTypeUid
,ClusterNumber
,ClusterName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,EntityId
,SiteUid
,CredentialDataLengthUid
,TimeScheduleTypeUid
,BinaryResourceUid
,IsActive
,AbaStartDigit
,AbaStopDigit
,AbaFoldOption
,AbaClipOption
,WiegandStartBit
,WiegandStopBit
,CardaxStartBit
,CardaxStopBit
,LockoutAfterInvalidAttempts
,LockoutDurationSeconds
,AccessRuleOverrideTimeout
,UnlimitedCredentialTimeout
,TimeZoneId
,CrisisActivateInputOutputGroupUid
,CrisisResetInputOutputGroupUid
,AccessPortalLockedLedBehaviorModeUid
,AccessPortalUnlockedLedBehaviorModeUid
,AccessPortalTypeUid
,TemplateAccessPortalUid
,CurrentTimeForCluster
,ClusterGroupId
,COUNT(*) OVER() TotalRowCount
FROM GCS.Cluster
WHERE EntityId = @EntityId OR
ClusterUid in (SELECT DISTINCT(ClusterUid) FROM ClusterEntityMap WHERE EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 0 THEN ClusterName end) asc,
         (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 1 THEN ClusterName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Cluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_BySiteUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_BySiteUid]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_BySiteUid]
@SiteUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Cluster

if @PageSize = 0
	set @PageSize = 1

SELECT 
ClusterUid
,ClusterTypeUid
,ClusterNumber
,ClusterName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,EntityId
,SiteUid
,CredentialDataLengthUid
,TimeScheduleTypeUid
,BinaryResourceUid
,IsActive
,AbaStartDigit
,AbaStopDigit
,AbaFoldOption
,AbaClipOption
,WiegandStartBit
,WiegandStopBit
,CardaxStartBit
,CardaxStopBit
,LockoutAfterInvalidAttempts
,LockoutDurationSeconds
,AccessRuleOverrideTimeout
,UnlimitedCredentialTimeout
,TimeZoneId
,CrisisActivateInputOutputGroupUid
,CrisisResetInputOutputGroupUid
,AccessPortalLockedLedBehaviorModeUid
,AccessPortalUnlockedLedBehaviorModeUid
,AccessPortalTypeUid
,TemplateAccessPortalUid
,CurrentTimeForCluster
,ClusterGroupId
,COUNT(*) OVER() TotalRowCount
FROM GCS.Cluster
WHERE 
SiteUid = @SiteUid 
ORDER BY (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 0 THEN ClusterName end) asc,
         (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 1 THEN ClusterName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_BySiteUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.Cluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Cluster

if @PageSize = 0
	set @PageSize = 1

SELECT 
ClusterUid
,ClusterName
,Description
,IsActive
,BinaryResourceUid
,COUNT(*) OVER() TotalRowCount
FROM GCS.Cluster
ORDER BY (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 0 THEN ClusterName end) asc,
         (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 1 THEN ClusterName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Cluster table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_SelectByPK]
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
ClusterUid
,ClusterTypeUid
,ClusterNumber
,ClusterName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,EntityId
,SiteUid
,CredentialDataLengthUid
,TimeScheduleTypeUid
,IsActive
,AbaStartDigit
,AbaStopDigit
,AbaFoldOption
,WiegandStartBit
,WiegandStopBit
,CardaxStartBit
,CardaxStopBit
,LockoutAfterInvalidAttempts
,LockoutDurationSeconds
,AccessRuleOverrideTimeout
,UnlimitedCredentialTimeout
,TimeZoneId
,BinaryResourceUid
,CrisisActivateInputOutputGroupUid
,CrisisResetInputOutputGroupUid
,AccessPortalLockedLedBehaviorModeUid
,AccessPortalUnlockedLedBehaviorModeUid
,AccessPortalTypeUid
,TemplateAccessPortalUid
,AbaClipOption
,CurrentTimeForCluster
,ClusterGroupId
,1 as TotalRowCount
FROM GCS.Cluster
WHERE 
ClusterUid = @ClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.Cluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_SelectSearch]
@ClusterName nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Cluster

if @PageSize = 0
	set @PageSize = 1

SELECT 
ClusterUid
,ClusterTypeUid
,ClusterNumber
,ClusterName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,EntityId
,SiteUid
,CredentialDataLengthUid
,TimeScheduleTypeUid
,IsActive
,AbaStartDigit
,AbaStopDigit
,AbaFoldOption
,WiegandStartBit
,WiegandStopBit
,CardaxStartBit
,CardaxStopBit
,LockoutAfterInvalidAttempts
,LockoutDurationSeconds
,AccessRuleOverrideTimeout
,UnlimitedCredentialTimeout
,TimeZoneId
,BinaryResourceUid
,CrisisActivateInputOutputGroupUid
,CrisisResetInputOutputGroupUid
,AccessPortalLockedLedBehaviorModeUid
,AccessPortalUnlockedLedBehaviorModeUid
,AccessPortalTypeUid
,TemplateAccessPortalUid
,AbaClipOption
,CurrentTimeForCluster
,ClusterGroupId
,COUNT(*) OVER() TotalRowCount
FROM GCS.Cluster
WHERE 
(@ClusterName IS NULL OR ClusterName LIKE @ClusterName + '%')
ORDER BY (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 0 THEN ClusterName end) asc,
         (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 1 THEN ClusterName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_SelectSearch] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_InfoByTimeScheduleUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_InfoByTimeScheduleUid]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_InfoByTimeScheduleUid]
@TimeScheduleUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
--,@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyClusterTimeScheduleMap t
join GCS.Cluster c on c.ClusterUid = t.ClusterUid
WHERE TimeScheduleUid = @TimeScheduleUid

if @PageSize = 0
	set @PageSize = 1

	--IF @CultureName IS NULL SET @CultureName = 'en-US'

	--declare @languageId uniqueidentifier
	--select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT
t.ClusterUid, c.ClusterName, t.PanelScheduleNumber, c.Description, c.IsActive
,COUNT(*) OVER() TotalRowCount
from GCS.GalaxyClusterTimeScheduleMap t
join GCS.Cluster c on c.ClusterUid = t.ClusterUid
WHERE TimeScheduleUid = @TimeScheduleUid
ORDER BY (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 0 THEN ClusterName end) asc,
         (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 1 THEN ClusterName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_InfoByTimeScheduleUid] TO public
GO


/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.Cluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_Insert]
@ClusterUid uniqueidentifier 
,@ClusterTypeUid uniqueidentifier 
,@ClusterNumber int 
,@ClusterName nvarchar(65) 
,@Description nvarchar(1000)
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
,@EntityId uniqueidentifier 
,@SiteUid uniqueidentifier 
,@CredentialDataLengthUid uniqueidentifier 
,@TimeScheduleTypeUid uniqueidentifier 
,@IsActive bit 
,@AbaStartDigit smallint 
,@AbaStopDigit smallint 
,@AbaFoldOption bit 
,@WiegandStartBit smallint 
,@WiegandStopBit smallint 
,@CardaxStartBit smallint 
,@CardaxStopBit smallint 
,@LockoutAfterInvalidAttempts smallint 
,@LockoutDurationSeconds int 
,@AccessRuleOverrideTimeout smallint  = null
,@UnlimitedCredentialTimeout smallint 
,@TimeZoneId nvarchar(65) 
,@BinaryResourceUid uniqueidentifier  = null
,@CrisisActivateInputOutputGroupUid uniqueidentifier  = null
,@CrisisResetInputOutputGroupUid uniqueidentifier  = null
,@AccessPortalLockedLedBehaviorModeUid uniqueidentifier 
,@AccessPortalUnlockedLedBehaviorModeUid uniqueidentifier 
,@AccessPortalTypeUid uniqueidentifier  = null
,@TemplateAccessPortalUid uniqueidentifier  = null
,@AbaClipOption bit 
--,@ClusterGroupId int 
AS

declare @ret int;
select @ret = 0;


if @ClusterUid = '00000000-0000-0000-0000-000000000000'
	SET @ClusterUid = NULL


if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @BinaryResourceUid = NULL

if @CrisisActivateInputOutputGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @CrisisActivateInputOutputGroupUid  = NULL

if @CrisisResetInputOutputGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @CrisisResetInputOutputGroupUid = NULL

if @AccessPortalTypeUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalTypeUid = NULL
	
if @TemplateAccessPortalUid = '00000000-0000-0000-0000-000000000000'
	SET @TemplateAccessPortalUid = NULL

if @ClusterUid = '00000000-0000-0000-0000-000000000000' OR @ClusterUid IS NULL
	SET @ClusterUid = NewID()

INSERT INTO GCS.Cluster
(
ClusterUid
,ClusterTypeUid
,ClusterNumber
,ClusterName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,EntityId
,SiteUid
,CredentialDataLengthUid
,TimeScheduleTypeUid
,IsActive
,AbaStartDigit
,AbaStopDigit
,AbaFoldOption
,WiegandStartBit
,WiegandStopBit
,CardaxStartBit
,CardaxStopBit
,LockoutAfterInvalidAttempts
,LockoutDurationSeconds
,AccessRuleOverrideTimeout
,UnlimitedCredentialTimeout
,TimeZoneId
,BinaryResourceUid
,CrisisActivateInputOutputGroupUid
,CrisisResetInputOutputGroupUid
,AccessPortalLockedLedBehaviorModeUid
,AccessPortalUnlockedLedBehaviorModeUid
,AccessPortalTypeUid
,TemplateAccessPortalUid
,AbaClipOption
--,ClusterGroupId
) 
VALUES 
(
@ClusterUid
,@ClusterTypeUid
,@ClusterNumber
,@ClusterName
,@Description
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
,@EntityId
,@SiteUid
,@CredentialDataLengthUid
,@TimeScheduleTypeUid
,@IsActive
,@AbaStartDigit
,@AbaStopDigit
,@AbaFoldOption
,@WiegandStartBit
,@WiegandStopBit
,@CardaxStartBit
,@CardaxStopBit
,@LockoutAfterInvalidAttempts
,@LockoutDurationSeconds
,@AccessRuleOverrideTimeout
,@UnlimitedCredentialTimeout
,@TimeZoneId
,@BinaryResourceUid
,@CrisisActivateInputOutputGroupUid
,@CrisisResetInputOutputGroupUid
,@AccessPortalLockedLedBehaviorModeUid
,@AccessPortalUnlockedLedBehaviorModeUid
,@AccessPortalTypeUid
,@TemplateAccessPortalUid
,@AbaClipOption
--,@ClusterGroupId
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.Cluster table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_Update]
@ClusterUid uniqueidentifier 
,@ClusterTypeUid uniqueidentifier
,@ClusterNumber int
,@ClusterName nvarchar(65)
,@Description nvarchar(1000)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@EntityId uniqueidentifier
,@SiteUid uniqueidentifier
,@CredentialDataLengthUid uniqueidentifier
,@TimeScheduleTypeUid uniqueidentifier
,@IsActive bit
,@AbaStartDigit smallint
,@AbaStopDigit smallint
,@AbaFoldOption bit
,@WiegandStartBit smallint
,@WiegandStopBit smallint
,@CardaxStartBit smallint
,@CardaxStopBit smallint
,@LockoutAfterInvalidAttempts smallint
,@LockoutDurationSeconds int
,@AccessRuleOverrideTimeout smallint
,@UnlimitedCredentialTimeout smallint
,@TimeZoneId nvarchar(65)
,@BinaryResourceUid uniqueidentifier
,@CrisisActivateInputOutputGroupUid uniqueidentifier
,@CrisisResetInputOutputGroupUid uniqueidentifier
,@AccessPortalLockedLedBehaviorModeUid uniqueidentifier
,@AccessPortalUnlockedLedBehaviorModeUid uniqueidentifier
,@AccessPortalTypeUid uniqueidentifier
,@TemplateAccessPortalUid uniqueidentifier
,@AbaClipOption bit
--,@ClusterGroupId int
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @BinaryResourceUid = NULL

if @CrisisActivateInputOutputGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @CrisisActivateInputOutputGroupUid  = NULL

if @CrisisResetInputOutputGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @CrisisResetInputOutputGroupUid = NULL
	
if @AccessPortalTypeUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalTypeUid = NULL

if @TemplateAccessPortalUid = '00000000-0000-0000-0000-000000000000'
	SET @TemplateAccessPortalUid = NULL


UPDATE GCS.Cluster
SET 
ClusterUid = @ClusterUid
,ClusterTypeUid = @ClusterTypeUid
,ClusterNumber = @ClusterNumber
,ClusterName = @ClusterName
,Description = @Description
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,EntityId = @EntityId
,SiteUid = @SiteUid
,CredentialDataLengthUid = @CredentialDataLengthUid
,TimeScheduleTypeUid = @TimeScheduleTypeUid
,IsActive = @IsActive
,AbaStartDigit = @AbaStartDigit
,AbaStopDigit = @AbaStopDigit
,AbaFoldOption = @AbaFoldOption
,WiegandStartBit = @WiegandStartBit
,WiegandStopBit = @WiegandStopBit
,CardaxStartBit = @CardaxStartBit
,CardaxStopBit = @CardaxStopBit
,LockoutAfterInvalidAttempts = @LockoutAfterInvalidAttempts
,LockoutDurationSeconds = @LockoutDurationSeconds
,AccessRuleOverrideTimeout = @AccessRuleOverrideTimeout
,UnlimitedCredentialTimeout = @UnlimitedCredentialTimeout
,TimeZoneId = @TimeZoneId
,BinaryResourceUid = @BinaryResourceUid
,CrisisActivateInputOutputGroupUid = @CrisisActivateInputOutputGroupUid
,CrisisResetInputOutputGroupUid = @CrisisResetInputOutputGroupUid
,AccessPortalLockedLedBehaviorModeUid = @AccessPortalLockedLedBehaviorModeUid
,AccessPortalUnlockedLedBehaviorModeUid = @AccessPortalUnlockedLedBehaviorModeUid
,AccessPortalTypeUid = @AccessPortalTypeUid
,TemplateAccessPortalUid = @TemplateAccessPortalUid
,AbaClipOption = @AbaClipOption
--,ClusterGroupId = @ClusterGroupId
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
ClusterUid = @ClusterUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.Cluster table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_UpdateConcurrency]
@ClusterUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.Cluster
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
ClusterUid = @ClusterUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.Cluster table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_DeleteByPK]
@ClusterUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.Cluster
WHERE
ClusterUid = @ClusterUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[ClusterPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.Cluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.Cluster

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ClusterPDSA_RowCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Cluster_SelectionListForSite]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Cluster_SelectionListForSite]
GO

CREATE OR ALTER PROCEDURE [GCS].[Cluster_SelectionListForSite]
	@SiteUid [uniqueidentifier],
	@PageNumber int,
	@PageSize int,
	@SortColumn nvarchar(255) = 'InsertDate',
	@DescendingOrder bit = 1
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Cluster

if @PageSize = 0
	set @PageSize = 1

select c.ClusterUid, c.SiteUid, c.ClusterName, c.ClusterNumber, c.ClusterGroupId, c.EntityId, br.BinaryResource, COUNT(*) OVER() TotalRowCount from GCS.Cluster c
left outer join GCS.gcsBinaryResource br on br.BinaryResourceUid = c.BinaryResourceUid
WHERE c.SiteUid = @SiteUid
ORDER BY (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 0 THEN ClusterName end) asc,
         (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 1 THEN ClusterName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN c.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN c.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN c.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN c.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

ALTER AUTHORIZATION ON [GCS].[Cluster_SelectionListForSite] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[Cluster_SelectionListForSite] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Cluster_SelectionListForEntityAndSite]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Cluster_SelectionListForEntityAndSite]
GO

CREATE OR ALTER PROCEDURE [GCS].[Cluster_SelectionListForEntityAndSite]
	@EntityId [uniqueidentifier],
	@SiteUid [uniqueidentifier],
	@PageNumber int,
	@PageSize int,
	@SortColumn nvarchar(255) = 'InsertDate',
	@DescendingOrder bit = 1
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Cluster

if @PageSize = 0
	set @PageSize = 1

select c.ClusterUid, c.SiteUid, c.ClusterName, c.ClusterNumber, c.ClusterGroupId, c.EntityId, br.BinaryResource, COUNT(*) OVER() TotalRowCount
 from GCS.Cluster c
left outer join GCS.gcsBinaryResource br on br.BinaryResourceUid = c.BinaryResourceUid
WHERE c.EntityId = @EntityId or c.ClusterUid in (select ClusterUid from GCS.ClusterEntityMap where EntityId = @EntityId)
AND c.SiteUid = @SiteUid
ORDER BY (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 0 THEN ClusterName end) asc,
         (CASE WHEN @SortColumn = 'ClusterName' AND @DescendingOrder = 1 THEN ClusterName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN c.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN c.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN c.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN c.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[Cluster_SelectionListForEntityAndSite] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[Cluster_SelectionListForEntityAndSite] TO [public] AS [dbo]
GO


if dbo.fn_GCSDoesColumnExist('gcsEntityIdProducer', 'SignalRUrl') = 0
BEGIN
	ALTER TABLE GCS.gcsEntityIdProducer
	ADD SignalRUrl nvarchar(255) null
END
GO

UPDATE GCS.gcsEntityIdProducer SET SignalRUrl = 'http://localhost:81/idProducer.BadgingServer/' WHERE SignalRUrl IS NULL
GO

ALTER TABLE GCS.gcsEntityIdProducer
ALTER COLUMN SignalRUrl nvarchar(255) NOT NULL
GO


/* All Stored Procedures for table: gcsEntityIdProducer */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsEntityIdProducer table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityIdProducerPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityIdProducerPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsEntityIdProducerPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityId
,Url
,DevUrl
,WebClientUrl
,SignalRUrl
,SubscriptionId
,idProducerUserName
,idProducerPassword
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsEntityIdProducer

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityIdProducerPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsEntityIdProducer table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityIdProducerPDSA_ByPersonUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityIdProducerPDSA_ByPersonUid]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityIdProducerPDSA_ByPersonUid]
@PersonUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
t.EntityId
,Url
,DevUrl
,WebClientUrl
,SignalRUrl
,SubscriptionId
,idProducerUserName
,idProducerPassword
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
FROM GCS.gcsEntityIdProducer t
JOIN GCS.Person p on p.EntityId = t.EntityId
WHERE p.PersonUid = @PersonUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityIdProducerPDSA_ByPersonUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsEntityIdProducer table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityIdProducerPDSA_BySubscriptionId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityIdProducerPDSA_BySubscriptionId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityIdProducerPDSA_BySubscriptionId]
@SubscriptionId int 
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityId
,Url
,DevUrl
,WebClientUrl
,SignalRUrl
,SubscriptionId
,idProducerUserName
,idProducerPassword
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsEntityIdProducer
WHERE SubscriptionId = @SubscriptionId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityIdProducerPDSA_BySubscriptionId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.gcsEntityIdProducer table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityIdProducerPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityIdProducerPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsEntityIdProducerPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityId
,Url
FROM GCS.gcsEntityIdProducer

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityIdProducerPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsEntityIdProducer table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityIdProducerPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityIdProducerPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityIdProducerPDSA_SelectByPK]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityId
,Url
,DevUrl
,WebClientUrl
,SignalRUrl
,SubscriptionId
,idProducerUserName
,idProducerPassword
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsEntityIdProducer
WHERE 
EntityId = @EntityId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityIdProducerPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsEntityIdProducer table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityIdProducerPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityIdProducerPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityIdProducerPDSA_SelectSearch]
@Url nvarchar(255) 
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityId
,Url
,DevUrl
,WebClientUrl
,SignalRUrl
,SubscriptionId
,idProducerUserName
,idProducerPassword
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsEntityIdProducer
WHERE 
(@Url IS NULL OR Url LIKE @Url + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityIdProducerPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.gcsEntityIdProducer table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityIdProducerPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityIdProducerPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityIdProducerPDSA_Insert]
@EntityId uniqueidentifier 
,@Url nvarchar(255) 
,@DevUrl nvarchar(255)
,@WebClientUrl nvarchar(255) 
,@SignalRUrl nvarchar(255)
,@SubscriptionId int 
,@idProducerUserName nvarchar(50)  = null
,@idProducerPassword nvarchar(50)  = null
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

INSERT INTO GCS.gcsEntityIdProducer
(
EntityId
,Url
,DevUrl
,WebClientUrl
,SignalRUrl
,SubscriptionId
,idProducerUserName
,idProducerPassword
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@EntityId
,@Url
,@DevUrl
,@WebClientUrl
,@SignalRUrl
,@SubscriptionId
,@idProducerUserName
,@idProducerPassword
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityIdProducerPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsEntityIdProducer table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityIdProducerPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityIdProducerPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityIdProducerPDSA_Update]
@EntityId uniqueidentifier 
,@Url nvarchar(255)
,@DevUrl nvarchar(255)
,@WebClientUrl nvarchar(255)
,@SignalRUrl nvarchar(255)
,@SubscriptionId int
,@idProducerUserName nvarchar(50)
,@idProducerPassword nvarchar(50)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsEntityIdProducer
SET 
EntityId = @EntityId
,Url = @Url
,DevUrl = @DevUrl
,WebClientUrl = @WebClientUrl
,SignalRUrl = @SignalRUrl
,SubscriptionId = @SubscriptionId
,idProducerUserName = @idProducerUserName
,idProducerPassword = @idProducerPassword
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
EntityId = @EntityId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsEntityIdProducerPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsEntityIdProducer table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityIdProducerPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityIdProducerPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityIdProducerPDSA_UpdateConcurrency]
@EntityId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsEntityIdProducer
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
EntityId = @EntityId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsEntityIdProducerPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsEntityIdProducer table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityIdProducerPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityIdProducerPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityIdProducerPDSA_DeleteByPK]
@EntityId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsEntityIdProducer
WHERE
EntityId = @EntityId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityIdProducerPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsEntityIdProducer table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityIdProducerPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityIdProducerPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityIdProducerPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsEntityIdProducer

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityIdProducerPDSA_RowCount] TO public
GO


exec dbo.gcs_DeleteCheckConstraint 'GCS', 'UserDefinedPropertyType', 'CKC_PROPERTYTYPE_USERDEFI'
go 

ALTER TABLE [GCS].[UserDefinedPropertyType]  WITH CHECK ADD  CONSTRAINT [CKC_PROPERTYTYPE_USERDEFI] CHECK  (([PropertyType]='Guid' OR [PropertyType]='List' OR [PropertyType]='Date' OR [PropertyType]='Boolean' OR [PropertyType]='Number' OR [PropertyType]='Text' OR [PropertyType]='Photo'))
GO


if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.PersonCredentialBadgeDataView')
            AND   type = 'V')
   drop view GCS.PersonCredentialBadgeDataView
go

/*==============================================================*/
/* View: PersonCredentialBadgeDataView                        */
/*==============================================================*/
create view GCS.PersonCredentialBadgeDataView as
		SELECT p.PersonUid, 
	pc.PersonCredentialUid,
	p.ActivationDateTime,
	p.Company,
	p.ConcurrencyValue,
	p.CountryOfBirthUid,
	p.DateOfBirth,
	p.DepartmentUid,
	p.EmploymentDate,
	p.EntityId,
	p.Ethnicity,
	p.ExpirationDateTime,
	p.FirstName,
	p.FullName,
	p.GenderUid,
	p.HasPhysicalDisability,
	p.HasVertigo,
	p.HomeOfficeLocation,
	p.Initials,
	p.InsertDate,
	p.InsertName,
	p.JobTitle,
	p.LastName,
	p.LegalName,
	p.MiddleName,
	p.NationalIdentificationNumber,
	p.Nationality,
	p.NickName,
	p.OriginId,
	p.PersonActiveStatusTypeUid,
	p.PersonId,
	p.PersonRecordTypeUid,
	p.PreferredName,
	p.PrimaryLanguage,
	p.Race,
	p.RowOrigin,
	p.SecondaryLanguage,
	p.SysGalEmployeeId,
	p.TerminationDate,
	p.TextData1,
	p.TextData2,
	p.TextData3,
	p.TextData4,
	p.TextData5,
	p.TextData6,
	p.TextData7,
	p.TextData8,
	p.TextData9,
	p.TextData10,
	p.TextData11,
	p.TextData12,
	p.TextData13,
	p.TextData14,
	p.TextData15,
	p.TextData16,
	p.TextData17,
	p.TextData18,
	p.TextData19,
	p.TextData20,
	p.TextData21,
	p.TextData22,
	p.TextData23,
	p.TextData24,
	p.TextData25,
	p.TextData26,
	p.TextData27,
	p.TextData28,
	p.TextData29,
	p.TextData30,
	p.TextData31,
	p.TextData32,
	p.TextData33,
	p.TextData34,
	p.TextData35,
	p.TextData36,
	p.TextData37,
	p.TextData38,
	p.TextData39,
	p.TextData40,
	p.TextData41,
	p.TextData42,
	p.TextData43,
	p.TextData44,
	p.TextData45,
	p.TextData46,
	p.TextData47,
	p.TextData48,
	p.TextData49,
	p.TextData50,
	p.Trace,
	p.UpdateDate,
	p.UpdateName,
	p.VeryImportantPerson,
	mainPhoto.PhotoImage as 'PersonPhotoMainPhoto',
	altPhoto.PhotoImage as 'PersonPhotoAlternatePhoto',
	pacp.AccessProfileUid,
	accessProfile.AccessProfileName,
	pc.ActivationDateTime as 'CredentialActivationDate',
	pc.CredentialDescription,
	pc.ExpirationDateTime as 'CredentialExpirationDateTime',
	c.CardNumber as CredentialCardNumber,
	cred26Wiegand.FacilityCode as Credential26BitStandardFacilityCode,
	cred26Wiegand.IdCode as Credential26BitStandardIdCode,
	credCorp1k35.CompanyCode as CredentialCorporate1K35BitCompanyCode,
	credCorp1k35.IdCode as CredentialCorporate1K35BitIdCode,
	credCorp1k48.CompanyCode as CredentialCorporate1K48BitCompanyCode,
	credCorp1k48.IdCode as CredentialCorporate1K48BitIdCode,
	credCyp37.FacilityCode as CredentialCypress37BitFacilityCode,
	credCyp37.IdCode as CredentialCypress37BitIdCode,
	credH1030237.IdCode as CredentialH1030237BitIdCode,
	credH1030437.FacilityCode as CredentialH1030437BitFacilityCode,
	credH1030437.IdCode as CredentialH1030437BitIdCode,
	credSWH37.FacilityCode as CredentialSoftwareHouse37BitFacilityCode,
	credSWH37.SiteCode as CredentialSoftwareHouse37BitSiteCode,
	credSWH37.IdCode as CredentialSoftwareHouse37BitIdCode,
	credXceed40.SiteCode as CredentialXceedId40BitSiteCode,
	credXceed40.IdCode as CredentialXceedId40BitIdCode,
	country.CountryName,
	dept.DepartmentName,
	entity.EntityName,
	gender.Display as 'Gender',
	activeStatus.Display as 'PersonActiveStatusType',
	recordType.Display as 'PersonRecordType',
	GetDate() as Date1,
	GetDate() as Date2,
	'' as SelectItem1,
	'' as SelectItem2,
	'' as SelectItem3,
	'' as SelectItem4,
	'' as SelectItem5,
	'' as SelectItem6,
	'' as SelectItem7,
	'' as SelectItem8,
	'' as SelectItem9,
	'' as SelectItem10,
	(SELECT CONVERT(date, getdate())) as CurrentDate,
	SYSDATETIMEOFFSET() as 'CurrentDateTime',
	badgeTemp.TemplateName as BadgeTemplateName,
	dossierTemp.TemplateName as DossierTemplateName
	FROM GCS.Person p
	JOIN GCS.PersonCredential pc on pc.PersonUid = p.PersonUid
	LEFT OUTER JOIN GCS.PersonPhoto mainPhoto on mainPhoto.PersonUid = p.PersonUid AND mainPhoto.Tag = '*'
	LEFT OUTER JOIN GCS.PersonPhoto altPhoto on altPhoto.PersonUid = p.PersonUid AND mainPhoto.Tag = '2'
	LEFT OUTER JOIN GCS.PersonAccessControlProperties pacp on pacp.PersonUid = p.PersonUid
	LEFT OUTER JOIN GCS.AccessProfile accessProfile on accessProfile.AccessProfileUid = pacp.AccessProfileUid
	LEFT OUTER JOIN GCS.Credential c on c.CredentialUid = pc.CredentialUid
	LEFT OUTER JOIN GCS.Credential26BitStandard cred26Wiegand on cred26Wiegand.CredentialUid = c.CredentialUid
	LEFT OUTER JOIN GCS.CredentialCorporate1K35Bit credCorp1k35 on credCorp1k35.CredentialUid = c.CredentialUid
	LEFT OUTER JOIN GCS.CredentialCorporate1K48Bit credCorp1k48 on credCorp1k48.CredentialUid = c.CredentialUid
	LEFT OUTER JOIN GCS.CredentialCypress37Bit credCyp37 on credCyp37.CredentialUid = c.CredentialUid
	LEFT OUTER JOIN GCS.CredentialH1030237Bit credH1030237 on credH1030237.CredentialUid = c.CredentialUid
	LEFT OUTER JOIN GCS.CredentialH1030437Bit credH1030437 on credH1030437.CredentialUid = c.CredentialUid
	LEFT OUTER JOIN GCS.CredentialSoftwareHouse37Bit credSWH37 on credSWH37.CredentialUid = c.CredentialUid
	LEFT OUTER JOIN GCS.CredentialXceedId40Bit credXceed40 on credXceed40.CredentialUid = c.CredentialUid
	LEFT OUTER JOIN GCS.Country country on country.CountryUid = p.CountryOfBirthUid
	LEFT OUTER JOIN GCS.Department dept on dept.DepartmentUid = p.DepartmentUid
	JOIN GCS.gcsEntity entity on entity.EntityId = p.EntityId
	LEFT OUTER JOIN GCS.Gender gender on gender.GenderUid = p.GenderUid
	LEFT OUTER JOIN GCS.PersonActiveStatusType activeStatus on activeStatus.PersonActiveStatusTypeUid = p.PersonActiveStatusTypeUid
	LEFT OUTER JOIN GCS.PersonRecordType recordType on recordType.PersonRecordTypeUid = p.PersonRecordTypeUid
	LEFT OUTER JOIN GCS.BadgeTemplate badgeTemp on badgeTemp.BadgeTemplateUid = pc.BadgeTemplateUid
	LEFT OUTER JOIN GCS.BadgeTemplate dossierTemp on dossierTemp.BadgeTemplateUid = pc.DossierBadgeTemplateUid
go



--CREATE OR ALTER FUNCTION [GCS].[Int2Argb] (@intColor int) 
--RETURNS nvarchar(20)
--as
--begin
--declare @argb nvarchar(20)

--	set @argb = '#' +  right(master.sys.fn_varbintohexstr(@intColor),8)
--	return @argb
--end
--go

--GRANT EXECUTE ON GCS.[Int2Argb] TO public
--GO

if dbo.fn_GCSDoesViewExist('ActivityHistoryView') = 1
BEGIN
	DROP VIEW GCS.ActivityHistoryView
END
go


if dbo.fn_GCSDoesColumnExist('gcsEntity', 'ClusterGroupId') = 0
BEGIN
	ALTER TABLE [GCS].[gcsEntity]
	ADD ClusterGroupId [int] NOT NULL default 0
END
go 

--update GCS.gcsEntity set ClusterGroupId = 0

begin
declare @cgid int = 0
declare @entid uniqueidentifier

-- Change Cluster # for Alex's cluster to # 2
	--update GCS.Cluster set ClusterNumber = 2 where ClusterUid = '27D50B43-CBC3-49BD-B4AE-AF4D005B47C0'
	--update GCS.GalaxyCpu set ClusterNumber = 2 where GalaxyPanelUid in (select GalaxyPanelUid from GCS.GalaxyPanel where ClusterUid = '27D50B43-CBC3-49BD-B4AE-AF4D005B47C0') 
	DECLARE cgidCursor CURSOR FOR SELECT EntityId from GCS.gcsEntity where EntityId not in ('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000002' ) AND ClusterGroupId = 0
	OPEN cgidCursor
	FETCH NEXT FROM cgidCursor INTO @entid
	WHILE @@FETCH_STATUS = 0
	BEGIN
		set @cgid = GCS.fnChooseAvailableClusterGroupId()
		update GCS.gcsEntity set ClusterGroupId = @cgid where current of cgidCursor
		--update GCS.Cluster set ClusterGroupId = @cgid where EntityId = @entid
		update GCS.GalaxyCpu set ClusterGroupId = @cgid where GalaxyPanelUid in (select GalaxyPanelUid from GCS.GalaxyPanel where ClusterUid in (select ClusterUid from GCS.Cluster where EntityId = @entid)) 
		FETCH NEXT FROM cgidCursor INTO @entid
	end
	CLOSE cgidCursor;
	DEALLOCATE cgidCursor;
end

/*==============================================================*/
/* Index: idx_EntityClusterGroupId                              */
/*==============================================================*/
if dbo.[fn_GCSDoesIndexExist]('gcsEntity', 'idx_EntityClusterGroupId') = 0
BEGIN
	create unique nonclustered index idx_EntityClusterGroupId on GCS.gcsEntity (ClusterGroupId ASC)
	   where EntityId <> '00000000-0000-0000-0000-000000000001'
END
GO

if dbo.fn_GCSDoesColumnExist('gcsEntity', 'TimeZoneId') = 0
BEGIN
	ALTER TABLE [GCS].[gcsEntity]
	ADD [TimeZoneId] [nvarchar](65) NOT NULL default '*'
END
go 

/****** Object:  Index [idxAccessPortalActivityEventUniqueId]    Script Date: 5/24/2021 2:58:18 PM ******/
if dbo.[fn_GCSDoesIndexExist]('Cluster', 'idxClusterNumberGroupId') = 1
BEGIN
	DROP INDEX [idxClusterNumberGroupId] ON [GCS].[Cluster]
END
GO

/****** Object:  Index [idxClusterNumber]    Script Date: 5/24/2021 2:58:18 PM ******/
if dbo.[fn_GCSDoesIndexExist]('Cluster', 'idxClusterNumber') = 0
BEGIN

	/****** Object:  Index [idxClusterName]    Script Date: 4/17/2023 2:28:49 PM ******/
	CREATE UNIQUE NONCLUSTERED INDEX [idxClusterNumber] ON [GCS].[Cluster]
	(
		[EntityId] ASC,
		[ClusterNumber] ASC
	)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
END
GO



if dbo.fn_GCSDoesColumnExist('Cluster', 'ClusterGroupIdOrig') = 0
BEGIN
	alter table GCS.Cluster
	ADD ClusterGroupIdOrig int null;
END
go 

update GCS.Cluster set ClusterGroupIdOrig = ClusterGroupId where ClusterGroupIdOrig is null
go

exec dbo.gcs_DeleteDefaultConstraint 'GCS','Cluster', 'ClusterGroupId'
go

if dbo.fn_GCSDoesColumnExist('Cluster', 'ClusterGroupId') = 1
BEGIN
	ALTER TABLE [GCS].[Cluster]
	DROP COLUMN ClusterGroupId
END
go 

CREATE OR ALTER FUNCTION [GCS].[fnGetEntityClusterGroupId] (@entityId uniqueidentifier) 
RETURNS int
as
begin
	declare @cgid int = -1
	select @cgid = ClusterGroupId from GCS.gcsEntity where EntityId = @entityId
	return @cgid

end
go

GRANT EXECUTE ON GCS.[fnGetEntityClusterGroupId] TO public
GO


if dbo.fn_GCSDoesColumnExist('Cluster', 'ClusterGroupId') = 0
BEGIN
	ALTER TABLE [GCS].[Cluster]
	add ClusterGroupId as (GCS.fnGetEntityClusterGroupId(EntityId));
END
go 

if dbo.fn_GCSDoesColumnExist('GalaxyActivityEventType', 'DeviceType') = 0
BEGIN
	ALTER TABLE GCS.GalaxyActivityEventType
	ADD DeviceType varchar(50) null
END
GO

--update GCS.GalaxyActivityEventType set DeviceType = null
update GCS.GalaxyActivityEventType SET DeviceType = 'InputOutputGroup' WHERE DeviceType IS NULL AND
(EventType like '%IoGroup%' OR EventType like '%DoorGroup%')
go

update GCS.GalaxyActivityEventType SET DeviceType = 'InputDevice' WHERE DeviceType IS NULL AND
(EventType like '%Point%' OR EventType like '%Input%')
go

update GCS.GalaxyActivityEventType SET DeviceType = 'OutputDevice' WHERE DeviceType IS NULL AND
EventType like '%Output%'
go

update GCS.GalaxyActivityEventType SET DeviceType = 'Elevator' WHERE DeviceType IS NULL AND
EventType like '%Elevator%'
go

update GCS.GalaxyActivityEventType SET DeviceType = 'GalaxyPanel' WHERE DeviceType IS NULL AND
(EventType like '%CPU%' OR EventType like '%CrisisMode%' OR EventType like '%PassbackForgiven%' OR (EventType like '%activated%' and EventType not like 'AutoUnlockActivatedByAccessGranted')
OR EventType like '%DualSerialInterface%' OR EventType like '%EmergencyUnlock%' OR EventType like 'BoardCommunication%' )
go

update GCS.GalaxyActivityEventType SET DeviceType = 'AccessPortal' WHERE DeviceType IS NULL
go

if dbo.fn_GCSDoesColumnExist('GalaxyActivityEventType', 'ForeColorHex') = 1
BEGIN
	ALTER TABLE GCS.GalaxyActivityEventType
	DROP COLUMN ForeColorHex
END
GO

if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.ActivityEventView')
            AND   type = 'V')
begin
	drop view GCS.ActivityEventView
end
go


if dbo.fn_GCSDoesColumnExist('ActivityEvent', 'ForeColorHex') = 1
BEGIN
	ALTER TABLE GCS.ActivityEvent
	DROP COLUMN ForeColorHex
END
GO


CREATE OR ALTER FUNCTION [GCS].[Int2Rgba] (@intColor int) 
RETURNS nvarchar(20)
as
begin

declare @rgba nvarchar(20)
declare @hexstring nvarchar(20)
declare @a nvarchar(2)
declare @rgb nvarchar(6)

	set @hexstring = right(master.sys.fn_varbintohexstr(@intColor),8);
	set @a=left(@hexstring, 2)
	set @rgb=right(@hexstring, 6)

	--print @hexstring
	--print 'a:' + @a
	--print 'rgb:' + @rgb
	set @rgba = '#' + @rgb+@a
	--print @rgba
	return @rgba
end
go

GRANT EXECUTE ON GCS.[Int2Rgba] TO public
GO


if dbo.fn_GCSDoesColumnExist('GalaxyActivityEventType', 'ForeColorHex') = 0
BEGIN
	ALTER TABLE GCS.GalaxyActivityEventType
	ADD ForeColorHex as ([GCS].[Int2Rgba](ForeColor));
END
GO


if dbo.fn_GCSDoesColumnExist('ActivityEvent', 'ForeColorHex') = 0
BEGIN
	ALTER TABLE GCS.ActivityEvent
	ADD ForeColorHex as ([GCS].[Int2Rgba](ForeColor));
END
GO

if dbo.fn_GCSDoesColumnExist('AccessPortalActivityAlarmEvent', 'ResponseRequired') = 0
BEGIN
	ALTER TABLE GCS.AccessPortalActivityAlarmEvent
	ADD ResponseRequired bit not null default 0;
END
GO


if dbo.fn_GCSDoesColumnExist('AccessPortalAlertEvent', 'ResponseRequired') = 0
BEGIN
	ALTER TABLE GCS.AccessPortalAlertEvent
	ADD ResponseRequired bit not null default 0;
END
GO


if dbo.fn_GCSDoesColumnExist('GalaxyPanelActivityAlarmEvent', 'ResponseRequired') = 0
BEGIN
	ALTER TABLE GCS.GalaxyPanelActivityAlarmEvent
	ADD ResponseRequired bit not null default 0;
END
GO


if dbo.fn_GCSDoesColumnExist('GalaxyPanelAlertEvent', 'ResponseRequired') = 0
BEGIN
	ALTER TABLE GCS.GalaxyPanelAlertEvent
	ADD ResponseRequired bit not null default 0;
END
GO


if dbo.fn_GCSDoesColumnExist('InputDeviceActivityAlarmEvent', 'ResponseRequired') = 0
BEGIN
	ALTER TABLE GCS.InputDeviceActivityAlarmEvent
	ADD ResponseRequired bit not null default 0;
END
GO


if dbo.fn_GCSDoesColumnExist('InputDeviceAlertEvent', 'ResponseRequired') = 0
BEGIN
	ALTER TABLE GCS.InputDeviceAlertEvent
	ADD ResponseRequired bit not null default 0;
END
GO


if dbo.[fn_GCSDoesIndexExist]('AccessPortalActivityEvent', 'idxAccessPortalActivityEvent') = 1
BEGIN
	/****** Object:  Index [idxAccessPortalActivityEvent]    Script Date: 2/17/2023 8:20:08 AM ******/
	DROP INDEX [idxAccessPortalActivityEvent] ON [GCS].[AccessPortalActivityEvent]
END
GO

if dbo.[fn_GCSDoesIndexExist]('AccessPortalActivityEvent', 'idxAccessPortalActivityEventDateTime') = 1
BEGIN
	/****** Object:  Index [idxAccessPortalActivityEventDateTime]    Script Date: 2/17/2023 8:20:56 AM ******/
	DROP INDEX [idxAccessPortalActivityEventDateTime] ON [GCS].[AccessPortalActivityEvent]
END
GO

if dbo.[fn_GCSDoesIndexExist]('AccessPortalActivityEvent', 'idxAccessPortalActivityEventUniqueId') = 1
BEGIN
	/****** Object:  Index [idxAccessPortalActivityEventUniqueId]    Script Date: 2/17/2023 8:21:35 AM ******/
	DROP INDEX [idxAccessPortalActivityEventUniqueId] ON [GCS].[AccessPortalActivityEvent]
END
GO

if dbo.gcs_GetColumnDataType( 'GCS', 'AccessPortalActivityEvent', 'ActivityDateTime') <> 'datetimeoffset'
begin
	alter table GCS.AccessPortalActivityEvent 
	alter column ActivityDateTime datetimeoffset(7) not null
end
go

if dbo.fn_GCSDoesColumnExist('AccessPortalActivityEvent', 'ActivityDateTimeUTC') = 0
BEGIN
	ALTER TABLE GCS.AccessPortalActivityEvent
	ADD ActivityDateTimeUTC as ActivityDateTime AT TIME ZONE 'UTC'
END
GO

/****** Object:  Index [idxAccessPortalActivityEvent]    Script Date: 2/17/2023 8:20:08 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxAccessPortalActivityEvent] ON [GCS].[AccessPortalActivityEvent]
(
	[CpuUid] ASC,
	[ActivityDateTime] ASC,
	[BufferIndex] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO


/****** Object:  Index [idxAccessPortalActivityEventDateTime]    Script Date: 2/17/2023 8:20:56 AM ******/
CREATE NONCLUSTERED INDEX [idxAccessPortalActivityEventDateTime] ON [GCS].[AccessPortalActivityEvent]
(
	[ActivityDateTime] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO

/****** Object:  Index [idxAccessPortalActivityEventUniqueId]    Script Date: 2/17/2023 8:21:35 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxAccessPortalActivityEventUniqueId] ON [GCS].[AccessPortalActivityEvent]
(
	[CpuNumber] ASC,
	[ActivityDateTime] ASC,
	[BufferIndex] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO


if dbo.[fn_GCSDoesIndexExist]('GalaxyPanelActivityEvent', 'idxGalaxyPanelActivityEvent') = 1
BEGIN
	/****** Object:  Index [idxGalaxyPanelActivityEvent]    Script Date: 2/17/2023 9:14:15 AM ******/
	DROP INDEX [idxGalaxyPanelActivityEvent] ON [GCS].[GalaxyPanelActivityEvent]
END
GO

if dbo.[fn_GCSDoesIndexExist]('GalaxyPanelActivityEvent', 'idxGalaxyPanelActivityEventDateTime') = 1
BEGIN
	/****** Object:  Index [idxGalaxyPanelActivityEventDateTime]    Script Date: 2/17/2023 9:16:28 AM ******/
	DROP INDEX [idxGalaxyPanelActivityEventDateTime] ON [GCS].[GalaxyPanelActivityEvent]
END
GO

if dbo.gcs_GetColumnDataType( 'GCS', 'GalaxyPanelActivityEvent', 'ActivityDateTime') <> 'datetimeoffset'
begin
	alter table GCS.GalaxyPanelActivityEvent 
	alter column ActivityDateTime datetimeoffset(7) not null
end
go

if dbo.fn_GCSDoesColumnExist('GalaxyPanelActivityEvent', 'ActivityDateTimeUTC') = 0
BEGIN
	ALTER TABLE GCS.GalaxyPanelActivityEvent
	ADD ActivityDateTimeUTC as ActivityDateTime AT TIME ZONE 'UTC'
END
GO

/****** Object:  Index [idxGalaxyPanelActivityEvent]    Script Date: 2/17/2023 9:15:55 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxGalaxyPanelActivityEvent] ON [GCS].[GalaxyPanelActivityEvent]
(
	[ActivityDateTime] ASC,
	[CpuUid] ASC,
	[BufferIndex] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO

/****** Object:  Index [idxGalaxyPanelActivityEventDateTime]    Script Date: 2/17/2023 9:16:28 AM ******/
CREATE NONCLUSTERED INDEX [idxGalaxyPanelActivityEventDateTime] ON [GCS].[GalaxyPanelActivityEvent]
(
	[ActivityDateTime] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO


if dbo.[fn_GCSDoesIndexExist]('InputDeviceActivityEvent', 'idxInputDeviceActivityEvent') = 1
BEGIN
	/****** Object:  Index [idxInputDeviceActivityEvent]    Script Date: 2/17/2023 9:18:07 AM ******/
	DROP INDEX [idxInputDeviceActivityEvent] ON [GCS].[InputDeviceActivityEvent]
END
GO

if dbo.[fn_GCSDoesIndexExist]('InputDeviceActivityEvent', 'idxInputDeviceActivityEventDateTime') = 1
BEGIN
	/****** Object:  Index [idxInputDeviceActivityEventDateTime]    Script Date: 2/17/2023 9:18:31 AM ******/
	DROP INDEX [idxInputDeviceActivityEventDateTime] ON [GCS].[InputDeviceActivityEvent]
END
GO

if dbo.gcs_GetColumnDataType( 'GCS', 'InputDeviceActivityEvent', 'ActivityDateTime') <> 'datetimeoffset'
begin
	alter table GCS.InputDeviceActivityEvent 
	alter column ActivityDateTime datetimeoffset(7) not null
end
go

if dbo.fn_GCSDoesColumnExist('InputDeviceActivityEvent', 'ActivityDateTimeUTC') = 0
BEGIN
	ALTER TABLE GCS.InputDeviceActivityEvent
	ADD ActivityDateTimeUTC as ActivityDateTime AT TIME ZONE 'UTC'
END
GO

/****** Object:  Index [idxInputDeviceActivityEvent]    Script Date: 2/17/2023 9:18:08 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxInputDeviceActivityEvent] ON [GCS].[InputDeviceActivityEvent]
(
	[CpuUid] ASC,
	[ActivityDateTime] ASC,
	[BufferIndex] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO


/****** Object:  Index [idxInputDeviceActivityEventDateTime]    Script Date: 2/17/2023 9:18:32 AM ******/
CREATE NONCLUSTERED INDEX [idxInputDeviceActivityEventDateTime] ON [GCS].[InputDeviceActivityEvent]
(
	[ActivityDateTime] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO



if dbo.[fn_GCSDoesIndexExist]('OutputDeviceActivityEvent', 'idxOutputDeviceActivityEvent') = 1
BEGIN
	/****** Object:  Index [idxOutputDeviceActivityEvent]    Script Date: 2/17/2023 9:20:49 AM ******/
	DROP INDEX [idxOutputDeviceActivityEvent] ON [GCS].[OutputDeviceActivityEvent]
END
GO

if dbo.[fn_GCSDoesIndexExist]('OutputDeviceActivityEvent', 'idxOutputDeviceActivityEventDateTime') = 1
BEGIN
	/****** Object:  Index [idxOutputDeviceActivityEventDateTime]    Script Date: 2/17/2023 9:21:31 AM ******/
	DROP INDEX [idxOutputDeviceActivityEventDateTime] ON [GCS].[OutputDeviceActivityEvent]
END
GO

if dbo.gcs_GetColumnDataType( 'GCS', 'OutputDeviceActivityEvent', 'ActivityDateTime') <> 'datetimeoffset'
begin
	alter table GCS.OutputDeviceActivityEvent 
	alter column ActivityDateTime datetimeoffset(7) not null
end
go

if dbo.fn_GCSDoesColumnExist('OutputDeviceActivityEvent', 'ActivityDateTimeUTC') = 0
BEGIN
	ALTER TABLE GCS.OutputDeviceActivityEvent
	ADD ActivityDateTimeUTC as ActivityDateTime AT TIME ZONE 'UTC'
END
GO


/****** Object:  Index [idxOutputDeviceActivityEvent]    Script Date: 2/17/2023 9:20:49 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxOutputDeviceActivityEvent] ON [GCS].[OutputDeviceActivityEvent]
(
	[CpuUid] ASC,
	[ActivityDateTime] ASC,
	[BufferIndex] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO

/****** Object:  Index [idxOutputDeviceActivityEventDateTime]    Script Date: 2/17/2023 9:21:31 AM ******/
CREATE NONCLUSTERED INDEX [idxOutputDeviceActivityEventDateTime] ON [GCS].[OutputDeviceActivityEvent]
(
	[ActivityDateTime] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO



if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.DeviceAlertEventSettingsView')
            AND   type = 'V')
begin
	drop view GCS.DeviceAlertEventSettingsView
end
go


exec dbo.[gcs_DeleteIndex] 'GCS', 'AccessPortal', 'idxAccessPortalName'
go

ALTER TABLE GCS.AccessPortal
ALTER COLUMN PortalName nvarchar(65) not null
GO

CREATE UNIQUE NONCLUSTERED INDEX [idxAccessPortalName] ON [GCS].[AccessPortal]
(
	[SiteUid] ASC,
	[PortalName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO

exec dbo.gcs_DeleteDefaultConstraint 'GCS','AccessPortalAlarmEventAcknowledgment', 'InsertDate'
go


if dbo.gcs_GetColumnDataType( 'GCS', 'AccessPortalAlarmEventAcknowledgment', 'InsertDate') <> 'datetimeoffset'
begin
	alter table GCS.AccessPortalAlarmEventAcknowledgment 
	alter column InsertDate datetimeoffset(7) not null
end
go

alter table GCS.AccessPortalAlarmEventAcknowledgment 
ADD CONSTRAINT DF_AccessPortalAlarmEventAcknowledgment_InsertDate DEFAULT SYSDATETIMEOFFSET() FOR InsertDate
go

exec dbo.gcs_DeleteDefaultConstraint 'GCS','AccessPortalAlarmEventAcknowledgment', 'UpdateDate'
go


if dbo.gcs_GetColumnDataType( 'GCS', 'AccessPortalAlarmEventAcknowledgment', 'UpdateDate') <> 'datetimeoffset'
begin
	alter table GCS.AccessPortalAlarmEventAcknowledgment 
	alter column UpdateDate datetimeoffset(7) not null
end
go

alter table GCS.AccessPortalAlarmEventAcknowledgment 
ADD CONSTRAINT DF_AccessPortalAlarmEventAcknowledgment_UpdateDate DEFAULT SYSDATETIMEOFFSET() FOR UpdateDate
go


exec dbo.gcs_DeleteDefaultConstraint 'GCS','GalaxyPanelAlarmEventAcknowledgment', 'InsertDate'
go


if dbo.gcs_GetColumnDataType( 'GCS', 'GalaxyPanelAlarmEventAcknowledgment', 'InsertDate') <> 'datetimeoffset'
begin
	alter table GCS.GalaxyPanelAlarmEventAcknowledgment 
	alter column InsertDate datetimeoffset(7) not null
end
go

alter table GCS.GalaxyPanelAlarmEventAcknowledgment 
ADD CONSTRAINT DF_GalaxyPanelAlarmEventAcknowledgment_InsertDate DEFAULT SYSDATETIMEOFFSET() FOR InsertDate
go


exec dbo.gcs_DeleteDefaultConstraint 'GCS','GalaxyPanelAlarmEventAcknowledgment', 'UpdateDate'
go


if dbo.gcs_GetColumnDataType( 'GCS', 'GalaxyPanelAlarmEventAcknowledgment', 'UpdateDate') <> 'datetimeoffset'
begin
	alter table GCS.GalaxyPanelAlarmEventAcknowledgment 
	alter column UpdateDate datetimeoffset(7) not null
end
go

alter table GCS.GalaxyPanelAlarmEventAcknowledgment 
ADD CONSTRAINT DF_GalaxyPanelAlarmEventAcknowledgment_UpdateDate DEFAULT SYSDATETIMEOFFSET() FOR UpdateDate
go





exec dbo.gcs_DeleteDefaultConstraint 'GCS','InputDeviceAlarmEventAcknowledgment', 'InsertDate'
go


if dbo.gcs_GetColumnDataType( 'GCS', 'InputDeviceAlarmEventAcknowledgment', 'InsertDate') <> 'datetimeoffset'
begin
	alter table GCS.InputDeviceAlarmEventAcknowledgment 
	alter column InsertDate datetimeoffset(7) not null
end
go

alter table GCS.InputDeviceAlarmEventAcknowledgment 
ADD CONSTRAINT DF_InputDeviceAlarmEventAcknowledgment_InsertDate DEFAULT SYSDATETIMEOFFSET() FOR InsertDate
go

exec dbo.gcs_DeleteDefaultConstraint 'GCS','InputDeviceAlarmEventAcknowledgment', 'UpdateDate'
go

if dbo.gcs_GetColumnDataType( 'GCS', 'InputDeviceAlarmEventAcknowledgment', 'UpdateDate') <> 'datetimeoffset'
begin
	alter table GCS.InputDeviceAlarmEventAcknowledgment 
	alter column UpdateDate datetimeoffset(7) not null
end
go

alter table GCS.InputDeviceAlarmEventAcknowledgment 
ADD CONSTRAINT DF_InputDeviceAlarmEventAcknowledgment_UpdateDate DEFAULT SYSDATETIMEOFFSET() FOR UpdateDate
go

/*==============================================================*/
/* View: ActivityHistoryView                        */
/*==============================================================*/
create or alter view GCS.ActivityHistoryView WITH SCHEMABINDING 
as
	select  apae.ActivityDateTime as ActivityDateTime, 
	apae.ActivityDateTimeUTC,
	--CASE 
	--	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = 'AD7E7002-E6EC-4E0C-AB4F-FA3D1C8E0F9F') IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = 'AD7E7002-E6EC-4E0C-AB4F-FA3D1C8E0F9F')
	--	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey)
	--	ELSE 
		gaet.Display
		--END 
		AS EventTypeMessage,
	gaet.ForeColor,
	gaet.ForeColorHex,
	ap.PortalName as DeviceName, site.SiteName, 
	ap.EntityId, 
	ap.AccessPortalUid as DeviceUid, 
	gaet.GalaxyActivityEventTypeUid as EventTypeUid,
	'AccessPortal' as [DeviceType], 
	p.LastName, p.FirstName, isnull( p.Trace, 0) as IsTraced,
	pc.CredentialDescription,
	apae.PersonUid, apae.CredentialUid,
	cluster.ClusterUid,
	cluster.ClusterNumber,
	cluster.ClusterName,
	cluster.ClusterGroupId,
	gp.PanelNumber,
	NULL as InputOutputGroupName,
	NULL as InputOutputGroupNumber,
	apae.CpuNumber,
	ib.BoardNumber,
	ibs.SectionNumber,
	ghm.ModuleNumber,
	ibsn.NodeNumber,
	apae.AccessPortalActivityEventUid as PK,	
	apaae.AlarmPriority,
	apaae.ResponseRequired,
	AckData.AcknowledgedTime,
	AckData.AcknowledgeComment,
	AckData.IsAcknowledgeable,
--	AckData.IsAcknowledged,
	IIF( (select count(*) from GCS.AccessPortalAlarmEventAcknowledgment apaae where apaae.AccessPortalActivityEventUid = apae.AccessPortalActivityEventUid) = 0, 0, 1) as IsAcknowledged,
	AckData.AcknowledgedByUser,
	ent.EntityName, ent.EntityType,
	(select count(*) from GCS.AccessPortalAlarmEventAcknowledgment apaae where apaae.AccessPortalActivityEventUid =  apae.AccessPortalActivityEventUid) as AckCount,
	COUNT(*) OVER() as TotalRecordCount,0 as PageNumber,0 as PageSize from GCS.AccessPortalActivityEvent apae
	join GCS.GalaxyActivityEventType gaet on gaet.GalaxyActivityEventTypeUid = apae.GalaxyActivityEventTypeUid
	join GCS.AccessPortal ap on ap.AccessPortalUid = apae.AccessPortalUid
	join GCS.Site site on site.SiteUid = ap.SiteUid
	join GCS.gcsEntity ent on ent.EntityId=ap.EntityId
	left outer join GCS.Person p on p.PersonUid = apae.PersonUid
	left outer join GCS.PersonCredential pc on pc.PersonUid = apae.PersonUid AND pc.CredentialUid = apae.CredentialUid
	left outer join GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = apae.AccessPortalUid
	left outer join GCS.GalaxyInterfaceBoardSectionNode ibsn on ibsn.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
	left outer join GCS.GalaxyHardwareModule ghm on ghm.GalaxyHardwareModuleUid = ibsn.GalaxyHardwareModuleUid
	left outer join GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = ghm.GalaxyInterfaceBoardSectionUid
	left outer join GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	left outer join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = apgha.GalaxyPanelUid
	left outer join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	left outer join GCS.AccessPortalActivityAlarmEvent apaae on apaae.AccessPortalActivityEventUid = apae.AccessPortalActivityEventUid
	--left outer join GCS.AccessPortalAlarmEventAcknowledgment apaea on apaea.AccessPortalActivityEventUid = apae.AccessPortalActivityEventUid
	--left outer join GCS.gcsUser u on u.UserId = apaea.UserId
	OUTER APPLY (SELECT TOP 1 apaea.InsertDate AS AcknowledgedTime, Response as AcknowledgeComment, 
	CASE WHEN AlarmPriority IS NOT NULL THEN 1 ELSE 0 END AS IsAcknowledgeable,
	CASE WHEN apaea.InsertDate IS NOT NULL THEN 1 ELSE 0 END AS IsAcknowledged,
	u.DisplayName as AcknowledgedByUser
	FROM GCS.AccessPortalAlarmEventAcknowledgment apaea
	left outer join GCS.gcsUser u on u.UserId = apaea.UserId WHERE apaea.AccessPortalActivityEventUid = apae.AccessPortalActivityEventUid) AckData
union
	select  gpae.ActivityDateTime as ActivityDateTime, 
	gpae.ActivityDateTimeUTC,
	--CASE 
	--	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = 'AD7E7002-E6EC-4E0C-AB4F-FA3D1C8E0F9F') IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = 'AD7E7002-E6EC-4E0C-AB4F-FA3D1C8E0F9F')
	--	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey)
	--	ELSE 
		gaet.Display
		--END 
		AS EventTypeMessage,
	gaet.ForeColor,
	gaet.ForeColorHex,
	gp.PanelName as DeviceName, site.SiteName, 
	cluster.EntityId, 
	gp.GalaxyPanelUid as DeviceUid,
	gaet.GalaxyActivityEventTypeUid as EventTypeUid,
	'GalaxyPanel' as [DeviceType], 
	p.LastName, p.FirstName, isnull( p.Trace, 0) as IsTraced,
	pc.CredentialDescription,
	gpae.PersonUid, 
	gpae.CredentialUid,
	cluster.ClusterUid,
	cluster.ClusterNumber,
	cluster.ClusterName,
	cluster.ClusterGroupId,
	gp.PanelNumber,
	iog.Display as InputOutputGroupName,
	gpae.InputOutputGroupNumber,
	gpae.CpuNumber,
	gpae.BoardNumber,
	gpae.SectionNumber,
	gpae.ModuleNumber,
	gpae.NodeNumber,
	gpae.GalaxyPanelActivityEventUid as PK,
	gpaae.AlarmPriority,
	gpaae.ResponseRequired,
	AckData.AcknowledgedTime,
	AckData.AcknowledgeComment,
	AckData.IsAcknowledgeable,
--	AckData.IsAcknowledged,
	IIF( (select count(*) from GCS.GalaxyPanelAlarmEventAcknowledgment gpaae where gpaae.GalaxyPanelActivityEventUid = gpae.GalaxyPanelActivityEventUid) = 0, 0, 1) as IsAcknowledged,
	AckData.AcknowledgedByUser,
	ent.EntityName, ent.EntityType,
	(select count(*) from GCS.GalaxyPanelAlarmEventAcknowledgment gpaae where gpaae.GalaxyPanelActivityEventUid = gpae.GalaxyPanelActivityEventUid) as AckCount,
	COUNT(*) OVER() as TotalRecordCount,0 as PageNumber,0 as PageSize from GCS.GalaxyPanelActivityEvent gpae
	join GCS.GalaxyActivityEventType gaet on gaet.GalaxyActivityEventTypeUid = gpae.GalaxyActivityEventTypeUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = gpae.GalaxyPanelUid
	join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	join GCS.Site site on site.SiteUid = cluster.SiteUid
	join GCS.gcsEntity ent on ent.EntityId=cluster.EntityId
	left outer join GCS.Person p on p.PersonUid = gpae.PersonUid
	left outer join GCS.PersonCredential pc on pc.PersonUid = gpae.PersonUid AND pc.CredentialUid = gpae.CredentialUid
	left outer join GCS.InputOutputGroup iog on iog.InputOutputGroupUid = gpae.InputOutputGroupUid
	left outer join GCS.GalaxyPanelActivityAlarmEvent gpaae on gpaae.GalaxyPanelActivityEventUid = gpae.GalaxyPanelActivityEventUid
	--left outer join GCS.GalaxyPanelAlarmEventAcknowledgment gpaea on gpaea.GalaxyPanelActivityEventUid = gpae.GalaxyPanelActivityEventUid
	OUTER APPLY (SELECT TOP 1 gpaea.InsertDate AS AcknowledgedTime, Response as AcknowledgeComment, 
	CASE WHEN AlarmPriority IS NOT NULL THEN 1 ELSE 0 END AS IsAcknowledgeable,
	CASE WHEN gpaea.InsertDate IS NOT NULL THEN 1 ELSE 0 END AS IsAcknowledged,
	u.DisplayName as AcknowledgedByUser
	FROM GCS.GalaxyPanelAlarmEventAcknowledgment gpaea
	left outer join GCS.gcsUser u on u.UserId = gpaea.UserId WHERE gpaea.GalaxyPanelActivityEventUid = gpae.GalaxyPanelActivityEventUid) AckData

union
	select  idae.ActivityDateTime as ActivityDateTime, 
	idae.ActivityDateTimeUTC,
	--CASE 
	--	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = 'AD7E7002-E6EC-4E0C-AB4F-FA3D1C8E0F9F') IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = 'AD7E7002-E6EC-4E0C-AB4F-FA3D1C8E0F9F')
	--	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey)
	--	ELSE 
		gaet.Display
		--END 
		AS EventTypeMessage,
	gaet.ForeColor,
	gaet.ForeColorHex,
	id.InputName as DeviceName, site.SiteName, 
	id.EntityId, 
	id.InputDeviceUid as DeviceUid, 
	gaet.GalaxyActivityEventTypeUid as EventTypeUid,
	'InputDevice' as [DeviceType], 
	null as LastName, null as FirstName, 0 as IsTraced, null as CredentialDescription, null as PersonUid, null as CredentialUid,
	cluster.ClusterUid,
	cluster.ClusterNumber,
	cluster.ClusterName,
	cluster.ClusterGroupId,
	gp.PanelNumber,
	NULL as InputOutputGroupName,
	NULL as InputOutputGroupNumber,
	idae.CpuNumber,
	ib.BoardNumber,
	ibs.SectionNumber,
	ghm.ModuleNumber,
	ibsn.NodeNumber,
	idae.InputDeviceActivityEventUid as PK,
	idaae.AlarmPriority,
	idaae.ResponseRequired,
	AckData.AcknowledgedTime,
	AckData.AcknowledgeComment,
	AckData.IsAcknowledgeable,
--	AckData.IsAcknowledged,
	IIF( (select count(*) from GCS.InputDeviceAlarmEventAcknowledgment idaae where idaae.InputDeviceActivityEventUid =  idae.InputDeviceActivityEventUid) = 0, 0, 1) as IsAcknowledged,
	AckData.AcknowledgedByUser,
	ent.EntityName, ent.EntityType,
	(select count(*) from GCS.InputDeviceAlarmEventAcknowledgment idaae where idaae.InputDeviceActivityEventUid =  idae.InputDeviceActivityEventUid) as AckCount,
	COUNT(*) OVER() as TotalRecordCount,0 as PageNumber,0 as PageSize from GCS.InputDeviceActivityEvent idae
	join GCS.GalaxyActivityEventType gaet on gaet.GalaxyActivityEventTypeUid = idae.GalaxyActivityEventTypeUid
	join GCS.InputDevice id on id.InputDeviceUid = idae.InputDeviceUid
	join GCS.Site site on site.SiteUid = id.SiteUid
	join GCS.gcsEntity ent on ent.EntityId=id.EntityId
	left outer join GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = idae.InputDeviceUid
	left outer join GCS.GalaxyInterfaceBoardSectionNode ibsn on ibsn.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
	left outer join GCS.GalaxyHardwareModule ghm on ghm.GalaxyHardwareModuleUid = ibsn.GalaxyHardwareModuleUid
	left outer join GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = ghm.GalaxyInterfaceBoardSectionUid
	left outer join GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	left outer join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = idgha.GalaxyPanelUid
	left outer join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	left outer join GCS.InputDeviceActivityAlarmEvent idaae on idaae.InputDeviceActivityEventUid = idae.InputDeviceActivityEventUid
	----left outer join GCS.InputDeviceAlarmEventAcknowledgment idaea on idaea.InputDeviceActivityEventUid = idae.InputDeviceActivityEventUid
	----left outer join GCS.gcsUser u on u.UserId = idaea.UserId
	OUTER APPLY (SELECT TOP 1 idaea.InsertDate AS AcknowledgedTime, Response as AcknowledgeComment, 
	CASE WHEN AlarmPriority IS NOT NULL THEN 1 ELSE 0 END AS IsAcknowledgeable,
	CASE WHEN idaea.InsertDate IS NOT NULL THEN 1 ELSE 0 END AS IsAcknowledged,
	u.DisplayName as AcknowledgedByUser
	FROM GCS.InputDeviceAlarmEventAcknowledgment idaea
	left outer join GCS.gcsUser u on u.UserId = idaea.UserId WHERE idaea.InputDeviceActivityEventUid = idae.InputDeviceActivityEventUid) AckData

union
	select  odae.ActivityDateTime as ActivityDateTime,
	odae.ActivityDateTimeUTC,
	--CASE 
	--	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = 'AD7E7002-E6EC-4E0C-AB4F-FA3D1C8E0F9F') IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = 'AD7E7002-E6EC-4E0C-AB4F-FA3D1C8E0F9F')
	--	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey)
	--	ELSE 
		gaet.Display
--		END 
		AS EventTypeMessage,
	gaet.ForeColor,
	gaet.ForeColorHex,
	od.OutputName as DeviceName, site.SiteName, 
	od.EntityId, 
	od.OutputDeviceUid as DeviceUid, 
	gaet.GalaxyActivityEventTypeUid as EventTypeUid,
	'OutputDevice' as [DeviceType], 
	null as LastName, null as FirstName,  0 as IsTraced, null as CredentialDescription, null as PersonUid, null as CredentialUid,
	cluster.ClusterUid,
	cluster.ClusterNumber,
	cluster.ClusterName,
	cluster.ClusterGroupId,
	gp.PanelNumber,
	NULL as InputOutputGroupName,
	NULL as InputOutputGroupNumber,
	odae.CpuNumber,
	ib.BoardNumber,
	ibs.SectionNumber,
	ghm.ModuleNumber,
	ibsn.NodeNumber,
	odae.OutputDeviceActivityEventUid as PK,
	null as AlarmPriority,
	0 as ResponseRequired,
	null as AcknowledgedTime,
	null as AcknowledgeComment,
	0 as IsAcknowledgeable,
	0 as IsAcknowledged,
	NULL as AcknowledgedByUser,
	ent.EntityName, ent.EntityType,
	0 as AckCount,
	COUNT(*) OVER() as TotalRecordCount,0 as PageNumber,0 as PageSize from GCS.OutputDeviceActivityEvent odae
	join GCS.GalaxyActivityEventType gaet on gaet.GalaxyActivityEventTypeUid = odae.GalaxyActivityEventTypeUid
	join GCS.OutputDevice od on od.OutputDeviceUid = odae.OutputDeviceUid
	join GCS.Site site on site.SiteUid = od.SiteUid
	join GCS.gcsEntity ent on ent.EntityId=od.EntityId
	left outer join GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = odae.OutputDeviceUid
	left outer join GCS.GalaxyInterfaceBoardSectionNode ibsn on ibsn.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
	left outer join GCS.GalaxyHardwareModule ghm on ghm.GalaxyHardwareModuleUid = ibsn.GalaxyHardwareModuleUid
	left outer join GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = ghm.GalaxyInterfaceBoardSectionUid
	left outer join GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	left outer join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = odgha.GalaxyPanelUid
	left outer join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
go
	

CREATE OR ALTER PROCEDURE GCS.[select_ActivityHistory]
@EntityId uniqueidentifier,
@UserId uniqueidentifier = null,
@StartDateTime datetimeoffset = null,
@EndDateTime datetimeoffset = null,
@DeviceUid uniqueidentifier = null,
@PersonUid uniqueidentifier = null,
@CredentialUid uniqueidentifier = null,
@ClusterUid uniqueidentifier = null,
@EventTypeUids nvarchar(2000) = null,
@IsAcknowledgeable bit = null,
@IsActionRequired bit = null,
@IsTraced bit = null,
@StartPriority int = null,
@EndPriority int = null,
@Priorities nvarchar(1000) = null,
@JustNumber bit = 0,
@PageNumber int = 0,
@PageSize int = 0,
@SortColumn nvarchar(255) = 'ActivityDateTime',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = null,
@IncludeLoggingOnOffEvents bit = 0
AS

IF @StartDateTime is null OR @StartDateTime < '1900-01-01'--min(ActivityDateTime) from GCS.AccessPortalActivityEvent
	SELECT @StartDateTime = '1900-01-01' --dateadd(d, -1, SYSDATETIMEOFFSET())
if @EndDateTime is null OR @EndDateTime < @StartDateTime
	select @EndDateTime = dateadd(d, 1, SYSDATETIMEOFFSET())-- @StartDateTime)

--print convert(nvarchar, @StartDateTime, 0)
--print convert(nvarchar, @StartDateTime, 1)
--print convert(nvarchar, @EndDateTime, 0)
--print convert(nvarchar, @EndDateTime, 1)

declare @languageId uniqueidentifier
declare @dynSql nvarchar(max) = N''
declare @pagingSqlClause nvarchar(200) = N''
DECLARE @totalPages int = 0

if @SortColumn is not null and len(@SortColumn) > 0
begin
	set @SortColumn = TRIM(@SortColumn)
end

if @SortColumn is null or len(@SortColumn) = 0
	set @SortColumn = 'ActivityDateTime'


--IF @CultureName IS NULL OR LEN(LTRIM(@CultureName)) = 0 SET @CultureName = 'en-US'

--select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

if @PageNumber is null
	set @PageNumber = 0

if @PageSize is null
	set @PageSize = 0

if @PageSize > 0 AND @PageNumber > 0 
BEGIN
	DECLARE @pagedOffset int
	select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
	set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
END

--set @dynSql = N'select COUNT(*) OVER() TotalItemCount, * from GCS.ActivityHistoryView WHERE ActivityDateTime >= ''' + cast(@StartDateTime as nvarchar) + N''''
if @JustNumber is null or @JustNumber <> 1
begin
set @dynSql = N'select COUNT(*) OVER() TotalItemCount, PK, ActivityDateTime, ActivityDateTimeUTC, AcknowledgeComment, AcknowledgedTime, EventTypeUid, EventTypeMessage, ForeColorHex, AlarmPriority, DeviceType, DeviceUid, DeviceName, PersonUid, LastName, FirstName, IsTraced, CredentialDescription, ClusterUid, ClusterName, InputOutputGroupName, IsAcknowledgeable, AckCount, IsAcknowledged, AcknowledgedByUser, EntityId, EntityName, EntityType from GCS.ActivityHistoryView WHERE ActivityDateTime >= ''' + convert(nvarchar, @StartDateTime, 0) + N''''
end
else
begin
set @pagingSqlClause = N''
set @dynSql = N'select COUNT(*) as TotalItemCount, null as PK, null as ActivityDateTime, null as ActivityDateTimeUTC, null as AcknowledgeComment, null as AcknowledgedTime, null as EventTypeUid, null as EventTypeMessage, null as ForeColorHex, null as AlarmPriority, null as DeviceType, null as DeviceUid, null as DeviceName, null as PersonUid, null as LastName, null as FirstName, null as IsTraced, null as CredentialDescription, null as ClusterUid, null as ClusterName, null as InputOutputGroupName, IsAcknowledgeable, AckCount, IsAcknowledged, AcknowledgedByUser, EntityId, EntityName, EntityType from GCS.ActivityHistoryView WHERE ActivityDateTime >= ''' + convert(nvarchar, @StartDateTime, 0) + N''''
end

if @EndDateTime is not null 
begin
	if @EndDateTime < @StartDateTime
		set @EndDateTime = DATEADD( d, 1, @StartDateTime)
	set @dynSql = @dynSql + N' AND ActivityDateTime <= ''' + convert(nvarchar, @EndDateTime, 0) + ''''
end

if @EntityId is not null AND @EntityId <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND EntityId = ''' + cast(@EntityId as nvarchar(100)) + ''''
end

if @UserId is not null AND @UserId <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND EntityId in (select EntityId from GCS.gcsUserEntity where UserId = ''' + cast(@UserId as nvarchar(40)) + ''')'
end

if @DeviceUid is not null AND @DeviceUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND DeviceUid = ''' + cast(@DeviceUid as nvarchar(100)) + ''''
end

if @PersonUid is not null AND @PersonUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND PersonUid = ''' + cast(@PersonUid as nvarchar(100)) + ''''
end

if @IsTraced is not null AND @IsTraced = 1
begin
	set @dynSql = @dynSql + N' AND IsTraced = 1'
end

if @CredentialUid is not null AND @CredentialUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND CredentialUid = ''' + cast(@CredentialUid as nvarchar(100)) + ''''
end

if @ClusterUid is not null AND @ClusterUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND ClusterUid = ''' + cast(@ClusterUid as nvarchar(100)) + ''''
end

if @IsAcknowledgeable is not null AND @IsAcknowledgeable = 1
begin
	--set @dynSql = @dynSql + N' AND AlarmPriority IS NOT NULL'
	set @dynSql = @dynSql + N' AND IsAcknowledgeable = 1'
end

if @IsActionRequired is not null AND @IsActionRequired = 1
begin
	set @dynSql = @dynSql + N' AND ResponseRequired = 1'
end

if @StartPriority is not null and @StartPriority > 0
begin
	set @dynSql = @dynSql + N' AND AlarmPriority IS NOT NULL AND AlarmPriority >= ' + cast(@StartPriority AS NVARCHAR)
end

if @EndPriority is not null and @EndPriority > 0
begin
	set @dynSql = @dynSql + N' AND (AlarmPriority IS NULL OR AlarmPriority <= ' + cast(@EndPriority AS NVARCHAR) + ')'
end

if @Priorities is not null and LEN(TRIM(@Priorities)) > 0 
begin
-- split @Priorities into lust of numbers
	set @dynSql = @dynSql + N' AND AlarmPriority IS NOT NULL AND AlarmPriority in (' + @Priorities + ')'
	--SELECT * INTO #Priorities FROM fnSPLIT_int( @Priorities, N',')	
end

if @EventTypeUids is not null and LEN(TRIM(@EventTypeUids)) > 0 
begin
-- split @Priorities into lust of numbers
	set @dynSql = @dynSql + N' AND EventTypeUid in (' + @EventTypeUids + ')'
	--SELECT * INTO #Priorities FROM fnSPLIT_int( @Priorities, N',')	
end

if @IncludeLoggingOnOffEvents IS NOT NULL AND @IncludeLoggingOnOffEvents = 0
BEGIN
	set @dynSql = @dynSql + N' AND EventTypeUid NOT IN (''00000000-0000-0000-0001-000000009760'', ''00000000-0000-0000-0001-000000009761'')'
END

if @JustNumber is null or @JustNumber <> 1
begin
	set @dynSql = @dynSql + N' ORDER BY ' + @SortColumn 
	if @DescendingOrder = 1
		set @dynSql = @dynSql + N' desc'

	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @dynSql = @dynSql + @pagingSqlClause
	END
end

print @dynSql
exec sp_executesql @dynSql
GO

GRANT EXECUTE ON GCS.[select_ActivityHistory] TO public
GO




IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[select_AccessPortalActivityHistory]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.select_AccessPortalActivityHistory
GO

CREATE OR ALTER PROCEDURE GCS.select_AccessPortalActivityHistory
@EntityId uniqueidentifier = null,
@DeviceUid uniqueidentifier = null,
@PersonUid uniqueidentifier = null,
@CredentialUid uniqueidentifier = null,
@StartDateTime datetimeoffset = null,
@EndDateTime datetimeoffset = null,
@CultureName nvarchar(20) = null,
@PageNumber int = 0,
@PageSize int = 0,
@MaxResults int = 0,
@DescendingOrder bit = 1
AS

IF @StartDateTime is null
	select @StartDateTime = '1753-01-01'--min(ActivityDateTime) from GCS.AccessPortalActivityEvent

if @EndDateTime is null
	select @EndDateTime = dateadd(day, 1, SYSDATETIMEOFFSET())

declare @languageId uniqueidentifier
declare @dynSql nvarchar(max) = N''
declare @pagingSqlClause nvarchar(200) = N''
DECLARE @totalPages int = 0

IF @CultureName IS NULL OR LEN(LTRIM(@CultureName)) = 0 SET @CultureName = 'en-US'

select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

if @PageNumber is null
	set @PageNumber = 0

if @PageSize is null
	set @PageSize = 0

if @MaxResults is null
	set @MaxResults = 0

IF @MaxResults > 0
BEGIN
	SET @PageSize = 0
	set @PageNumber = 0
END

if @PageSize > 0 AND @PageNumber > 0 AND @MaxResults = 0 
BEGIN
	DECLARE @pagedOffset int
	select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
	set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
END

set @dynSql = N'select '

IF @MaxResults IS NOT NULL AND @MaxResults > 0 AND @pagingSqlClause = N''
BEGIN
	SET @dynSql = @dynSql + 'TOP('
	SET @dynSql = @dynSql + CONVERT(nvarchar(10), @MaxResults)
	SET @dynSql = @dynSql + ')'
END


set @dynSql = @dynSql + N' apae.ActivityDateTime, 
apae.ActivityDateTimeUTC,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(100)) + ''') IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(100)) + ''')
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey)
	ELSE gaet.Display
	END AS EventTypeMessage,
gaet.ForeColor,
ap.PortalName as DeviceName, site.SiteName, 
ap.EntityId, 
ap.AccessPortalUid as DeviceUid, 
gaet.GalaxyActivityEventTypeUid as EventTypeUid,
''AccessPortal'' as [DeviceType], 
p.LastName, p.FirstName, 
pc.CredentialDescription,
apae.PersonUid, apae.CredentialUid,
cluster.ClusterNumber,
cluster.ClusterName,
cluster.ClusterGroupId,
gp.PanelNumber,
NULL as InputOutputGroupName,
NULL as InputOutputGroupNumber,
apae.CpuNumber,
ib.BoardNumber,
ibs.SectionNumber,
ghm.ModuleNumber,
ibsn.NodeNumber,
apae.AccessPortalActivityEventUid as PK,
COUNT(*) OVER() as TotalRecordCount,'
set @dynSql = @dynSql + cast(@PageNumber as nvarchar(10)) + ' as PageNumber,'
set @dynSql = @dynSql + cast(@PageSize as nvarchar(10)) + ' as PageSize'
set @dynSql = @dynSql + N' from [GalaxySMS].GCS.AccessPortalActivityEvent apae
join GalaxySMS.GCS.GalaxyActivityEventType gaet on gaet.GalaxyActivityEventTypeUid = apae.GalaxyActivityEventTypeUid
join GalaxySMS.GCS.AccessPortal ap on ap.AccessPortalUid = apae.AccessPortalUid
join GalaxySMS.GCS.Site site on site.SiteUid = ap.SiteUid
left outer join GalaxySMS.GCS.Person p on p.PersonUid = apae.PersonUid
left outer join GalaxySMS.GCS.PersonCredential pc on pc.PersonUid = apae.PersonUid AND pc.CredentialUid = apae.CredentialUid
left outer join GalaxySMS.GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = apae.AccessPortalUid
left outer join GalaxySMS.GCS.GalaxyInterfaceBoardSectionNode ibsn on ibsn.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
left outer join GalaxySMS.GCS.GalaxyHardwareModule ghm on ghm.GalaxyHardwareModuleUid = ibsn.GalaxyHardwareModuleUid
left outer join GalaxySMS.GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = ghm.GalaxyInterfaceBoardSectionUid
left outer join GalaxySMS.GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
left outer join GalaxySMS.GCS.GalaxyPanel gp on gp.GalaxyPanelUid = apgha.GalaxyPanelUid
left outer join GalaxySMS.GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
where apae.ActivityDateTime between ''' + cast(@StartDateTime as nvarchar(100)) + ''' AND ''' + cast(@EndDateTime as nvarchar(100)) + ''''

if @EntityId is not null AND @EntityId <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND ( ap.EntityId = ''' + cast(@EntityId as nvarchar(100)) + ''''
	set @dynSql = @dynSql + N'  or ap.AccessPortalUid IN (SELECT AccessPortalUid FROM GCS.AccessPortalEntityMap WHERE EntityId = ''' + cast(@EntityId as nvarchar(100)) + N'''))'
end

if @DeviceUid is not null AND @DeviceUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N'and apae.AccessPortalUid = ''' + cast(@DeviceUid as nvarchar(100)) + ''''
end

if @PersonUid is not null AND @PersonUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N'and apae.PersonUid = ''' + cast(@PersonUid as nvarchar(100)) + ''''
end

if @CredentialUid is not null AND @CredentialUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N'and apae.CredentialUid = ''' + cast(@CredentialUid as nvarchar(100)) + ''''
end

set @dynSql = @dynSql + N' ORDER BY ActivityDateTime'
if @DescendingOrder = 1
	set @dynSql = @dynSql + N' desc'

if LEN(@pagingSqlClause) > 0
BEGIN
	set @dynSql = @dynSql + @pagingSqlClause
END

print @dynSql
exec sp_executesql @dynSql
GO

GRANT EXECUTE ON GCS.[select_AccessPortalActivityHistory] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[select_GalaxyPanelActivityHistory]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.select_GalaxyPanelActivityHistory
GO

CREATE OR ALTER PROCEDURE GCS.select_GalaxyPanelActivityHistory
@EntityId uniqueidentifier = null,
@DeviceUid uniqueidentifier = null,
@StartDateTime datetimeoffset = null,
@EndDateTime datetimeoffset = null,
@IncludeLoggingOnOffEvents bit = 0,
@CultureName nvarchar(20) = null,
@PageNumber int = 0,
@PageSize int = 0,
@MaxResults int = 0,
@DescendingOrder bit = 1
AS

IF @StartDateTime is null
	select @StartDateTime = '1753-01-01'--min(ActivityDateTime) from GCS.AccessPortalActivityEvent

if @EndDateTime is null
	select @EndDateTime = dateadd(day, 1, SYSDATETIMEOFFSET())

declare @languageId uniqueidentifier
declare @dynSql nvarchar(max) = N''
declare @pagingSqlClause nvarchar(200) = N''

IF @CultureName IS NULL OR LEN(LTRIM(@CultureName)) = 0 SET @CultureName = 'en-US'

select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

if @PageNumber is null
	set @PageNumber = 0

if @PageSize is null
	set @PageSize = 0

if @MaxResults is null
	set @MaxResults = 0

IF @MaxResults > 0
BEGIN
	SET @PageSize = 0
	set @PageNumber = 0
END

if @PageSize > 0 AND @PageNumber > 0 AND @MaxResults = 0 
BEGIN
	DECLARE @pagedOffset int
	select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
	set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
END

set @dynSql = N'select '

IF @MaxResults IS NOT NULL AND @MaxResults > 0 AND @pagingSqlClause = N''
BEGIN
	SET @dynSql = @dynSql + 'TOP('
	SET @dynSql = @dynSql + CONVERT(nvarchar(10), @MaxResults)
	SET @dynSql = @dynSql + ')'
END


set @dynSql = @dynSql + N' gpae.ActivityDateTime, 
gpae.ActivityDateTimeUTC,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(100)) + ''') IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(100)) + ''')
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey)
	ELSE gaet.Display
	END AS EventTypeMessage,
gaet.ForeColor,
gp.PanelName as DeviceName, site.SiteName, 
cluster.EntityId, 
gp.GalaxyPanelUid as DeviceUid,
gaet.GalaxyActivityEventTypeUid as EventTypeUid,
''GalaxyPanel'' as [DeviceType], 
p.LastName, p.FirstName, 
pc.CredentialDescription,
gpae.PersonUid, 
gpae.CredentialUid,
cluster.ClusterNumber,
cluster.ClusterName,
cluster.ClusterGroupId,
gp.PanelNumber,
iog.Display as InputOutputGroupName,
gpae.InputOutputGroupNumber,
gpae.CpuNumber, gpae.BoardNumber, gpae.SectionNumber,gpae.ModuleNumber,gpae.NodeNumber,
gpae.GalaxyPanelActivityEventUid as PK,
COUNT(*) OVER() as TotalRecordCount,'
set @dynSql = @dynSql + cast(@PageNumber as nvarchar(10)) + ' as PageNumber,'
set @dynSql = @dynSql + cast(@PageSize as nvarchar(10)) + ' as PageSize'
set @dynSql = @dynSql + N' from [GalaxySMS].GCS.GalaxyPanelActivityEvent gpae
join GalaxySMS.GCS.GalaxyActivityEventType gaet on gaet.GalaxyActivityEventTypeUid = gpae.GalaxyActivityEventTypeUid
join GalaxySMS.GCS.GalaxyPanel gp on gp.GalaxyPanelUid = gpae.GalaxyPanelUid
join GalaxySMS.GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
join GalaxySMS.GCS.Site site on site.SiteUid = cluster.SiteUid
left outer join GalaxySMS.GCS.Person p on p.PersonUid = gpae.PersonUid
left outer join GalaxySMS.GCS.PersonCredential pc on pc.PersonUid = gpae.PersonUid AND pc.CredentialUid = gpae.CredentialUid
left outer join GalaxySMS.GCS.InputOutputGroup iog on iog.InputOutputGroupUid = gpae.InputOutputGroupUid
where gpae.ActivityDateTime between ''' + cast(@StartDateTime as nvarchar(100)) + ''' AND ''' + cast(@EndDateTime as nvarchar(100)) + ''''

if @EntityId is not null AND @EntityId <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND (cluster.EntityId = ''' + cast(@EntityId as nvarchar(100)) + ''''
	set @dynSql = @dynSql + N' or cluster.ClusterUid IN (SELECT ClusterUid FROM GCS.ClusterEntityMap WHERE EntityId = ''' + cast(@EntityId as nvarchar(100)) + N'''))'
end

if @DeviceUid is not null AND @DeviceUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND gpae.GalaxyPanelUid = ''' + cast(@DeviceUid as nvarchar(100)) + ''''
end

if @IncludeLoggingOnOffEvents is null or @IncludeLoggingOnOffEvents = 0
	set @dynSql = @dynSql + N' AND gpae.GalaxyActivityEventTypeUid not in (''00000000-0000-0000-0001-000000009760'', ''00000000-0000-0000-0001-000000009761'')'

set @dynSql = @dynSql + N' ORDER BY ActivityDateTime'
if @DescendingOrder = 1
	set @dynSql = @dynSql + N' desc'

if LEN(@pagingSqlClause) > 0
BEGIN
	set @dynSql = @dynSql + @pagingSqlClause
END

print @dynSql
exec sp_executesql @dynSql
GO

GRANT EXECUTE ON GCS.select_GalaxyPanelActivityHistory TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[select_InputDeviceActivityHistory]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.select_InputDeviceActivityHistory
GO

CREATE OR ALTER PROCEDURE GCS.select_InputDeviceActivityHistory
@EntityId uniqueidentifier = null,
@DeviceUid uniqueidentifier = null,
@StartDateTime datetimeoffset = null,
@EndDateTime datetimeoffset = null,
@CultureName nvarchar(20) = null,
@PageNumber int = 0,
@PageSize int = 0,
@MaxResults int = 0,
@DescendingOrder bit = 1
AS

IF @StartDateTime is null
	select @StartDateTime = '1753-01-01'--min(ActivityDateTime) from GCS.AccessPortalActivityEvent

if @EndDateTime is null
	select @EndDateTime = dateadd(day, 1, SYSDATETIMEOFFSET())

declare @languageId uniqueidentifier
declare @dynSql nvarchar(max) = N''
declare @pagingSqlClause nvarchar(200) = N''
DECLARE @totalPages int = 0

IF @CultureName IS NULL OR LEN(LTRIM(@CultureName)) = 0 SET @CultureName = 'en-US'

select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

if @PageNumber is null
	set @PageNumber = 0

if @PageSize is null
	set @PageSize = 0

if @MaxResults is null
	set @MaxResults = 0

IF @MaxResults > 0
BEGIN
	SET @PageSize = 0
	set @PageNumber = 0
END

if @PageSize > 0 AND @PageNumber > 0 AND @MaxResults = 0 
BEGIN
	DECLARE @pagedOffset int
	select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
	set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
END

set @dynSql = N'select '

IF @MaxResults IS NOT NULL AND @MaxResults > 0 AND @pagingSqlClause = N''
BEGIN
	SET @dynSql = @dynSql + 'TOP('
	SET @dynSql = @dynSql + CONVERT(nvarchar(10), @MaxResults)
	SET @dynSql = @dynSql + ')'
END


set @dynSql = @dynSql + N' idae.ActivityDateTime, 
idae.ActivityDateTimeUTC,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(100)) + ''') IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(100)) + ''')
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey)
	ELSE gaet.Display
	END AS EventTypeMessage,
gaet.ForeColor,
id.InputName as DeviceName, site.SiteName, 
id.EntityId, 
id.InputDeviceUid as DeviceUid, 
gaet.GalaxyActivityEventTypeUid as EventTypeUid,
''InputDevice'' as [DeviceType], 
null as LastName, null as FirstName, null as CredentialDescription, null as PersonUid, null as CredentialUid,
cluster.ClusterNumber,
cluster.ClusterName,
cluster.ClusterGroupId,
gp.PanelNumber,
NULL as InputOutputGroupName,
NULL as InputOutputGroupNumber,
idae.CpuNumber,
ib.BoardNumber,
ibs.SectionNumber,
ghm.ModuleNumber,
ibsn.NodeNumber,
idae.InputDeviceActivityEventUid as PK,
COUNT(*) OVER() as TotalRecordCount,'
set @dynSql = @dynSql + cast(@PageNumber as nvarchar(10)) + ' as PageNumber,'
set @dynSql = @dynSql + cast(@PageSize as nvarchar(10)) + ' as PageSize'
set @dynSql = @dynSql + N' from [GalaxySMS].GCS.InputDeviceActivityEvent idae
join GalaxySMS.GCS.GalaxyActivityEventType gaet on gaet.GalaxyActivityEventTypeUid = idae.GalaxyActivityEventTypeUid
join GalaxySMS.GCS.InputDevice id on id.InputDeviceUid = idae.InputDeviceUid
join GalaxySMS.GCS.Site site on site.SiteUid = id.SiteUid
left outer join GalaxySMS.GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = idae.InputDeviceUid
left outer join GalaxySMS.GCS.GalaxyInterfaceBoardSectionNode ibsn on ibsn.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
left outer join GalaxySMS.GCS.GalaxyHardwareModule ghm on ghm.GalaxyHardwareModuleUid = ibsn.GalaxyHardwareModuleUid
left outer join GalaxySMS.GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = ghm.GalaxyInterfaceBoardSectionUid
left outer join GalaxySMS.GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
left outer join GalaxySMS.GCS.GalaxyPanel gp on gp.GalaxyPanelUid = idgha.GalaxyPanelUid
left outer join GalaxySMS.GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
where idae.ActivityDateTime between ''' + cast(@StartDateTime as nvarchar(100)) + ''' AND ''' + cast(@EndDateTime as nvarchar(100)) + ''''

if @EntityId is not null AND @EntityId <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND ( id.EntityId = ''' + cast(@EntityId as nvarchar(100)) + ''''
	set @dynSql = @dynSql + N'  or id.InputDeviceUid IN (SELECT InputDeviceUid FROM GCS.InputDeviceEntityMap WHERE EntityId = ''' + cast(@EntityId as nvarchar(100)) + N'''))'
end

if @DeviceUid is not null AND @DeviceUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N'and idae.InputDeviceUid = ''' + cast(@DeviceUid as nvarchar(100)) + ''''
end

set @dynSql = @dynSql + N' ORDER BY ActivityDateTime'
if @DescendingOrder = 1
	set @dynSql = @dynSql + N' desc'

if LEN(@pagingSqlClause) > 0
BEGIN
	set @dynSql = @dynSql + @pagingSqlClause
END

print @dynSql
exec sp_executesql @dynSql
GO

GRANT EXECUTE ON GCS.select_InputDeviceActivityHistory TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[select_OutputDeviceActivityHistory]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.select_OutputDeviceActivityHistory
GO

CREATE OR ALTER PROCEDURE GCS.select_OutputDeviceActivityHistory
@EntityId uniqueidentifier = null,
@DeviceUid uniqueidentifier = null,
@StartDateTime datetimeoffset = null,
@EndDateTime datetimeoffset = null,
@CultureName nvarchar(20) = null,
@PageNumber int = 0,
@PageSize int = 0,
@MaxResults int = 0,
@DescendingOrder bit = 1
AS

IF @StartDateTime is null
	select @StartDateTime = '1753-01-01'--min(ActivityDateTime) from GCS.AccessPortalActivityEvent

if @EndDateTime is null
	select @EndDateTime = dateadd(day, 1, SYSDATETIMEOFFSET())

declare @languageId uniqueidentifier
declare @dynSql nvarchar(max) = N''
declare @pagingSqlClause nvarchar(200) = N''
DECLARE @totalPages int = 0

IF @CultureName IS NULL OR LEN(LTRIM(@CultureName)) = 0 SET @CultureName = 'en-US'

select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

if @PageNumber is null
	set @PageNumber = 0

if @PageSize is null
	set @PageSize = 0

if @MaxResults is null
	set @MaxResults = 0

IF @MaxResults > 0
BEGIN
	SET @PageSize = 0
	set @PageNumber = 0
END

if @PageSize > 0 AND @PageNumber > 0 AND @MaxResults = 0 
BEGIN
	DECLARE @pagedOffset int
	select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
	set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
END

set @dynSql = N'select '

IF @MaxResults IS NOT NULL AND @MaxResults > 0 AND @pagingSqlClause = N''
BEGIN
	SET @dynSql = @dynSql + 'TOP('
	SET @dynSql = @dynSql + CONVERT(nvarchar(10), @MaxResults)
	SET @dynSql = @dynSql + ')'
END


set @dynSql = @dynSql + N' odae.ActivityDateTime,
odae.ActivityDateTimeUTC,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(100)) + ''') IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = gaet.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(100)) + ''')
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = gaet.DisplayResourceKey)
	ELSE gaet.Display
	END AS EventTypeMessage,
gaet.ForeColor,
od.OutputName as DeviceName, site.SiteName, 
od.EntityId, 
od.OutputDeviceUid as DeviceUid, 
gaet.GalaxyActivityEventTypeUid as EventTypeUid,
''OutputDevice'' as [DeviceType], 
null as LastName, null as FirstName, null as CredentialDescription, null as PersonUid, null as CredentialUid,
cluster.ClusterNumber,
cluster.ClusterName,
cluster.ClusterGroupId,
gp.PanelNumber,
NULL as InputOutputGroupName,
NULL as InputOutputGroupNumber,
odae.CpuNumber,
ib.BoardNumber,
ibs.SectionNumber,
ghm.ModuleNumber,
ibsn.NodeNumber,
odae.OutputDeviceActivityEventUid as PK,
COUNT(*) OVER() as TotalRecordCount,'
set @dynSql = @dynSql + cast(@PageNumber as nvarchar(10)) + ' as PageNumber,'
set @dynSql = @dynSql + cast(@PageSize as nvarchar(10)) + ' as PageSize'
set @dynSql = @dynSql + N' from [GalaxySMS].GCS.OutputDeviceActivityEvent odae
join GalaxySMS.GCS.GalaxyActivityEventType gaet on gaet.GalaxyActivityEventTypeUid = odae.GalaxyActivityEventTypeUid
join GalaxySMS.GCS.OutputDevice od on od.OutputDeviceUid = odae.OutputDeviceUid
join GalaxySMS.GCS.Site site on site.SiteUid = od.SiteUid
left outer join GalaxySMS.GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = odae.OutputDeviceUid
left outer join GalaxySMS.GCS.GalaxyInterfaceBoardSectionNode ibsn on ibsn.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
left outer join GalaxySMS.GCS.GalaxyHardwareModule ghm on ghm.GalaxyHardwareModuleUid = ibsn.GalaxyHardwareModuleUid
left outer join GalaxySMS.GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = ghm.GalaxyInterfaceBoardSectionUid
left outer join GalaxySMS.GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
left outer join GalaxySMS.GCS.GalaxyPanel gp on gp.GalaxyPanelUid = odgha.GalaxyPanelUid
left outer join GalaxySMS.GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
where odae.ActivityDateTime between ''' + cast(@StartDateTime as nvarchar(100)) + ''' AND ''' + cast(@EndDateTime as nvarchar(100)) + ''''

if @EntityId is not null AND @EntityId <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND ( od.EntityId = ''' + cast(@EntityId as nvarchar(100)) + ''''
	set @dynSql = @dynSql + N'  or od.OutputDeviceUid IN (SELECT OutputDeviceUid FROM GCS.OutputDeviceEntityMap WHERE EntityId = ''' + cast(@EntityId as nvarchar(100)) + N'''))'
end

if @DeviceUid is not null AND @DeviceUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N'and odae.OutputDeviceUid = ''' + cast(@DeviceUid as nvarchar(100)) + ''''
end

set @dynSql = @dynSql + N' ORDER BY ActivityDateTime'
if @DescendingOrder = 1
	set @dynSql = @dynSql + N' desc'

if LEN(@pagingSqlClause) > 0
BEGIN
	set @dynSql = @dynSql + @pagingSqlClause
END

print @dynSql
exec sp_executesql @dynSql
GO


GRANT EXECUTE ON GCS.select_OutputDeviceActivityHistory TO public
GO

--exec GCS.[select_CombinedActivityHistory] null, null, null, null, null, null, null, null, null, 0, null, 1, 10

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[select_CombinedActivityHistory]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[select_CombinedActivityHistory]
GO
CREATE OR ALTER PROCEDURE GCS.[select_CombinedActivityHistory]
@EntityId uniqueidentifier = null,
@AccessPortalUid uniqueidentifier = null,
@PersonUid uniqueidentifier = null,
@CredentialUid uniqueidentifier = null,
@GalaxyPanelUid uniqueidentifier = null,
@InputDeviceUid uniqueidentifier = null,
@OutputDeviceUid uniqueidentifier = null,
@StartDateTime datetimeoffset = null,
@EndDateTime datetimeoffset = null,
@IncludeLoggingOnOffEvents bit = 0,
@CultureName nvarchar(20) = null,
@PageNumber int = 0,
@PageSize int = 0,
@MaxResults int = 0,
@DescendingOrder bit = 1
AS
declare @dynSql nvarchar(max) = N''
declare @pagingSqlClause nvarchar(200) = N''
DECLARE @totalPages int = 0

IF @StartDateTime is null
	select @StartDateTime = '1753-01-01'-- min(ActivityDateTime) from GCS.OutputDeviceActivityEvent

if @EndDateTime is null
	select @EndDateTime = dateadd(day, 1, SYSDATETIMEOFFSET())


CREATE TABLE #activityHistory(
	[ActivityDateTime] datetimeoffset(7) NULL,
	[ActivityDateTimeUTC] datetimeoffset(7) NULL,
	[EventTypeMessage] [nvarchar](255) NULL,
	[ForeColor] int NULL,
	[DeviceName] [nvarchar](255) NULL,
	[SiteName] [nvarchar](255) NULL,
	[EntityId] uniqueidentifier null,
	[DeviceUid] uniqueidentifier NULL,
	[EventTypeUid] uniqueidentifier NULL,
	[DeviceType] nvarchar(50) NULL,
	[LastName] [nvarchar](255) NULL,
	[FirstName] [nvarchar](255) NULL,
	[CredentialDescription] [nvarchar](255) NULL,
	[PersonUid] uniqueidentifier NULL,
	[CredentialUid] uniqueidentifier NULL,
	[ClusterNumber] int NULL,
	[ClusterName] [nvarchar](255) NULL,
	[ClusterGroupId] int NULL,
	[PanelNumber] int NULL,
	[InputOutputGroupName] [nvarchar](255) NULL,
	[InputOutputGroupNumber] int NULL,
	[CpuNumber] int NULL,
	[BoardNumber] int NULL,
	[SectionNumber] int NULL,
	[ModuleNumber] int NULL,
	[NodeNumber] int NULL,
	[PK] uniqueidentifier,
	[TotalRecordCount] bigint NULL,
	[PageNumber] int NULL,
	[PageSize] int NULL
)

--Inserting Records from Stored procedure to Temporary Table
INSERT INTO #activityHistory
	exec GCS.select_AccessPortalActivityHistory @EntityId, @AccessPortalUid, @PersonUid, @CredentialUid, @StartDateTime, @EndDateTime, @CultureName, @PageNumber, @PageSize, @MaxResults, @DescendingOrder
INSERT INTO #activityHistory
	exec GCS.select_GalaxyPanelActivityHistory @EntityId, @GalaxyPanelUid, @StartDateTime, @EndDateTime, @IncludeLoggingOnOffEvents, @CultureName, @PageNumber, @PageSize, @MaxResults, @DescendingOrder
INSERT INTO #activityHistory
	exec GCS.select_InputDeviceActivityHistory @EntityId, @InputDeviceUid, @StartDateTime, @EndDateTime, @CultureName, @PageNumber, @PageSize, @MaxResults, @DescendingOrder
INSERT INTO #activityHistory
	exec GCS.select_OutputDeviceActivityHistory @EntityId, @OutputDeviceUid, @StartDateTime, @EndDateTime, @CultureName, @PageNumber, @PageSize, @MaxResults, @DescendingOrder

--if @PageNumber is null
--	set @PageNumber = 0

--if @PageSize is null
--	set @PageSize = 0

--if @MaxResults is null
--	set @MaxResults = 0

--IF @MaxResults > 0
--BEGIN
--	SET @PageSize = 0
--	set @PageNumber = 0
--END

--if @PageSize > 0 AND @PageNumber > 0 AND @MaxResults = 0 
--BEGIN
--	DECLARE @pagedOffset int
--	select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
--	set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
--END

--set @dynSql = N'select '

--IF @MaxResults IS NOT NULL AND @MaxResults > 0 AND @pagingSqlClause = N''
--BEGIN
--	SET @dynSql = @dynSql + 'TOP('
--	SET @dynSql = @dynSql + CONVERT(nvarchar(10), @MaxResults)
--	SET @dynSql = @dynSql + ')'
--END

--set @dynSql = @dynSql + N' *, COUNT(*) OVER() as TotalRecordCount,'
--set @dynSql = @dynSql + cast(@PageNumber as nvarchar(10)) + ' as PageNumber,'
--set @dynSql = @dynSql + cast(@PageSize as nvarchar(10)) + ' as PageSize'
--set @dynSql = @dynSql + N' from #activityHistory ORDER BY ActivityDateTime'
	
--if LEN(@pagingSqlClause) > 0
--BEGIN
--	set @dynSql = @dynSql + @pagingSqlClause
--END

--print @dynSql
--exec sp_executesql @dynSql
	select * from #activityHistory ORDER BY ActivityDateTime

drop table #activityHistory
GO

GRANT EXECUTE ON GCS.[select_CombinedActivityHistory] TO public
GO

if dbo.fn_GCSDoesColumnExist('AccessPortal', 'IsEnabled') = 0
BEGIN
	ALTER TABLE [GCS].AccessPortal
	ADD IsEnabled bit not null default 1
END
go  


if dbo.fn_GCSDoesColumnExist('AccessPortal', 'IsEnabledLastUpdated') = 0
BEGIN
	ALTER TABLE [GCS].AccessPortal
	ADD IsEnabledLastUpdated datetimeoffset null
END
go  



CREATE OR ALTER FUNCTION [GCS].[AccessPortal_GetGalaxyInterfaceBoardSectionModeInfo](@accessPortalUid [uniqueidentifier])
RETURNS smallint WITH EXECUTE AS CALLER
AS 
BEGIN
declare @modecode smallint

	SELECT @modecode = ibm.ModeCode FROM GCS.GalaxyInterfaceBoardSection gibs
	JOIN GCS.GalaxyHardwareModule ghm on ghm.GalaxyInterfaceBoardSectionUid = gibs.GalaxyInterfaceBoardSectionUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode gibsn on gibsn.GalaxyHardwareModuleUid = ghm.GalaxyHardwareModuleUid
	JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.GalaxyInterfaceBoardSectionNodeUid = gibsn.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.InterfaceBoardSectionMode ibm on ibm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
	WHERE apgha.AccessPortalUid = @accessPortalUid

	RETURN @modecode;
END
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortal_GetGalaxyInterfaceBoardSectionModeInfo] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortal_GetGalaxyInterfaceBoardSectionModeInfo] TO [public] AS [dbo]
GO

if dbo.fn_GCSDoesColumnExist('AccessPortal', 'IsBoundToHardware') = 1
BEGIN
	ALTER TABLE [GCS].AccessPortal
	DROP COLUMN [IsBoundToHardware]
END
go  

IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'IsAccessPortalBoundToHardware'
                    AND Routine_Type = 'FUNCTION' ) 
	DROP FUNCTION [GCS].IsAccessPortalBoundToHardware
go

CREATE OR ALTER FUNCTION [GCS].[IsAccessPortalBoundToHardware] (@AccessPortalUid uniqueidentifier) 
RETURNS bit
as
BEGIN

	if not exists (select AccessPortalUid from GCS.AccessPortal where AccessPortalUid = @AccessPortalUid)
		return 0;
	
	if exists (select * from GCS.AccessPortalGalaxyHardwareAddress where AccessPortalUid = @AccessPortalUid)
		return 1;
	return 0;	
END
go

GRANT EXECUTE ON GCS.[IsAccessPortalBoundToHardware] TO public
GO


if dbo.fn_GCSDoesColumnExist('AccessPortal', 'IsBoundToHardware') = 0
BEGIN
	ALTER TABLE [GCS].AccessPortal
	ADD [IsBoundToHardware] AS ([GCS].[IsAccessPortalBoundToHardware](AccessPortalUid))
END
go  














if dbo.fn_GCSDoesColumnExist('AccessPortal', 'IsBoundToHardware') = 1
BEGIN
	ALTER TABLE [GCS].AccessPortal
	DROP COLUMN [IsBoundToHardware]
END
go  

IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'IsAccessPortalBoundToHardware'
                    AND Routine_Type = 'FUNCTION' ) 
	DROP FUNCTION [GCS].IsAccessPortalBoundToHardware
go

CREATE OR ALTER FUNCTION [GCS].[IsAccessPortalBoundToHardware] (@AccessPortalUid uniqueidentifier) 
RETURNS bit
as
BEGIN

	if not exists (select AccessPortalUid from GCS.AccessPortal where AccessPortalUid = @AccessPortalUid)
		return 0;
	
	if exists (select * from GCS.AccessPortalGalaxyHardwareAddress where AccessPortalUid = @AccessPortalUid)
		return 1;
	return 0;	
END
go

GRANT EXECUTE ON GCS.[IsAccessPortalBoundToHardware] TO public
GO


if dbo.fn_GCSDoesColumnExist('AccessPortal', 'IsBoundToHardware') = 0
BEGIN
	ALTER TABLE [GCS].AccessPortal
	ADD [IsBoundToHardware] AS ([GCS].[IsAccessPortalBoundToHardware](AccessPortalUid))
END
go  



if dbo.fn_GCSDoesColumnExist('InputDevice', 'IsBoundToHardware') = 1
BEGIN
	ALTER TABLE [GCS].InputDevice
	DROP COLUMN [IsBoundToHardware]
END
go  

IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'IsInputDeviceBoundToHardware'
                    AND Routine_Type = 'FUNCTION' ) 
	DROP FUNCTION [GCS].IsInputDeviceBoundToHardware
go

CREATE OR ALTER FUNCTION [GCS].[IsInputDeviceBoundToHardware] (@InputDeviceUid uniqueidentifier) 
RETURNS bit
as
BEGIN

	if not exists (select InputDeviceUid from GCS.InputDevice where InputDeviceUid = @InputDeviceUid)
		return 0;
	
	if exists (select * from GCS.InputDeviceGalaxyHardwareAddress where InputDeviceUid = @InputDeviceUid)
		return 1;
	return 0;	
END
go

GRANT EXECUTE ON GCS.[IsInputDeviceBoundToHardware] TO public
GO


if dbo.fn_GCSDoesColumnExist('InputDevice', 'IsBoundToHardware') = 0
BEGIN
	ALTER TABLE [GCS].InputDevice
	ADD [IsBoundToHardware] AS ([GCS].[IsInputDeviceBoundToHardware](InputDeviceUid))
END
go  



if dbo.fn_GCSDoesColumnExist('OutputDevice', 'IsBoundToHardware') = 1
BEGIN
	ALTER TABLE [GCS].OutputDevice
	DROP COLUMN [IsBoundToHardware]
END
go  

IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'IsOutputDeviceBoundToHardware'
                    AND Routine_Type = 'FUNCTION' ) 
	DROP FUNCTION [GCS].IsOutputDeviceBoundToHardware
go

CREATE OR ALTER FUNCTION [GCS].[IsOutputDeviceBoundToHardware] (@OutputDeviceUid uniqueidentifier) 
RETURNS bit
as
BEGIN

	if not exists (select OutputDeviceUid from GCS.OutputDevice where OutputDeviceUid = @OutputDeviceUid)
		return 0;
	
	if exists (select * from GCS.OutputDeviceGalaxyHardwareAddress where OutputDeviceUid = @OutputDeviceUid)
		return 1;
	return 0;	
END
go

GRANT EXECUTE ON GCS.[IsOutputDeviceBoundToHardware] TO public
GO


if dbo.fn_GCSDoesColumnExist('OutputDevice', 'IsBoundToHardware') = 0
BEGIN
	ALTER TABLE [GCS].OutputDevice
	ADD [IsBoundToHardware] AS ([GCS].[IsOutputDeviceBoundToHardware](OutputDeviceUid))
END
go  






if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.InputDeviceGalaxyHardwareAddressView')
            AND   type = 'V')
   drop view GCS.[InputDeviceGalaxyHardwareAddressView]
go

create view [GCS].[InputDeviceGalaxyHardwareAddressView] as
	SELECT id.InputName, id.InputDeviceUid,
	c.ClusterNumber, c.ClusterGroupId, ct.ClusterTypeUid, ct.TypeCode as 'ClusterTypeCode',
	gpm.GalaxyPanelModelUid, gpm.TypeCode as 'GalaxyPanelTypeCode', gp.PanelNumber,
	gib.BoardNumber, ibt.InterfaceBoardTypeUid, ibt.TypeCode as 'InterfaceBoardTypeCode', ibt.Model as 'InterfaceBoardModel',
	gibs.SectionNumber, ibsm.InterfaceBoardSectionModeUid, ibsm.ModeCode as 'InterfaceBoardSectionModeCode',
	ghm.ModuleNumber, ghmt.GalaxyHardwareModuleTypeUid, ghmt.ModuleTypeCode,
	gibsn.NodeNumber, 
	c.ClusterUid,
	gp.GalaxyPanelUid, 
	gib.GalaxyInterfaceBoardUid,
	gibs.GalaxyInterfaceBoardSectionUid,
	ghm.GalaxyHardwareModuleUid,
	gibsn.GalaxyInterfaceBoardSectionNodeUid,
	gibsn.IsNodeActive
	FROM GCS.InputDevice id
	JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = id.InputDeviceUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode gibsn on gibsn.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule ghm on ghm.GalaxyHardwareModuleUid = gibsn.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = ghm.GalaxyHardwareModuleTypeUid
	JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = ghm.GalaxyInterfaceBoardSectionUid
	JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
	JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
	JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = gib.GalaxyPanelUid
	JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = gp.GalaxyPanelModelUid
	JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
	JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
GO
ALTER AUTHORIZATION ON [GCS].[InputDeviceGalaxyHardwareAddressView] TO  SCHEMA OWNER 
GO

if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.OutputDeviceGalaxyHardwareAddressView')
            AND   type = 'V')
   drop view GCS.[OutputDeviceGalaxyHardwareAddressView]
go

/*==============================================================*/
/* View: OutputDeviceGalaxyHardwareAddressView                        */
/*==============================================================*/
create view [GCS].[OutputDeviceGalaxyHardwareAddressView] as
	SELECT od.OutputName, od.OutputDeviceUid,
	c.ClusterNumber, c.ClusterGroupId, ct.ClusterTypeUid, ct.TypeCode as 'ClusterTypeCode',
	gpm.GalaxyPanelModelUid, gpm.TypeCode as 'GalaxyPanelTypeCode', gp.PanelNumber,
	gib.BoardNumber, ibt.InterfaceBoardTypeUid, ibt.TypeCode as 'InterfaceBoardTypeCode', ibt.Model as 'InterfaceBoardModel',
	gibs.SectionNumber, ibsm.InterfaceBoardSectionModeUid, ibsm.ModeCode as 'InterfaceBoardSectionModeCode',
	ghm.ModuleNumber, ghmt.GalaxyHardwareModuleTypeUid, ghmt.ModuleTypeCode,
	gibsn.NodeNumber, 
	c.ClusterUid,
	gp.GalaxyPanelUid, 
	gib.GalaxyInterfaceBoardUid,
	gibs.GalaxyInterfaceBoardSectionUid,
	ghm.GalaxyHardwareModuleUid,
	gibsn.GalaxyInterfaceBoardSectionNodeUid,
	gibsn.IsNodeActive
	FROM GCS.OutputDevice od
	JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = od.OutputDeviceUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode gibsn on gibsn.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule ghm on ghm.GalaxyHardwareModuleUid = gibsn.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = ghm.GalaxyHardwareModuleTypeUid
	JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = ghm.GalaxyInterfaceBoardSectionUid
	JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
	JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
	JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = gib.GalaxyPanelUid
	JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = gp.GalaxyPanelModelUid
	JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
	JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
GO
ALTER AUTHORIZATION ON [GCS].[OutputDeviceGalaxyHardwareAddressView] TO  SCHEMA OWNER 
GO


if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.AccessPortalGalaxyHardwareAddressView')
            AND   type = 'V')
   drop view GCS.[AccessPortalGalaxyHardwareAddressView]
go

/*==============================================================*/
/* View: AccessPortalHardwareAddressView                        */
/*==============================================================*/
create view [GCS].[AccessPortalGalaxyHardwareAddressView] as
	SELECT ap.PortalName, ap.AccessPortalUid,
	c.ClusterNumber, c.ClusterGroupId, ct.ClusterTypeUid, ct.TypeCode as 'ClusterTypeCode',
	gpm.GalaxyPanelModelUid, gpm.TypeCode as 'GalaxyPanelTypeCode', gp.PanelNumber,
	gib.BoardNumber, ibt.InterfaceBoardTypeUid, ibt.TypeCode as 'InterfaceBoardTypeCode', ibt.Model as 'InterfaceBoardModel',
	gibs.SectionNumber, ibsm.InterfaceBoardSectionModeUid, ibsm.ModeCode as 'InterfaceBoardSectionModeCode',
	ghm.ModuleNumber, ghmt.GalaxyHardwareModuleTypeUid, ghmt.ModuleTypeCode,
	gibsn.NodeNumber, apgha.DoorNumber, 
	c.ClusterUid,
	gp.GalaxyPanelUid, 
	gib.GalaxyInterfaceBoardUid,
	gibs.GalaxyInterfaceBoardSectionUid,
	ghm.GalaxyHardwareModuleUid,
	gibsn.GalaxyInterfaceBoardSectionNodeUid,
	gibsn.IsNodeActive,
	ap.IsEnabled
	FROM GCS.AccessPortal ap
	JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode gibsn on gibsn.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule ghm on ghm.GalaxyHardwareModuleUid = gibsn.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = ghm.GalaxyHardwareModuleTypeUid
	JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = ghm.GalaxyInterfaceBoardSectionUid
	JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
	JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
	JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = gib.GalaxyPanelUid
	JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = gp.GalaxyPanelModelUid
	JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
	JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalGalaxyHardwareAddressView] TO  SCHEMA OWNER 
GO


/* All Stored Procedures for table: GalaxyPanel */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.GalaxyPanel table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyPanel

if @PageSize = 0
	set @PageSize = 1

SELECT 
GalaxyPanelUid
,t.ClusterUid
,GalaxyPanelModelUid
,PanelNumber
,PanelName
,Location
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,c.ClusterGroupId
,c.ClusterName
,c.EntityId
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.GalaxyInterfaceBoard where GalaxyPanelUid = t.GalaxyPanelUid) as InterfaceBoardCount
,(SELECT COUNT(*) from GCS.GalaxyCpu where GalaxyPanelUid = t.GalaxyPanelUid and IsActive = 1) as ActiveCpuCount
,(SELECT COUNT(*) from GCS.AccessPortalGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as AccessPortalCount
,(SELECT COUNT(*) from GCS.InputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as InputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode <> 64) as OutputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode = 64) as ElevatorOutputCount
FROM GCS.GalaxyPanel t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN PanelName end) asc,
         (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 1 THEN PanelName end) desc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 0 THEN PanelNumber end) asc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 1 THEN PanelNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanel table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_ByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyPanel

if @PageSize = 0
	set @PageSize = 1

SELECT 
GalaxyPanelUid
,t.ClusterUid
,GalaxyPanelModelUid
,PanelNumber
,PanelName
,Location
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,c.ClusterGroupId
,c.ClusterName
,c.EntityId
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.GalaxyInterfaceBoard where GalaxyPanelUid = t.GalaxyPanelUid) as InterfaceBoardCount
,(SELECT COUNT(*) from GCS.GalaxyCpu where GalaxyPanelUid = t.GalaxyPanelUid and IsActive = 1) as ActiveCpuCount
,(SELECT COUNT(*) from GCS.AccessPortalGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as AccessPortalCount
,(SELECT COUNT(*) from GCS.InputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as InputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode <> 64) as OutputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode = 64) as ElevatorOutputCount
FROM GCS.GalaxyPanel t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
t.ClusterUid = @ClusterUid
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN PanelName end) asc,
         (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 1 THEN PanelName end) desc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 0 THEN PanelNumber end) asc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 1 THEN PanelNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanel table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_ByGalaxyPanelModelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_ByGalaxyPanelModelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_ByGalaxyPanelModelUid]
@GalaxyPanelModelUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyPanel

if @PageSize = 0
	set @PageSize = 1

SELECT 
GalaxyPanelUid
,t.ClusterUid
,GalaxyPanelModelUid
,PanelNumber
,PanelName
,Location
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,c.ClusterGroupId
,c.ClusterName
,c.EntityId
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.GalaxyInterfaceBoard where GalaxyPanelUid = t.GalaxyPanelUid) as InterfaceBoardCount
,(SELECT COUNT(*) from GCS.GalaxyCpu where GalaxyPanelUid = t.GalaxyPanelUid and IsActive = 1) as ActiveCpuCount
,(SELECT COUNT(*) from GCS.AccessPortalGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as AccessPortalCount
,(SELECT COUNT(*) from GCS.InputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as InputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode <> 64) as OutputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode = 64) as ElevatorOutputCount
FROM GCS.GalaxyPanel t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
GalaxyPanelModelUid = @GalaxyPanelModelUid
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN PanelName end) asc,
         (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 1 THEN PanelName end) desc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 0 THEN PanelNumber end) asc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 1 THEN PanelNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_ByGalaxyPanelModelUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanel table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_ByHardwareAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_ByHardwareAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_ByHardwareAddress]
@ClusterGroupId int,
@ClusterNumber int,
@PanelNumber int,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyPanel

if @PageSize = 0
	set @PageSize = 1

SELECT 
GalaxyPanelUid
,t.ClusterUid
,GalaxyPanelModelUid
,PanelNumber
,PanelName
,Location
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,c.ClusterGroupId
,c.ClusterName
,c.EntityId
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.GalaxyInterfaceBoard where GalaxyPanelUid = t.GalaxyPanelUid) as InterfaceBoardCount
,(SELECT COUNT(*) from GCS.GalaxyCpu where GalaxyPanelUid = t.GalaxyPanelUid and IsActive = 1) as ActiveCpuCount
,(SELECT COUNT(*) from GCS.AccessPortalGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as AccessPortalCount
,(SELECT COUNT(*) from GCS.InputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as InputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode <> 64) as OutputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode = 64) as ElevatorOutputCount
FROM GCS.GalaxyPanel t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
t.PanelNumber = @PanelNumber and c.ClusterGroupId = @ClusterGroupId and c.ClusterNumber = @ClusterNumber
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN PanelName end) asc,
         (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 1 THEN PanelName end) desc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 0 THEN PanelNumber end) asc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 1 THEN PanelNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_ByHardwareAddress] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanel table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_BySiteUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_BySiteUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_BySiteUid]
@SiteUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyPanel

if @PageSize = 0
	set @PageSize = 1

SELECT 
GalaxyPanelUid
,t.ClusterUid
,GalaxyPanelModelUid
,PanelNumber
,PanelName
,Location
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,c.ClusterGroupId
,c.ClusterName
,c.EntityId
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.GalaxyInterfaceBoard where GalaxyPanelUid = t.GalaxyPanelUid) as InterfaceBoardCount
,(SELECT COUNT(*) from GCS.GalaxyCpu where GalaxyPanelUid = t.GalaxyPanelUid and IsActive = 1) as ActiveCpuCount
,(SELECT COUNT(*) from GCS.AccessPortalGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as AccessPortalCount
,(SELECT COUNT(*) from GCS.InputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as InputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode <> 64) as OutputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode = 64) as ElevatorOutputCount
FROM GCS.GalaxyPanel t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
t.ClusterUid IN (SELECT ClusterUid FROM GCS.Cluster WHERE SiteUid = @SiteUid)
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN PanelName end) asc,
         (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 1 THEN PanelName end) desc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 0 THEN PanelNumber end) asc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 1 THEN PanelNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_BySiteUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.GalaxyPanel table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyPanel

if @PageSize = 0
	set @PageSize = 1

SELECT 
GalaxyPanelUid
,PanelName
,COUNT(*) OVER() TotalRowCount
FROM GCS.GalaxyPanel
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN PanelName end) asc,
         (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 1 THEN PanelName end) desc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 0 THEN PanelNumber end) asc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 1 THEN PanelNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanel table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_SelectByPK]
@GalaxyPanelUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyPanel

if @PageSize = 0
	set @PageSize = 1

SELECT 
GalaxyPanelUid
,t.ClusterUid
,GalaxyPanelModelUid
,PanelNumber
,PanelName
,Location
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,c.ClusterGroupId
,c.ClusterName
,c.EntityId
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.GalaxyInterfaceBoard where GalaxyPanelUid = t.GalaxyPanelUid) as InterfaceBoardCount
,(SELECT COUNT(*) from GCS.GalaxyCpu where GalaxyPanelUid = t.GalaxyPanelUid and IsActive = 1) as ActiveCpuCount
,(SELECT COUNT(*) from GCS.AccessPortalGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as AccessPortalCount
,(SELECT COUNT(*) from GCS.InputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as InputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode <> 64) as OutputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode = 64) as ElevatorOutputCount
FROM GCS.GalaxyPanel t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
GalaxyPanelUid = @GalaxyPanelUid
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN PanelName end) asc,
         (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 1 THEN PanelName end) desc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 0 THEN PanelNumber end) asc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 1 THEN PanelNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.GalaxyPanel table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_SelectSearch]
@PanelName nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyPanel

if @PageSize = 0
	set @PageSize = 1

SELECT 
GalaxyPanelUid
,t.ClusterUid
,GalaxyPanelModelUid
,PanelNumber
,PanelName
,Location
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,c.ClusterGroupId
,c.ClusterName
,c.EntityId
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.GalaxyInterfaceBoard where GalaxyPanelUid = t.GalaxyPanelUid) as InterfaceBoardCount
,(SELECT COUNT(*) from GCS.GalaxyCpu where GalaxyPanelUid = t.GalaxyPanelUid and IsActive = 1) as ActiveCpuCount
,(SELECT COUNT(*) from GCS.AccessPortalGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as AccessPortalCount
,(SELECT COUNT(*) from GCS.InputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as InputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode <> 64) as OutputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode = 64) as ElevatorOutputCount
FROM GCS.GalaxyPanel t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
(@PanelName IS NULL OR PanelName LIKE @PanelName + '%')
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN PanelName end) asc,
         (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 1 THEN PanelName end) desc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 0 THEN PanelNumber end) asc,
         (CASE WHEN @SortColumn = 'PanelNumber' AND @DescendingOrder = 1 THEN PanelNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.GalaxyPanel table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_Insert]
@GalaxyPanelUid uniqueidentifier 
,@ClusterUid uniqueidentifier 
,@GalaxyPanelModelUid uniqueidentifier  = null
,@PanelNumber int 
,@PanelName nvarchar(65) 
,@Location nvarchar(65) 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @GalaxyPanelUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyPanelUid = NULL

if @GalaxyPanelUid = '00000000-0000-0000-0000-000000000000' OR @GalaxyPanelUid IS NULL
	SET @GalaxyPanelUid = NewID()

INSERT INTO GCS.GalaxyPanel
(
GalaxyPanelUid
,ClusterUid
,GalaxyPanelModelUid
,PanelNumber
,PanelName
,Location
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@GalaxyPanelUid
,@ClusterUid
,@GalaxyPanelModelUid
,@PanelNumber
,@PanelName
,@Location
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.GalaxyPanel table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_Update]
@GalaxyPanelUid uniqueidentifier 
,@ClusterUid uniqueidentifier
,@GalaxyPanelModelUid uniqueidentifier
,@PanelNumber int
,@PanelName nvarchar(65)
,@Location nvarchar(65)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;


UPDATE GCS.GalaxyPanel
SET 
ClusterUid = @ClusterUid
,GalaxyPanelModelUid = @GalaxyPanelModelUid
,PanelNumber = @PanelNumber
,PanelName = @PanelName
,Location = @Location
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
GalaxyPanelUid = @GalaxyPanelUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.GalaxyPanel table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_UpdateConcurrency]
@GalaxyPanelUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.GalaxyPanel
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
GalaxyPanelUid = @GalaxyPanelUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.GalaxyPanel table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_DeleteByPK]
@GalaxyPanelUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.GalaxyPanel
WHERE
GalaxyPanelUid = @GalaxyPanelUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.GalaxyPanel table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.GalaxyPanel

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_RowCount] TO public
GO

IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'IsPersonActive'
                    AND Routine_Type = 'FUNCTION' ) 
DROP FUNCTION [GCS].[IsPersonActive]
go

CREATE OR ALTER FUNCTION [GCS].[IsPersonActive] (@PersonUid uniqueidentifier) 
RETURNS bit
as
BEGIN
DECLARE @isActiveCalculated bit
set @isActiveCalculated = 0
declare @activationDateTime datetimeoffset
declare @expirationDateTime datetimeoffset
declare @employmentDate date
declare @terminationDate date
declare @inactiveState bit
declare @isActive bit
declare @minDate date
declare @minDateTime datetimeoffset

set @minDate = '1753-01-01'
set @minDateTime = '1753-01-01 00:00:00.000'

	if not exists (select PersonUid from GCS.Person where PersonUid = @PersonUid)
		return @isActiveCalculated
		
	-- Default to active. The subsequent code will set to 0 if the person is inactive for some reason
	set @isActiveCalculated = 1

	select @activationDateTime = p.ActivationDateTime, @expirationDateTime = p.ExpirationDateTime, @employmentDate = p.EmploymentDate, @terminationDate = p.TerminationDate,
	@inactiveState = past.PersonInactiveState, 
	@isActive = pacp.IsActive
	FROM GCS.Person p
	JOIN GCS.PersonAccessControlProperties pacp ON pacp.PersonUid = p.PersonUid
	LEFT OUTER JOIN GCS.PersonActiveStatusType past on past.PersonActiveStatusTypeUid = p.PersonActiveStatusTypeUid
	WHERE p.PersonUid = @PersonUid

	-- These properties, if set to 0 or 1 respectively, override any dates
	if @isActive = 0
	BEGIN
		SET @isActiveCalculated = 0
	END
	ELSE IF @inactiveState is not null AND @inactiveState = 1
	BEGIN
		SET @isActiveCalculated = 0
	END
	ELSE 
	BEGIN
		-- IF ANY OF THE DATES THAT CAN IMPACT THE ACTIVE STATE OF THE PERSON ARE NOT NULL, THEN EXAMINE EACH ONE APPROPRIATELY
		IF @activationDateTime IS NOT NULL OR @expirationDateTime IS NOT NULL OR @employmentDate IS NOT NULL OR @terminationDate IS NOT NULL
		BEGIN
			declare @now datetimeoffset
			set @now = SYSDATETIMEOFFSET()
			if (@activationDateTime is not null AND @activationDateTime > @now) 
				set @isActiveCalculated = 0
			else if (@employmentDate is not null AND @employmentDate > @now)
				set @isActiveCalculated = 0
			else if (@expirationDateTime is not null AND @expirationDateTime <= @now AND @expirationDateTime <> @minDateTime)
				set @isActiveCalculated = 0
			else if (@terminationDate is not null AND @terminationDate <= @now AND @terminationDate <> @minDate)
				set @isActiveCalculated = 0
		END
	END

	return @isActiveCalculated
END
GO

GRANT EXECUTE ON GCS.[IsPersonActive] TO public
GO


IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'GetPersonActiveCardCount'
                    AND Routine_Type = 'FUNCTION' ) 
DROP FUNCTION [GCS].[GetPersonActiveCardCount]
go

CREATE OR ALTER FUNCTION [GCS].[GetPersonActiveCardCount] (@PersonUid uniqueidentifier) 
RETURNS smallint
as
BEGIN
declare @activeCredentialCount smallint
declare @activationModeCode smallint
declare @expirationModeCode smallint
declare @activationDateTime datetimeoffset
declare @expirationDateTime datetimeoffset
declare @usageCount smallint
declare @isActive bit
declare @cardNumber nvarchar(100)
set @activeCredentialCount = 0;

	select @activationModeCode = pactm.Code, @activationDateTime = pc.ActivationDateTime,
	@expirationModeCode = pexm.Code, @expirationDateTime = pc.ExpirationDateTime,
	@usageCount = pc.UsageCount, @isActive = pc.IsActive, @cardNumber = c.CardNumber
	from GCS.PersonCredential pc
	join GCS.PersonActivationMode pactm on pactm.PersonActivationModeUid = pc.PersonActivationModeUid
	join GCS.PersonExpirationMode pexm on pexm.PersonExpirationModeUid = pc.PersonExpirationModeUid
	join GCS.Credential c on c.CredentialUid = pc.CredentialUid
	where pc.PersonUid = @PersonUid and pc.IsActive = 1 and (
	(pactm.Code = 0 OR (pactm.Code in (1,2) AND ActivationDateTime < SYSDATETIMEOFFSET())) AND
	(pexm.Code = 0 OR ( pexm.Code in (2,4) and UsageCount > 0) OR (pexm.Code IN (1,3,4) AND ExpirationDateTime >= SYSDATETIMEOFFSET()))
	)
	select @activeCredentialCount = @@ROWCOUNT
	return @activeCredentialCount
END
GO

GRANT EXECUTE ON GCS.[GetPersonActiveCardCount] TO public
GO

if dbo.fn_GCSDoesColumnExist('Person', 'ActiveStatusCode') = 1
BEGIN
	alter table GCS.Person DROP Column ActiveStatusCode
END
go  



IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'GetPersonActiveStatusCode'
                    AND Routine_Type = 'FUNCTION' ) 
	DROP FUNCTION [GCS].[GetPersonActiveStatusCode]
go

CREATE OR ALTER FUNCTION [GCS].[GetPersonActiveStatusCode] (@PersonUid uniqueidentifier) 
RETURNS smallint
as
BEGIN
DECLARE @activeStatusCodeCalculated smallint
declare @activationDateTime datetimeoffset
declare @expirationDateTime datetimeoffset
declare @employmentDate date
declare @terminationDate date
declare @personInactiveState bit
declare @personAccessControlPropertiesIsActive bit
declare @minDate date
declare @minDateTime datetime
declare @activeCardCount smallint

-- return codes
-- 0 = Person Not Found
-- 1 = Active 
-- 2 = Inactive
-- 3 = InactiveNotYetActivated,
-- 4 = InactiveExpiredByDateOrUsage,
-- 5 = InactiveNotYetEmployed,
-- 6 = InactiveTerminated,
-- 7 = InactiveByActiveStatusType,
-- 8 = InactiveNoActiveCards

set @minDate = '1753-01-01'
set @minDateTime = '1753-01-01 00:00:00.000'
set @activeStatusCodeCalculated = 0	-- default to not found
set @activeCardCount = 0

	if not exists (select PersonUid from GCS.Person where PersonUid = @PersonUid)
		return @activeStatusCodeCalculated
		
	-- Default to active. The subsequent code will set to some inactive state if the person is inactive for some reason
	set @activeStatusCodeCalculated = 1

	select @activationDateTime = p.ActivationDateTime, @expirationDateTime = p.ExpirationDateTime, @employmentDate = p.EmploymentDate, @terminationDate = p.TerminationDate,
	@personInactiveState = past.PersonInactiveState, 
	@personAccessControlPropertiesIsActive = pacp.IsActive
	FROM GCS.Person p
	JOIN GCS.PersonAccessControlProperties pacp ON pacp.PersonUid = p.PersonUid
	LEFT OUTER JOIN GCS.PersonActiveStatusType past on past.PersonActiveStatusTypeUid = p.PersonActiveStatusTypeUid
	WHERE p.PersonUid = @PersonUid

	-- These properties, if set to 0 or 1 respectively, override any dates
	if @personAccessControlPropertiesIsActive = 0
	BEGIN
		SET @activeStatusCodeCalculated = 2	-- This is the checkbox (bool) in the AccessControlProperties table
	END
	ELSE IF @personInactiveState is not null AND @personInactiveState = 1
	BEGIN
		SET @activeStatusCodeCalculated = 7	-- Inactive due to the Active Status Type Selection 
	END
	ELSE 
	BEGIN
		-- IF ANY OF THE DATES THAT CAN IMPACT THE ACTIVE STATE OF THE PERSON ARE NOT NULL, THEN EXAMINE EACH ONE APPROPRIATELY
		IF @activationDateTime IS NOT NULL OR @expirationDateTime IS NOT NULL OR @employmentDate IS NOT NULL OR @terminationDate IS NOT NULL
		BEGIN
			declare @now datetimeoffset
			set @now = SYSDATETIMEOFFSET()
			if (@activationDateTime is not null AND @activationDateTime > @now) 
				set @activeStatusCodeCalculated = 3 -- Not yet activated
			else if (@employmentDate is not null AND @employmentDate > @now)
				set @activeStatusCodeCalculated = 5 -- Not employed yet
			else if (@expirationDateTime is not null AND @expirationDateTime <= @now AND @expirationDateTime <> @minDateTime)
				set @activeStatusCodeCalculated = 4 -- Expired by date or date & time
			else if (@terminationDate is not null AND @terminationDate <= @now AND @terminationDate <> @minDate)
				set @activeStatusCodeCalculated = 6 -- Terminated
		END
	END

	IF @activeStatusCodeCalculated = 1	-- IF none of the preceeding checks have determined that the person is inactive for any reason, then check to see if the person has any active cards
	BEGIN
		set @activeCardCount = GCS.[GetPersonActiveCardCount] (@PersonUid)
		if @activeCardCount = 0
			set @activeStatusCodeCalculated = 8
	END
	return @activeStatusCodeCalculated
	end
go

GRANT EXECUTE ON GCS.[GetPersonActiveStatusCode] TO public
GO


if dbo.fn_GCSDoesColumnExist('Person', 'ActiveStatusCode') = 0
BEGIN
	ALTER TABLE [GCS].Person
	ADD [ActiveStatusCode]  AS ([GCS].[GetPersonActiveStatusCode](PersonUid))
END
go  

if dbo.fn_GCSDoesColumnExist('GalaxyCpu', 'ClusterGroupId') = 0
BEGIN
	ALTER TABLE [GCS].[GalaxyCpu]
	ADD ClusterGroupId int  NULL default 0
END
go  

update GCS.GalaxyCpu set ClusterGroupId = 0 where ClusterGroupId is null
go

ALTER TABLE [GCS].[GalaxyCpu]
ALTER COLUMN ClusterGroupId int NOT NULL
go

if dbo.fn_GCSDoesColumnExist('GalaxyCpu', 'Version') = 0
BEGIN
	ALTER TABLE GCS.GalaxyCpu
	ADD [Version] [nvarchar](65) NULL;

END
GO

/* All Stored Procedures for table: GalaxyCpu */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.GalaxyCpu table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_SelectAll]
GO

CREATE or ALTER PROCEDURE GCS.[GalaxyCpuPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
CpuUid
,GalaxyPanelUid
,GalaxyCpuModelUid
,ClusterGroupId
,ClusterNumber
,PanelNumber
,CpuNumber
,SerialNumber
,IpAddress
,Model
,PreventFlashLoading
,PreventDataLoading
,DefaultEventLoggingOn
,[Version]
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,IsActive
FROM GCS.GalaxyCpu

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyCpu table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_ByClusterUid]
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
CpuUid
,GalaxyPanelUid
,GalaxyCpuModelUid
,ClusterGroupId
,ClusterNumber
,PanelNumber
,CpuNumber
,SerialNumber
,IpAddress
,Model
,PreventFlashLoading
,PreventDataLoading
,DefaultEventLoggingOn
,IsActive
,[Version]
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyCpu
WHERE 
GalaxyPanelUid IN (SELECT GalaxyPanelUid FROM GalaxyPanel WHERE ClusterUid = @ClusterUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyCpu table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_ByGalaxyCpuModelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_ByGalaxyCpuModelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_ByGalaxyCpuModelUid]
@GalaxyCpuModelUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
CpuUid
,GalaxyPanelUid
,GalaxyCpuModelUid
,ClusterGroupId
,ClusterNumber
,PanelNumber
,CpuNumber
,SerialNumber
,IpAddress
,Model
,PreventFlashLoading
,PreventDataLoading
,DefaultEventLoggingOn
,IsActive
,[Version]
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyCpu
WHERE 
GalaxyCpuModelUid = @GalaxyCpuModelUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_ByGalaxyCpuModelUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyCpu table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_ByGalaxyPanelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_ByGalaxyPanelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_ByGalaxyPanelUid]
@GalaxyPanelUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
CpuUid
,GalaxyPanelUid
,GalaxyCpuModelUid
,ClusterGroupId
,ClusterNumber
,PanelNumber
,CpuNumber
,SerialNumber
,IpAddress
,Model
,PreventFlashLoading
,PreventDataLoading
,DefaultEventLoggingOn
,IsActive
,[Version]
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyCpu
WHERE 
GalaxyPanelUid = @GalaxyPanelUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_ByGalaxyPanelUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows AND the primary key column AND the 'description' column
'* in the GCS.GalaxyCpu table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
CpuUid
,SerialNumber
FROM GCS.GalaxyCpu

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyCpu table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_SelectByPK]
@CpuUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
CpuUid
,GalaxyPanelUid
,GalaxyCpuModelUid
,ClusterGroupId
,ClusterNumber
,PanelNumber
,CpuNumber
,SerialNumber
,IpAddress
,Model
,PreventFlashLoading
,PreventDataLoading
,DefaultEventLoggingOn
,[Version]
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,IsActive
FROM GCS.GalaxyCpu
WHERE 
CpuUid = @CpuUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.GalaxyCpu table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_SelectSearch]
@SerialNumber nvarchar(30) 
AS

declare @ret int;
select @ret = 0;

SELECT 
CpuUid
,GalaxyPanelUid
,GalaxyCpuModelUid
,ClusterGroupId
,ClusterNumber
,PanelNumber
,CpuNumber
,SerialNumber
,IpAddress
,Model
,PreventFlashLoading
,PreventDataLoading
,DefaultEventLoggingOn
,IsActive
,[Version]
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue

FROM GCS.GalaxyCpu
WHERE 
(@SerialNumber IS NULL OR SerialNumber LIKE @SerialNumber + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyCpu table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_ByHardwareAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_ByHardwareAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_ByHardwareAddress]
@ClusterGroupId int
,@ClusterNumber int
,@PanelNumber int
,@CpuNumber int 
AS

declare @ret int;
select @ret = 0;

SELECT 
CpuUid
,GalaxyPanelUid
,GalaxyCpuModelUid
,ClusterGroupId
,ClusterNumber
,PanelNumber
,CpuNumber
,SerialNumber
,IpAddress
,Model
,PreventFlashLoading
,PreventDataLoading
,DefaultEventLoggingOn
,IsActive
,[Version]
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyCpu
WHERE 
ClusterGroupId = @ClusterGroupId AND ClusterNumber = @ClusterNumber AND PanelNumber = @PanelNumber AND CpuNumber = @CpuNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_ByHardwareAddress] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.GalaxyCpu table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_Insert]
@CpuUid uniqueidentifier 
,@GalaxyPanelUid uniqueidentifier 
,@GalaxyCpuModelUid uniqueidentifier
,@ClusterGroupId int
,@ClusterNumber int
,@PanelNumber int 
,@CpuNumber smallint 
,@SerialNumber nvarchar(30)  = null
,@IpAddress nvarchar(30)  = null
,@Model int  = null
,@PreventFlashLoading bit 
,@PreventDataLoading bit 
,@DefaultEventLoggingOn bit 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
,@IsActive bit 
,@Version nvarchar(65)
AS

declare @ret int;
select @ret = 0;


if @CpuUid = '00000000-0000-0000-0000-000000000000'
	SET @CpuUid = NULL

if @CpuUid = '00000000-0000-0000-0000-000000000000' OR @CpuUid IS NULL
	SET @CpuUid = NewID()

INSERT INTO GCS.GalaxyCpu
(
CpuUid
,GalaxyPanelUid
,GalaxyCpuModelUid
,ClusterGroupId
,ClusterNumber
,PanelNumber
,CpuNumber
,SerialNumber
,IpAddress
,Model
,PreventFlashLoading
,PreventDataLoading
,DefaultEventLoggingOn
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,IsActive
,[Version]
) 
VALUES 
(
@CpuUid
,@GalaxyPanelUid
,@GalaxyCpuModelUid
,@ClusterGroupId
,@ClusterNumber
,@PanelNumber
,@CpuNumber
,@SerialNumber
,@IpAddress
,@Model
,@PreventFlashLoading
,@PreventDataLoading
,@DefaultEventLoggingOn
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
,@IsActive
,@Version
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.GalaxyCpu table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_Update]
@CpuUid uniqueidentifier 
,@GalaxyPanelUid uniqueidentifier
,@GalaxyCpuModelUid uniqueidentifier
,@ClusterGroupId int
,@ClusterNumber int
,@PanelNumber int
,@CpuNumber smallint
,@SerialNumber nvarchar(30)
,@IpAddress nvarchar(30)
,@Model int
,@PreventFlashLoading bit
,@PreventDataLoading bit
,@DefaultEventLoggingOn bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@IsActive bit
,@Version nvarchar(65)
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.GalaxyCpu
SET 
CpuUid = @CpuUid
,GalaxyPanelUid = @GalaxyPanelUid
,GalaxyCpuModelUid = @GalaxyCpuModelUid
,ClusterGroupId = @ClusterGroupId
,ClusterNumber = @ClusterNumber
,PanelNumber = @PanelNumber
,CpuNumber = @CpuNumber
,SerialNumber = @SerialNumber
,IpAddress = @IpAddress
,Model = @Model
,PreventFlashLoading = @PreventFlashLoading
,PreventDataLoading = @PreventDataLoading
,DefaultEventLoggingOn = @DefaultEventLoggingOn
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,IsActive = @IsActive
,[Version] = @Version
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
CpuUid = @CpuUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.GalaxyCpu table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_UpdateConcurrency]
@CpuUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.GalaxyCpu
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
CpuUid = @CpuUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.GalaxyCpu table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_DeleteByPK]
@CpuUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.GalaxyCpu
WHERE
CpuUid = @CpuUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.GalaxyCpu table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyCpuPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.GalaxyCpu

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyCpuPDSA_RowCount] TO public
GO


if dbo.fn_GCSDoesColumnExist('gcsUserEntity', 'IsAdministrator') = 0
BEGIN
	ALTER TABLE [GCS].[gcsUserEntity]
	ADD IsAdministrator bit not null default 0

	update GCS.gcsUserEntity set IsAdministrator = 1 where 
	UserEntityId in (select UserEntityId from GCS.gcsUserEntityRole uer
	join GCS.gcsRole r on r.RoleId = uer.RoleId where r.IsAdministratorRole = 1)
END
go  

if dbo.fn_GCSDoesColumnExist('gcsUserEntity', 'AllowParentRoles') = 1
BEGIN
	EXEC sp_rename 'GCS.gcsUserEntity.AllowParentRoles', 'InheritParentRoles', 'COLUMN';
END
go  

if dbo.fn_GCSDoesColumnExist('gcsUserEntity', 'InheritParentRoles') = 0
BEGIN
	ALTER TABLE [GCS].[gcsUserEntity]
	ADD InheritParentRoles bit not null default 0
END
go  


if exists (select 1
          from sysobjects
          where id = object_id('GCS.tu_gcsuserentityapplicationrole')
          and type = 'TR')
   drop trigger GCS.tu_gcsuserentityapplicationrole
go
	--sp_rename 'GCS.gcsUserEntityRole.idxUserEntityIdRoleId', 'idxUserEntitiyIdRoleId', 'INDEX';

if dbo.[fn_GCSDoesIndexExist] ('gcsUserEntityRole', 'idxUserEntitiyIdRoleId') = 1
BEGIN
	DROP INDEX idxUserEntitiyIdRoleId ON [GCS].[gcsUserEntityRole]
	create unique nonclustered index idxUserEntityIdRoleId on GCS.gcsUserEntityRole (UserEntityId ASC,
	  RoleId ASC)
END
GO

if dbo.fn_GCSDoesTableExist('gcsUserEntityRole') = 0
begin
	/*==============================================================*/
	/* Table: gcsUserEntityRole                                     */
	/*==============================================================*/
	create table GCS.gcsUserEntityRole (
	   UserEntityRoleId     GCS.UniversalUniqueId    RowGuidCol not null,
	   UserEntityId         uniqueidentifier    not null,
	   RoleId               uniqueidentifier     not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1,
	   constraint PK_GCSUSERENTITYROLE primary key (UserEntityRoleId))

	/*==============================================================*/
	/* Index: idxUserEntitiyIdRoleId                                */
	/*==============================================================*/
	create unique nonclustered index idxUserEntityIdRoleId on GCS.gcsUserEntityRole (UserEntityId ASC,
	  RoleId ASC)

	alter table GCS.gcsUserEntityRole
	   add constraint FK_UserEntityRoleRole foreign key (RoleId)
		  references GCS.gcsRole (RoleId)
			 on update cascade on delete cascade
end
go

exec dbo.gcs_DeleteTrigger 'GCS', 'ti_gcsuserentityapplicationrole'
go

exec dbo.gcs_DeleteTrigger 'GCS', 'ti_gcsuserentityrole'
go

create trigger GCS.ti_gcsuserentityrole on GCS.gcsUserEntityRole for insert as
begin
    declare
       @maxcard  int,
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.gcsUserEntity" must exist when inserting a child in "GCS.gcsUserEntityRole"  */
    if update(UserEntityId)
    begin
       if (select count(*)
           from   GCS.gcsUserEntity t1, inserted t2
           where  t1.UserEntityId = t2.UserEntityId) != @numrows
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.gcsUserEntity". Cannot create child in "GCS.gcsUserEntityRole".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go

exec dbo.gcs_DeleteTrigger 'GCS', 'tu_gcsuserentityapplicationrole'
go

exec dbo.gcs_DeleteTrigger 'GCS', 'tu_gcsuserentityrole'
go

create trigger GCS.tu_gcsuserentityrole on GCS.gcsUserEntityRole for update as
begin
   declare
      @maxcard  int,
      @ins_UserEntityRoleId uniqueidentifier,
      @del_UserEntityRoleId uniqueidentifier,
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.gcsUserEntity" must exist when updating a child in "GCS.gcsUserEntityRole"  */
      if update(UserEntityId)
      begin
         if (select count(*)
             from   GCS.gcsUserEntity t1, inserted t2
             where  t1.UserEntityId = t2.UserEntityId) != @numrows
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.gcsUserEntity" does not exist. Cannot modify child in "GCS.gcsUserEntityRole".'
               goto error
            end
      end
      declare cIns cursor local for select 
              UserEntityRoleId
          from inserted
      declare cDel cursor local for select 
              UserEntityRoleId
          from deleted


      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go







if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.UserEntityApplicationRoleView')
            AND   type = 'V')
   drop view GCS.UserEntityApplicationRoleView
go


--/*==============================================================*/
--/* View: UserEntityApplicationRole                        */
--/*==============================================================*/
--create view GCS.UserEntityApplicationRoleView as
--select u.UserName, e.EntityName, app.ApplicationName, r.RoleName, uear.UserEntityApplicationRoleId, uear.EntityApplicationRoleId, u.UserId, app.ApplicationId, r.RoleId, e.EntityId
--from GCS.gcsUserEntityApplicationRole uear
--join GCS.gcsUserEntity ue on ue.UserEntityId = uear.UserEntityId
--join GCS.gcsEntityApplicationRole ear on ear.EntityApplicationRoleId = uear.EntityApplicationRoleId
--join GCS.gcsRole r on r.RoleId = ear.RoleId
--join gcs.gcsApplication app on app.ApplicationId = r.ApplicationId
--join gcs.gcsUser u on u.userid = ue.UserId
--join gcs.gcsEntity e on e.entityId = ue.EntityId
--go
if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.UserEntityRoleView')
            AND   type = 'V')
   drop view GCS.UserEntityRoleView
go

/*==============================================================*/
/* View: UserEntityRole                        */
/*==============================================================*/
create or alter view GCS.UserEntityRoleView as
--select u.UserName, e.EntityName, r.RoleName, u.UserId, r.RoleId, e.EntityId, ue.IsAdministrator, ue.InheritParentRoles
--from GCS.gcsUserEntityRole uer
--join GCS.gcsUserEntity ue on ue.UserEntityId = uer.UserEntityId
--join GCS.gcsRole r on r.RoleId = uer.RoleId
--join gcs.gcsUser u on u.userid = ue.UserId
--join gcs.gcsEntity e on e.entityId = ue.EntityId
select u.UserName, e.EntityName, r.RoleName, u.UserId, r.RoleId, e.EntityId, e.ParentEntityId, ue.IsAdministrator, ue.InheritParentRoles, r.IsAdministratorRole,
rf.IncludeAllClusters, rf.IncludeAllAccessPortals, rf.IncludeAllInputOutputGroups, rf.IncludeAllInputDevices, rf.IncludeAllOutputDevices, rf.IncludeAllSites, rf.IncludeAllRegions
from GCS.gcsUserEntity ue 
left outer join GCS. gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
left outer join GCS.gcsRole r on r.RoleId = uer.RoleId
left outer join GCS.RoleFilters rf on rf.RoleId = r.RoleId
join gcs.gcsUser u on u.userid = ue.UserId
join gcs.gcsEntity e on e.entityId = ue.EntityId
go

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_UserEntityApplicationRolesForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_UserEntityApplicationRolesForUserId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_UserEntityRolesForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_UserEntityRolesForUserId]
GO

CREATE OR ALTER PROCEDURE GCS.[gcs_UserEntityRolesForUserId]
@UserId uniqueidentifier
as
select * from GCS.UserEntityRoleView
where UserId = @UserId
go

GRANT EXECUTE ON GCS.[gcs_UserEntityRolesForUserId] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_SelectEntityApplicationRoleId_ByEntityApplicationAndRoleIds]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_SelectEntityApplicationRoleId_ByEntityApplicationAndRoleIds] 
GO

--CREATE OR ALTER PROCEDURE GCS.[gcs_SelectEntityApplicationRoleId_ByEntityApplicationAndRoleIds] 
--@EntityId uniqueidentifier,
--@ApplicationId uniqueidentifier,
--@RoleId uniqueidentifier
--AS

--declare @ret int;
--select @ret = 0;

--select top(1) EntityApplicationRoleId from GCS.gcsEntityApplicationRole ear
--join GCS.gcsEntityApplication ea on ea.EntityApplicationId = ear.EntityApplicationId
--where ea.EntityId = @EntityId AND ea.ApplicationId = @ApplicationId AND ear.RoleId = @RoleId

--if @@ROWCOUNT = 0
--  SELECT @ret = -1;

--RETURN @ret;
--GOF

--GRANT EXECUTE ON GCS.[gcs_SelectEntityApplicationRoleId_ByEntityApplicationAndRoleIds] TO public
--GO

alter table [GCS].[gcsApplicationSetting]
alter column [SettingDescription] [nvarchar](255) NULL
go

alter table [GCS].[gcsUserSetting]
alter column [SettingDescription] [nvarchar](255) NULL
go



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserSetting_ByApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserSetting_ByApplicationId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserSetting_ByApplicationId]
@ApplicationId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

IF @ApplicationId = '00000000-0000-0000-0000-000000000000' OR @ApplicationId IS NULL
BEGIN
	SELECT 
	UserSettingId
	,UserId
	,ApplicationId
	,Category
	,SettingKey
	,SettingValue
	,SettingDescription
	,InsertName
	,InsertDate
	,UpdateName
	,UpdateDate
	,ConcurrencyValue
	FROM GCS.gcsUserSetting
	WHERE ApplicationId IS NULL
END
ELSE
BEGIN
	SELECT 
	UserSettingId
	,UserId
	,ApplicationId
	,Category
	,SettingKey
	,SettingValue
	,SettingDescription
	,InsertName
	,InsertDate
	,UpdateName
	,UpdateDate
	,ConcurrencyValue
	FROM GCS.gcsUserSetting
	WHERE ApplicationId = @ApplicationId
END

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserSetting_ByApplicationId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserSetting_ByUserIdApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserSetting_ByUserIdApplicationId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserSetting_ByUserIdApplicationId]
@UserId uniqueidentifier
,@ApplicationId uniqueidentifier
AS

declare @ret int;
select @ret = 0;

IF @ApplicationId = '00000000-0000-0000-0000-000000000000' OR @ApplicationId IS NULL
BEGIN
	SELECT 
	UserSettingId
	,UserId
	,ApplicationId
	,Category
	,SettingKey
	,SettingValue
	,SettingDescription
	,InsertName
	,InsertDate
	,UpdateName
	,UpdateDate
	,ConcurrencyValue
	FROM GCS.gcsUserSetting
	WHERE 
	UserId = @UserId AND ApplicationId IS NULL
END
ELSE
BEGIN
	SELECT 
	UserSettingId
	,UserId
	,ApplicationId
	,Category
	,SettingKey
	,SettingValue
	,SettingDescription
	,InsertName
	,InsertDate
	,UpdateName
	,UpdateDate
	,ConcurrencyValue
	FROM GCS.gcsUserSetting
	WHERE 
	UserId = @UserId AND ApplicationId = @ApplicationId
END
if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserSetting_ByUserIdApplicationId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserSetting_ByUserIdApplicationIdCategory]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserSetting_ByUserIdApplicationIdCategory]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserSetting_ByUserIdApplicationIdCategory]
@UserId uniqueidentifier
,@ApplicationId uniqueidentifier
,@Category nvarchar(100)
AS

declare @ret int;
select @ret = 0;

IF @ApplicationId = '00000000-0000-0000-0000-000000000000' OR @ApplicationId IS NULL
BEGIN
	SELECT 
	UserSettingId
	,UserId
	,ApplicationId
	,Category
	,SettingKey
	,SettingValue
	,SettingDescription
	,InsertName
	,InsertDate
	,UpdateName
	,UpdateDate
	,ConcurrencyValue
	FROM GCS.gcsUserSetting
	WHERE 
	UserId = @UserId AND ApplicationId IS NULL AND Category = @Category
END
ELSE
BEGIN
	SELECT 
	UserSettingId
	,UserId
	,ApplicationId
	,Category
	,SettingKey
	,SettingValue
	,SettingDescription
	,InsertName
	,InsertDate
	,UpdateName
	,UpdateDate
	,ConcurrencyValue
	FROM GCS.gcsUserSetting
	WHERE 
	UserId = @UserId AND ApplicationId = @ApplicationId AND Category = @Category
END
if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserSetting_ByUserIdApplicationIdCategory] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserSetting_ByUserIdApplicationIdCategorySettingKey]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserSetting_ByUserIdApplicationIdCategorySettingKey]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserSetting_ByUserIdApplicationIdCategorySettingKey]
@UserId uniqueidentifier
,@ApplicationId uniqueidentifier
,@Category nvarchar(100)
,@SettingKey nvarchar(255)
AS

declare @ret int;
select @ret = 0;


IF @ApplicationId = '00000000-0000-0000-0000-000000000000' OR @ApplicationId IS NULL
BEGIN
	SELECT 
		UserSettingId
		,UserId
		,ApplicationId
		,Category
		,SettingKey
		,SettingValue
		,SettingDescription
		,InsertName
		,InsertDate
		,UpdateName
		,UpdateDate
		,ConcurrencyValue
		FROM GCS.gcsUserSetting
		WHERE 
		UserId = @UserId AND ApplicationId IS NULL AND Category = @Category AND SettingKey  = @SettingKey
END
ELSE
BEGIN
	SELECT 
		UserSettingId
		,UserId
		,ApplicationId
		,Category
		,SettingKey
		,SettingValue
		,SettingDescription
		,InsertName
		,InsertDate
		,UpdateName
		,UpdateDate
		,ConcurrencyValue
		FROM GCS.gcsUserSetting
		WHERE 
		UserId = @UserId AND ApplicationId = @ApplicationId AND Category = @Category AND SettingKey  = @SettingKey
END

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserSetting_ByUserIdApplicationIdCategorySettingKey] TO public
GO


if dbo.fn_GCSDoesColumnExist('gcsSerializedObject', 'ObjectGuid') = 1
BEGIN
	drop TABLE [GCS].[gcsSerializedObject]
END
go  

/****** Object:  Table [GCS].[gcsSerializedObject]    Script Date: 8/31/2020 2:22:12 PM ******/

if dbo.fn_GCSDoesTableExist('gcsSerializedObject') = 0
BEGIN
CREATE TABLE [GCS].[gcsSerializedObject](
	[SerializedObjectId] [uniqueidentifier] ROWGUIDCOL  NOT NULL,
	[ApplicationId] [uniqueidentifier] NOT NULL,
	[Key] [nvarchar](255) NOT NULL,
	[SerializedObject] [nvarchar](max) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[InsertName] [nvarchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[InsertDate] [datetimeoffset] NOT NULL,
	[UpdateName] [nvarchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[UpdateDate] [datetimeoffset] NULL,
	[ConcurrencyValue] [smallint] NULL,
 CONSTRAINT [PK_GCSSERIALIZEDOBJECT] PRIMARY KEY CLUSTERED 
(
	[SerializedObjectId] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

EXEC sys.sp_bindefault @defname=N'[GCS].[D_NewID]', @objname=N'[GCS].[gcsSerializedObject].[SerializedObjectId]' , @futureonly='futureonly'

/*==============================================================*/
/* Index: idxSerializedObject_ApplicationIdKey                  */
/*==============================================================*/
create unique index idxSerializedObject_ApplicationIdKey on GCS.gcsSerializedObject (
ApplicationId ASC,
[Key] ASC
)


ALTER AUTHORIZATION ON [GCS].[gcsSerializedObject] TO  SCHEMA OWNER 
end
GO


IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[GCS].[gcs_IsSerializedObjectUnique]') AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [GCS].[gcs_IsSerializedObjectUnique]
go

CREATE OR ALTER PROCEDURE [GCS].[gcs_IsSerializedObjectUnique]
	(@SerializedObjectId uniqueidentifier,
	@ApplicationId uniqueidentifier,
	@Key nvarchar(255),
	@Result int output
	)
AS
	select @Result = count(*) from GCS.gcsSerializedObject where SerializedObjectId <> @SerializedObjectId AND (ApplicationId = @ApplicationId AND [Key] = @Key)
	select @Result as Result
go

GRANT EXECUTE ON [GCS].[gcs_IsSerializedObjectUnique] TO public
GO

/* All Stored Procedures for table: gcsSerializedObject */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsSerializedObject table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsSerializedObjectPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsSerializedObjectPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsSerializedObjectPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
SerializedObjectId
,ApplicationId
,[Key]
,SerializedObject
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsSerializedObject

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsSerializedObjectPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows AND the primary key column AND the 'description' column
'* in the GCS.gcsSerializedObject table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsSerializedObjectPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsSerializedObjectPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsSerializedObjectPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
SerializedObjectId
,[Key]
FROM GCS.gcsSerializedObject

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsSerializedObjectPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsSerializedObject table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsSerializedObjectPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsSerializedObjectPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsSerializedObjectPDSA_SelectByPK]
@SerializedObjectId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
SerializedObjectId
,ApplicationId
,[Key]
,SerializedObject
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsSerializedObject
WHERE 
SerializedObjectId = @SerializedObjectId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsSerializedObjectPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsSerializedObject table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsSerializedObjectPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsSerializedObjectPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsSerializedObjectPDSA_SelectSearch]
@Key nvarchar(255) 
AS

declare @ret int;
select @ret = 0;

SELECT 
SerializedObjectId
,ApplicationId
,[Key]
,SerializedObject
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsSerializedObject
WHERE 
(@Key IS NULL OR [Key] LIKE @Key + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsSerializedObjectPDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsSerializedObject table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsSerializedObjectPDSA_ByApplicationIdKey]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsSerializedObjectPDSA_ByApplicationIdKey]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsSerializedObjectPDSA_ByApplicationIdKey]
@ApplicationId uniqueidentifier,
@Key nvarchar(255)
AS

declare @ret int;
select @ret = 0;

SELECT 
SerializedObjectId
,ApplicationId
,[Key]
,SerializedObject
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsSerializedObject
WHERE 
ApplicationId = @ApplicationId AND [Key] = @Key

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsSerializedObjectPDSA_ByApplicationIdKey] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.gcsSerializedObject table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsSerializedObjectPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsSerializedObjectPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsSerializedObjectPDSA_Insert]
@SerializedObjectId uniqueidentifier 
,@ApplicationId uniqueidentifier 
,@Key nvarchar(255) 
,@SerializedObject nvarchar(max) 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @SerializedObjectId = '00000000-0000-0000-0000-000000000000'
	SET @SerializedObjectId = NULL

if @SerializedObjectId = '00000000-0000-0000-0000-000000000000' OR @SerializedObjectId IS NULL
	SET @SerializedObjectId = NewID()

INSERT INTO GCS.gcsSerializedObject
(
SerializedObjectId
,ApplicationId
,[Key]
,SerializedObject
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@SerializedObjectId
,@ApplicationId
,@Key
,@SerializedObject
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsSerializedObjectPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsSerializedObject table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsSerializedObjectPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsSerializedObjectPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsSerializedObjectPDSA_Update]
@SerializedObjectId uniqueidentifier 
,@ApplicationId uniqueidentifier
,@Key nvarchar(255)
,@SerializedObject nvarchar(max)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsSerializedObject
SET 
SerializedObjectId = @SerializedObjectId
,ApplicationId = @ApplicationId
,[Key] = @Key
,SerializedObject = @SerializedObject
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
SerializedObjectId = @SerializedObjectId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsSerializedObjectPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsSerializedObject table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsSerializedObjectPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsSerializedObjectPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsSerializedObjectPDSA_UpdateConcurrency]
@SerializedObjectId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsSerializedObject
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
SerializedObjectId = @SerializedObjectId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsSerializedObjectPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsSerializedObject table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsSerializedObjectPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsSerializedObjectPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsSerializedObjectPDSA_DeleteByPK]
@SerializedObjectId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsSerializedObject
WHERE
SerializedObjectId = @SerializedObjectId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsSerializedObjectPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsSerializedObject table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsSerializedObjectPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsSerializedObjectPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsSerializedObjectPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsSerializedObject

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsSerializedObjectPDSA_RowCount] TO public
GO

if dbo.fn_GCSDoesTableExist('gcsLargeObjectStorage') = 0
begin
/*==============================================================*/
/* Table: gcsLargeObjectStorage                                 */
/*==============================================================*/
create table GCS.gcsLargeObjectStorage (
   Uid                  GCS.UniversalUniqueId    RowGuidCol not null UNIQUE,
   EntityId             GCS.UniversalUniqueId    null,
   UniqueTag            nvarchar(255)        not null,
   DataType             nvarchar(255)        not null,
   TextData             nvarchar(4000)       null,
   FileStreamData       varbinary(Max)       filestream null,
   BlobData             varbinary(8000)      null,
   InsertName           nvarchar(100)         not null default user_name(),
   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
   UpdateName           nvarchar(100)         null default user_name(),
   UpdateDate           datetimeoffset            null default SYSDATETIMEOFFSET(),
   ConcurrencyValue     smallint             null default 1,
   constraint PK_GCSLARGEOBJECTSTORAGE primary key (Uid)
)

	/*==============================================================*/
	/* Index: idx_UniqueTag                                         */
	/*==============================================================*/
	create unique index idx_UniqueTag on GCS.gcsLargeObjectStorage (
	UniqueTag ASC,
	EntityId ASC
	)

	alter table GCS.gcsLargeObjectStorage
	   add constraint FK_gcsFileStreamStorageEntity foreign key (EntityId)
		  references GCS.gcsEntity (EntityId)
			 on update cascade on delete cascade
end
go



IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[GCS].[gcs_IsLargeObjectStorageUnique]') AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [GCS].[gcs_IsLargeObjectStorageUnique]
go

CREATE OR ALTER PROCEDURE [GCS].[gcs_IsLargeObjectStorageUnique]
	(@Uid uniqueidentifier,
	@EntityId uniqueidentifier,
	@UniqueTag nvarchar(255),
	@Result int output
	)
AS
	select @Result = count(*) from GCS.gcsLargeObjectStorage where [Uid] <> @Uid AND (EntityId = @EntityId AND UniqueTag = @UniqueTag)
	select @Result as Result
go

GRANT EXECUTE ON [GCS].[gcs_IsLargeObjectStorageUnique] TO public
GO


/* All Stored Procedures for table: gcsLargeObjectStorage */

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsLargeObjectStorage table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsLargeObjectStoragePDSA_ByEntityIdAndUniqueTag]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsLargeObjectStoragePDSA_ByEntityIdAndUniqueTag]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsLargeObjectStoragePDSA_ByEntityIdAndUniqueTag]
@EntityId uniqueidentifier,
@UniqueTag nvarchar(255)
AS

declare @ret int;
select @ret = 0;

if @EntityId IS NULL or @EntityId = '00000000-0000-0000-0000-000000000000'
BEGIN
SELECT 
Uid
,EntityId
,UniqueTag
,DataType
,TextData
,FileStreamData
,BlobData
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsLargeObjectStorage
WHERE 
EntityId IS NULL AND UniqueTag = @UniqueTag
END
ELSE
BEGIN
SELECT 
Uid
,EntityId
,UniqueTag
,DataType
,TextData
,FileStreamData
,BlobData
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsLargeObjectStorage
WHERE 
EntityId = @EntityId AND UniqueTag = @UniqueTag
END

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsLargeObjectStoragePDSA_ByEntityIdAndUniqueTag] TO public
Go 

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsLargeObjectStorage table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsLargeObjectStoragePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsLargeObjectStoragePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsLargeObjectStoragePDSA_SelectByPK]
@Uid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
Uid
,EntityId
,UniqueTag
,DataType
,TextData
,FileStreamData
,BlobData
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsLargeObjectStorage
WHERE 
Uid = @Uid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsLargeObjectStoragePDSA_SelectByPK] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.gcsLargeObjectStorage table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsLargeObjectStoragePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsLargeObjectStoragePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsLargeObjectStoragePDSA_Insert]
@Uid uniqueidentifier 
,@EntityId uniqueidentifier  = null
,@UniqueTag nvarchar(255) 
,@DataType nvarchar(255) 
,@TextData nvarchar(4000)  = null
,@FileStreamData varbinary(max)
,@BlobData varbinary(8000)
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @Uid = '00000000-0000-0000-0000-000000000000'
	SET @Uid = NULL
if @EntityId = '00000000-0000-0000-0000-000000000000'
	SET @EntityId = NULL

if @Uid = '00000000-0000-0000-0000-000000000000' OR @Uid IS NULL
	SET @Uid = NewID()

INSERT INTO GCS.gcsLargeObjectStorage
(
Uid
,EntityId
,UniqueTag
,DataType
,TextData
,FileStreamData
,BlobData
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@Uid
,@EntityId
,@UniqueTag
,@DataType
,@TextData
,@FileStreamData
,@BlobData
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsLargeObjectStoragePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsLargeObjectStorage table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsLargeObjectStoragePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsLargeObjectStoragePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsLargeObjectStoragePDSA_Update]
@Uid uniqueidentifier 
,@EntityId uniqueidentifier
,@UniqueTag nvarchar(255)
,@DataType nvarchar(255)
,@TextData nvarchar(4000)
,@FileStreamData varbinary(max)
,@BlobData varbinary(8000)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @EntityId = '00000000-0000-0000-0000-000000000000'
	SET @EntityId = NULL

UPDATE GCS.gcsLargeObjectStorage
SET 
Uid = @Uid
,EntityId = @EntityId
,UniqueTag = @UniqueTag
,DataType = @DataType
,TextData = @TextData
,FileStreamData = @FileStreamData
,BlobData = @BlobData
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
Uid = @Uid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsLargeObjectStoragePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsLargeObjectStorage table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsLargeObjectStoragePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsLargeObjectStoragePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsLargeObjectStoragePDSA_UpdateConcurrency]
@Uid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsLargeObjectStorage
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
Uid = @Uid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsLargeObjectStoragePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsLargeObjectStorage table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsLargeObjectStoragePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsLargeObjectStoragePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsLargeObjectStoragePDSA_DeleteByPK]
@Uid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsLargeObjectStorage
WHERE
Uid = @Uid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsLargeObjectStoragePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsLargeObjectStorage table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsLargeObjectStoragePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsLargeObjectStoragePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsLargeObjectStoragePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsLargeObjectStorage

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsLargeObjectStoragePDSA_RowCount] TO public
GO

/*==============================================================*/
/* Table: gcsEntityCount                                        */
/*==============================================================*/
if dbo.fn_GCSDoesTableExist('gcsEntityCount') = 0
BEGIN
	create table GCS.gcsEntityCount (
	   EntityCountUid       GCS.UniversalUniqueId    RowGuidCol not null,
	   EntityId             GCS.UniversalUniqueId    not null,
	   CountType            GCS.Text50               not null,
	   CountValue           bigint               not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1,
	   constraint PK_GCSENTITYCOUNT primary key (EntityCountUid)
	)

	alter table GCS.gcsEntityCount
	   add constraint FK_gcsEntityCountEntity foreign key (EntityId)
		  references GCS.gcsEntity (EntityId)
			 on update cascade on delete cascade
END
go  

/* All Stored Procedures for table: gcsEntityCount */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsEntityCount table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityCountUid
,EntityId
,CountType
,CountValue
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsEntityCount

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows AND the primary key column AND the 'description' column
'* in the GCS.gcsEntityCount table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityCountUid
,CountType
FROM GCS.gcsEntityCount

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsEntityCount table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_SelectByPK]
@EntityCountUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityCountUid
,EntityId
,CountType
,CountValue
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsEntityCount
WHERE 
EntityCountUid = @EntityCountUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsEntityCount table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_SelectSearch]
@CountType nvarchar(50) 
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityCountUid
,EntityId
,CountType
,CountValue
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsEntityCount
WHERE 
(@CountType IS NULL OR CountType LIKE @CountType + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsEntityCount table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_ByEntityId]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityCountUid
,EntityId
,CountType
,CountValue
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsEntityCount
WHERE 
EntityId = @EntityId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsEntityCount table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_ByEntityIdAndType]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_ByEntityIdAndType]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_ByEntityIdAndType]
@EntityId uniqueidentifier,
@CountType nvarchar(50)
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityCountUid
,EntityId
,CountType
,CountValue
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsEntityCount
WHERE 
EntityId = @EntityId AND
CountType = @CountType

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_ByEntityIdAndType] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.gcsEntityCount table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_Insert]
@EntityCountUid uniqueidentifier 
,@EntityId uniqueidentifier 
,@CountType nvarchar(50) 
,@CountValue bigint 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @EntityCountUid = '00000000-0000-0000-0000-000000000000'
	SET @EntityCountUid = NULL

if @EntityCountUid = '00000000-0000-0000-0000-000000000000' OR @EntityCountUid IS NULL
	SET @EntityCountUid = NewID()

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@EntityCountUid
,@EntityId
,@CountType
,@CountValue
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsEntityCount table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_Update]
@EntityCountUid uniqueidentifier 
,@EntityId uniqueidentifier
,@CountType nvarchar(50)
,@CountValue bigint
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsEntityCount
SET 
EntityCountUid = @EntityCountUid
,EntityId = @EntityId
,CountType = @CountType
,CountValue = @CountValue
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
EntityCountUid = @EntityCountUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsEntityCount table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_UpdateConcurrency]
@EntityCountUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsEntityCount
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
EntityCountUid = @EntityCountUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsEntityCount table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_DeleteByPK]
@EntityCountUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsEntityCount
WHERE
EntityCountUid = @EntityCountUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsEntityCount table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsEntityCount

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_RowCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertAccessPortalCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertAccessPortalCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertAccessPortalCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.AccessPortal WHERE EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'AccessPortal'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertAccessPortalCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertInputDeviceCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertInputDeviceCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertInputDeviceCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.InputDevice WHERE EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'InputDevice'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertInputDeviceCount] TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertOutputDeviceCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertOutputDeviceCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertOutputDeviceCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.OutputDevice WHERE EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'OutputDevice'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertOutputDeviceCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertPersonCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertPersonCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertPersonCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.Person WHERE EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'Person'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertPersonCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertPrimaryUserCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertPrimaryUserCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertPrimaryUserCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.gcsUser where PrimaryEntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'PrimaryUser'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertPrimaryUserCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertEntityUserCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertEntityUserCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertEntityUserCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.gcsUserEntity where EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'EntityUser'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertEntityUserCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertTimeScheduleCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertTimeScheduleCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertTimeScheduleCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.TimeSchedule where EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'TimeSchedule'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertTimeScheduleCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertSiteCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertSiteCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertSiteCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.Site where EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'Site'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertSiteCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertClusterCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertClusterCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertClusterCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.Cluster where EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'Cluster'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertClusterCount] TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertPanelCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertPanelCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertPanelCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.GalaxyPanel where ClusterUid in (select ClusterUid FROM GCS.Cluster where EntityId = @entityId)

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'Panel'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertPanelCount] TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertInterfaceBoardCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertInterfaceBoardCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertInterfaceBoardCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.GalaxyInterfaceBoard where GalaxyPanelUid in (select GalaxyPanelUid from GCS.GalaxyPanel where ClusterUid in (select ClusterUid FROM GCS.Cluster where EntityId = @entityId))

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'InterfaceBoard'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertInterfaceBoardCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertAccessPortalActivityEventCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertAccessPortalActivityEventCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertAccessPortalActivityEventCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.AccessPortalActivityEvent where AccessPortalUid in (select AccessPortalUid from GCS.AccessPortal where EntityId = @entityId)

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'AccessPortalActivityEvent'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertAccessPortalActivityEventCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertInputDeviceActivityEventCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertInputDeviceActivityEventCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertInputDeviceActivityEventCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.InputDeviceActivityEvent where InputDeviceUid in (select InputDeviceUid from GCS.InputDevice where EntityId = @entityId)

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'InputDeviceActivityEvent'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertInputDeviceActivityEventCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertOutputDeviceActivityEventCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertOutputDeviceActivityEventCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertOutputDeviceActivityEventCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.OutputDeviceActivityEvent where OutputDeviceUid in (select OutputDeviceUid from GCS.OutputDevice where EntityId = @entityId)

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'OutputDeviceActivityEvent'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertOutputDeviceActivityEventCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertGalaxyPanelActivityEventCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertGalaxyPanelActivityEventCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertGalaxyPanelActivityEventCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.GalaxyPanelActivityEvent where GalaxyPanelUid in (select GalaxyPanelUid from GCS.GalaxyPanel where ClusterUid in (select ClusterUid FROM GCS.Cluster where EntityId = @entityId))

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'GalaxyPanelActivityEvent'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertGalaxyPanelActivityEventCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertAccessGroupCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertAccessGroupCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertAccessGroupCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.AccessGroup WHERE EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'AccessGroup'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertAccessGroupCount] TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertAccessProfileCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertAccessProfileCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertAccessProfileCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.AccessProfile WHERE EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'AccessProfile'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertAccessProfileCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertInputOutputGroupCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertInputOutputGroupCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertInputOutputGroupCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.InputOutputGroup WHERE EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'InputOutputGroup'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertInputOutputGroupCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertAccessPortalGroupCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertAccessPortalGroupCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertAccessPortalGroupCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.AccessPortalAlertEvent apae
join GCS.AccessPortal ap on ap.AccessPortalUid = apae.AccessPortalUid 
join GCS.InputOutputGroup iog on iog.InputOutputGroupUid = apae.InputOutputGroupUid
where AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-00000000000C' and iog.IOGroupNumber <> 0 and ap.EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'AccessPortalGroup'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertAccessPortalGroupCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertRegionCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertRegionCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertRegionCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.Region WHERE EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'Region'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertRegionCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertDayTypeCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertDayTypeCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertDayTypeCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.DayType WHERE EntityId = @EntityId and IsActive = 1

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'DayType'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertDayTypeCount] TO public
GO




IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_InsertTimePeriodCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_InsertTimePeriodCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_InsertTimePeriodCount]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

declare @cnt int
select @cnt = count(*) from GCS.GalaxyTimePeriod WHERE EntityId = @EntityId

INSERT INTO GCS.gcsEntityCount
(
EntityCountUid
,EntityId
,CountType
,CountValue
) 
VALUES 
(
NewID()
,@EntityId
,N'TimePeriod'
,@cnt)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_InsertTimePeriodCount] TO public
GO









IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_GenerateAllCounts]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_GenerateAllCounts]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_GenerateAllCounts]
@EntityId uniqueidentifier 
AS

if @EntityId IS NULL OR @EntityId = '00000000-0000-0000-0000-000000000000'
begin
	DECLARE entCursor CURSOR FOR SELECT EntityId from GCS.gcsEntity where EntityId <> '00000000-0000-0000-0000-000000000001' ORDER BY EntityId 
	OPEN entCursor
	FETCH NEXT FROM entCursor INTO @EntityId
	WHILE @@FETCH_STATUS = 0
	BEGIN
		EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertInputDeviceCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertOutputDeviceCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertPersonCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertPrimaryUserCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertEntityUserCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertTimeScheduleCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertSiteCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertClusterCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertPanelCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertInterfaceBoardCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalActivityEventCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertInputDeviceActivityEventCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertOutputDeviceActivityEventCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertGalaxyPanelActivityEventCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertAccessGroupCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertAccessProfileCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertInputOutputGroupCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalGroupCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertRegionCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertDayTypeCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertTimePeriodCount] @EntityId
	FETCH NEXT FROM entCursor INTO @EntityId
	END
	CLOSE entCursor;
	DEALLOCATE entCursor;
end
else
begin
	EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertInputDeviceCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertOutputDeviceCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertPersonCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertPrimaryUserCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertEntityUserCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertTimeScheduleCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertSiteCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertClusterCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertPanelCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertInterfaceBoardCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalActivityEventCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertInputDeviceActivityEventCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertOutputDeviceActivityEventCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertGalaxyPanelActivityEventCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertAccessGroupCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertAccessProfileCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertInputOutputGroupCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalGroupCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertRegionCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertDayTypeCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertTimePeriodCount] @EntityId
end
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_GenerateAllCounts] TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityCountPDSA_GetLatestCounts]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityCountPDSA_GetLatestCounts]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_GetLatestCounts]
@EntityId uniqueidentifier 
AS
	SELECT dd.[CountType], dd.[CountValue], dd.[EntityId], dd.[InsertDate]
	FROM
	(SELECT [CountType], max([InsertDate]) as [InsertDate] 
	FROM GCS.gcsEntityCount 
	WHERE EntityId = @EntityId
	GROUP BY CountType) r
	INNER JOIN GCS.gcsEntityCount dd
	ON dd.[CountType] = r.[CountType] AND dd.[InsertDate] = r.InsertDate
	WHERE dd.EntityId = @EntityId
	ORDER BY CountType
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_GetLatestCounts] TO public
GO
 
/****** Object:  Index [idxAccessPortalActivityEventUniqueId]    Script Date: 5/24/2021 2:58:18 PM ******/
if dbo.[fn_GCSDoesIndexExist]('AccessPortalActivityEvent', 'idxAccessPortalActivityEvent') = 1
BEGIN
	DROP INDEX [idxAccessPortalActivityEvent] ON [GCS].[AccessPortalActivityEvent]
END
GO

/****** Object:  Index [idxAccessPortalActivityEventUniqueId]    Script Date: 5/24/2021 2:58:18 PM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxAccessPortalActivityEvent] ON [GCS].[AccessPortalActivityEvent]
(
	[CpuUid] ASC,
	[ActivityDateTime] ASC,
	[BufferIndex] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO

/****** Object:  Index [idxInputDeviceActivityEvent]    Script Date: 5/24/2021 3:22:54 PM ******/
if dbo.[fn_GCSDoesIndexExist]('InputDeviceActivityEvent', 'idxInputDeviceActivityEvent') = 1
BEGIN
	DROP INDEX [idxInputDeviceActivityEvent] ON [GCS].[InputDeviceActivityEvent]
END
GO

/****** Object:  Index [idxInputDeviceActivityEvent]    Script Date: 5/24/2021 3:22:54 PM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxInputDeviceActivityEvent] ON [GCS].[InputDeviceActivityEvent]
(
	[CpuUid] ASC,
	[ActivityDateTime] ASC,
	[BufferIndex] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO


/****** Object:  Index [idxGalaxyPanelActivityEvent]    Script Date: 5/24/2021 3:29:29 PM ******/
if dbo.[fn_GCSDoesIndexExist]('GalaxyPanelActivityEvent', 'idxGalaxyPanelActivityEvent') = 1
BEGIN
	DROP INDEX [idxGalaxyPanelActivityEvent] ON [GCS].[GalaxyPanelActivityEvent]
END
GO

/****** Object:  Index [idxGalaxyPanelActivityEvent]    Script Date: 5/24/2021 3:29:29 PM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxGalaxyPanelActivityEvent] ON [GCS].[GalaxyPanelActivityEvent]
(
	[ActivityDateTime] ASC,
	[CpuUid] ASC,
	[BufferIndex] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO

/****** Object:  Index [idxOutputDeviceActivityEvent]    Script Date: 5/24/2021 3:30:13 PM ******/
if dbo.[fn_GCSDoesIndexExist]('OutputDeviceActivityEvent', 'idxOutputDeviceActivityEvent') = 1
BEGIN
	DROP INDEX [idxOutputDeviceActivityEvent] ON [GCS].[OutputDeviceActivityEvent]
END
go  

/****** Object:  Index [idxOutputDeviceActivityEvent]    Script Date: 5/24/2021 3:30:13 PM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxOutputDeviceActivityEvent] ON [GCS].[OutputDeviceActivityEvent]
(
	[CpuUid] ASC,
	[ActivityDateTime] ASC,
	[BufferIndex] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO



/* All Stored Procedures for table: InputDevice */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.InputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDevice table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ByBinaryResourceUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ByBinaryResourceUid]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ByBinaryResourceUid]
@BinaryResourceUid uniqueidentifier
,@IsNodeActive bit = null 
AS

declare @ret int;
select @ret = 0;

SELECT
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE 
t.BinaryResourceUid = @BinaryResourceUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ByBinaryResourceUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDevice table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE c.ClusterUid = @ClusterUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDevice table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE t.EntityId = @EntityId or t.InputDeviceUid IN (SELECT t.InputDeviceUid FROM GCS.InputDeviceEntityMap WHERE EntityId = @EntityId)
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDevice table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ByGalaxyPanelAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ByGalaxyPanelAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ByGalaxyPanelAddress]
@ClusterGroupId int,
@ClusterNumber int,
@PanelNumber int,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE 
c.ClusterGroupId = @ClusterGroupId AND
c.ClusterNumber = @ClusterNumber AND
p.PanelNumber = @PanelNumber
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ByGalaxyPanelAddress] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDevice table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ByGalaxyPanelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ByGalaxyPanelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ByGalaxyPanelUid]
@GalaxyPanelUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE p.GalaxyPanelUid= @GalaxyPanelUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ByGalaxyPanelUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDevice table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ByHardwareAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ByHardwareAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ByHardwareAddress]
@ClusterGroupId int,
@ClusterNumber int,
@PanelNumber int,
@BoardNumber int,
@SectionNumber int,
@ModuleNumber int,
@NodeNumber int
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

SELECT 
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE 
c.ClusterGroupId = @ClusterGroupId AND
c.ClusterNumber = @ClusterNumber AND
p.PanelNumber = @PanelNumber AND
gib.BoardNumber = @BoardNumber AND
gibs.SectionNumber = @SectionNumber AND
m.ModuleNumber = @ModuleNumber AND
n.NodeNumber = @NodeNumber
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY r.RegionName, s.SiteName, t.InputName

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ByHardwareAddress] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ByName]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ByName]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ByName]
@InputName nvarchar(65) 
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1

AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE (@InputName IS NULL OR t.InputName LIKE '%' + @InputName + '%' )
 And (t.EntityId = @EntityId OR (t.InputDeviceUid IN (SELECT InputDeviceUid FROM GCS.InputDeviceEntityMap WHERE EntityId = @EntityId)))
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ByName] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ByNameOrComments]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ByNameOrComments]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ByNameOrComments]
@InputName nvarchar(65) 
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE (@InputName IS NULL OR t.InputName LIKE '%' + @InputName + '%' or t.Location LIKE '%' + @InputName + '%' or t.CriticalityComment LIKE '%' + @InputName + '%' or t.ServiceComment LIKE '%' + @InputName + '%' or t.Comment LIKE '%' + @InputName + '%')
 And (t.EntityId = @EntityId OR (t.InputDeviceUid IN (SELECT InputDeviceUid FROM GCS.InputDeviceEntityMap WHERE EntityId = @EntityId)))
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ByNameOrComments] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDevice table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ByRegionUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ByRegionUid]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ByRegionUid]
@RegionUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE t.SiteUid IN (SELECT SiteUid FROM GCS.Site WHERE RegionUid = @RegionUid)
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ByRegionUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDevice table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_BySiteUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_BySiteUid]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_BySiteUid]
@SiteUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE t.SiteUid = @SiteUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_BySiteUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.InputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
InputDeviceUid
,InputName
,IsActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;
if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_SelectListBox] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ListBoxByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ListBoxByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ListBoxByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null 
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
id.EntityId
,id.InputDeviceUid
,id.InputName
,id.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice id
JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = id.InputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE 
c.ClusterUid  = @ClusterUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN id.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN id.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN id.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN id.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ListBoxByClusterUid] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ListBoxByGalaxyPanelAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ListBoxByGalaxyPanelAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ListBoxByGalaxyPanelAddress]
@ClusterGroupId int,
@ClusterNumber int,
@PanelNumber int,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
id.EntityId
,id.InputDeviceUid
,id.InputName
,id.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice id
JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = id.InputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE 
c.ClusterGroupId = @ClusterGroupId AND
c.ClusterNumber = @ClusterNumber AND
p.PanelNumber = @PanelNumber
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN id.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN id.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN id.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN id.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ListBoxByGalaxyPanelAddress] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ListBoxByGalaxyPanelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ListBoxByGalaxyPanelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ListBoxByGalaxyPanelUid]
@GalaxyPanelUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1 
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
id.EntityId
,id.InputDeviceUid
,id.InputName
,id.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice id
JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = id.InputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE 
p.GalaxyPanelUid  = @GalaxyPanelUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN id.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN id.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN id.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN id.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ListBoxByGalaxyPanelUid] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ListBoxByName]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ListBoxByName]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ListBoxByName]
@InputName nvarchar(65) 
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
id.EntityId
,id.InputDeviceUid
,id.InputName
,id.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice id
JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = id.InputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE (@InputName IS NULL OR id.InputName LIKE '%' + @InputName + '%')
 And (id.EntityId = @EntityId OR (id.InputDeviceUid IN (SELECT InputDeviceUid FROM GCS.InputDeviceEntityMap WHERE EntityId = @EntityId)))
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN id.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN id.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN id.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN id.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.InputDevicePDSA_ListBoxByName TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ListBoxByNameOrComments]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ListBoxByNameOrComments]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ListBoxByNameOrComments]
@InputName nvarchar(65) 
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
id.EntityId
,id.InputDeviceUid
,id.InputName
,id.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice id
JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = id.InputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE (@InputName IS NULL OR id.InputName LIKE '%' + @InputName + '%' or id.Location LIKE '%' + @InputName + '%' or id.CriticalityComment LIKE '%' + @InputName + '%' or id.ServiceComment LIKE '%' + @InputName + '%' or id.Comment LIKE '%' + @InputName + '%')
 And (id.EntityId = @EntityId OR (id.InputDeviceUid IN (SELECT InputDeviceUid FROM GCS.InputDeviceEntityMap WHERE EntityId = @EntityId)))
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN id.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN id.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN id.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN id.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.InputDevicePDSA_ListBoxByNameOrComments TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ListBoxByPrimaryKey]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ListBoxByPrimaryKey]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_ListBoxByPrimaryKey]
@InputDeviceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
id.EntityId
,id.InputDeviceUid
,id.InputName
,id.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice id
JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = id.InputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE 
id.InputDeviceUid  = @InputDeviceUid
ORDER BY id.InputName

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_ListBoxByPrimaryKey] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDevice table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_SelectByPK]
@InputDeviceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE
t.InputDeviceUid = @InputDeviceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.InputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_SelectSearch]
@InputName nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT
 t.InputDeviceUid
, t.EntityId
, t.SiteUid
, t.BinaryResourceUid
, t.InputName
, t.Location
, t.ServiceComment
, t.CriticalityComment
, t.Comment
, t.EMailEventsEnabled
, t.TransmitEventsEnabled
, t.FileOutputEnabled
, t.IsActive
, t.IsTemplate
, t.InsertName
, t.InsertDate
, t.UpdateName
, t.UpdateDate
, t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = t.InputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE 
(@InputName IS NULL OR t.InputName LIKE @InputName + '%')
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.InputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_Insert]
@InputDeviceUid uniqueidentifier 
,@EntityId uniqueidentifier 
,@SiteUid uniqueidentifier 
,@BinaryResourceUid uniqueidentifier  = null
,@InputName nvarchar(65) 
,@Location nvarchar(255)  = null
,@ServiceComment nvarchar(255)  = null
,@CriticalityComment nvarchar(255)  = null
,@Comment nvarchar(255)  = null
,@EMailEventsEnabled bit 
,@TransmitEventsEnabled bit 
,@FileOutputEnabled bit 
,@IsActive bit 
,@IsTemplate bit 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @InputDeviceUid = '00000000-0000-0000-0000-000000000000'
	SET @InputDeviceUid = NULL
if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @BinaryResourceUid = NULL

if @InputDeviceUid = '00000000-0000-0000-0000-000000000000' OR @InputDeviceUid IS NULL
	SET @InputDeviceUid = NewID()

INSERT INTO GCS.InputDevice
(
InputDeviceUid
,EntityId
,SiteUid
,BinaryResourceUid
,InputName
,Location
,ServiceComment
,CriticalityComment
,Comment
,EMailEventsEnabled
,TransmitEventsEnabled
,FileOutputEnabled
,IsActive
,IsTemplate
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@InputDeviceUid
,@EntityId
,@SiteUid
,@BinaryResourceUid
,@InputName
,@Location
,@ServiceComment
,@CriticalityComment
,@Comment
,@EMailEventsEnabled
,@TransmitEventsEnabled
,@FileOutputEnabled
,@IsActive
,@IsTemplate
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.InputDevice table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_Update]
@InputDeviceUid uniqueidentifier 
,@EntityId uniqueidentifier
,@SiteUid uniqueidentifier
,@BinaryResourceUid uniqueidentifier
,@InputName nvarchar(65)
,@Location nvarchar(255)
,@ServiceComment nvarchar(255)
,@CriticalityComment nvarchar(255)
,@Comment nvarchar(255)
,@EMailEventsEnabled bit
,@TransmitEventsEnabled bit
,@FileOutputEnabled bit
,@IsActive bit 
,@IsTemplate bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @BinaryResourceUid = NULL

UPDATE GCS.InputDevice
SET 
EntityId = @EntityId
,SiteUid = @SiteUid
,BinaryResourceUid = @BinaryResourceUid
,InputName = @InputName
,Location = @Location
,ServiceComment = @ServiceComment
,CriticalityComment = @CriticalityComment
,Comment = @Comment
,EMailEventsEnabled = @EMailEventsEnabled
,TransmitEventsEnabled = @TransmitEventsEnabled
,FileOutputEnabled = @FileOutputEnabled
,IsActive = @IsActive
,IsTemplate = @IsTemplate
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
InputDeviceUid = @InputDeviceUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.InputDevice table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_UpdateConcurrency]
@InputDeviceUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.InputDevice
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
InputDeviceUid = @InputDeviceUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.InputDevice table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_DeleteByPK]
@InputDeviceUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.InputDevice
WHERE
InputDeviceUid = @InputDeviceUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[InputDevicePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.InputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevicePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.InputDevice

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDevicePDSA_RowCount] TO public
GO

/* All Stored Procedures for table: OutputDevice */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.OutputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_SelectAll] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ByBinaryResourceUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ByBinaryResourceUid]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ByBinaryResourceUid]
@BinaryResourceUid uniqueidentifier 
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE 
t.BinaryResourceUid = @BinaryResourceUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY r.RegionName, s.SiteName, t.OutputName

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ByBinaryResourceUid] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE 
c.ClusterUid = @ClusterUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ByClusterUid] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE t.EntityId = @EntityId or t.OutputDeviceUid IN (SELECT t.OutputDeviceUid FROM GCS.OutputDeviceEntityMap WHERE EntityId = @EntityId)
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ByEntityId] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ByGalaxyPanelAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ByGalaxyPanelAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ByGalaxyPanelAddress]
@ClusterGroupId int,
@ClusterNumber int,
@PanelNumber int,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE 
c.ClusterGroupId = @ClusterGroupId AND
c.ClusterNumber = @ClusterNumber AND
p.PanelNumber = @PanelNumber
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ByGalaxyPanelAddress] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ByGalaxyPanelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ByGalaxyPanelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ByGalaxyPanelUid]
@GalaxyPanelUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE p.GalaxyPanelUid= @GalaxyPanelUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ByGalaxyPanelUid] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ByHardwareAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ByHardwareAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ByHardwareAddress]
@ClusterGroupId int,
@ClusterNumber int,
@PanelNumber int,
@BoardNumber int,
@SectionNumber int,
@ModuleNumber int,
@NodeNumber int
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE
c.ClusterGroupId = @ClusterGroupId AND
c.ClusterNumber = @ClusterNumber AND
p.PanelNumber = @PanelNumber AND
gib.BoardNumber = @BoardNumber AND
gibs.SectionNumber = @SectionNumber AND
m.ModuleNumber = @ModuleNumber AND
n.NodeNumber = @NodeNumber
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY r.RegionName, s.SiteName, t.OutputName

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ByHardwareAddress] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ByName]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ByName]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ByName]
@OutputName nvarchar(65)
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE (@OutputName IS NULL OR t.OutputName LIKE '%' + @OutputName + '%')
and t.OutputDeviceUid IN (SELECT t.OutputDeviceUid FROM GCS.OutputDeviceEntityMap WHERE EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ByName] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ByNameAndComments]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ByNameAndComments]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ByNameAndComments]
@OutputName nvarchar(65)
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE (@OutputName IS NULL OR t.OutputName LIKE '%' + @OutputName + '%' or t.Location LIKE '%' + @OutputName + '%' or t.CriticalityComment LIKE '%' + @OutputName + '%' or t.ServiceComment LIKE '%' + @OutputName + '%' or t.Comment LIKE '%' + @OutputName + '%')
and t.OutputDeviceUid IN (SELECT t.OutputDeviceUid FROM GCS.OutputDeviceEntityMap WHERE EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ByNameAndComments] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ByRegionUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ByRegionUid]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ByRegionUid]
@RegionUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE t.SiteUid IN (SELECT SiteUid FROM GCS.Site WHERE RegionUid = @RegionUid)
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ByRegionUid] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_BySiteUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_BySiteUid]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_BySiteUid]
@SiteUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE t.SiteUid = @SiteUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_BySiteUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.OutputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
OutputDeviceUid
,OutputName
,IsActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_SelectListBox] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ListBoxByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ListBoxByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ListBoxByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null 
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
od.EntityId
,od.OutputDeviceUid
,od.OutputName
,od.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice od
JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = od.OutputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE 
c.ClusterUid  = @ClusterUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN od.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN od.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN od.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN od.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ListBoxByClusterUid] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ListBoxByGalaxyPanelAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ListBoxByGalaxyPanelAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ListBoxByGalaxyPanelAddress]
@ClusterGroupId int,
@ClusterNumber int,
@PanelNumber int,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null 
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
od.EntityId
,od.OutputDeviceUid
,od.OutputName
,od.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice od
JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = od.OutputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE 
c.ClusterGroupId = @ClusterGroupId AND
c.ClusterNumber = @ClusterNumber AND
p.PanelNumber = @PanelNumber
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN od.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN od.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN od.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN od.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ListBoxByGalaxyPanelAddress] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ListBoxByGalaxyPanelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ListBoxByGalaxyPanelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ListBoxByGalaxyPanelUid]
@GalaxyPanelUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null 
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
od.EntityId
,od.OutputDeviceUid
,od.OutputName
,od.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice od
JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = od.OutputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE 
p.GalaxyPanelUid  = @GalaxyPanelUid
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN od.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN od.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN od.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN od.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ListBoxByGalaxyPanelUid] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ListBoxByName]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ListBoxByName]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ListBoxByName]
@OutputName nvarchar(65)
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
od.EntityId
,od.OutputDeviceUid
,od.OutputName
,od.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice od
JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = od.OutputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE (@OutputName IS NULL OR od.OutputName LIKE '%' + @OutputName + '%')
and od.OutputDeviceUid IN (SELECT od.OutputDeviceUid FROM GCS.OutputDeviceEntityMap WHERE EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN od.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN od.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN od.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN od.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ListBoxByName] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ListBoxByNameAndComments]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ListBoxByNameAndComments]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ListBoxByNameAndComments]
@OutputName nvarchar(65)
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT 
od.EntityId
,od.OutputDeviceUid
,od.OutputName
,od.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice od
JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = od.OutputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE (@OutputName IS NULL OR od.OutputName LIKE '%' + @OutputName + '%' or od.Location LIKE '%' + @OutputName + '%' or od.CriticalityComment LIKE '%' + @OutputName + '%' or od.ServiceComment LIKE '%' + @OutputName + '%' or od.Comment LIKE '%' + @OutputName + '%')
and od.OutputDeviceUid IN (SELECT od.OutputDeviceUid FROM GCS.OutputDeviceEntityMap WHERE EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN od.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN od.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN od.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN od.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ListBoxByNameAndComments] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ListBoxByPrimaryKey]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ListBoxByPrimaryKey]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_ListBoxByPrimaryKey]
@OutputDeviceUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

SELECT 
od.EntityId
,od.OutputDeviceUid
,od.OutputName
,od.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice od
JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = od.OutputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE 
od.OutputDeviceUid = @OutputDeviceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ListBoxByPrimaryKey] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_SelectByPK]
@OutputDeviceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE
t.OutputDeviceUid = @OutputDeviceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_SelectByPK] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_SelectSearch]
@OutputName nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@IsNodeActive bit = null
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

if @PageSize = 0
	set @PageSize = 1

SELECT
t.OutputDeviceUid
,t.EntityId
,t.SiteUid
,t.BinaryResourceUid
,t.OutputName
,t.Location
,t.ServiceComment
,t.CriticalityComment
,t.Comment
,t.IsTemplate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,s.SiteName
,r.RegionName
,r.RegionUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = t.OutputDeviceUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE 
(@OutputName IS NULL OR OutputName LIKE @OutputName + '%')
AND n.IsNodeActive = CASE
    WHEN @IsNodeActive is not null THEN @IsNodeActive 
    ELSE n.IsNodeActive 
    END
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.OutputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_Insert]
@OutputDeviceUid uniqueidentifier 
,@BinaryResourceUid uniqueidentifier  = null
,@EntityId uniqueidentifier 
,@SiteUid uniqueidentifier 
,@OutputName nvarchar(65) 
,@Location nvarchar(255)  = null
,@ServiceComment nvarchar(255)  = null
,@CriticalityComment nvarchar(255)  = null
,@Comment nvarchar(255)  = null
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @OutputDeviceUid = '00000000-0000-0000-0000-000000000000'
	SET @OutputDeviceUid = NULL
if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @BinaryResourceUid = NULL

if @OutputDeviceUid = '00000000-0000-0000-0000-000000000000' OR @OutputDeviceUid IS NULL
	SET @OutputDeviceUid = NewID()

INSERT INTO GCS.OutputDevice
(
OutputDeviceUid
,BinaryResourceUid
,EntityId
,SiteUid
,OutputName
,Location
,ServiceComment
,CriticalityComment
,Comment
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@OutputDeviceUid
,@BinaryResourceUid
,@EntityId
,@SiteUid
,@OutputName
,@Location
,@ServiceComment
,@CriticalityComment
,@Comment
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.OutputDevice table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_Update]
@OutputDeviceUid uniqueidentifier 
,@BinaryResourceUid uniqueidentifier
,@EntityId uniqueidentifier
,@SiteUid uniqueidentifier
,@OutputName nvarchar(65)
,@Location nvarchar(255)
,@ServiceComment nvarchar(255)
,@CriticalityComment nvarchar(255)
,@Comment nvarchar(255)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @BinaryResourceUid = NULL

UPDATE GCS.OutputDevice
SET 
BinaryResourceUid = @BinaryResourceUid
,EntityId = @EntityId
,SiteUid = @SiteUid
,OutputName = @OutputName
,Location = @Location
,ServiceComment = @ServiceComment
,CriticalityComment = @CriticalityComment
,Comment = @Comment
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
OutputDeviceUid = @OutputDeviceUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.OutputDevice table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_UpdateConcurrency]
@OutputDeviceUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.OutputDevice
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
OutputDeviceUid = @OutputDeviceUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.OutputDevice table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_DeleteByPK]
@OutputDeviceUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.OutputDevice
WHERE
OutputDeviceUid = @OutputDeviceUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[OutputDevicePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.OutputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.OutputDevice

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_RowCount] TO public
GO

/* All Stored Procedures for table: TimeSchedule */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.TimeSchedule table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.TimeSchedule

if @PageSize = 0
	set @PageSize = 1

SELECT 
TimeScheduleUid
,EntityId
,DisplayResourceKey
,DescriptionResourceKey
,InsertName
,Display
,InsertDate
,Description
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.TimeSchedule
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.TimeSchedule table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_ByAssaDsrUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_ByAssaDsrUid]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_ByAssaDsrUid]
@AssaDsrUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.TimeSchedule

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
TimeScheduleUid
,EntityId
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.TimeSchedule t
WHERE 
TimeScheduleUid in (SELECT TimeScheduleUid FROM GCS.AssaDsrTimeScheduleMap WHERE AssaDsrUid = @AssaDsrUid )
AND TimeScheduleUid <> '00000000-0000-0000-0000-000000000002'
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_ByAssaDsrUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.TimeSchedule table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.TimeSchedule

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
TimeScheduleUid
,EntityId
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.TimeSchedule t
WHERE 
EntityId = @EntityId
AND TimeScheduleUid <> '00000000-0000-0000-0000-000000000002'
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.TimeSchedule table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_ByGalaxyClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_ByGalaxyClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_ByGalaxyClusterUid]
@GalaxyClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.TimeSchedule

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
TimeScheduleUid
,t.EntityId
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.TimeSchedule t
JOIN GCS.Cluster c on c.ClusterUid = @GalaxyClusterUid
WHERE 
( TimeScheduleUid in (SELECT TimeScheduleUid FROM GCS.GalaxyClusterTimeScheduleMap WHERE ClusterUid = @GalaxyClusterUid) )
--AND TimeScheduleUid in (SELECT TimeScheduleUid FROM GCS.TimeScheduleEntityMap WHERE EntityId = c.EntityId) ) OR
OR t.EntityId = '00000000-0000-0000-0000-000000000001'
AND t.TimeScheduleUid <> '00000000-0000-0000-0000-000000000002'
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_ByGalaxyClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.TimeSchedule table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_ByMappedEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_ByMappedEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_ByMappedEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.TimeSchedule

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
TimeScheduleUid
,EntityId
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.TimeSchedule t
WHERE 
t.EntityId = @EntityId OR
t.TimeScheduleUid in (SELECT TimeScheduleUid FROM GCS.TimeScheduleEntityMap WHERE EntityId = @EntityId)
AND t.TimeScheduleUid <> '00000000-0000-0000-0000-000000000002'
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_ByMappedEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.TimeSchedule table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.TimeSchedule

if @PageSize = 0
	set @PageSize = 1

SELECT 
TimeScheduleUid
,Display
,COUNT(*) OVER() TotalRowCount
FROM GCS.TimeSchedule
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.TimeSchedule table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_SelectByPK]
@TimeScheduleUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
TimeScheduleUid
,EntityId
,DisplayResourceKey
,DescriptionResourceKey
,InsertName
,Display
,InsertDate
,Description
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.TimeSchedule
WHERE 
TimeScheduleUid = @TimeScheduleUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.TimeSchedule table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_SelectSearch]
@Display nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.TimeSchedule

if @PageSize = 0
	set @PageSize = 1

SELECT 
TimeScheduleUid
,EntityId
,DisplayResourceKey
,DescriptionResourceKey
,InsertName
,Display
,InsertDate
,Description
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.TimeSchedule
WHERE 
(@Display IS NULL OR Display LIKE @Display + '%')
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_SelectSearch] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_ScheduleInfoForGalaxyClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_ScheduleInfoForGalaxyClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_ScheduleInfoForGalaxyClusterUid]
@GalaxyClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
,@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.TimeSchedule

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
t.TimeScheduleUid
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,cmap.PanelScheduleNumber
,COUNT(*) OVER() TotalRowCount
FROM GCS.TimeSchedule t
JOIN GCS.GalaxyClusterTimeScheduleMap cmap on cmap.ClusterUid = @GalaxyClusterUid and cmap.TimeScheduleUid = t.TimeScheduleUid
WHERE ClusterUid = @GalaxyClusterUid 
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
		 (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'Number' AND @DescendingOrder = 0 THEN cmap.PanelScheduleNumber end) asc,
         (CASE WHEN @SortColumn = 'Number' AND @DescendingOrder = 1 THEN cmap.PanelScheduleNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_ScheduleInfoForGalaxyClusterUid] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.TimeSchedule table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_Insert]
@TimeScheduleUid uniqueidentifier 
,@EntityId uniqueidentifier 
,@DisplayResourceKey uniqueidentifier  = null
,@DescriptionResourceKey uniqueidentifier  = null
,@InsertName nvarchar(100) 
,@Display nvarchar(65) 
,@InsertDate datetimeoffset 
,@Description nvarchar(1000)  = null
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @TimeScheduleUid = '00000000-0000-0000-0000-000000000000'
	SET @TimeScheduleUid = NULL
if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

if @TimeScheduleUid = '00000000-0000-0000-0000-000000000000' OR @TimeScheduleUid IS NULL
	SET @TimeScheduleUid = NewID()

INSERT INTO GCS.TimeSchedule
(
TimeScheduleUid
,EntityId
,DisplayResourceKey
,DescriptionResourceKey
,InsertName
,Display
,InsertDate
,Description
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@TimeScheduleUid
,@EntityId
,@DisplayResourceKey
,@DescriptionResourceKey
,@InsertName
,@Display
,@InsertDate
,@Description
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.TimeSchedule table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_Update]
@TimeScheduleUid uniqueidentifier 
,@EntityId uniqueidentifier
,@DisplayResourceKey uniqueidentifier
,@DescriptionResourceKey uniqueidentifier
,@Display nvarchar(65)
,@Description nvarchar(1000)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

UPDATE GCS.TimeSchedule
SET 
TimeScheduleUid = @TimeScheduleUid
,EntityId = @EntityId
,DisplayResourceKey = @DisplayResourceKey
,DescriptionResourceKey = @DescriptionResourceKey
,Display = @Display
,Description = @Description
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
TimeScheduleUid = @TimeScheduleUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.TimeSchedule table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_UpdateConcurrency]
@TimeScheduleUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.TimeSchedule
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
TimeScheduleUid = @TimeScheduleUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.TimeSchedule table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_DeleteByPK]
@TimeScheduleUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.TimeSchedule
WHERE
TimeScheduleUid = @TimeScheduleUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[TimeSchedulePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.TimeSchedule table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[TimeSchedulePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[TimeSchedulePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[TimeSchedulePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.TimeSchedule

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[TimeSchedulePDSA_RowCount] TO public
GO




if dbo.fn_GCSDoesColumnExist('gcsAudit', 'UserId') = 0
BEGIN
	ALTER TABLE [GCS].[gcsAudit]
	ADD UserId uniqueidentifier  NULL
END
go  


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
ALTER PROCEDURE [GCS].[gcsAudit_Insert]
	@AuditId [uniqueidentifier],
	@TransactionId [uniqueidentifier],
	@TableName [nvarchar](128),
	@OperationType [nvarchar](10),
	@PrimaryKeyColumn [nvarchar](128),
	@PrimaryKeyValue [uniqueidentifier],
	@RecordTag [nvarchar](255),
	@AuditXml [xml] = null,
	@ColumnName [nvarchar](128) = null,
	@OriginalValue [nvarchar](max) = null,
	@NewValue [nvarchar](max) = null,
	@OriginalBinaryValue [varbinary](max) = null,
	@NewBinaryValue [varbinary](max) = null,
	@InsertName [nvarchar](100),
	@InsertDate [datetimeoffset],
	@UserId [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @AuditId = '00000000-0000-0000-0000-000000000000'
	SET @AuditId = NULL

if @AuditId = '00000000-0000-0000-0000-000000000000' OR @AuditId IS NULL
	SET @AuditId = NewID()

INSERT INTO [GalaxySMS-AuditActivity].[GCS].gcsAudit
(
AuditId
,TransactionId
,TableName
,OperationType
,PrimaryKeyColumn
,PrimaryKeyValue
,RecordTag
,AuditXml
,ColumnName
,OriginalValue
,NewValue
,OriginalBinaryValue
,NewBinaryValue
,InsertName
,InsertDate
,UserId
) 
VALUES 
(
@AuditId
,@TransactionId
,@TableName
,@OperationType
,@PrimaryKeyColumn
,@PrimaryKeyValue
,@RecordTag
,@AuditXml
,@ColumnName
,@OriginalValue
,@NewValue
,@OriginalBinaryValue
,@NewBinaryValue
,@InsertName
,@InsertDate
,@UserId
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
go


/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsEntityApplication table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_ByApplicationAndEntity]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_ByApplicationAndEntity]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_SelectByEntityApplicationAndRole]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_SelectByEntityApplicationAndRole]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_SelectByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_SelectByRoleId]
GO



CREATE OR ALTER FUNCTION [GCS].[fn_GCSDoesUserHaveAccessPortalFilters] (	
	@UserId [uniqueidentifier],
	@EntityId [uniqueidentifier])
	returns int
AS
BEGIN
declare @Result int
declare @entId uniqueidentifier
declare @parentEntityId uniqueidentifier
declare @isAdministrator bit
declare @isAdministratorRole bit
declare @inheritParentRoles bit
declare @includeAllAccessPortals bit

	select @entId = EntityId, @parentEntityId = ParentEntityId, @isAdministrator = IsAdministrator, @isAdministratorRole = IsAdministratorRole, @inheritParentRoles = InheritParentRoles, @includeAllAccessPortals = IncludeAllAccessPortals from GCS.UserEntityRoleView where UserId = @UserId AND EntityId = @entityId
	
	if @isAdministrator = 1 OR @isAdministratorRole = 1 OR @includeAllAccessPortals = 1
	BEGIN
		return 0
	END

	while @inheritParentRoles = 1 AND @parentEntityId IS NOT NULL
	begin
		if [GCS].[fn_GCSDoesUserHaveAccessPortalFilters](@UserId, @parentEntityId) = 0
		BEGIN
			return 0
		END
	end
	return 1
END
GO
ALTER AUTHORIZATION ON [GCS].[fn_GCSDoesUserHaveAccessPortalFilters] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[fn_GCSDoesUserHaveAccessPortalFilters] TO [public] AS [dbo]
GO


IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'fnAccessPortalUids_SelectForUserId'
                    AND Routine_Type = 'FUNCTION' ) 
DROP FUNCTION [GCS].[fnAccessPortalUids_SelectForUserId]
go

--CREATE OR ALTER FUNCTION [GCS].[fnAccessPortalUids_SelectForUserId] (@UserId uniqueidentifier) 
--RETURNS @accessPortalUids TABLE (AccessPortalUid uniqueidentifier not null)
--as
--BEGIN
--	insert into @accessPortalUids select distinct(ap.AccessPortalUid) 
--	from GCS.gcsUser u
--	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
--	join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
--	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
--	join gcs.gcsRole r on r.roleid = uer.RoleId
--	join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
--	join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
--	--left outer 
--	join GCS.RoleAccessPortal roleAccessPortal on roleAccessPortal.RoleId = r.RoleId
--	--left outer 
--	join GCS.AccessPortal ap on ap.AccessPortalUid = roleAccessPortal.AccessPortalUid
--	where u.UserId = @UserId
--	return
--END
--GO
CREATE OR ALTER FUNCTION [GCS].[fnAccessPortalUids_SelectForUserId] (@UserId uniqueidentifier) 
RETURNS @accessPortalUids TABLE (AccessPortalUid uniqueidentifier not null)
as
BEGIN
declare @entityId uniqueidentifier
	-- Start by getting all userentities for the user
	declare ueCursor CURSOR LOCAL FOR
		select EntityId from GCS.gcsUserEntity WHERE UserId = @UserId
    OPEN ueCursor
    FETCH NEXT FROM ueCursor INTO @entityId
    WHILE @@FETCH_STATUS = 0
    BEGIN
		
		IF [GCS].[fn_GCSDoesUserHaveAccessPortalFilters] (@UserId, @entityId) = 1
		BEGIN -- IF THE USER HAS FILTERS FOR THE ENTITY, THEN USE THIS SQL
			insert into @accessPortalUids select distinct(ap.AccessPortalUid) 
			from GCS.gcsUser u
			join gcs.gcsUserEntity ue on ue.UserId = u.UserId
			join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
			join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
			join gcs.gcsRole r on r.roleid = uer.RoleId
			join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
			join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
			--left outer 
			join GCS.RoleAccessPortal roleAccessPortal on roleAccessPortal.RoleId = r.RoleId
			--left outer 
			join GCS.AccessPortal ap on ap.AccessPortalUid = roleAccessPortal.AccessPortalUid
			where u.UserId = @UserId
		END
		ELSE
		BEGIN
			-- IF THE USER DOES NOT HAVE FILTERS FOR THE ENTITY, THEN USE THIS SQL TO SELECT ALL ClusterUids for the entity
			INSERT INTO @accessPortalUids SELECT DISTINCT(AccessPortalUid) from GCS.AccessPortal where EntityId = @entityId
		END
	FETCH NEXT FROM ueCursor INTO @entityId
    END
    CLOSE ueCursor;
    DEALLOCATE ueCursor;

	return
END
GO

GRANT SELECT ON GCS.[fnAccessPortalUids_SelectForUserId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalUids_SelectForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalUids_SelectForUserId]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalUids_SelectForUserId]
@UserId uniqueidentifier
AS
BEGIN
	--select distinct(ap.AccessPortalUid) 
	--from GCS.gcsUser u
	--join gcs.gcsUserEntity ue on ue.UserId = u.UserId
	--join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	--join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	--join gcs.gcsRole r on r.roleid = uer.RoleId
	--join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
	--join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
	----left outer 
	--join GCS.RoleAccessPortal roleAccessPortal on roleAccessPortal.RoleId = r.RoleId
	----left outer 
	--join GCS.AccessPortal ap on ap.AccessPortalUid = roleAccessPortal.AccessPortalUid
	--where u.UserId = @UserId
	select * from GCS.fnAccessPortalUids_SelectForUserId(@UserId)
END
GO

GRANT EXECUTE ON GCS.[AccessPortalUids_SelectForUserId] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalFilters_SelectForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalFilters_SelectForUserId]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalFilters_SelectForUserId]
@UserId uniqueidentifier,
@AccessPortalUid uniqueidentifier
AS
BEGIN
	
	if @AccessPortalUid is null or @AccessPortalUid = '00000000-0000-0000-0000-000000000000'
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, ap.AccessPortalUid, ap.PortalName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleAccessPortal roleAccessPortal on roleAccessPortal.RoleId = r.RoleId
		--left outer 
		join GCS.AccessPortal ap on ap.AccessPortalUid = roleAccessPortal.AccessPortalUid
		where u.UserId = @UserId
		ORDER BY AccessPortalUid, PermissionId
	END
	ELSE
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, ap.AccessPortalUid, ap.PortalName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleAccessPortal roleAccessPortal on roleAccessPortal.RoleId = r.RoleId
		--left outer 
		join GCS.AccessPortal ap on ap.AccessPortalUid = roleAccessPortal.AccessPortalUid
		where u.UserId = @UserId AND ap.AccessPortalUid = @AccessPortalUid
		ORDER BY PermissionId
	END
END
GO

GRANT EXECUTE ON GCS.[AccessPortalFilters_SelectForUserId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortal_GetUserPermission]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortal_GetUserPermission]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortal_GetUserPermission]
@UserId uniqueidentifier,
@AccessPortalUid uniqueidentifier,
@PermissionId uniqueidentifier,
@EntityId uniqueidentifier
AS
BEGIN
	if GCS.fn_GCSDoesUserHavePermission(@UserId, @EntityId, @PermissionId) > 0
	BEGIN
		select u.DisplayName, entity.EntityName, null as RoleName, null as PermissionName, @AccessPortalUid as AccessPortalUid, null as PortalName, null as PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		where u.UserId = @UserId 
	END
	ELSE
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, ap.AccessPortalUid, ap.PortalName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleAccessPortal roleAccessPortal on roleAccessPortal.RoleId = r.RoleId
		--left outer 
		join GCS.AccessPortal ap on ap.AccessPortalUid = roleAccessPortal.AccessPortalUid
		where u.UserId = @UserId AND ap.AccessPortalUid = @AccessPortalUid AND perm.PermissionId = @PermissionId
	END
END
GO

GRANT EXECUTE ON GCS.[AccessPortal_GetUserPermission] TO public
GO


CREATE OR ALTER FUNCTION [GCS].[fn_GCSDoesUserHaveInputDeviceFilters] (	
	@UserId [uniqueidentifier],
	@EntityId [uniqueidentifier])
	returns int
AS
BEGIN
declare @Result int
declare @entId uniqueidentifier
declare @parentEntityId uniqueidentifier
declare @isAdministrator bit
declare @isAdministratorRole bit
declare @inheritParentRoles bit
declare @includeAllInputDevices bit

	select @entId = EntityId, @parentEntityId = ParentEntityId, @isAdministrator = IsAdministrator, @isAdministratorRole = IsAdministratorRole, @inheritParentRoles = InheritParentRoles, @includeAllInputDevices = IncludeAllInputDevices from GCS.UserEntityRoleView where UserId = @UserId AND EntityId = @entityId
	
	if @isAdministrator = 1 OR @isAdministratorRole = 1 OR @includeAllInputDevices = 1
	BEGIN
		return 0
	END

	while @inheritParentRoles = 1 AND @parentEntityId IS NOT NULL
	begin
		if [GCS].[fn_GCSDoesUserHaveInputDeviceFilters](@UserId, @parentEntityId) = 0
		BEGIN
			return 0
		END
	end
	return 1
END
GO
ALTER AUTHORIZATION ON [GCS].[fn_GCSDoesUserHaveInputDeviceFilters] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[fn_GCSDoesUserHaveInputDeviceFilters] TO [public] AS [dbo]
GO
--IF EXISTS ( SELECT  1
--            FROM    Information_schema.Routines
--            WHERE   Specific_schema = 'GCS'
--                    AND specific_name = 'fnInputDeviceUids_SelectForUserId'
--                    AND Routine_Type = 'FUNCTION' ) 
--DROP FUNCTION [GCS].[fnInputDeviceUids_SelectForUserId]
--go

--CREATE OR ALTER FUNCTION [GCS].[fnInputDeviceUids_SelectForUserId] (@UserId uniqueidentifier) 
--RETURNS @InputDeviceUids TABLE (InputDeviceUid uniqueidentifier not null)
--as
--BEGIN
--	insert into @InputDeviceUids select distinct(id.InputDeviceUid) 
--	from GCS.gcsUser u
--	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
--	join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
--	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
--	join gcs.gcsRole r on r.roleid = uer.RoleId
--	join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
--	join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
--	--left outer 
--	join GCS.RoleInputDevice roleInputDevice on roleInputDevice.RoleId = r.RoleId
--	--left outer 
--	join GCS.InputDevice id on id.InputDeviceUid = roleInputDevice.InputDeviceUid
--	where u.UserId = @UserId
--	return
--END
--GO

--GRANT SELECT ON GCS.[fnInputDeviceUids_SelectForUserId] TO public
--GO
CREATE OR ALTER FUNCTION [GCS].[fnInputDeviceUids_SelectForUserId] (@UserId uniqueidentifier) 
RETURNS @InputDeviceUids TABLE (InputDeviceUid uniqueidentifier not null)
as
BEGIN
declare @entityId uniqueidentifier
	-- Start by getting all userentities for the user
	declare ueCursor CURSOR LOCAL FOR
		select EntityId from GCS.gcsUserEntity WHERE UserId = @UserId
    OPEN ueCursor
    FETCH NEXT FROM ueCursor INTO @entityId
    WHILE @@FETCH_STATUS = 0
    BEGIN
		
		IF [GCS].[fn_GCSDoesUserHaveInputDeviceFilters] (@UserId, @entityId) = 1
		BEGIN -- IF THE USER HAS FILTERS FOR THE ENTITY, THEN USE THIS SQL
			insert into @InputDeviceUids select distinct(id.InputDeviceUid) 
			from GCS.gcsUser u
			join gcs.gcsUserEntity ue on ue.UserId = u.UserId
			join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
			join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
			join gcs.gcsRole r on r.roleid = uer.RoleId
			join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
			join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
			--left outer 
			join GCS.RoleInputDevice roleInputDevice on roleInputDevice.RoleId = r.RoleId
			--left outer 
			join GCS.InputDevice id on id.InputDeviceUid = roleInputDevice.InputDeviceUid
			where u.UserId = @UserId
		END
		ELSE
		BEGIN
			-- IF THE USER DOES NOT HAVE FILTERS FOR THE ENTITY, THEN USE THIS SQL TO SELECT ALL ClusterUids for the entity
			INSERT INTO @InputDeviceUids SELECT DISTINCT(InputDeviceUid) from GCS.InputDevice where EntityId = @entityId
		END
	FETCH NEXT FROM ueCursor INTO @entityId
    END
    CLOSE ueCursor;
    DEALLOCATE ueCursor;

	return
END
GO

GRANT SELECT ON GCS.[fnInputDeviceUids_SelectForUserId] TO public
GO

--IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceUids_SelectForUserId]') AND type in (N'P', N'PC'))
--DROP PROCEDURE GCS.[InputDeviceUids_SelectForUserId]
--GO
--CREATE OR ALTER PROCEDURE GCS.[InputDeviceUids_SelectForUserId]
--@UserId uniqueidentifier
--AS
--BEGIN
--	select distinct(id.InputDeviceUid) 
--	from GCS.gcsUser u
--	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
--	join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
--	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
--	join gcs.gcsRole r on r.roleid = uer.RoleId
--	join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
--	join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
--	--left outer 
--	join GCS.RoleInputDevice roleInputDevice on roleInputDevice.RoleId = r.RoleId
--	--left outer 
--	join GCS.InputDevice id on id.InputDeviceUid = roleInputDevice.InputDeviceUid
--	where u.UserId = @UserId
--END
--GO

--GRANT EXECUTE ON GCS.[InputDeviceUids_SelectForUserId] TO public
--GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceUids_SelectForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceUids_SelectForUserId]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceUids_SelectForUserId]
@UserId uniqueidentifier
AS
BEGIN
--	select distinct(id.InputDeviceUid) 
--	from GCS.gcsUser u
--	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
--	join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
--	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
--	join gcs.gcsRole r on r.roleid = uer.RoleId
--	join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
--	join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
--	--left outer 
--	join GCS.RoleInputDevice roleInputDevice on roleInputDevice.RoleId = r.RoleId
--	--left outer 
--	join GCS.InputDevice id on id.InputDeviceUid = roleInputDevice.InputDeviceUid
--	where u.UserId = @UserId
	select * from GCS.fnInputDeviceUids_SelectForUserId(@UserId)
END
GO

GRANT EXECUTE ON GCS.[InputDeviceUids_SelectForUserId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceFilters_SelectForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceFilters_SelectForUserId]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceFilters_SelectForUserId]
@UserId uniqueidentifier,
@InputDeviceUid uniqueidentifier
AS
BEGIN
	
	if @InputDeviceUid is null or @InputDeviceUid = '00000000-0000-0000-0000-000000000000'
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, id.InputDeviceUid, id.InputName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	    join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	    join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleInputDevice roleInputDevice on roleInputDevice.RoleId = r.RoleId
		--left outer 
		join GCS.InputDevice id on id.InputDeviceUid = roleInputDevice.InputDeviceUid
		where u.UserId = @UserId
		ORDER BY InputDeviceUid, PermissionId
	END
	ELSE
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, id.InputDeviceUid, id.InputName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	    join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	    join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleInputDevice roleInputDevice on roleInputDevice.RoleId = r.RoleId
		--left outer 
		join GCS.InputDevice id on id.InputDeviceUid = roleInputDevice.InputDeviceUid
		where u.UserId = @UserId AND id.InputDeviceUid = @InputDeviceUid
		ORDER BY PermissionId
	END
END
GO

GRANT EXECUTE ON GCS.[InputDeviceFilters_SelectForUserId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevice_GetUserPermission]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevice_GetUserPermission]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDevice_GetUserPermission]
@UserId uniqueidentifier,
@InputDeviceUid uniqueidentifier,
@PermissionId uniqueidentifier,
@EntityId uniqueidentifier
AS
BEGIN
	if GCS.fn_GCSDoesUserHavePermission(@UserId, @EntityId, @PermissionId) > 0
	BEGIN
		select u.DisplayName, entity.EntityName, null as RoleName, null as PermissionName, @InputDeviceUid as InputDeviceUid, null as InputName, null as PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		where u.UserId = @UserId 
	END
	ELSE
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, id.InputDeviceUid, id.InputName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleInputDevice roleInputDevice on roleInputDevice.RoleId = r.RoleId
		--left outer 
		join GCS.InputDevice id on id.InputDeviceUid = roleInputDevice.InputDeviceUid
		where u.UserId = @UserId AND id.InputDeviceUid = @InputDeviceUid AND perm.PermissionId = @PermissionId
	END
END
GO

GRANT EXECUTE ON GCS.[InputDevice_GetUserPermission] TO public
GO


CREATE OR ALTER FUNCTION [GCS].[fn_GCSDoesUserHaveOutputDeviceFilters] (	
	@UserId [uniqueidentifier],
	@EntityId [uniqueidentifier])
	returns int
AS
BEGIN
declare @Result int
declare @entId uniqueidentifier
declare @parentEntityId uniqueidentifier
declare @isAdministrator bit
declare @isAdministratorRole bit
declare @inheritParentRoles bit
declare @includeAllOutputDevices bit

	select @entId = EntityId, @parentEntityId = ParentEntityId, @isAdministrator = IsAdministrator, @isAdministratorRole = IsAdministratorRole, @inheritParentRoles = InheritParentRoles, @includeAllOutputDevices = IncludeAllOutputDevices from GCS.UserEntityRoleView where UserId = @UserId AND EntityId = @entityId
	
	if @isAdministrator = 1 OR @isAdministratorRole = 1 OR @includeAllOutputDevices = 1
	BEGIN
		return 0
	END

	while @inheritParentRoles = 1 AND @parentEntityId IS NOT NULL
	begin
		if [GCS].[fn_GCSDoesUserHaveOutputDeviceFilters](@UserId, @parentEntityId) = 0
		BEGIN
			return 0
		END
	end
	return 1
END
GO
ALTER AUTHORIZATION ON [GCS].[fn_GCSDoesUserHaveOutputDeviceFilters] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[fn_GCSDoesUserHaveOutputDeviceFilters] TO [public] AS [dbo]
GO


IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'fnOutputDeviceUids_SelectForUserId'
                    AND Routine_Type = 'FUNCTION' ) 
DROP FUNCTION [GCS].[fnOutputDeviceUids_SelectForUserId]
go

CREATE OR ALTER FUNCTION [GCS].[fnOutputDeviceUids_SelectForUserId] (@UserId uniqueidentifier) 
RETURNS @OutputDeviceUids TABLE (OutputDeviceUid uniqueidentifier not null)
as
BEGIN
	--insert into @OutputDeviceUids select distinct(od.OutputDeviceUid) 
	--from GCS.gcsUser u
	--join gcs.gcsUserEntity ue on ue.UserId = u.UserId
	--join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	--join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	--join gcs.gcsRole r on r.roleid = uer.RoleId
	--join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
	--join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
	----left outer 
	--join GCS.RoleOutputDevice roleOutputDevice on roleOutputDevice.RoleId = r.RoleId
	----left outer 
	--join GCS.OutputDevice od on od.OutputDeviceUid = roleOutputDevice.OutputDeviceUid
	--where u.UserId = @UserId
	--return

declare @entityId uniqueidentifier
	-- Start by getting all userentities for the user
	declare ueCursor CURSOR LOCAL FOR
		select EntityId from GCS.gcsUserEntity WHERE UserId = @UserId
    OPEN ueCursor
    FETCH NEXT FROM ueCursor INTO @entityId
    WHILE @@FETCH_STATUS = 0
    BEGIN
		
		IF [GCS].[fn_GCSDoesUserHaveInputDeviceFilters] (@UserId, @entityId) = 1
		BEGIN -- IF THE USER HAS FILTERS FOR THE ENTITY, THEN USE THIS SQL
			insert into @OutputDeviceUids select distinct(od.OutputDeviceUid) 
			from GCS.gcsUser u
			join gcs.gcsUserEntity ue on ue.UserId = u.UserId
			join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
			join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
			join gcs.gcsRole r on r.roleid = uer.RoleId
			join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
			join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
			--left outer 
			join GCS.RoleOutputDevice roleOutputDevice on roleOutputDevice.RoleId = r.RoleId
			--left outer 
			join GCS.OutputDevice od on od.OutputDeviceUid = roleOutputDevice.OutputDeviceUid
			where u.UserId = @UserId
		END
		ELSE
		BEGIN
			-- IF THE USER DOES NOT HAVE FILTERS FOR THE ENTITY, THEN USE THIS SQL TO SELECT ALL ClusterUids for the entity
			INSERT INTO @OutputDeviceUids SELECT DISTINCT(OutputDeviceUid) from GCS.OutputDevice where EntityId = @entityId
		END
	FETCH NEXT FROM ueCursor INTO @entityId
    END
    CLOSE ueCursor;
    DEALLOCATE ueCursor;

	return
END
GO

GRANT SELECT ON GCS.[fnOutputDeviceUids_SelectForUserId] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDeviceUids_SelectForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDeviceUids_SelectForUserId]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDeviceUids_SelectForUserId]
@UserId uniqueidentifier
AS
BEGIN
	--select distinct(od.OutputDeviceUid) 
	--from GCS.gcsUser u
	--join gcs.gcsUserEntity ue on ue.UserId = u.UserId
	--join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	--join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	--join gcs.gcsRole r on r.roleid = uer.RoleId
	--join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
	--join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
	----left outer 
	--join GCS.RoleOutputDevice roleOutputDevice on roleOutputDevice.RoleId = r.RoleId
	----left outer 
	--join GCS.OutputDevice od on od.OutputDeviceUid = roleOutputDevice.OutputDeviceUid
	--where u.UserId = @UserId
	select * from GCS.fnOutputDeviceUids_SelectForUserId(@UserId)

END
GO

GRANT EXECUTE ON GCS.[OutputDeviceUids_SelectForUserId] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDeviceFilters_SelectForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDeviceFilters_SelectForUserId]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDeviceFilters_SelectForUserId]
@UserId uniqueidentifier,
@OutputDeviceUid uniqueidentifier
AS
BEGIN
	
	if @OutputDeviceUid is null or @OutputDeviceUid = '00000000-0000-0000-0000-000000000000'
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, od.OutputDeviceUid, od.OutputName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	    join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	    join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleOutputDevice roleOutputDevice on roleOutputDevice.RoleId = r.RoleId
		--left outer 
		join GCS.OutputDevice od on od.OutputDeviceUid = roleOutputDevice.OutputDeviceUid
		where u.UserId = @UserId
		ORDER BY OutputDeviceUid, PermissionId
	END
	ELSE
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, od.OutputDeviceUid, od.OutputName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	    join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	    join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleOutputDevice roleOutputDevice on roleOutputDevice.RoleId = r.RoleId
		--left outer 
		join GCS.OutputDevice od on od.OutputDeviceUid = roleOutputDevice.OutputDeviceUid
		where u.UserId = @UserId AND od.OutputDeviceUid = @OutputDeviceUid
		ORDER BY PermissionId
	END
END
GO

GRANT EXECUTE ON GCS.[OutputDeviceFilters_SelectForUserId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevice_GetUserPermission]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevice_GetUserPermission]
GO
CREATE OR ALTER PROCEDURE GCS.[OutputDevice_GetUserPermission]
@UserId uniqueidentifier,
@OutputDeviceUid uniqueidentifier,
@PermissionId uniqueidentifier,
@EntityId uniqueidentifier
AS
BEGIN
	if GCS.fn_GCSDoesUserHavePermission(@UserId, @EntityId, @PermissionId) > 0
	BEGIN
		select u.DisplayName, entity.EntityName, null as RoleName, null as PermissionName, @OutputDeviceUid as OutputDeviceUid, null as OutputName, null as PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		where u.UserId = @UserId 
	END
	ELSE
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, od.OutputDeviceUid, od.OutputName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleOutputDevice roleOutputDevice on roleOutputDevice.RoleId = r.RoleId
		--left outer 
		join GCS.OutputDevice od on od.OutputDeviceUid = roleOutputDevice.OutputDeviceUid
		where u.UserId = @UserId AND od.OutputDeviceUid = @OutputDeviceUid AND perm.PermissionId = @PermissionId
	END
END
GO

GRANT EXECUTE ON GCS.[OutputDevice_GetUserPermission] TO public
GO


IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'fnInputOutputGroupUids_SelectForUserId'
                    AND Routine_Type = 'FUNCTION' ) 
DROP FUNCTION [GCS].[fnInputOutputGroupUids_SelectForUserId]
go

CREATE OR ALTER FUNCTION [GCS].[fnInputOutputGroupUids_SelectForUserId] (@UserId uniqueidentifier) 
RETURNS @InputOutputGroupUids TABLE (InputOutputGroupUid uniqueidentifier not null)
as
BEGIN
	insert into @InputOutputGroupUids select distinct(iog.InputOutputGroupUid) 
	from GCS.gcsUser u
	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
	join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	join gcs.gcsRole r on r.roleid = uer.RoleId
	join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
	join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
	--left outer 
	join GCS.RoleInputOutputGroup roleInputOutputGroup on roleInputOutputGroup.RoleId = r.RoleId
	--left outer 
	join GCS.InputOutputGroup iog on iog.InputOutputGroupUid = roleInputOutputGroup.InputOutputGroupUid
	where u.UserId = @UserId
	return
END
GO

GRANT SELECT ON GCS.[fnInputOutputGroupUids_SelectForUserId] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupUids_SelectForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupUids_SelectForUserId]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupUids_SelectForUserId]
@UserId uniqueidentifier
AS
BEGIN
	select distinct(iog.InputOutputGroupUid) 
	from GCS.gcsUser u
	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
	join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	join gcs.gcsRole r on r.roleid = uer.RoleId
	join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
	join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
	--left outer 
	join GCS.RoleInputOutputGroup roleInputOutputGroup on roleInputOutputGroup.RoleId = r.RoleId
	--left outer 
	join GCS.InputOutputGroup iog on iog.InputOutputGroupUid = roleInputOutputGroup.InputOutputGroupUid
	where u.UserId = @UserId
END
GO

GRANT EXECUTE ON GCS.[InputOutputGroupUids_SelectForUserId] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupFilters_SelectForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupFilters_SelectForUserId]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupFilters_SelectForUserId]
@UserId uniqueidentifier,
@InputOutputGroupUid uniqueidentifier
AS
BEGIN
	
	if @InputOutputGroupUid is null or @InputOutputGroupUid = '00000000-0000-0000-0000-000000000000'
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, iog.InputOutputGroupUid, iog.Display, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	    join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	    join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleInputOutputGroup roleInputOutputGroup on roleInputOutputGroup.RoleId = r.RoleId
		--left outer 
		join GCS.InputOutputGroup iog on iog.InputOutputGroupUid = roleInputOutputGroup.InputOutputGroupUid
		where u.UserId = @UserId
		ORDER BY InputOutputGroupUid, PermissionId
	END
	ELSE
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, iog.InputOutputGroupUid, iog.Display, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	    join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	    join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleInputOutputGroup roleInputOutputGroup on roleInputOutputGroup.RoleId = r.RoleId
		--left outer 
		join GCS.InputOutputGroup iog on iog.InputOutputGroupUid = roleInputOutputGroup.InputOutputGroupUid
		where u.UserId = @UserId AND iog.InputOutputGroupUid = @InputOutputGroupUid
		ORDER BY PermissionId
	END
END
GO

GRANT EXECUTE ON GCS.[InputOutputGroupFilters_SelectForUserId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroup_GetUserPermission]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroup_GetUserPermission]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroup_GetUserPermission]
@UserId uniqueidentifier,
@InputOutputGroupUid uniqueidentifier,
@PermissionId uniqueidentifier,
@EntityId uniqueidentifier
AS
BEGIN
	if GCS.fn_GCSDoesUserHavePermission(@UserId, @EntityId, @PermissionId) > 0
	BEGIN
		select u.DisplayName, entity.EntityName, null as RoleName, null as PermissionName, @InputOutputGroupUid as InputOutputGroupUid, null as Display, null as PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		where u.UserId = @UserId 
	END
	ELSE
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, iog.InputOutputGroupUid, iog.Display, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleInputOutputGroup roleInputOutputGroup on roleInputOutputGroup.RoleId = r.RoleId
		--left outer 
		join GCS.InputOutputGroup iog on iog.InputOutputGroupUid = roleInputOutputGroup.InputOutputGroupUid
		where u.UserId = @UserId AND iog.InputOutputGroupUid = @InputOutputGroupUid AND perm.PermissionId = @PermissionId
	END
END
GO

GRANT EXECUTE ON GCS.[InputOutputGroup_GetUserPermission] TO public
GO


if dbo.fn_GCSDoesColumnExist('gcsRole', 'EntityId') = 0
BEGIN
	alter table GCS.gcsRole
	add EntityId uniqueidentifier null
END
go  


update GCS.gcsRole set EntityId = '00000000-0000-0000-0000-000000000002' where EntityId is null
go

alter table GCS.gcsRole
alter column EntityId uniqueidentifier not null

if dbo.[fn_GCSDoesIndexExist]('gcsRole', 'idxRoleName') = 1
BEGIN
	create unique nonclustered index idxRoleName on GCS.gcsRole (EntityId ASC, RoleName ASC)
END
GO



if dbo.fn_GCSDoesTableExist('RoleFilters') = 0
BEGIN
	/*==============================================================*/
	/* Table: RoleFilters                                           */
	/*==============================================================*/
	create table GCS.RoleFilters (
	   RoleId               GCS.UniversalUniqueId    RowGuidCol not null,
	   IncludeAllRegions    bit                  not null,
	   IncludeAllSites      bit                  not null,
	   IncludeAllClusters   bit                  not null,
	   IncludeAllAccessPortals bit               not null,
	   IncludeAllInputOutputGroups bit           not null,
	   IncludeAllInputDevices bit                not null,
	   IncludeAllOutputDevices bit               not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1
	)

	alter table GCS.RoleFilters
	   add constraint PK_ROLEFILTERS primary key (RoleId)

	alter table GCS.RoleFilters
	   add constraint FK_RoleFiltersRole foreign key (RoleId)
		  references GCS.gcsRole (RoleId)
			 on update cascade on delete cascade
end
go


if dbo.fn_GCSDoesColumnExist('RoleFilters', 'IncludeAllAccessPortals') = 0
BEGIN
	ALTER TABLE [GCS].[RoleFilters] ADD [IncludeAllAccessPortals] bit null
END
go  
	
UPDATE GCS.RoleFilters SET IncludeAllAccessPortals = 1 WHERE IncludeAllAccessPortals IS NULL
go

ALTER TABLE [GCS].[RoleFilters] ALTER COLUMN [IncludeAllAccessPortals] bit not null
go


if dbo.fn_GCSDoesColumnExist('RoleFilters', 'IncludeAllInputOutputGroups') = 0
BEGIN
	ALTER TABLE [GCS].[RoleFilters]
	ADD [IncludeAllInputOutputGroups] bit null
END
go  

UPDATE GCS.RoleFilters SET IncludeAllInputOutputGroups = 1 WHERE IncludeAllInputOutputGroups IS NULL
go

ALTER TABLE [GCS].[RoleFilters] ALTER COLUMN [IncludeAllInputOutputGroups] bit not null
go




if dbo.fn_GCSDoesColumnExist('RoleFilters', 'IncludeAllInputDevices') = 0
BEGIN
	ALTER TABLE [GCS].[RoleFilters]
	ADD [IncludeAllInputDevices] bit null
END
go  

UPDATE GCS.RoleFilters SET IncludeAllInputDevices = 1 WHERE IncludeAllInputDevices IS NULL
go

ALTER TABLE [GCS].[RoleFilters] ALTER COLUMN [IncludeAllInputDevices] bit not null
go


if dbo.fn_GCSDoesColumnExist('RoleFilters', 'IncludeAllOutputDevices') = 0
BEGIN
	ALTER TABLE [GCS].[RoleFilters]
	ADD [IncludeAllOutputDevices] bit null
END
go  

UPDATE GCS.RoleFilters SET IncludeAllOutputDevices = 1 WHERE IncludeAllOutputDevices IS NULL
go

ALTER TABLE [GCS].[RoleFilters] ALTER COLUMN [IncludeAllOutputDevices] bit not null
go


if dbo.fn_GCSDoesColumnExist('RoleCluster', 'IncludeAllAccessPortals') = 0
BEGIN
	ALTER TABLE [GCS].[RoleCluster]
	ADD [IncludeAllAccessPortals] bit null
END
go  


UPDATE GCS.RoleCluster SET IncludeAllAccessPortals = 1 WHERE IncludeAllAccessPortals IS NULL
go

ALTER TABLE [GCS].[RoleCluster] ALTER COLUMN [IncludeAllAccessPortals] bit not null
go


if dbo.fn_GCSDoesColumnExist('RoleCluster', 'IncludeAllInputOutputGroups') = 0
BEGIN
	ALTER TABLE [GCS].[RoleCluster]
	ADD [IncludeAllInputOutputGroups] bit null
END
go  


UPDATE GCS.RoleCluster SET IncludeAllInputOutputGroups = 1 WHERE IncludeAllInputOutputGroups IS NULL
go

ALTER TABLE [GCS].[RoleCluster] ALTER COLUMN [IncludeAllInputOutputGroups] bit not null
go




if dbo.fn_GCSDoesColumnExist('RoleCluster', 'IncludeAllInputDevices') = 0
BEGIN
	ALTER TABLE [GCS].[RoleCluster]
	ADD [IncludeAllInputDevices] bit null
END
go  


UPDATE GCS.RoleCluster SET IncludeAllInputDevices = 1 WHERE IncludeAllInputDevices IS NULL
go

ALTER TABLE [GCS].[RoleCluster] ALTER COLUMN [IncludeAllInputDevices] bit not null
go


if dbo.fn_GCSDoesColumnExist('RoleCluster', 'IncludeAllOutputDevices') = 0
BEGIN
	ALTER TABLE [GCS].[RoleCluster]
	ADD [IncludeAllOutputDevices] bit null
END
go  

UPDATE GCS.RoleCluster SET IncludeAllOutputDevices = 1 WHERE IncludeAllOutputDevices IS NULL
go

ALTER TABLE [GCS].[RoleCluster] ALTER COLUMN [IncludeAllOutputDevices] bit not null
go


if dbo.fn_GCSDoesTableExist('RoleRegion') = 0
BEGIN
/*==============================================================*/
/* Table: RoleRegion                                            */
/*==============================================================*/
	create table GCS.RoleRegion (
	   RoleRegionUid        GCS.UniversalUniqueId    RowGuidCol not null,
	   RoleId               uniqueidentifier     not null,
	   RegionUid            uniqueidentifier     not null,
	   IncludeAllSites      bit                  not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1
	)

	alter table GCS.RoleRegion
	   add constraint PK_ROLEREGION primary key (RoleRegionUid)

	/*==============================================================*/
	/* Index: idxRoleRegion                                         */
	/*==============================================================*/
	create unique nonclustered index idxRoleRegion on GCS.RoleRegion (RoleId ASC,
	  RegionUid ASC)

	alter table GCS.RoleRegion
	   add constraint FK_RoleRegionRegion foreign key (RegionUid)
		  references GCS.Region (RegionUid)
			 on update cascade on delete cascade

	alter table GCS.RoleRegion
	   add constraint FK_RoleRegionRole foreign key (RoleId)
		  references GCS.gcsRole (RoleId)
			 on update cascade on delete cascade
end
go


if dbo.fn_GCSDoesTableExist('RoleSite') = 0
BEGIN
/*==============================================================*/
/* Table: RoleSite                                              */
/*==============================================================*/
	create table GCS.RoleSite (
	   RoleSiteUid          GCS.UniversalUniqueId    RowGuidCol not null,
	   RoleId               uniqueidentifier     not null,
	   SiteUid              uniqueidentifier     not null,
	   IncludeAllClusters   bit                  not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1
	)

	alter table GCS.RoleSite
	   add constraint PK_ROLESITE primary key (RoleSiteUid)

	/*==============================================================*/
	/* Index: idxRoleSite                                           */
	/*==============================================================*/
	create unique nonclustered index idxRoleSite on GCS.RoleSite (RoleId ASC,
	  SiteUid ASC)

	alter table GCS.RoleSite
	   add constraint FK_RoleSiteRole foreign key (RoleId)
		  references GCS.gcsRole (RoleId)
			 on update cascade on delete cascade

	alter table GCS.RoleSite
	   add constraint FK_RoleSiteSite foreign key (SiteUid)
		  references GCS.Site (SiteUid)
			 on update cascade on delete cascade
end
go

-- Insert any missing RoleFilter items
BEGIN
	DECLARE @RoleId uniqueidentifier;
	DECLARE @RoleRegionUid uniqueidentifier;
	DECLARE @RoleSiteUid uniqueidentifier;
	DECLARE @RoleClusterUid uniqueidentifier;
	DECLARE @EntityId uniqueidentifier;
	DECLARE @RegionUid uniqueidentifier;
	DECLARE @SiteUid uniqueidentifier;
	DECLARE @ClusterUid uniqueidentifier;
	DECLARE @EntityName nvarchar(100)
	DECLARE @RoleName nvarchar(100)

    DECLARE RolesCursor CURSOR FOR 
		SELECT RoleId FROM GCS.gcsRole WHERE RoleId NOT IN (SELECT RoleId FROM GCS.RoleFilters);

    OPEN RolesCursor
    FETCH NEXT FROM RolesCursor INTO @RoleId
    WHILE @@FETCH_STATUS = 0
    BEGIN
		PRINT N'Inserting GCS.RoleFilter for RoleId: ' + cast(@RoleId as nvarchar(100))
		INSERT INTO GCS.RoleFilters (RoleId, IncludeAllRegions, IncludeAllSites, IncludeAllClusters, IncludeAllAccessPortals, IncludeAllInputDevices, IncludeAllOutputDevices, IncludeAllInputOutputGroups, InsertName, InsertDate, UpdateName, UpdateDate, ConcurrencyValue)
		values( @RoleId, 1, 1, 1, 1, 1, 1, 1, SUSER_NAME(), SYSDATETIMEOFFSET(), SUSER_NAME(), SYSDATETIMEOFFSET(), 0)
    FETCH NEXT FROM RolesCursor INTO @RoleId
    END
    CLOSE RolesCursor;
    DEALLOCATE RolesCursor;

	-- Insert missing RoleRegion rows for any RowFilters that have IncludeAllRegions set
    DECLARE RoleFiltersRegionCursor CURSOR FOR 
		SELECT rf.RoleId, r.EntityId, rgn.RegionUid, r.RoleName, e.EntityName, rr.RoleRegionUid
		FROM GCS.RoleFilters rf JOIN
		GCS.gcsRole r ON r.RoleId = rf.RoleId
		JOIN GCS.gcsEntity e on e.EntityId = r.EntityId
		left outer JOIN GCS.Region rgn on rgn.EntityId = r.EntityId
		LEFT OUTER JOIN GCS.RoleRegion rr on rr.RoleId = r.RoleId AND rr.RegionUid = rgn.RegionUid
		WHERE rf.IncludeAllRegions = 1
		AND rgn.RegionUid is not null and rr.RoleRegionUid is null

    OPEN RoleFiltersRegionCursor
    FETCH NEXT FROM RoleFiltersRegionCursor INTO @RoleId, @EntityId, @RegionUid, @RoleName, @EntityName, @RoleRegionUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		PRINT N'Inserting GCS.RoleRegion for RoleId: ' + cast(@RoleId as nvarchar(100)) + N', RegionUid: ' + cast(@RegionUid as nvarchar(100)) 
		INSERT INTO GCS.RoleRegion (RoleRegionUid, RoleId, RegionUid, IncludeAllSites, InsertName, InsertDate, UpdateName, UpdateDate, ConcurrencyValue)
		VALUES( NEWID(), @RoleId, @RegionUid, 1, SUSER_NAME(), SYSDATETIMEOFFSET(), SUSER_NAME(), SYSDATETIMEOFFSET(), 0 )

    FETCH NEXT FROM RoleFiltersRegionCursor INTO @RoleId, @EntityId, @RegionUid, @RoleName, @EntityName, @RoleRegionUid
    END
    CLOSE RoleFiltersRegionCursor;
    DEALLOCATE RoleFiltersRegionCursor;


	-- Insert missing RoleSite rows for any RowFilters that have IncludeAllSites set
    DECLARE RoleFiltersSiteCursor CURSOR FOR 
		SELECT rf.RoleId, r.EntityId, s.SiteUid, r.RoleName, e.EntityName, rs.RoleSiteUid
		FROM GCS.RoleFilters rf JOIN
		GCS.gcsRole r ON r.RoleId = rf.RoleId
		JOIN GCS.gcsEntity e on e.EntityId = r.EntityId
		left outer JOIN GCS.Site s on s.EntityId = r.EntityId
		LEFT OUTER JOIN GCS.RoleSite rs on rs.RoleId = r.RoleId AND rs.SiteUid = s.SiteUid
		WHERE rf.IncludeAllSites = 1
		AND s.SiteUid is not null and rs.RoleSiteUid is null

    OPEN RoleFiltersSiteCursor
    FETCH NEXT FROM RoleFiltersSiteCursor INTO @RoleId, @EntityId, @SiteUid, @RoleName, @EntityName, @RoleSiteUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		PRINT N'Inserting GCS.RoleSite for RoleId: ' + cast(@RoleId as nvarchar(100)) + N', SiteUid: ' + cast(@SiteUid as nvarchar(100)) 
		INSERT INTO GCS.RoleSite (RoleSiteUid, RoleId, SiteUid, IncludeAllClusters, InsertName, InsertDate, UpdateName, UpdateDate, ConcurrencyValue)
		VALUES( NEWID(), @RoleId, @SiteUid, 1, SUSER_NAME(), SYSDATETIMEOFFSET(), SUSER_NAME(), SYSDATETIMEOFFSET(), 0 )

    FETCH NEXT FROM RoleFiltersSiteCursor INTO @RoleId, @EntityId, @SiteUid, @RoleName, @EntityName, @RoleSiteUid
    END
    CLOSE RoleFiltersSiteCursor;
    DEALLOCATE RoleFiltersSiteCursor;



	-- Insert missing RoleCluster rows for any RowFilters that have IncludeAllClusters set
    DECLARE RoleFiltersClusterCursor CURSOR FOR 
		SELECT rf.RoleId, r.EntityId, c.ClusterUid, r.RoleName, e.EntityName, rc.RoleClusterUid
		FROM GCS.RoleFilters rf JOIN
		GCS.gcsRole r ON r.RoleId = rf.RoleId
		JOIN GCS.gcsEntity e on e.EntityId = r.EntityId
		left outer JOIN GCS.Cluster c on c.EntityId = r.EntityId
		LEFT OUTER JOIN GCS.RoleCluster rc on rc.RoleId = r.RoleId AND rc.ClusterUid = c.ClusterUid
		WHERE rf.IncludeAllClusters = 1
		AND c.ClusterUid is not null and rc.RoleClusterUid is null

    OPEN RoleFiltersClusterCursor
    FETCH NEXT FROM RoleFiltersClusterCursor INTO @RoleId, @EntityId, @ClusterUid, @RoleName, @EntityName, @RoleClusterUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		PRINT N'Inserting GCS.RoleCluster for RoleId: ' + cast(@RoleId as nvarchar(100)) + N', ClusterUid: ' + cast(@ClusterUid as nvarchar(100)) 
		INSERT INTO GCS.RoleCluster (RoleClusterUid, RoleId, ClusterUid, IncludeAllAccessPortals, IncludeAllInputDevices, IncludeAllOutputDevices, IncludeAllInputOutputGroups, InsertName, InsertDate, UpdateName, UpdateDate, ConcurrencyValue)
		VALUES( NEWID(), @RoleId, @ClusterUid, 1, 1, 1, 1, SUSER_NAME(), SYSDATETIMEOFFSET(), SUSER_NAME(), SYSDATETIMEOFFSET(), 0 )

    FETCH NEXT FROM RoleFiltersClusterCursor INTO @RoleId, @EntityId, @ClusterUid, @RoleName, @EntityName, @RoleClusterUid
    END
    CLOSE RoleFiltersClusterCursor;
    DEALLOCATE RoleFiltersClusterCursor;


	-- Insert missing RoleAccessPortal, RoleInputDevice, RoleOutputDevice & RoleInputOutputGroup rows for any RoleCluster that have IncludeAllXXX set

END
GO


CREATE OR ALTER FUNCTION [GCS].[fn_GCSDoesUserHaveClusterFilters] (	
	@UserId [uniqueidentifier],
	@EntityId [uniqueidentifier])
	returns int
AS
BEGIN
declare @Result int
declare @entId uniqueidentifier
declare @parentEntityId uniqueidentifier
declare @isAdministrator bit
declare @isAdministratorRole bit
declare @inheritParentRoles bit
declare @includeAllClusters bit

	select @entId = EntityId, @parentEntityId = ParentEntityId, @isAdministrator = IsAdministrator, @isAdministratorRole = IsAdministratorRole, @inheritParentRoles = InheritParentRoles, @includeAllClusters = IncludeAllClusters from GCS.UserEntityRoleView where UserId = @UserId AND EntityId = @entityId
	
	if @isAdministrator = 1 OR @isAdministratorRole = 1 OR @includeAllClusters = 1
	BEGIN
		return 0
	END

	while @inheritParentRoles = 1 AND @parentEntityId IS NOT NULL
	begin
		if [GCS].[fn_GCSDoesUserHaveClusterFilters](@UserId, @parentEntityId) = 0
		BEGIN
			return 0
		END
	end
	return 1
END
GO
ALTER AUTHORIZATION ON [GCS].[fn_GCSDoesUserHaveClusterFilters] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[fn_GCSDoesUserHaveClusterFilters] TO [public] AS [dbo]
GO




IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'fnClusterUids_SelectForUserId'
                    AND Routine_Type = 'FUNCTION' ) 
DROP FUNCTION [GCS].[fnClusterUids_SelectForUserId]
go

--CREATE OR ALTER FUNCTION [GCS].[fnClusterUids_SelectForUserId] (@UserId uniqueidentifier) 
--RETURNS @ClusterUids TABLE (ClusterUid uniqueidentifier not null)
--as
--BEGIN

--	insert into @ClusterUids select distinct(cluster.ClusterUid) 
--	from GCS.gcsUser u
--	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
--	join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
--	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
--	join gcs.gcsRole r on r.roleid = uer.RoleId
--	join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
--	join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
--	--left outer 
--	join GCS.RoleCluster roleCluster on roleCluster.RoleId = r.RoleId
--	--left outer 
--	join GCS.Cluster cluster on cluster.ClusterUid = roleCluster.ClusterUid
--	where u.UserId = @UserId
--	return
--END
--GO
CREATE OR ALTER FUNCTION [GCS].[fnClusterUids_SelectForUserId] (@UserId uniqueidentifier) 
RETURNS @ClusterUids TABLE (ClusterUid uniqueidentifier not null)
as
BEGIN
declare @entityId uniqueidentifier
	-- Start by getting all userentities for the user
	declare ueCursor CURSOR LOCAL FOR
		select EntityId from GCS.gcsUserEntity WHERE UserId = @UserId
    OPEN ueCursor
    FETCH NEXT FROM ueCursor INTO @entityId
    WHILE @@FETCH_STATUS = 0
    BEGIN
		
		IF [GCS].[fn_GCSDoesUserHaveClusterFilters] (@UserId, @entityId) = 1
		BEGIN -- IF THE USER HAS FILTERS FOR THE ENTITY, THEN USE THIS SQL
			insert into @ClusterUids select distinct(cluster.ClusterUid) 
			from GCS.gcsUser u
			join gcs.gcsUserEntity ue on ue.UserId = u.UserId
			join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
			join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
			join gcs.gcsRole r on r.roleid = uer.RoleId
			join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
			join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
			--left outer 
			join GCS.RoleCluster roleCluster on roleCluster.RoleId = r.RoleId
			--left outer 
			join GCS.Cluster cluster on cluster.ClusterUid = roleCluster.ClusterUid
			where u.UserId = @UserId
		END
		ELSE
		BEGIN
			-- IF THE USER DOES NOT HAVE FILTERS FOR THE ENTITY, THEN USE THIS SQL TO SELECT ALL ClusterUids for the entity
			INSERT INTO @ClusterUids SELECT DISTINCT(ClusterUid) from GCS.Cluster where EntityId = @entityId
		END
	FETCH NEXT FROM ueCursor INTO @entityId
    END
    CLOSE ueCursor;
    DEALLOCATE ueCursor;

	return
END
GO

GRANT SELECT ON GCS.[fnClusterUids_SelectForUserId] TO public
GO

--IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterUids_SelectForUserId]') AND type in (N'P', N'PC'))
--DROP PROCEDURE GCS.[ClusterUids_SelectForUserId]
--GO
--CREATE OR ALTER PROCEDURE GCS.[ClusterUids_SelectForUserId]
--@UserId uniqueidentifier
--AS
--BEGIN
--	select distinct(cluster.ClusterUid) 
--	from GCS.gcsUser u
--	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
--	join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
--	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
--	join gcs.gcsRole r on r.roleid = uer.RoleId
--	join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
--	join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
--	--left outer 
--	join GCS.RoleCluster roleCluster on roleCluster.RoleId = r.RoleId
--	--left outer 
--	join GCS.Cluster cluster on cluster.ClusterUid = roleCluster.ClusterUid
--	where u.UserId = @UserId
--END
--GO

CREATE OR ALTER PROCEDURE GCS.[ClusterUids_SelectForUserId]
@UserId uniqueidentifier
AS
BEGIN
	select * from GCS.fnClusterUids_SelectForUserId(@UserId)
END
GO

GRANT EXECUTE ON GCS.[ClusterUids_SelectForUserId] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ClusterFilters_SelectForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ClusterFilters_SelectForUserId]
GO
CREATE OR ALTER PROCEDURE GCS.[ClusterFilters_SelectForUserId]
@UserId uniqueidentifier,
@ClusterUid uniqueidentifier
AS
BEGIN
	
	if @ClusterUid is null or @ClusterUid = '00000000-0000-0000-0000-000000000000'
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, cluster.ClusterUid, cluster.ClusterName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	    join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	    join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleCluster roleCluster on roleCluster.RoleId = r.RoleId
		--left outer 
		join GCS.Cluster cluster on cluster.ClusterUid = roleCluster.ClusterUid
		where u.UserId = @UserId
		ORDER BY ClusterUid, PermissionId
	END
	ELSE
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, cluster.ClusterUid, cluster.ClusterName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
	    join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	    join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		--left outer 
		join GCS.RoleCluster roleCluster on roleCluster.RoleId = r.RoleId
		--left outer 
		join GCS.Cluster cluster on cluster.ClusterUid = roleCluster.ClusterUid
		where u.UserId = @UserId AND cluster.ClusterUid = @ClusterUid
		ORDER BY PermissionId
	END
END
GO

GRANT EXECUTE ON GCS.[ClusterFilters_SelectForUserId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Cluster_GetUserPermission]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Cluster_GetUserPermission]
GO
CREATE OR ALTER PROCEDURE GCS.[Cluster_GetUserPermission]
@UserId uniqueidentifier,
@ClusterUid uniqueidentifier,
@PermissionId uniqueidentifier,
@EntityId uniqueidentifier
AS
BEGIN

	
	if GCS.fn_GCSDoesUserHavePermission(@UserId, @EntityId, @PermissionId) > 0
	BEGIN
		select u.DisplayName, entity.EntityName, null as RoleName, null as PermissionName, @ClusterUid as ClusterUid, null as ClusterName, null as PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		where u.UserId = @UserId 
	END
	ELSE
	BEGIN
		select u.DisplayName, entity.EntityName, r.RoleName, perm.PermissionName, cluster.ClusterUid, cluster.ClusterName, perm.PermissionId
		from GCS.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity entity on entity.EntityId = ue.EntityId
		join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join gcs.gcsRole r on r.roleid = uer.RoleId
		join gcs.gcsRolePermission rolePerm on rolePerm.RoleId = r.RoleId
		join gcs.gcsPermission perm on perm.PermissionId = rolePerm.PermissionId
		left outer 
		join GCS.RoleCluster roleCluster on roleCluster.RoleId = r.RoleId
		left outer 
		join GCS.Cluster cluster on cluster.ClusterUid = roleCluster.ClusterUid
		where u.UserId = @UserId AND cluster.ClusterUid = @ClusterUid AND perm.PermissionId = @PermissionId
	END
END
go

GRANT EXECUTE ON GCS.[Cluster_GetUserPermission] TO public
GO

if dbo.fn_GCSDoesColumnExist('PersonPhoneNumber', 'SmsPermitted') = 0
BEGIN
	ALTER TABLE [GCS].[PersonPhoneNumber]
	ADD [SmsPermitted] [GCS].YesNo not null
END
go  

/* All Stored Procedures for table: PersonPhoneNumber */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.PersonPhoneNumber table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonPhoneNumberPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhoneNumberUid
,PersonUid
,CellCarrierUid
,Label
,PhoneNumber
,SmsPermitted
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoneNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhoneNumberPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoneNumber table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_ByClusterUid]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_ByPersonUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_ByPersonUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhoneNumberPDSA_ByPersonUid]
@PersonUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhoneNumberUid
,PersonUid
,CellCarrierUid
,Label
,PhoneNumber
,SmsPermitted
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoneNumber
WHERE 
PersonUid = @PersonUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhoneNumberPDSA_ByPersonUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoneNumber table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_ByPhoneNumber]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_ByPhoneNumber]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhoneNumberPDSA_ByPhoneNumber]
@PhoneNumber nvarchar(65)
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhoneNumberUid
,PersonUid
,CellCarrierUid
,Label
,PhoneNumber
,SmsPermitted
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoneNumber
WHERE 
PhoneNumber = @PhoneNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhoneNumberPDSA_ByPhoneNumber] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows AND the primary key column AND the 'description' column
'* in the GCS.PersonPhoneNumber table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonPhoneNumberPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhoneNumberUid
,Label
FROM GCS.PersonPhoneNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhoneNumberPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoneNumber table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhoneNumberPDSA_SelectByPK]
@PersonPhoneNumberUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhoneNumberUid
,PersonUid
,CellCarrierUid
,Label
,PhoneNumber
,SmsPermitted
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoneNumber
WHERE 
PersonPhoneNumberUid = @PersonPhoneNumberUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhoneNumberPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.PersonPhoneNumber table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhoneNumberPDSA_SelectSearch]
@Label nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhoneNumberUid
,PersonUid
,CellCarrierUid
,Label
,PhoneNumber
,SmsPermitted
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoneNumber
WHERE 
(@Label IS NULL OR Label LIKE @Label + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhoneNumberPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.PersonPhoneNumber table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhoneNumberPDSA_Insert]
@PersonPhoneNumberUid uniqueidentifier 
,@PersonUid uniqueidentifier 
,@CellCarrierUid uniqueidentifier  = null
,@Label nvarchar(65) 
,@PhoneNumber nvarchar(65) 
,@SmsPermitted [GCS].YesNo
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @PersonPhoneNumberUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonPhoneNumberUid = NULL

if @CellCarrierUid = '00000000-0000-0000-0000-000000000000'
	SET @CellCarrierUid = NULL

if @PersonPhoneNumberUid = '00000000-0000-0000-0000-000000000000' OR @PersonPhoneNumberUid IS NULL
	SET @PersonPhoneNumberUid = NewID()

INSERT INTO GCS.PersonPhoneNumber
(
PersonPhoneNumberUid
,PersonUid
,CellCarrierUid
,Label
,PhoneNumber
,SmsPermitted
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@PersonPhoneNumberUid
,@PersonUid
,@CellCarrierUid
,@Label
,@PhoneNumber
,@SmsPermitted
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhoneNumberPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.PersonPhoneNumber table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhoneNumberPDSA_Update]
@PersonPhoneNumberUid uniqueidentifier 
,@PersonUid uniqueidentifier
,@CellCarrierUid uniqueidentifier
,@Label nvarchar(65)
,@PhoneNumber nvarchar(65)
,@SmsPermitted [GCS].YesNo
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @CellCarrierUid = '00000000-0000-0000-0000-000000000000'
	SET @CellCarrierUid = NULL

UPDATE GCS.PersonPhoneNumber
SET 
PersonPhoneNumberUid = @PersonPhoneNumberUid
,PersonUid = @PersonUid
,CellCarrierUid = @CellCarrierUid
,Label = @Label
,PhoneNumber = @PhoneNumber
,SmsPermitted = @SmsPermitted
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
PersonPhoneNumberUid = @PersonPhoneNumberUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonPhoneNumberPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.PersonPhoneNumber table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhoneNumberPDSA_UpdateConcurrency]
@PersonPhoneNumberUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.PersonPhoneNumber
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
PersonPhoneNumberUid = @PersonPhoneNumberUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonPhoneNumberPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.PersonPhoneNumber table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhoneNumberPDSA_DeleteByPK]
@PersonPhoneNumberUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.PersonPhoneNumber
WHERE
PersonPhoneNumberUid = @PersonPhoneNumberUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhoneNumberPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.PersonPhoneNumber table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhoneNumberPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhoneNumberPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhoneNumberPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.PersonPhoneNumber

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhoneNumberPDSA_RowCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Credential_GetPersonInfoByCardBinaryData]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Credential_GetPersonInfoByCardBinaryData]
GO
CREATE OR ALTER PROCEDURE GCS.[Credential_GetPersonInfoByCardBinaryData]
@cardBinaryData binary(32)
as
begin

SELECT c.CredentialUid, CardNumber, CardBinaryData, CardNumberIsHex, BitCount, cf.Display as 'CredentialFormat', p.PersonUid,
p.LastName, p.FirstName, e.EntityName, e.EntityId from GCS.Credential c
join GCS.CredentialFormat cf on cf.CredentialFormatUid = c.CredentialFormatUid
left outer join GCS.PersonCredential pc on pc.CredentialUid = c.CredentialUid
left outer join GCS.Person p on p.PersonUid = pc.PersonUid
left outer join GCS.gcsEntity e on e.EntityId = p.EntityId
where c.CardBinaryData = @cardBinaryData
end
go

GRANT EXECUTE ON GCS.[Credential_GetPersonInfoByCardBinaryData] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Credential_GetPersonInfoByCardNumber]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Credential_GetPersonInfoByCardNumber]
GO
CREATE OR ALTER PROCEDURE GCS.[Credential_GetPersonInfoByCardNumber]
@cardNumber nvarchar(100)
as
begin
SELECT c.CredentialUid, CardNumber, CardBinaryData, CardNumberIsHex, BitCount, cf.Display as 'CredentialFormat', p.PersonUid,
p.LastName, p.FirstName, e.EntityName, e.EntityId from GCS.Credential c
join GCS.CredentialFormat cf on cf.CredentialFormatUid = c.CredentialFormatUid
left outer join GCS.PersonCredential pc on pc.CredentialUid = c.CredentialUid
left outer join GCS.Person p on p.PersonUid = pc.PersonUid
left outer join GCS.gcsEntity e on e.EntityId = p.EntityId
where c.CardNumber = @cardNumber
end
go

GRANT EXECUTE ON GCS.[Credential_GetPersonInfoByCardNumber] TO public
GO

/****** Object:  StoredProcedure [GCS].[GalaxyCpuConnectionPDSA_Insert]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[GalaxyCpuConnectionPDSA_Insert]
	@CpuUid [uniqueidentifier],
	@IsConnected [bit],
	@ServerAddress [nvarchar](255),
	@LastConnectedTime [datetimeoffset] = null,
	@LastDisconnectedTime [datetimeoffset] = null
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


INSERT INTO GCS.GalaxyCpuConnection
(
CpuUid
,IsConnected
,ServerAddress
,LastConnectedTime
,LastDisconnectedTime
) 
VALUES 
(
@CpuUid
,@IsConnected
,@ServerAddress
,@LastConnectedTime
,@LastDisconnectedTime
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyCpuConnectionPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyCpuConnectionPDSA_Insert] TO [public] AS [dbo]
GO

/****** Object:  StoredProcedure [GCS].[GalaxyCpuConnectionPDSA_Update]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[GalaxyCpuConnectionPDSA_Update]
	@CpuUid [uniqueidentifier],
	@IsConnected [bit],
	@ServerAddress [nvarchar](255),
	@LastConnectedTime [datetimeoffset],
	@LastDisconnectedTime [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

UPDATE GCS.GalaxyCpuConnection
SET 
CpuUid = @CpuUid
,IsConnected = @IsConnected
,ServerAddress = @ServerAddress
,LastConnectedTime = @LastConnectedTime
,LastDisconnectedTime = @LastDisconnectedTime
WHERE
CpuUid = @CpuUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyCpuConnectionPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyCpuConnectionPDSA_Update] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyCpuConnection_Save]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyCpuConnection_Save]
GO

/****** Object:  StoredProcedure [GCS].[GalaxyCpuConnection_Save]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[GalaxyCpuConnection_Save]
	@CpuUid [uniqueidentifier],
	@IsConnected [bit],
	@ServerAddress [nvarchar](255)
WITH EXECUTE AS CALLER
AS
declare @lastDisconnectedTime datetimeoffset
declare @lastConnectedTime datetimeoffset

	IF @CpuUid IS NULL OR @CpuUid = '00000000-0000-0000-0000-000000000000'
	BEGIN
		if exists ( select ServerAddress from GCS.GalaxyCpuConnection where ServerAddress = @ServerAddress)
		BEGIN
			UPDATE GCS.GalaxyCpuConnection SET IsConnected = @IsConnected where ServerAddress = @ServerAddress
		END
	END
	ELSE
	BEGIN
		IF NOT EXISTS(SELECT CpuUid from GCS.GalaxyCpuConnection where CpuUid = @CpuUid)
		begin
			if @IsConnected IS NULL OR @IsConnected = 0
				set @lastDisconnectedTime = SYSDATETIMEOFFSET()
			ELSE
				SET @lastConnectedTime = SYSDATETIMEOFFSET()
			exec [GCS].[GalaxyCpuConnectionPDSA_Insert] @CpuUid,@IsConnected,@ServerAddress,@lastConnectedTime,@lastDisconnectedTime 
		end
		else
		begin
			if @IsConnected IS NULL OR @IsConnected = 0
				update GCS.GalaxyCpuConnection set IsConnected = @IsConnected, LastDisconnectedTime = @lastDisconnectedTime where CpuUid = @CpuUid AND IsConnected <> @IsConnected
			else if @lastDisconnectedTime is null
				update GCS.GalaxyCpuConnection set IsConnected = @IsConnected, LastConnectedTime = @lastConnectedTime where CpuUid = @CpuUid AND IsConnected <> @IsConnected

			exec [GCS].[GalaxyCpuConnectionPDSA_Update] @CpuUid,@IsConnected,@ServerAddress,@lastConnectedTime,@lastDisconnectedTime 
		end
	END
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyCpuConnection_Save] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyCpuConnection_Save] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleClusterPDSA_ByAccessPortalTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleClusterPDSA_ByAccessPortalTypeUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleAccessPortalPDSA_ByAccessPortalTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleAccessPortalPDSA_ByAccessPortalTypeUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleOutputDevicePDSA_ByAccessPortalTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleOutputDevicePDSA_ByAccessPortalTypeUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputDevicePDSA_ByAccessPortalTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputDevicePDSA_ByAccessPortalTypeUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputOutputGroupPDSA_ByAccessPortalTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputOutputGroupPDSA_ByAccessPortalTypeUid]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleAccessPortalPDSA_ByAccessPortalUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleAccessPortalPDSA_ByAccessPortalUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleAccessPortalPDSA_ByAccessPortalUid]
@AccessPortalUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleAccessPortalUid
,RoleId
,t.AccessPortalUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,PortalName
FROM GCS.RoleAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
t.AccessPortalUid = @AccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleAccessPortalPDSA_ByAccessPortalUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleAccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleAccessPortalPDSA_ByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleAccessPortalPDSA_ByRoleId]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleAccessPortalPDSA_ByRoleId]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleAccessPortalUid
,RoleId
,t.AccessPortalUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,PortalName
FROM GCS.RoleAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
RoleId = @RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleAccessPortalPDSA_ByRoleId] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleAccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleAccessPortalPDSA_ByRoleIdAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleAccessPortalPDSA_ByRoleIdAndClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleAccessPortalPDSA_ByRoleIdAndClusterUid]
@RoleId uniqueidentifier,
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleAccessPortalUid
,RoleId
,t.AccessPortalUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,PortalName
FROM GCS.RoleAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
JOIN GCS.AccessPortalGalaxyHardwareAddress hwa ON hwa.AccessPortalUid = ap.AccessPortalUid
JOIN GCS.GalaxyPanel gp ON gp.GalaxyPanelUid = hwa.GalaxyPanelUid
WHERE 
RoleId = @RoleId AND gp.ClusterUid = @ClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleAccessPortalPDSA_ByRoleIdAndClusterUid] TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleAccessPortalPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleAccessPortalPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleAccessPortalPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleAccessPortalUid
,RoleId
,t.AccessPortalUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,PortalName
FROM GCS.RoleAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleAccessPortalPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleAccessPortal table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleAccessPortalPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleAccessPortalPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleAccessPortalPDSA_SelectByPK]
@RoleAccessPortalUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleAccessPortalUid
,RoleId
,t.AccessPortalUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,PortalName
FROM GCS.RoleAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
RoleAccessPortalUid = @RoleAccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleAccessPortalPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.RoleAccessPortal table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleAccessPortalPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleAccessPortalPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleAccessPortalPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleAccessPortalUid
,RoleId
,t.AccessPortalUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,PortalName
FROM GCS.RoleAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleAccessPortalPDSA_SelectSearch] TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleClusterPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleClusterPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleClusterPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleClusterUid
,RoleId
,t.ClusterUid
,IncludeAllAccessPortals
,IncludeAllInputOutputGroups
,IncludeAllInputDevices
,IncludeAllOutputDevices
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
FROM GCS.RoleCluster t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
ORDER BY ClusterName

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleClusterPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleCluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleClusterPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleClusterPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleClusterPDSA_ByClusterUid]
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleClusterUid
,RoleId
,t.ClusterUid
,IncludeAllAccessPortals
,IncludeAllInputOutputGroups
,IncludeAllInputDevices
,IncludeAllOutputDevices
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
FROM GCS.RoleCluster t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
WHERE 
t.ClusterUid = @ClusterUid
ORDER BY ClusterName

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleClusterPDSA_ByClusterUid] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleCluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleClusterPDSA_ByClusterAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleClusterPDSA_ByClusterAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleClusterPDSA_ByClusterAddress]
@ClusterGroupId int
,@ClusterNumber int
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleClusterUid
,RoleId
,t.ClusterUid
,IncludeAllAccessPortals
,IncludeAllInputOutputGroups
,IncludeAllInputDevices
,IncludeAllOutputDevices
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
FROM GCS.RoleCluster t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
WHERE 
c.ClusterGroupId = @ClusterGroupId AND c.ClusterNumber = @ClusterNumber
ORDER BY ClusterName

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleClusterPDSA_ByClusterAddress] TO public
GO



/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleCluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleClusterPDSA_ByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleClusterPDSA_ByRoleId]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleClusterPDSA_ByRoleId]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleClusterUid
,RoleId
,t.ClusterUid
,IncludeAllAccessPortals
,IncludeAllInputOutputGroups
,IncludeAllInputDevices
,IncludeAllOutputDevices
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
FROM GCS.RoleCluster t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
WHERE 
RoleId = @RoleId
ORDER BY ClusterName

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleClusterPDSA_ByRoleId] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleCluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleClusterPDSA_ByRoleIdAndSiteUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleClusterPDSA_ByRoleIdAndSiteUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleClusterPDSA_ByRoleIdAndSiteUid]
@RoleId uniqueidentifier,
@SiteUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleClusterUid
,RoleId
,t.ClusterUid
,IncludeAllAccessPortals
,IncludeAllInputOutputGroups
,IncludeAllInputDevices
,IncludeAllOutputDevices
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
FROM GCS.RoleCluster t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
WHERE 
RoleId = @RoleId and c.SiteUid = @SiteUid
ORDER BY ClusterName

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleClusterPDSA_ByRoleIdAndSiteUid] TO public
GO


/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.RoleCluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleClusterPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleClusterPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleClusterPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleClusterUid
,InsertName
FROM GCS.RoleCluster

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleClusterPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleCluster table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleClusterPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleClusterPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleClusterPDSA_SelectByPK]
@RoleClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleClusterUid
,RoleId
,t.ClusterUid
,IncludeAllAccessPortals
,IncludeAllInputOutputGroups
,IncludeAllInputDevices
,IncludeAllOutputDevices
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
FROM GCS.RoleCluster t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
WHERE 
RoleClusterUid = @RoleClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleClusterPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.RoleCluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleClusterPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleClusterPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleClusterPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleClusterUid
,RoleId
,t.ClusterUid
,IncludeAllAccessPortals
,IncludeAllInputOutputGroups
,IncludeAllInputDevices
,IncludeAllOutputDevices
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
FROM GCS.RoleCluster t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleClusterPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleInputOutputGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputOutputGroupPDSA_ByInputOutputGroupUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputOutputGroupPDSA_ByInputOutputGroupUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleInputOutputGroupPDSA_ByInputOutputGroupUid]
@InputOutputGroupUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputOutputGroupUid
,RoleId
,t.InputOutputGroupUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,Display as InputOutputGroupName
FROM GCS.RoleInputOutputGroup t
JOIN GCS.InputOutputGroup iog on iog.InputOutputGroupUid = t.InputOutputGroupUid
WHERE 
t.InputOutputGroupUid = @InputOutputGroupUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputOutputGroupPDSA_ByInputOutputGroupUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleInputOutputGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputOutputGroupPDSA_ByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputOutputGroupPDSA_ByRoleId]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleInputOutputGroupPDSA_ByRoleId]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputOutputGroupUid
,RoleId
,t.InputOutputGroupUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,Display as InputOutputGroupName
FROM GCS.RoleInputOutputGroup t
JOIN GCS.InputOutputGroup iog on iog.InputOutputGroupUid = t.InputOutputGroupUid
WHERE 
RoleId = @RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputOutputGroupPDSA_ByRoleId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputOutputGroupPDSA_ByRoleIdAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputOutputGroupPDSA_ByRoleIdAndClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleInputOutputGroupPDSA_ByRoleIdAndClusterUid]
@RoleId uniqueidentifier,
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputOutputGroupUid
,RoleId
,t.InputOutputGroupUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,Display as InputOutputGroupName
FROM GCS.RoleInputOutputGroup t
JOIN GCS.InputOutputGroup iog on iog.InputOutputGroupUid = t.InputOutputGroupUid
WHERE 
RoleId = @RoleId AND iog.ClusterUid = @ClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputOutputGroupPDSA_ByRoleIdAndClusterUid] TO public
GO






IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputOutputGroupPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputOutputGroupPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleInputOutputGroupPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputOutputGroupUid
,RoleId
,t.InputOutputGroupUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,Display as InputOutputGroupName
FROM GCS.RoleInputOutputGroup t
JOIN GCS.InputOutputGroup iog on iog.InputOutputGroupUid = t.InputOutputGroupUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputOutputGroupPDSA_SelectAll] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputOutputGroupPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputOutputGroupPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleInputOutputGroupPDSA_SelectByPK]
@RoleInputOutputGroupUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputOutputGroupUid
,RoleId
,t.InputOutputGroupUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,Display as InputOutputGroupName
FROM GCS.RoleInputOutputGroup t
JOIN GCS.InputOutputGroup iog on iog.InputOutputGroupUid = t.InputOutputGroupUid
WHERE 
RoleInputOutputGroupUid = @RoleInputOutputGroupUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputOutputGroupPDSA_SelectByPK] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputOutputGroupPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputOutputGroupPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleInputOutputGroupPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputOutputGroupUid
,RoleId
,t.InputOutputGroupUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,Display as InputOutputGroupName
FROM GCS.RoleInputOutputGroup t
JOIN GCS.InputOutputGroup iog on iog.InputOutputGroupUid = t.InputOutputGroupUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputOutputGroupPDSA_SelectSearch] TO public
GO



/* All Stored Procedures for table: RoleOutputDevice */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.RoleOutputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleOutputDevicePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleOutputDevicePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleOutputDevicePDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleOutputDeviceUid
,RoleId
,t.OutputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,OutputName
FROM GCS.RoleOutputDevice t
JOIN GCS.OutputDevice od on od.OutputDeviceUid = t.OutputDeviceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleOutputDevicePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleOutputDevice table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleOutputDevicePDSA_ByOutputDeviceUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleOutputDevicePDSA_ByOutputDeviceUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleOutputDevicePDSA_ByOutputDeviceUid]
@OutputDeviceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleOutputDeviceUid
,RoleId
,t.OutputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,OutputName
FROM GCS.RoleOutputDevice t
JOIN GCS.OutputDevice od on od.OutputDeviceUid = t.OutputDeviceUid
WHERE 
t.OutputDeviceUid = @OutputDeviceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleOutputDevicePDSA_ByOutputDeviceUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleOutputDevice table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleOutputDevicePDSA_ByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleOutputDevicePDSA_ByRoleId]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleOutputDevicePDSA_ByRoleId]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleOutputDeviceUid
,RoleId
,t.OutputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,OutputName
FROM GCS.RoleOutputDevice t
JOIN GCS.OutputDevice od on od.OutputDeviceUid = t.OutputDeviceUid
WHERE 
RoleId = @RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleOutputDevicePDSA_ByRoleId] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleOutputDevicePDSA_ByRoleIdAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleOutputDevicePDSA_ByRoleIdAndClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleOutputDevicePDSA_ByRoleIdAndClusterUid]
@RoleId uniqueidentifier,
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleOutputDeviceUid
,RoleId
,t.OutputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,OutputName
FROM GCS.RoleOutputDevice t
JOIN GCS.OutputDevice od on od.OutputDeviceUid = t.OutputDeviceUid
JOIN GCS.OutputDeviceGalaxyHardwareAddress hwa ON hwa.OutputDeviceUid = od.OutputDeviceUid
JOIN GCS.GalaxyPanel gp ON gp.GalaxyPanelUid = hwa.GalaxyPanelUid
WHERE 
RoleId = @RoleId AND gp.ClusterUid = @ClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleOutputDevicePDSA_ByRoleIdAndClusterUid] TO public
GO


/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleOutputDevice table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleOutputDevicePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleOutputDevicePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleOutputDevicePDSA_SelectByPK]
@RoleOutputDeviceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleOutputDeviceUid
,RoleId
,t.OutputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,OutputName
FROM GCS.RoleOutputDevice t
JOIN GCS.OutputDevice od on od.OutputDeviceUid = t.OutputDeviceUid
WHERE 
RoleOutputDeviceUid = @RoleOutputDeviceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleOutputDevicePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.RoleOutputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleOutputDevicePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleOutputDevicePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleOutputDevicePDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleOutputDeviceUid
,RoleId
,t.OutputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,OutputName
FROM GCS.RoleOutputDevice t
JOIN GCS.OutputDevice od on od.OutputDeviceUid = t.OutputDeviceUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleOutputDevicePDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.RoleInputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputDevicePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputDevicePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleInputDevicePDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputDeviceUid
,RoleId
,t.InputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,InputName
FROM GCS.RoleInputDevice t
JOIN GCS.InputDevice id on id.InputDeviceUid = t.InputDeviceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputDevicePDSA_SelectAll] TO public
GO


/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleInputDevice table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputDevicePDSA_ByInputDeviceUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputDevicePDSA_ByInputDeviceUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleInputDevicePDSA_ByInputDeviceUid]
@InputDeviceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputDeviceUid
,RoleId
,t.InputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,InputName
FROM GCS.RoleInputDevice t
JOIN GCS.InputDevice id on id.InputDeviceUid = t.InputDeviceUid
WHERE 
t.InputDeviceUid = @InputDeviceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputDevicePDSA_ByInputDeviceUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleInputDevice table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputDevicePDSA_ByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputDevicePDSA_ByRoleId]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleInputDevicePDSA_ByRoleId]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputDeviceUid
,RoleId
,t.InputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,InputName
FROM GCS.RoleInputDevice t
JOIN GCS.InputDevice id on id.InputDeviceUid = t.InputDeviceUid
WHERE 
RoleId = @RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputDevicePDSA_ByRoleId] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputDevicePDSA_ByRoleIdAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputDevicePDSA_ByRoleIdAndClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleInputDevicePDSA_ByRoleIdAndClusterUid]
@RoleId uniqueidentifier,
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputDeviceUid
,RoleId
,t.InputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,InputName
FROM GCS.RoleInputDevice t
JOIN GCS.InputDevice id on id.InputDeviceUid = t.InputDeviceUid
JOIN GCS.InputDeviceGalaxyHardwareAddress hwa ON hwa.InputDeviceUid = id.InputDeviceUid
JOIN GCS.GalaxyPanel gp ON gp.GalaxyPanelUid = hwa.GalaxyPanelUid
WHERE 
RoleId = @RoleId AND gp.ClusterUid = @ClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputDevicePDSA_ByRoleIdAndClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleInputDevice table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputDevicePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputDevicePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleInputDevicePDSA_SelectByPK]
@RoleInputDeviceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputDeviceUid
,RoleId
,t.InputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,InputName
FROM GCS.RoleInputDevice t
JOIN GCS.InputDevice id on id.InputDeviceUid = t.InputDeviceUid
WHERE 
RoleInputDeviceUid = @RoleInputDeviceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputDevicePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.RoleInputDevice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleInputDevicePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleInputDevicePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleInputDevicePDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleInputDeviceUid
,RoleId
,t.InputDeviceUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,InputName
FROM GCS.RoleInputDevice t
JOIN GCS.InputDevice id on id.InputDeviceUid = t.InputDeviceUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleInputDevicePDSA_SelectSearch] TO public
GO

/****** Object:  StoredProcedure [GCS].[ChooseAvailableClusterNumber]    Script Date: 8/31/2020 2:22:23 PM ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ChooseAvailableClusterNumber]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ChooseAvailableClusterNumber]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableClusterNumber]
	@ClusterGroupId [int]
WITH EXECUTE AS CALLER
AS
declare @ClusterNumber int
	declare @minClusterNumber int
	declare @maxClusterNumber int
	set @minClusterNumber = 1
	set @maxClusterNumber = 65535


declare @clusterNumbers table
( ClusterNumber int)

	insert into @clusterNumbers select ClusterNumber from GCS.Cluster where ClusterGroupId = @ClusterGroupId ORDER BY ClusterNumber

	declare @count int
	select @count = count(*) from @clusterNumbers
	if @count = 0
	begin
		set @ClusterNumber = @minClusterNumber
	end
	else if @count = (@maxClusterNumber - @minClusterNumber)
	begin
		set @ClusterNumber = 0 
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minClusterNumber
		DECLARE clusterNumberCursor CURSOR FOR SELECT ClusterNumber from @clusterNumbers ORDER BY ClusterNumber
		OPEN clusterNumberCursor
		FETCH NEXT FROM clusterNumberCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			set @lastNumber = @currentNumber

			FETCH NEXT FROM clusterNumberCursor INTO @currentNumber
	    END
		CLOSE clusterNumberCursor;
		DEALLOCATE clusterNumberCursor;
		set @ClusterNumber = @lastNumber + 1
	end
	select @ClusterNumber as ClusterNumber
GO
ALTER AUTHORIZATION ON [GCS].[ChooseAvailableClusterNumber] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[ChooseAvailableClusterNumber] TO [public] AS [dbo]
GO


CREATE OR ALTER FUNCTION [GCS].[fnChooseAvailableClusterGroupId]()
RETURNS INT
AS
BEGIN
declare @ClusterGroupId int
	declare @minNumber int
	declare @maxNumber int
	set @minNumber = 1
	set @maxNumber = 65535


declare @clusterGroupIdNumbers table
( ClusterGroupId int)

	insert into @clusterGroupIdNumbers select distinct(ClusterGroupId) from GCS.gcsEntity ORDER BY ClusterGroupId

	declare @count int
	select @count = count(*) from @clusterGroupIdNumbers
	if @count = 0
	begin
		set @ClusterGroupId = @minNumber
	end
	else if @count = (@maxNumber - @minNumber)
	begin
		set @ClusterGroupId = 0 
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minNumber
		DECLARE clusterGroupIdCursor CURSOR FOR SELECT ClusterGroupId from @clusterGroupIdNumbers ORDER BY ClusterGroupId
		OPEN clusterGroupIdCursor
		FETCH NEXT FROM clusterGroupIdCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			set @lastNumber = @currentNumber

			FETCH NEXT FROM clusterGroupIdCursor INTO @currentNumber
	    END
		CLOSE clusterGroupIdCursor;
		DEALLOCATE clusterGroupIdCursor;
		set @ClusterGroupId = @lastNumber + 1
	end
	return @ClusterGroupId
END
GO
ALTER AUTHORIZATION ON [GCS].[fnChooseAvailableClusterGroupId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[fnChooseAvailableClusterGroupId] TO [public] AS [dbo]
GO



--IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ChooseAvailableClusterGroupId]') AND type in (N'P', N'PC'))
--DROP PROCEDURE GCS.[ChooseAvailableClusterGroupId]
--GO
--SET ANSI_NULLS ON
--GO
--SET QUOTED_IDENTIFIER ON
--GO
--CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableClusterGroupId]
--WITH EXECUTE AS CALLER
--AS
--	declare @ClusterGroupId int = -1
--	SET @ClusterGroupId = [GCS].[fnChooseAvailableClusterGroupId]()
--	select @ClusterGroupId as ClusterGroupId
--GO
--ALTER AUTHORIZATION ON [GCS].[ChooseAvailableClusterGroupId] TO  SCHEMA OWNER 
--GO
--GRANT EXECUTE ON [GCS].[ChooseAvailableClusterGroupId] TO [public] AS [dbo]
--GO





/****** Object:  StoredProcedure [dbo].[gcs_GetAllColumnGuidValues]    Script Date: 8/31/2020 2:22:22 PM ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'dbo.[gcs_GetAllColumnGuidValues]') AND type in (N'P', N'PC'))
DROP PROCEDURE dbo.[gcs_GetAllColumnGuidValues]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [dbo].[gcs_GetAllColumnGuidValues]
	@SchemaName [varchar](100),
	@TableName [varchar](100),
	@ColumnName [varchar](100),
	@Where varchar(255)
WITH EXECUTE AS CALLER
AS
SET NOCOUNT ON

declare 
    @sql nvarchar(500)

	if @SchemaName is null or len(@SchemaName) = 0
		set @SchemaName = 'gcs'
    select @sql = 'select ' + @ColumnName + ' as Uid from [' + @SchemaName + '].[' + @TableName + ']'
	
	if @Where is not null and len(@Where) > 0
		set @sql = @sql + N' WHERE ' + @Where

	--print @sql

    exec sp_executesql @sql
GO
ALTER AUTHORIZATION ON [dbo].[gcs_GetAllColumnGuidValues] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [dbo].[gcs_GetAllColumnGuidValues] TO [public] AS [dbo]
GO


if exists (select 1
          from sysobjects
          where id = object_id('GCS.ti_personlastusage')
          AND type = 'TR')
   drop trigger GCS.ti_personlastusage
go

if exists (select 1
          from sysobjects
          where id = object_id('GCS.tu_personlastusage')
          AND type = 'TR')
   drop trigger GCS.tu_personlastusage
go

if dbo.fn_GCSDoesTableExist('PersonLastUsage') = 0
BEGIN
	/*==============================================================*/
	/* Table: PersonLastUsage                                       */
	/*==============================================================*/
	create table GCS.PersonLastUsage (
	   PersonUid            GCS.UniversalUniqueId    not null,
	   LastAccessPortalActivityEventUid GCS.UniversalUniqueId    null,
	   LastAccessGrantedAccessPortalActivityEventUid GCS.UniversalUniqueId    null
	)

	alter table GCS.PersonLastUsage
	   add constraint PK_PERSONLASTUSAGE primary key (PersonUid)

	alter table GCS.PersonLastUsage
	   add constraint FK_PersonLastUsagePerson foreign key (PersonUid)
		  references GCS.Person (PersonUid)
			 on update cascade on delete cascade
END
go


create trigger GCS.ti_personlastusage on GCS.PersonLastUsage for insert as
begin
    declare
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.AccessPortalActivityEvent" must exist when inserting a child in "GCS.PersonLastUsage"  */
    if update(LastAccessPortalActivityEventUid)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  LastAccessPortalActivityEventUid is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.AccessPortalActivityEvent t1, inserted t2
              where  t1.AccessPortalActivityEventUid = t2.LastAccessPortalActivityEventUid) != @numrows - @numnull
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.AccessPortalActivityEvent". Cannot create child in "GCS.PersonLastUsage".'
             goto error
          end
    end
    /*  Parent "GCS.AccessPortalActivityEvent" must exist when inserting a child in "GCS.PersonLastUsage"  */
    if update(LastAccessGrantedAccessPortalActivityEventUid)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  LastAccessGrantedAccessPortalActivityEventUid is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.AccessPortalActivityEvent t1, inserted t2
              where  t1.AccessPortalActivityEventUid = t2.LastAccessGrantedAccessPortalActivityEventUid) != @numrows - @numnull
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.AccessPortalActivityEvent". Cannot create child in "GCS.PersonLastUsage".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


create trigger GCS.tu_personlastusage on GCS.PersonLastUsage for update as
begin
   declare
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.AccessPortalActivityEvent" must exist when updating a child in "GCS.PersonLastUsage"  */
      if update(LastAccessPortalActivityEventUid)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  LastAccessPortalActivityEventUid is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.AccessPortalActivityEvent t1, inserted t2
                where  t1.AccessPortalActivityEventUid = t2.LastAccessPortalActivityEventUid) != @numrows - @numnull
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.AccessPortalActivityEvent" does not exist. Cannot modify child in "GCS.PersonLastUsage".'
               goto error
            end
      end
      /*  Parent "GCS.AccessPortalActivityEvent" must exist when updating a child in "GCS.PersonLastUsage"  */
      if update(LastAccessGrantedAccessPortalActivityEventUid)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  LastAccessGrantedAccessPortalActivityEventUid is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.AccessPortalActivityEvent t1, inserted t2
                where  t1.AccessPortalActivityEventUid = t2.LastAccessGrantedAccessPortalActivityEventUid) != @numrows - @numnull
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.AccessPortalActivityEvent" does not exist. Cannot modify child in "GCS.PersonLastUsage".'
               goto error
            end
      end

      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


/* All Stored Procedures for table: PersonLastUsage */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.PersonLastUsage table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonLastUsagePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonLastUsagePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonLastUsagePDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonUid
,LastAccessPortalActivityEventUid
,LastAccessGrantedAccessPortalActivityEventUid
FROM GCS.PersonLastUsage

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonLastUsagePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonLastUsage table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonLastUsagePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonLastUsagePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonLastUsagePDSA_SelectByPK]
@PersonUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonUid
,LastAccessPortalActivityEventUid
,LastAccessGrantedAccessPortalActivityEventUid
FROM GCS.PersonLastUsage
WHERE 
PersonUid = @PersonUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonLastUsagePDSA_SelectByPK] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.PersonLastUsage table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonLastUsagePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonLastUsagePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonLastUsagePDSA_Insert]
@PersonUid uniqueidentifier 
,@LastAccessPortalActivityEventUid uniqueidentifier  = null
,@LastAccessGrantedAccessPortalActivityEventUid uniqueidentifier  = null
AS

declare @ret int;
select @ret = 0;

if @LastAccessPortalActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @LastAccessPortalActivityEventUid = NULL
if @LastAccessGrantedAccessPortalActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @LastAccessGrantedAccessPortalActivityEventUid = NULL

INSERT INTO GCS.PersonLastUsage
(
PersonUid
,LastAccessPortalActivityEventUid
,LastAccessGrantedAccessPortalActivityEventUid
) 
VALUES 
(
@PersonUid
,@LastAccessPortalActivityEventUid
,@LastAccessGrantedAccessPortalActivityEventUid
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonLastUsagePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.PersonLastUsage table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonLastUsagePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonLastUsagePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonLastUsagePDSA_Update]
@PersonUid uniqueidentifier 
,@LastAccessPortalActivityEventUid uniqueidentifier
,@IsAccessGrantedEvent bit
AS

declare @ret int;
select @ret = 0;

if @LastAccessPortalActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @LastAccessPortalActivityEventUid = NULL

if not exists(select PersonUid from GCS.PersonLastUsage where PersonUid = @PersonUid)
begin
	if @IsAccessGrantedEvent = 0
	begin
		INSERT INTO GCS.PersonLastUsage (PersonUid, LastAccessPortalActivityEventUid, LastAccessGrantedAccessPortalActivityEventUid)
		VALUES ( @PersonUid, @LastAccessPortalActivityEventUid, null)
	end
	else
	begin
		INSERT INTO GCS.PersonLastUsage (PersonUid, LastAccessPortalActivityEventUid, LastAccessGrantedAccessPortalActivityEventUid)
		VALUES ( @PersonUid, @LastAccessPortalActivityEventUid, @LastAccessPortalActivityEventUid)
	end
end
else
begin
	if @IsAccessGrantedEvent = 0
	begin
		UPDATE GCS.PersonLastUsage
		SET LastAccessPortalActivityEventUid = @LastAccessPortalActivityEventUid
		WHERE PersonUid = @PersonUid
	end
	else
	begin
		UPDATE GCS.PersonLastUsage
		SET LastAccessPortalActivityEventUid = @LastAccessPortalActivityEventUid, LastAccessGrantedAccessPortalActivityEventUid = @LastAccessPortalActivityEventUid
		WHERE PersonUid = @PersonUid
	end
end

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonLastUsagePDSA_Update] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.PersonLastUsage table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonLastUsagePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonLastUsagePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonLastUsagePDSA_DeleteByPK]
@PersonUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.PersonLastUsage
WHERE
PersonUid = @PersonUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonLastUsagePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.PersonLastUsage table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonLastUsagePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonLastUsagePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonLastUsagePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.PersonLastUsage

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonLastUsagePDSA_RowCount] TO public
GO


/*==============================================================*/
/* Table: AccessPortalLastUsage                                 */
/*==============================================================*/
if dbo.fn_GCSDoesTableExist('AccessPortalLastUsage') = 0
begin
	create table GCS.AccessPortalLastUsage (
	   AccessPortalUid      GCS.UniversalUniqueId    RowGuidCol not null,
	   LastActivityEventUid uniqueidentifier   null,
	   LastAccessGrantedActivityEventUid uniqueidentifier  null,
	   constraint PK_ACCESSPORTALLASTUSAGE primary key (AccessPortalUid)
	)

	alter table GCS.AccessPortalLastUsage
   add constraint FK_AccessPortalLastUsageAccessPortal foreign key (AccessPortalUid)
      references GCS.AccessPortal (AccessPortalUid)
         on update cascade on delete cascade
end
go


create or alter trigger GCS.ti_accessportallastusage on GCS.AccessPortalLastUsage for insert as
begin
    declare
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.AccessPortalActivityEvent" must exist when inserting a child in "GCS.AccessPortalLastUsage"  */
    if update(LastActivityEventUid)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  LastActivityEventUid is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.AccessPortalActivityEvent t1, inserted t2
              where  t1.AccessPortalActivityEventUid = t2.LastActivityEventUid) != @numrows - @numnull
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.AccessPortalActivityEvent". Cannot create child in "GCS.AccessPortalLastUsage".'
             goto error
          end
    end
    /*  Parent "GCS.AccessPortalActivityEvent" must exist when inserting a child in "GCS.AccessPortalLastUsage"  */
    if update(LastAccessGrantedActivityEventUid)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  LastAccessGrantedActivityEventUid is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.AccessPortalActivityEvent t1, inserted t2
              where  t1.AccessPortalActivityEventUid = t2.LastAccessGrantedActivityEventUid) != @numrows - @numnull
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.AccessPortalActivityEvent". Cannot create child in "GCS.AccessPortalLastUsage".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


create or alter trigger GCS.tu_accessportallastusage on GCS.AccessPortalLastUsage for update as
begin
   declare
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.AccessPortalActivityEvent" must exist when updating a child in "GCS.AccessPortalLastUsage"  */
      if update(LastActivityEventUid)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  LastActivityEventUid is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.AccessPortalActivityEvent t1, inserted t2
                where  t1.AccessPortalActivityEventUid = t2.LastActivityEventUid) != @numrows - @numnull
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.AccessPortalActivityEvent" does not exist. Cannot modify child in "GCS.AccessPortalLastUsage".'
               goto error
            end
      end
      /*  Parent "GCS.AccessPortalActivityEvent" must exist when updating a child in "GCS.AccessPortalLastUsage"  */
      if update(LastAccessGrantedActivityEventUid)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  LastAccessGrantedActivityEventUid is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.AccessPortalActivityEvent t1, inserted t2
                where  t1.AccessPortalActivityEventUid = t2.LastAccessGrantedActivityEventUid) != @numrows - @numnull
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.AccessPortalActivityEvent" does not exist. Cannot modify child in "GCS.AccessPortalLastUsage".'
               goto error
            end
      end

      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go




IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[insert_AccessPortalActivityEvent]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[insert_AccessPortalActivityEvent]
GO

CREATE OR ALTER PROCEDURE [GCS].[insert_AccessPortalActivityEvent]
	@AccessPortalActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@AccessPortalUid [uniqueidentifier],
	@CredentialUid [uniqueidentifier] = null,
	@PersonUid [uniqueidentifier] = null,
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int],
	@InsertDate [datetimeoffset],
	@eventType [varchar](50),
	@CredentialBytes [varbinary](32),
	@IsAlarmEvent [bit],
	@AlarmPriority [int],
	@ResponseRequired bit,
	@NoteUid [uniqueidentifier],
	@BinaryResourceUid [uniqueidentifier],
	@IsAccessGrantedEvent [bit]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @AccessPortalActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalActivityEventUid = NULL
if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL
if @PersonUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonUid = NULL

if @AccessPortalActivityEventUid = '00000000-0000-0000-0000-000000000000' OR @AccessPortalActivityEventUid IS NULL
	SET @AccessPortalActivityEventUid = NewID()

if @eventType IS NOT NULL AND ( @GalaxyActivityEventTypeUid IS NULL OR @GalaxyActivityEventTypeUid = '00000000-0000-0000-0000-000000000000')
	SELECT @GalaxyActivityEventTypeUid = GalaxyActivityEventTypeUid FROM [GCS].[GalaxyActivityEventType] WHERE EventType = @eventType

INSERT INTO GCS.AccessPortalActivityEvent
(
AccessPortalActivityEventUid
,GalaxyActivityEventTypeUid
,AccessPortalUid
,CredentialUid
,PersonUid
,CpuUid
,CpuNumber
,ActivityDateTime
,BufferIndex
,CredentialBytes
,InsertDate
) 
VALUES 
(
@AccessPortalActivityEventUid
,@GalaxyActivityEventTypeUid
,@AccessPortalUid
,@CredentialUid
,@PersonUid
,@CpuUid
,@CpuNumber
,@ActivityDateTime
,@BufferIndex
,@CredentialBytes
,@InsertDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

if @IsAlarmEvent is not null AND @IsAlarmEvent <> 0 AND @ret = 0
BEGIN
	if @NoteUid = '00000000-0000-0000-0000-000000000000'
		SET @NoteUid = NULL

	if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
		SET @BinaryResourceUid = NULL

	INSERT INTO GCS.AccessPortalActivityAlarmEvent (AccessPortalActivityEventUid, NoteUid, BinaryResourceUid, AlarmPriority,ResponseRequired)
	VALUES (@AccessPortalActivityEventUid, @NoteUid, @BinaryResourceUid, @AlarmPriority,@ResponseRequired)
END
--ELSE
--BEGIN
	if @PersonUid is not null
	begin
		exec GCS.[PersonLastUsagePDSA_Update] @PersonUid, @AccessPortalActivityEventUid, @IsAccessGrantedEvent
	end
--END

exec GCS.[AccessPortalLastUsagePDSA_Update] @AccessPortalUid, @AccessPortalActivityEventUid, @IsAccessGrantedEvent

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[insert_AccessPortalActivityEvent] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[insert_AccessPortalActivityEvent] TO [public] AS [dbo]
GO


if dbo.fn_GCSDoesViewExist('AccessPortal_LocationData') = 1
BEGIN
	DROP VIEW GCS.[AccessPortal_LocationData]
END
go


create view [GCS].[AccessPortal_LocationData] as
SELECT ap.AccessPortalUid,
	ap.PortalName,
	c.ClusterName,
	s.SiteName,
	ent.EntityName
	from GCS.AccessPortal ap
	left outer join GCS.AccessPortalGalaxyHardwareAddress apgalhwaddr on apgalhwaddr.accessPortalUid = ap.AccessPortalUid
	left outer join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = apgalhwaddr.GalaxyPanelUid
	left outer join GCS.Cluster c on c.ClusterUid = gp.ClusterUid
	left outer join GCS.Site s on s.SiteUid = c.SiteUid
	left outer join GCS.gcsEntity ent on ent.EntityId = s.EntityId
	GO

ALTER AUTHORIZATION ON [GCS].[AccessPortal_LocationData] TO  SCHEMA OWNER 
GO




IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonUid_GetListByPersonValuesWithParams]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonUid_GetListByPersonValuesWithParams]
GO


/****** Object:  StoredProcedure [GCS].[PersonUid_GetListByPersonValuesWithParams]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonUid_GetListByPersonValuesWithParams]
	@EntityId [uniqueidentifier],
	@SearchByColumnName1 [nvarchar](255),
	@SearchData1 [nvarchar](255),
	@SearchByColumnName2 [nvarchar](255),
	@SearchData2 [nvarchar](255),
	@SearchByColumnName3 [nvarchar](255),
	@SearchData3 [nvarchar](255),
	@SearchByColumnName4 [nvarchar](255),
	@SearchData4 [nvarchar](255),
	@SearchByColumnName5 [nvarchar](255),
	@SearchData5 [nvarchar](255),
	@SearchByColumnName6 [nvarchar](255),
	@SearchData6 [nvarchar](255),
	@SearchByColumnName7 [nvarchar](255),
	@SearchData7 [nvarchar](255),
	@SearchByColumnName8 [nvarchar](255),
	@SearchData8 [nvarchar](255),
	@ExactMatch [smallint] = 0,
	@AnywhereWithin [smallint] = 0,
	@OrNotAnd [smallint] = 0,
	@MaximumResults [int] = 0,
	@PageNumber [int] = 0,
	@PageSize [int] = 0,
	@DateComparisonType [nvarchar](20) = '=',
	@OrderBy nvarchar(255) = 'LastName asc, FirstName asc'
WITH EXECUTE AS CALLER
AS
DECLARE @sql nvarchar(max)

DECLARE @Column nvarchar(255)
DECLARE @Value nvarchar(255)
DECLARE @searchByPersonCredentialColumn smallint 
DECLARE @whereAdded smallint
DECLARE @whereClause nvarchar(max)
DECLARE @pagingSqlClause nvarchar(200)

	BEGIN TRY
	
	SET @whereAdded = 0
	SET @whereClause = ''
	
	if @PageSize is not null AND @PageSize > 0 AND ( @MaximumResults IS NULL OR @MaximumResults = 0 )
	BEGIN
		DECLARE @pagedOffset int
		select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
		set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
	END
	ELSE
		SET @pagingSqlClause = N''


	if @OrderBy is null or len(@OrderBy) = 0
	begin
		set @OrderBy = 'LastName asc, FirstName asc'
	end

    SET @sql = N'SELECT'
	IF @MaximumResults IS NOT NULL AND @MaximumResults > 0 AND @pagingSqlClause = ''
		SET @sql = @sql + N' TOP(' + CAST(@MaximumResults AS NVARCHAR) + ')' 

    SET @sql = @sql + N' PersonUid, LastName, FirstName, InsertDate, UpdateDate, COUNT(*) OVER() as TotalCardCount'
    SET @sql = @sql + N' FROM GCS.Person WHERE PersonUid IN '
	SET @sql = @sql + N' (SELECT DISTINCT(p.PersonUid) FROM GCS.Person p'

	declare @ColumnsValues table
	( 
		ID INT IDENTITY(1, 1),
		ColumnName nvarchar(255),
		ColumnValue nvarchar(255)
	)

	if @SearchByColumnName1 is not null AND LEN(@SearchByColumnName1) > 0
	begin
		insert into @ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName1, @SearchData1)
	end

	if @SearchByColumnName2 is not null AND LEN(@SearchByColumnName2) > 0
	begin
		insert into @ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName2, @SearchData2)
	end

	if @SearchByColumnName3 is not null AND LEN(@SearchByColumnName3) > 0
	begin
		insert into @ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName3, @SearchData3)
	end

	if @SearchByColumnName4 is not null AND LEN(@SearchByColumnName4) > 0
	begin
		insert into @ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName4, @SearchData4)
	end

	if @SearchByColumnName5 is not null AND LEN(@SearchByColumnName5) > 0
	begin
		insert into @ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName5, @SearchData5)
	end

	if @SearchByColumnName6 is not null AND LEN(@SearchByColumnName6) > 0
	begin
		insert into @ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName6, @SearchData6)
	end

	if @SearchByColumnName7 is not null AND LEN(@SearchByColumnName7) > 0
	begin
		insert into @ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName7, @SearchData7)
	end

	if @SearchByColumnName8 is not null AND LEN(@SearchByColumnName8) > 0
	begin
		insert into @ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName8, @SearchData8)
	end

	declare @cnt int
	select @cnt = count(*) from @ColumnsValues
	IF @cnt > 0
	BEGIN
		
		declare @prefixLen int
		declare @prefix nvarchar(100)

		-- REPLACE ALL GCS.PersonCredential column prefixes with pc
		set @prefix = 'GCS.PersonCredential'
		set @prefixLen = LEN(@prefix);
		UPDATE @ColumnsValues SET ColumnName = 'pc' + RIGHT(ColumnName, len(ColumnName)-@prefixLen) WHERE ColumnName LIKE @prefix + '%'

		-- REPLACE ALL GCS.Person column prefixes with p
		set @prefix = 'GCS.Person'
		set @prefixLen = LEN(@prefix);
		UPDATE @ColumnsValues SET ColumnName = 'p' + RIGHT(ColumnName, len(ColumnName)-@prefixLen) WHERE ColumnName LIKE @prefix + '%'

		SELECT @Column = NULL, @Value = NULL, @whereAdded = 0, @whereClause = '', @searchByPersonCredentialColumn = 0
		 
		SET @sql = @sql + N' LEFT OUTER JOIN GCS.PersonCredential pc ON pc.PersonUid = p.PersonUid '
		
		DECLARE ColumnCursor CURSOR FOR 
				SELECT ColumnName, ColumnValue FROM @ColumnsValues

		OPEN ColumnCursor
		
		FETCH NEXT FROM ColumnCursor INTO @Column, @Value
		WHILE @@FETCH_STATUS = 0
		BEGIN
			PRINT 'Column: ' + @Column		
			PRINT 'Value: ' + @Value
			
			IF @Column IS NOT NULL
			BEGIN
				SELECT @whereAdded = 1
				IF LEN(@whereClause) > 0
				BEGIN
					IF @OrNotAnd = 1
					BEGIN
						SET @whereClause = @whereClause + ' OR '
					END
					ELSE
					BEGIN
						SET @whereClause = @whereClause + ' AND '
					END
				END
				ELSE
					SET @whereClause = @whereClause + ' WHERE ( '
				
				IF @Value IS NULL OR LEN(@Value) = 0 OR @Value = 'NULL'
				BEGIN
					SET @whereClause = @whereClause + N'(' + @Column
--					SET @whereClause = @whereClause + N' IS NULL OR ' + @Column + N' = '''')'
					SET @whereClause = @whereClause + N' IS NULL OR ' + @Column + N' LIKE ''%'')'
				END
				ELSE
				BEGIN
					--SET @whereClause = @whereClause + @Column
					IF @ExactMatch = 1
					BEGIN
						SET @whereClause = @whereClause + @Column
						SET @whereClause = @whereClause + N' = '''
						SET @whereClause = @whereClause + @Value
						SET @whereClause = @whereClause + N''''
					END
					ELSE
					BEGIN
						IF @Column IN ('p.DepartmentUid', 'p.PersonUid', 'p.EntityId', 'p.PersonRecordTypeUid', 'p.CountryOfBirthUid', 'p.PersonActiveStatusTypeUid', 'p.GenderUid' )
						BEGIN
							SET @whereClause = @whereClause + @Column
							SET @whereClause = @whereClause + N' = '''
							SET @whereClause = @whereClause + @Value
							SET @whereClause = @whereClause + N''''
						END
						ELSE IF @Column IN ('p.InsertDate', 'p.UpdateDate', 'p.DateOfBirth', 'p.EmploymentDate', 'p.TerminationDate', 'p.ActivationDateTime', 'p.ExpirationDateTime', 'pc.ActivationDateTime', 'pc.ExpirationDateTime', 'pc.BadgeLastPrinted', 'pc.DossierLastPrinted', 'pc.InsertDate', 'pc.UpdateDate')
						BEGIN
							SET @whereClause = @whereClause + N'CAST(CAST(' + @Column + N' AS DATE) AS NVARCHAR(255))'

							SET @whereClause = @whereClause + N' ' + @DateComparisonType
							SET @whereClause = @whereClause + N' '''
							SET @whereClause = @whereClause + @Value
							SET @whereClause = @whereClause + N''''
						END
						ELSE
						BEGIN
							SET @whereClause = @whereClause + @Column
							SET @whereClause = @whereClause + N' LIKE '''
							if @AnywhereWithin = 1
							begin
								SET @whereClause = @whereClause + N'%'
							end
							SET @whereClause = @whereClause + @Value
							SET @whereClause = @whereClause + N'%'''
						END
					END	
				END			
				DECLARE @cardPrefix nvarchar(20)
				SET @cardPrefix = 'pc.'
				IF  LEFT(@Column, LEN(@cardPrefix))= @cardPrefix 
				BEGIN
					PRINT 'Search column in PersonCredential table'
					SET @searchByPersonCredentialColumn = 1
				END	
			END
		FETCH NEXT FROM ColumnCursor INTO @Column, @Value
		END
		CLOSE ColumnCursor;
		DEALLOCATE ColumnCursor;		
	END
	
	IF @whereAdded = 1
		SET @whereClause = @whereClause + ' ) '
			 

	IF @whereAdded = 1
		SET @whereClause = @whereClause + ' AND '
	ELSE
		SET @whereClause = @whereClause + ' WHERE '

	SELECT @whereAdded = 1
	SET @whereClause = @whereClause + N' ( p.EntityId = '''
	set @whereClause = @whereClause + cast(@EntityId as nvarchar(40)) + N''')'

	IF @whereAdded = 1
	BEGIN
		SET @whereClause = @whereClause + ' ) '
		SET @sql = @sql + @whereClause
	END
	ELSE
		SET @sql = @sql +  ' ) '
		
	
    SET @sql = @sql + ' ORDER BY '
    
    SET @sql = @sql + @OrderBy
    
	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @sql = @sql + @pagingSqlClause
	END
	
    print @sql
    execute sp_executesql @sql 
	
	END TRY
	BEGIN CATCH
		exec [usp_GetErrorInfo] 0,1
	END CATCH			

GO
ALTER AUTHORIZATION ON [GCS].[PersonUid_GetListByPersonValuesWithParams] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonUid_GetListByPersonValuesWithParams] TO [public] AS [dbo]
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonUid_GetRecentlyAddedOrUpdated]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonUid_GetRecentlyAddedOrUpdated]
GO

/****** Object:  StoredProcedure [GCS].[PersonUid_GetRecentlyAddedOrUpdated]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonUid_GetRecentlyAddedOrUpdated]
	@EntityId [uniqueidentifier],
	@AddedOrUpdatedSince [datetimeoffset],
	@MaximumResults [int] = 0,
	@PageNumber [int] = 0,
	@PageSize [int] = 0,
	@OrderBy [nvarchar](1000) = 'LastName asc, FirstName asc'
WITH EXECUTE AS CALLER
AS
DECLARE @sql nvarchar(max)

DECLARE @dateString nvarchar(100)
DECLARE @pagingSqlClause nvarchar(200)

	BEGIN TRY

	if @OrderBy is null or len(@OrderBy) = 0
	begin
		set @OrderBy = 'LastName asc, FirstName asc'
	end
		
	SET @dateString = CAST(@AddedOrUpdatedSince AS NVARCHAR)
	
	if @PageSize is not null AND @PageSize > 0 AND ( @MaximumResults IS NULL OR @MaximumResults = 0 )
	BEGIN
		DECLARE @pagedOffset int
		select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
		set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
	END
	ELSE
		SET @pagingSqlClause = N''


    SET @sql = N'SELECT'
	IF @MaximumResults IS NOT NULL AND @MaximumResults > 0 AND @pagingSqlClause = ''
		SET @sql = @sql + N' TOP(' + CAST(@MaximumResults AS NVARCHAR) + ')' 
    SET @sql = @sql + N' PersonUid, LastName, FirstName, InsertDate, UpdateDate, COUNT(*) OVER() as TotalCount FROM GCS.Person WHERE PersonUid IN (SELECT DISTINCT(p.PersonUid) FROM GCS.Person p left outer join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid '
	set @sql = @sql + N' left outer join GCS.Credential c on c.CredentialUid = pc.CredentialUid'
	set @sql = @sql + N' left outer join GCS.PersonAccessControlProperties pacp on pacp.PersonUid = p.PersonUid'
	set @sql = @sql + N' left outer join GCS.PersonOtisElevator otis on otis.PersonUid = p.PersonUid'
	set @sql = @sql + N' left outer join GCS.PersonAddress addr on addr.PersonUid = p.PersonUid'
	set @sql = @sql + N' left outer join GCS.PersonNote note on note.PersonUid = p.PersonUid'
	set @sql = @sql + N' left outer join GCS.PersonPhoneNumber phone on phone.PersonUid = p.PersonUid'
	set @sql = @sql + N' left outer join GCS.PersonEmailAddress email on email.PersonUid = p.PersonUid'
	set @sql = @sql + N' left outer join GCS.PersonClusterPermission clusters on clusters.PersonUid = p.PersonUid '
	set @sql = @sql + N' left outer join GCS.PersonPhoto photo on photo.PersonUid = p.PersonUid '
	set @sql = @sql + N' left outer join GCS.PersonLcdMessage lcd on lcd.PersonUid = p.PersonUid '
	set @sql = @sql + N' left outer join GCS.PersonTextProperty txtProp on txtProp.PersonUid = p.PersonUid '
	set @sql = @sql + N' left outer join GCS.PersonNumberProperty numProp on numProp.PersonUid = p.PersonUid '
	set @sql = @sql + N' left outer join GCS.PersonDateProperty dateProp on dateProp.PersonUid = p.PersonUid '
	set @sql = @sql + N' left outer join GCS.PersonBooleanProperty boolProp on boolProp.PersonUid = p.PersonUid '
	set @sql = @sql + N' left outer join GCS.PersonPropertyBag bagProp on bagProp.PersonUid = p.PersonUid '
	set @sql = @sql + N' left outer join GCS.PersonListPropertyItem liProp on liProp.PersonUid = p.PersonUid '
	set @sql = @sql + N' WHERE ('
	set @sql = @sql + N' p.InsertDate >= ''' + @dateString + N''' OR p.UpdateDate >= ''' + @dateString + N''''
	set @sql = @sql + N' OR pc.InsertDate >= ''' + @dateString + N''' OR pc.UpdateDate >= ''' + @dateString + N''''
	set @sql = @sql + N' OR c.InsertDate >= ''' + @dateString + N''' OR c.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR pacp.InsertDate >= ''' + @dateString + N''' OR pacp.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR otis.InsertDate >= ''' + @dateString + N''' OR otis.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR addr.InsertDate >= ''' + @dateString + N''' OR addr.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR note.InsertDate >= ''' + @dateString + N''' OR note.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR phone.InsertDate >= ''' + @dateString + N''' OR phone.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR email.InsertDate >= ''' + @dateString + N''' OR email.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR clusters.InsertDate >= ''' + @dateString + N''' OR clusters.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR photo.InsertDate >= ''' + @dateString + N''' OR photo.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR lcd.InsertDate >= ''' + @dateString + N''' OR lcd.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR txtProp.InsertDate >= ''' + @dateString + N''' OR txtProp.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR numProp.InsertDate >= ''' + @dateString + N''' OR numProp.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR dateProp.InsertDate >= ''' + @dateString + N''' OR dateProp.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR boolProp.InsertDate >= ''' + @dateString + N''' OR boolProp.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR bagProp.InsertDate >= ''' + @dateString + N''' OR bagProp.UpdateDate >= ''' + @dateString + N''''
	SET @sql = @sql + N' OR liProp.InsertDate >= ''' + @dateString + N''' OR liProp.UpdateDate >= ''' + @dateString + N''''

	set @sql = @sql + N') AND EntityId = ''' + cast(@EntityId as nvarchar(40)) + N''') ORDER BY ' + @OrderBy

	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @sql = @sql + @pagingSqlClause
	END

    print @sql
    execute sp_executesql @sql 
	
	END TRY
	BEGIN CATCH
		exec [usp_GetErrorInfo] 0,1
	END CATCH			

GO
ALTER AUTHORIZATION ON [GCS].[PersonUid_GetRecentlyAddedOrUpdated] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonUid_GetRecentlyAddedOrUpdated] TO [public] AS [dbo]
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonUid_GetByCredentialFieldValues]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonUid_GetByCredentialFieldValues]
GO

/****** Object:  StoredProcedure [GCS].[PersonUid_GetByCredentialFieldValues]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonUid_GetByCredentialFieldValues]
	@CredentialParts [nvarchar](100),
	@EntityId [uniqueidentifier] = null,
	@OrderBy [nvarchar](1000) = 'LastName asc, FirstName asc'
WITH EXECUTE AS CALLER
AS
DECLARE @pagingSqlClause nvarchar(200)
DECLARE @sql nvarchar(max)
DECLARE @credType nvarchar(100)
DECLARE @credPart1 nvarchar(100)
DECLARE @credPart2 nvarchar(100)
DECLARE @credPart3 nvarchar(100)
DECLARE @credPart4 nvarchar(100)
DECLARE @credPart5 nvarchar(100)
declare @partCounter int

	set @partCounter = 0

	BEGIN TRY
		if @OrderBy is null or len(@OrderBy) = 0
		begin
			set @OrderBy = 'LastName asc, FirstName asc'
		end

		DECLARE @part nvarchar(100)
		SELECT * INTO #CredentialParts FROM fnSPLIT_nVARCHAR( @CredentialParts, N':')	
		DECLARE CredentialPartsCursor CURSOR FOR 
				SELECT NVARCHAR_DATA FROM #CredentialParts
		OPEN CredentialPartsCursor
		
		FETCH NEXT FROM CredentialPartsCursor INTO @part
		WHILE @@FETCH_STATUS = 0
		BEGIN
			PRINT @part
			if @partCounter = 0
				set @credType = @part
			else if @partCounter = 1
				set @credPart1 = @part
			else if @partCounter = 2
				set @credPart2 = @part
			else if @partCounter = 3
				set @credPart3 = @part
			else if @partCounter = 4
				set @credPart4 = @part
			else if @partCounter = 5
				set @credPart5 = @part

			set @partCounter = @partCounter + 1
			FETCH NEXT FROM CredentialPartsCursor INTO @part
		END
		CLOSE CredentialPartsCursor;
		DEALLOCATE CredentialPartsCursor;	
	
		declare @personUid uniqueidentifier
		declare @lastName nvarchar(65)
		declare @firstName nvarchar(65)
		declare @InsertDate datetimeoffset
		declare @UpdateDate datetimeoffset

		if @credType = 'Wiegand26Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.Credential26BitStandard cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.Credential26BitStandard cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end	
		else if @credType = 'HIDCorp1K35Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCorporate1K35Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.CompanyCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCorporate1K35Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.CompanyCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end	
		else if @credType = 'HIDCorp1K48Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCorporate1K48Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.CompanyCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCorporate1K48Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.CompanyCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end		
		else if @credType = 'PIV75Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialPIV75Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.AgencyCode = @credPart1 AND cd.SiteCode = @credPart2 AND cd.CredentialCode = @credPart3
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialPIV75Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.AgencyCode = @credPart1 AND cd.SiteCode = @credPart2 AND cd.CredentialCode = @credPart3 AND p.EntityId = @EntityId
		end		
		else if @credType = 'BQT36Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialBqt36Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2 AND cd.IssueCode = @credPart3
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialBqt36Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2 AND cd.IssueCode = @credPart3 AND p.EntityId = @EntityId
		end		
		else if @credType = 'XceedID40Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialXceedId40Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.SiteCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialXceedId40Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.SiteCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end		
		else if @credType = 'Cypress37Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCypress37Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCypress37Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end	
		else if @credType = 'HIDH1030437Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialH1030437Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialH1030437Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end	
		else if @credType = 'HIDH1030237Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialH1030237Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.IdCode = @credPart1
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialH1030237Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.IdCode = @credPart1 AND p.EntityId = @EntityId
		end	
		else if @credType = 'SoftwareHouse37Bit '
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialSoftwareHouse37Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.SiteCode = @credPart2 AND cd.IdCode = @credPart3
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialSoftwareHouse37Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.SiteCode = @credPart2 AND cd.IdCode = @credPart3 AND p.EntityId = @EntityId
		end	


		if @personUid is not null
			select @personUid, @lastName, @firstName, @insertDate, @updateDate, 1 as TotalCount
		else
			select PersonUid, LastName, FirstName, @insertDate, @updateDate, 1 as TotalCount from GCS.Person where PersonUid is null
	
	END TRY
	BEGIN CATCH
		exec [usp_GetErrorInfo] 0,1
	END CATCH			

GO
ALTER AUTHORIZATION ON [GCS].[PersonUid_GetByCredentialFieldValues] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonUid_GetByCredentialFieldValues] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonUid_GetByCardNumber]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonUid_GetByCardNumber]
GO

/****** Object:  StoredProcedure [GCS].[PersonUid_GetByCardNumber]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonUid_GetByCardNumber]
	@CardNumber [nvarchar](100),
	@EntityId [uniqueidentifier] = null,
	@MaximumResults [int] = 0,
	@PageNumber [int] = 0,
	@PageSize [int] = 0,
	@OrderBy [nvarchar](1000) = 'LastName asc, FirstName asc'
WITH EXECUTE AS CALLER
AS
DECLARE @pagingSqlClause nvarchar(200)
DECLARE @sql nvarchar(max)
	
	BEGIN TRY
		
	if @PageSize is not null AND @PageSize > 0 AND ( @MaximumResults IS NULL OR @MaximumResults = 0 )
	BEGIN
		DECLARE @pagedOffset int
		select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
		set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
	END
	ELSE
		SET @pagingSqlClause = N''

	if @OrderBy is null or len(@OrderBy) = 0
	begin
		set @OrderBy = 'LastName asc, FirstName asc'
	end

    SET @sql = N'SELECT'
	IF @MaximumResults IS NOT NULL AND @MaximumResults > 0 AND @pagingSqlClause = ''
		SET @sql = @sql + N' TOP(' + CAST(@MaximumResults AS NVARCHAR) + ')' 

    SET @sql = @sql + N' PersonUid, LastName, FirstName, InsertDate, UpdateDate, COUNT(*) OVER() as TotalCount FROM GCS.Person WHERE PersonUid IN (SELECT DISTINCT(pc.PersonUid) from GCS.Credential c JOIN GCS.PersonCredential pc on pc.CredentialUid = c.CredentialUid '
	
	if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
	BEGIN
		SET @sql = @sql + N' where c.CardNumber = ''' 
		set @sql = @sql + @CardNumber + N''')'
	END
	else
	BEGIN
		SET @sql = @sql + N' join GCS.Person p on p.PersonUid = pc.PersonUid where c.CardNumber = ''' 
		set @sql = @sql + @CardNumber + N''' AND p.EntityId = ''' 
		SET @sql = @sql + cast(@EntityId as nvarchar(100)) + N''')'
	END
		
	SET @sql = @sql + N' ORDER BY ' + @OrderBy

	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @sql = @sql + @pagingSqlClause
	END

    print @sql
    execute sp_executesql @sql 
	
	END TRY
	BEGIN CATCH
		exec [usp_GetErrorInfo] 0,1
	END CATCH			

GO
ALTER AUTHORIZATION ON [GCS].[PersonUid_GetByCardNumber] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonUid_GetByCardNumber] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonUid_GetByCardFieldValue]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonUid_GetByCardFieldValue]
GO

/****** Object:  StoredProcedure [GCS].[PersonUid_GetByCardFieldValue]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonUid_GetByCardFieldValue]
	@IdNumber [bigint],
	@EntityId [uniqueidentifier] = null,
	@MaximumResults [int] = 0,
	@PageNumber [int] = 0,
	@PageSize [int] = 0,
	@OrderBy [nvarchar](1000) = 'LastName asc, FirstName asc'
WITH EXECUTE AS CALLER
AS
DECLARE @pagingSqlClause nvarchar(200)
DECLARE @sql nvarchar(max)
	
	BEGIN TRY
		
	if @PageSize is not null AND @PageSize > 0 AND ( @MaximumResults IS NULL OR @MaximumResults = 0 )
	BEGIN
		DECLARE @pagedOffset int
		select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
		set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
	END
	ELSE
		SET @pagingSqlClause = N''

	if @OrderBy is null or len(@OrderBy) = 0
	begin
		set @OrderBy = 'LastName asc, FirstName asc'
	end

    SET @sql = N'SELECT'
	IF @MaximumResults IS NOT NULL AND @MaximumResults > 0 AND @pagingSqlClause = ''
		SET @sql = @sql + N' TOP(' + CAST(@MaximumResults AS NVARCHAR) + ')' 

    SET @sql = @sql + N' PersonUid, LastName, FirstName, InsertDate, UpdateDate, COUNT(*) OVER() as TotalCount FROM GCS.Person WHERE PersonUid IN (SELECT DISTINCT(pc.PersonUid) from GCS.Credential c JOIN GCS.PersonCredential pc on pc.CredentialUid = c.CredentialUid join GCS.Person p on p.PersonUid = pc.PersonUid where pc.CredentialUid in (' 
	SET @sql = @sql + N' SELECT c.CredentialUid FROM GCS.Credential c WHERE c.CardNumber = '''+ cast(@idNumber as nvarchar(100)) + ''''
	SET @sql = @sql + N' UNION SELECT CredentialUid FROM GCS.Credential26BitStandard WHERE IdCode = '+ cast(@idNumber as nvarchar(100)) + N' OR FacilityCode = '+ cast(@idNumber as nvarchar(100))
	SET @sql = @sql + N' UNION SELECT CredentialUid FROM GCS.CredentialCorporate1K35Bit WHERE IdCode = '+ cast(@idNumber as nvarchar(100)) + N' OR CompanyCode = '+ cast(@idNumber as nvarchar(100))
	SET @sql = @sql + N' UNION SELECT CredentialUid FROM GCS.CredentialCorporate1K48Bit WHERE IdCode = '+ cast(@idNumber as nvarchar(100)) + N' OR CompanyCode = '+ cast(@idNumber as nvarchar(100))
	SET @sql = @sql + N' UNION SELECT CredentialUid FROM GCS.CredentialCypress37Bit WHERE IdCode = '+ cast(@idNumber as nvarchar(100)) + N' OR FacilityCode = '+ cast(@idNumber as nvarchar(100)) 
	SET @sql = @sql + N' UNION SELECT CredentialUid FROM GCS.CredentialData WHERE Number1 = '+ cast(@idNumber as nvarchar(100)) + N' OR Number2 = '+ cast(@idNumber as nvarchar(100)) + N' OR Number3 = '+ cast(@idNumber as nvarchar(100)) + N' OR Number4 = '+ cast(@idNumber as nvarchar(100)) + N' OR Number5 = '+ cast(@idNumber as nvarchar(100)) 
	SET @sql = @sql + N' UNION SELECT CredentialUid FROM GCS.CredentialH1030437Bit WHERE IdCode = '+ cast(@idNumber as nvarchar(100)) + N' OR FacilityCode = '+ cast(@idNumber as nvarchar(100)) 
	SET @sql = @sql + N' UNION SELECT CredentialUid FROM GCS.CredentialPIV75Bit WHERE CredentialCode = '+ cast(@idNumber as nvarchar(100)) + N' OR AgencyCode = '+ cast(@idNumber as nvarchar(100)) + N' OR SiteCode = '+ cast(@idNumber as nvarchar(100))
	SET @sql = @sql + N' UNION SELECT CredentialUid FROM GCS.CredentialXceedId40Bit WHERE IdCode = '+ cast(@idNumber as nvarchar(100)) + N' OR SiteCode = '+ cast(@idNumber as nvarchar(100)) 
	SET @sql = @sql + N' UNION SELECT CredentialUid FROM GCS.CredentialBqt36Bit WHERE IdCode = '+ cast(@idNumber as nvarchar(100)) + N' OR FacilityCode = '+ cast(@idNumber as nvarchar(100)) + N' OR IssueCode = '+ cast(@idNumber as nvarchar(100))
	SET @sql = @sql + N')'

	IF @EntityId IS NOT NULL AND @EntityId <> '00000000-0000-0000-0000-000000000000'
	BEGIN
		SET @sql = @sql + N' AND p.EntityId = ''' + cast(@EntityId as nvarchar(100)) + ''''
	END	
	SET @sql = @sql + N')'

	set @sql = @sql + N' ORDER BY ' + @OrderBy

	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @sql = @sql + @pagingSqlClause
	END

    print @sql
    execute sp_executesql @sql 
	
	END TRY
	BEGIN CATCH
		exec [usp_GetErrorInfo] 0,1
	END CATCH			

GO
ALTER AUTHORIZATION ON [GCS].[PersonUid_GetByCardFieldValue] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonUid_GetByCardFieldValue] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonUid_GetByAccessProfileUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonUid_GetByAccessProfileUid]
GO

/****** Object:  StoredProcedure [GCS].[PersonUid_GetByAccessProfileUid]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonUid_GetByAccessProfileUid]
	@AccessProfileUid [uniqueidentifier],
	@EntityId [uniqueidentifier] = null,
	@MaximumResults [int] = 0,
	@PageNumber [int] = 0,
	@PageSize [int] = 0,
	@OrderBy [nvarchar](1000) = 'LastName asc, FirstName asc'
WITH EXECUTE AS CALLER
AS
DECLARE @pagingSqlClause nvarchar(200)
DECLARE @sql nvarchar(max)
	
	BEGIN TRY
		
	if @PageSize is not null AND @PageSize > 0 AND ( @MaximumResults IS NULL OR @MaximumResults = 0 )
	BEGIN
		DECLARE @pagedOffset int
		select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
		set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
	END
	ELSE
		SET @pagingSqlClause = N''

	if @OrderBy is null or len(@OrderBy) = 0
	begin
		set @OrderBy = 'LastName asc, FirstName asc'
	end

    SET @sql = N'SELECT'
	IF @MaximumResults IS NOT NULL AND @MaximumResults > 0 AND @pagingSqlClause = ''
		SET @sql = @sql + N' TOP(' + CAST(@MaximumResults AS NVARCHAR) + ')' 

    SET @sql = @sql + N' PersonUid, LastName, FirstName, InsertDate, UpdateDate, COUNT(*) OVER() as TotalCount FROM GCS.Person WHERE PersonUid IN (SELECT DISTINCT(c.PersonUid) from GCS.PersonAccessControlProperties c join GCS.Person p on p.PersonUid = c.PersonUid where c.AccessProfileUid = ''' 
	SET @sql = @sql + cast(@AccessProfileUid as nvarchar(100))
	SET @sql = @sql + N''''


	IF @EntityId IS NOT NULL AND @EntityId <> '00000000-0000-0000-0000-000000000000'
	BEGIN
		SET @sql = @sql + N' AND p.EntityId = ''' + cast(@EntityId as nvarchar(100)) + ''''
	END	
	SET @sql = @sql + N')'

	set @sql = @sql + N' ORDER BY ' + @OrderBy

	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @sql = @sql + @pagingSqlClause
	END

    print @sql
    execute sp_executesql @sql 
	
	END TRY
	BEGIN CATCH
		exec [usp_GetErrorInfo] 0,1
	END CATCH			

GO
ALTER AUTHORIZATION ON [GCS].[PersonUid_GetByAccessProfileUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonUid_GetByAccessProfileUid] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonSummary_SearchWithParams]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonSummary_SearchWithParams]
GO
/****** Object:  StoredProcedure [GCS].[PersonSummary_SearchWithParams]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonSummary_SearchWithParams]
	@EntityId [uniqueidentifier],
	@SearchByColumnName1 [nvarchar](255),
	@SearchData1 [nvarchar](255),
	@SearchByColumnName2 [nvarchar](255),
	@SearchData2 [nvarchar](255),
	@SearchByColumnName3 [nvarchar](255),
	@SearchData3 [nvarchar](255),
	@SearchByColumnName4 [nvarchar](255),
	@SearchData4 [nvarchar](255),
	@SearchByColumnName5 [nvarchar](255),
	@SearchData5 [nvarchar](255),
	@SearchByColumnName6 [nvarchar](255),
	@SearchData6 [nvarchar](255),
	@SearchByColumnName7 [nvarchar](255),
	@SearchData7 [nvarchar](255),
	@SearchByColumnName8 [nvarchar](255),
	@SearchData8 [nvarchar](255),
	@CredentialPartNumber [bigint],
	@UidValue [uniqueidentifier] = '00000000-0000-0000-0000-000000000000',
	@ExactMatch [smallint] = 0,
	@AnywhereWithin [smallint] = 0,
	@OrNotAnd [smallint] = 0,
	@OrderBy [nvarchar](1000) = 'LastName asc, FirstName asc',
	@MaximumResults [int] = 0,
	@PageNumber [int] = 0,
	@PageSize [int] = 0,
	@DateComparisonType [nvarchar](20) = '=',
	@CultureName [nvarchar](20) = NULL,
	@IncludeLastUsageData bit = 0
WITH EXECUTE AS CALLER
AS
DECLARE @sql nvarchar(max)

DECLARE @pagingSqlClause nvarchar(200)

	if @PageSize is not null AND @PageSize > 0 AND ( @MaximumResults IS NULL OR @MaximumResults = 0 )
	BEGIN
		DECLARE @pagedOffset int
		select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
		set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY '
	END
	ELSE
		SET @pagingSqlClause = N''

CREATE TABLE #PersonUids
( 
	ID INT IDENTITY(1, 1),
    PersonUid uniqueidentifier,
	LastName nvarchar(65),
	FirstName nvarchar(65),
	InsertDate datetimeoffset,
	UpdateDate datetimeoffset,
	TotalCardCount int
)

CREATE TABLE #PersonUidsPaged
( 
    PersonUid uniqueidentifier,
	LastName nvarchar(65),
	FirstName nvarchar(65),
	InsertDate datetimeoffset,
	UpdateDate datetimeoffset,
	TotalCardCount int
)

    IF @OrderBy IS NULL OR LEN(@OrderBy) = 0
    BEGIN
		SET @OrderBy = 'LastName asc, FirstName asc'
	END

	if @SearchByColumnName1 = 'RecentlyAddedOrModified'
	BEGIN
		insert into #PersonUids (PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount)
		exec [GCS].[PersonUid_GetRecentlyAddedOrUpdated] @EntityId, @SearchData1, 0, 0, 0, @OrderBy
	END
	ELSE IF @SearchByColumnName1 = 'ByCredentialFieldValues'
	BEGIN
		insert into #PersonUids (PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount)
		exec [GCS].[PersonUid_GetByCredentialFieldValues] @SearchData1, @EntityId, @OrderBy
	END
	ELSE IF @SearchByColumnName1 = 'ByCredentialNumber'
	BEGIN
		insert into #PersonUids (PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount)
		exec [GCS].[PersonUid_GetByCardNumber] @SearchData1, @EntityId, 0, 0, 0, @OrderBy
	END
	ELSE IF @SearchByColumnName1 = 'ByCredentialFieldValue'
	BEGIN
		insert into #PersonUids (PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount)
		exec [GCS].[PersonUid_GetByCardFieldValue] @CredentialPartNumber, @EntityId, 0, 0, 0, @OrderBy
	END
	ELSE IF @SearchByColumnName1 = 'ByAccessProfileUid'
	BEGIN
		insert into #PersonUids (PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount)
		exec [GCS].[PersonUid_GetByAccessProfileUid] @UidValue, @EntityId, @MaximumResults, 0, 0, @OrderBy
	END	ELSE
	BEGIN
		insert into #PersonUids (PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount)
		exec GCS.[PersonUid_GetListByPersonValuesWithParams] @EntityId,@SearchByColumnName1,@SearchData1,@SearchByColumnName2,@SearchData2,@SearchByColumnName3,@SearchData3,@SearchByColumnName4,@SearchData4,@SearchByColumnName5,@SearchData5,@SearchByColumnName6,@SearchData6,@SearchByColumnName7,@SearchData7,@SearchByColumnName8,@SearchData8, @ExactMatch, @AnywhereWithin, @OrNotAnd, @MaximumResults, 0, 0, @DateComparisonType, @OrderBy
	END


	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @sql = N'insert into #PersonUidsPaged (PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount) SELECT PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount FROM #PersonUids ORDER BY ' + @OrderBy + @pagingSqlClause
	END
	ELSE
	BEGIN
		set @sql = N'insert into #PersonUidsPaged (PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount) SELECT PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount FROM #PersonUids ORDER BY ' + @OrderBy 
	END
	print @sql
	execute sp_executesql @sql 
	 
	-- -- For debugging only
	--set @sql = N'SELECT * FROM #PersonUidsPaged ORDER BY ' + @OrderBy 
	--execute sp_executesql @sql 

	IF @CultureName IS NULL OR LEN(@CultureName) = 0 SET @CultureName = 'en-US'

	declare @languageId uniqueidentifier
	select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

    SET @sql = N'SELECT'
	IF @MaximumResults IS NOT NULL AND @MaximumResults > 0 AND @pagingSqlClause = ''
		SET @sql = @sql + N' DISTINCT TOP(' + CAST(@MaximumResults AS NVARCHAR) + ')' 

    --SET @sql = @sql + N' p.PersonUid, PersonId, FirstName, MiddleName, LastName, NickName, LegalName, FullName, PreferredName, Company, Trace, VeryImportantPerson, HasPhysicalDisability, e.EntityName, d.DepartmentName, p.EntityId, ActivationDateTime, ExpirationDateTime, p.InsertName, p.InsertDate, p.UpdateName, p.UpdateDate, p.SysGalEmployeeId, [GCS].[IsPersonActive](p.PersonUid) as IsPersonActive' 
	  SET @sql = @sql + N' p.PersonUid, PersonId, FirstName, MiddleName, LastName, NickName, LegalName, FullName, PreferredName, Company, Trace, VeryImportantPerson, HasPhysicalDisability, e.EntityName, d.DepartmentName, p.EntityId, p.ActivationDateTime, p.ExpirationDateTime, p.InsertName, p.InsertDate, p.UpdateName, p.UpdateDate, p.SysGalEmployeeId, [GCS].[GetPersonActiveStatusCode](p.PersonUid) as ActiveStatusCode' 

	if @IncludeLastUsageData = 1
	BEGIN
		SET @sql = @sql + N', ev1.ActivityDateTime as LastUsageActivityDateTime, ap.PortalName as LastUsageAccessPortal, ap.ClusterName as LastUsageClusterName, ap.SiteName as LastUsageSiteName, ap.EntityName as LastUsageEntityName, pcred.CredentialDescription as LastCredentialName'
	END
	ELSE
	BEGIN
		SET @sql = @sql + N', SYSDATETIMEOFFSET() as LastUsageActivityDateTime, '''' as LastUsageAccessPortal, '''' as LastUsageClusterName, '''' as LastUsageSiteName, '''' as LastUsageEntityName, '''' as LastCredentialName'
	END

    SET @sql = @sql + N' ,CASE WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = st.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(40)) + ''')'
	SET @sql = @sql + N' IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = st.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(40)) + ''')'
	SET @sql = @sql + N' WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = st.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = st.DisplayResourceKey) ELSE st.Display END AS ActiveStatus'
	SET @sql = @sql + N' ,CASE WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = rt.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(40)) + ''')'
	SET @sql = @sql + N' IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = rt.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(40)) + ''')'
	SET @sql = @sql + N' WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = rt.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = rt.DisplayResourceKey) ELSE rt.Display END AS RecordType '

	IF @SearchByColumnName1 IS NOT NULL AND @SearchByColumnName1 NOT IN ('RecentlyAddedOrModified', 'ByCredentialFieldValues', 'ByCredentialNumber', 'ByCredentialFieldValue', 'ByAccessProfileUid')
	BEGIN
		IF @SearchByColumnName1 IS NULL OR LEN(@SearchByColumnName1) = 0
		BEGIN
			SET @sql = @sql + N' , ''All Records'' AS SearchField'
		END
		ELSE
		BEGIN
			declare @prefix nvarchar(100)
			set @prefix = 'GCS.PersonCredential'
			SELECT @SearchByColumnName1 = REPLACE(@SearchByColumnName1,@prefix,'pc');

			-- REPLACE ALL GCS.Person column prefixes with p
			set @prefix = 'GCS.Person'
			SELECT @SearchByColumnName1 = REPLACE(@SearchByColumnName1,@prefix,'p');

			SET @sql = @sql + N' ,' + @SearchByColumnName1 + N' AS ''SearchField'''
		END
	END
	ELSE
		SET @sql = @sql + N' , ''' + @SearchByColumnName1 + ''' AS SearchField'

    SET @sql = @sql + N' , COUNT(*) OVER() as TotalCardCount  '	
     
	SET @sql = @sql + N' INTO #TempTable   '	
    SET @sql = @sql + N' from GCS.Person p join GCS.gcsEntity e on e.EntityId = p.EntityId '
    SET @sql = @sql + N' left outer join GCS.Department d on d.DepartmentUid = p.DepartmentUid '
    SET @sql = @sql + N' left outer join GCS.PersonActiveStatusType st on st.PersonActiveStatusTypeUid = p.PersonActiveStatusTypeUid '
    SET @sql = @sql + N' left outer join GCS.PersonRecordType rt on rt.PersonRecordTypeUid = p.PersonRecordTypeUid'
	if @IncludeLastUsageData = 1
	BEGIN
		SET @sql = @sql + N' left outer join GCS.PersonLastUsage plu on plu.PersonUid = p.PersonUid'
		SET @sql = @sql + N' left outer join GCS.AccessPortalActivityEvent ev1 on ev1.AccessPortalActivityEventUid = plu.LastAccessGrantedAccessPortalActivityEventUid'
		SET @sql = @sql + N' left outer join GCS.AccessPortal_LocationData ap on ap.AccessPortalUid = ev1.AccessPortalUid'
		SET @sql = @sql + N' left outer join GCS.PersonCredential pcred on pcred.CredentialUid = ev1.CredentialUid AND pcred.PersonUid = p.PersonUid'
	END
    SET @sql = @sql + N' WHERE p.PersonUid IN '
	SET @sql = @sql + N' ( SELECT PersonUid from #PersonUidsPaged )'

--	PRINT @sql
 --   IF @ORDERBY IS NULL OR LEN(@ORDERBY) = 0
	--BEGIN
	--	SET @ORDERBY = 'LastName, FirstName'
	--END   
	 
    SET @sql = @sql + N' ORDER BY '
    SET @sql = @sql + @OrderBy
	
	SET @sql = @sql + N'; SELECT *, (select count(*) from #PersonUids) as TotalPersonCount from #tempTable ORDER BY '
    SET @sql = @sql + @OrderBy
	SET @sql = @sql + N';'
	SET @sql = @sql + N'drop table #tempTable;'

    print @sql

    execute sp_executesql @sql 
	
	DROP TABLE #PersonUidsPaged
	DROP TABLE #PersonUids
GO
ALTER AUTHORIZATION ON [GCS].[PersonSummary_SearchWithParams] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonSummary_SearchWithParams] TO [public] AS [dbo]
GO

if dbo.fn_GCSDoesColumnExist('gcsEntity', 'EntityType') = 0
BEGIN
	ALTER TABLE [GCS].[gcsEntity]
	ADD EntityType GCS.Text65  NULL 
END
go 


if dbo.fn_GCSDoesColumnExist('gcsEntity', 'AutoMapTimeSchedules') = 0
BEGIN
	ALTER TABLE [GCS].[gcsEntity]
	ADD AutoMapTimeSchedules bit                  not null default 1
END
go 



/* All Stored Procedures for table: gcsEntity */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_SelectAll]
@PageNumber int = 0,
@PageSize int = 0,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@ActiveOnly bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsEntity

if @PageSize = 0
	set @PageSize = 1

SELECT 
e.EntityId as EntityId
,e.EntityName as EntityName
,e.EntityDescription as EntityDescription
,e.EntityKey as EntityKey
,e.IsDefault as IsDefault
,e.IsActive as IsActive
,e.EntityType as EntityType
,e.AutoMapTimeSchedules
,e.ClusterGroupId
,e.TimeZoneId
,e.InsertName as InsertName
,e.InsertDate as InsertDate
,e.UpdateName as UpdateName
,e.UpdateDate as UpdateDate
,e.ConcurrencyValue as ConcurrencyValue
,e.BinaryResourceUid as BinaryResourceUid
,e.License as License
,e.PublicKey as PublicKey
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
WHERE e.IsActive between 
(case when @ActiveOnly = 0 then 0 else 1 end)
and 1
ORDER BY (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 0 THEN e.EntityName end) asc,
         (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 1 THEN e.EntityName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN e.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN e.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN e.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN e.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_SelectAll] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsEntity table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_SelectAllForUser]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_SelectAllForUser]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_SelectAllForUser]
@UserId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@ActiveOnly bit = 0,
@IgnoreEntityId uniqueidentifier = NULL,
@ParentEntityId uniqueidentifier = NULL,
@SearchText nvarchar(255) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsEntity

IF @IgnoreEntityId = '00000000-0000-0000-0000-000000000000'
    SET @IgnoreEntityId  = NULL

IF @ParentEntityId = '00000000-0000-0000-0000-000000000000'
    SET @ParentEntityId = NULL

SELECT 
e.EntityId as EntityId
,e.EntityName as EntityName
,e.EntityDescription as EntityDescription
,e.EntityKey as EntityKey
,e.IsDefault as IsDefault
,e.IsActive as IsActive
,e.EntityType as EntityType
,e.AutoMapTimeSchedules
,e.ClusterGroupId
,e.TimeZoneId
,e.InsertName as InsertName
,e.InsertDate as InsertDate
,e.UpdateName as UpdateName
,e.UpdateDate as UpdateDate
,e.ConcurrencyValue as ConcurrencyValue
,e.BinaryResourceUid as BinaryResourceUid
,e.License as License
,e.PublicKey as PublicKey
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
WHERE e.EntityId IN (SELECT EntityId from GCS.gcsUserEntity WHERE UserId = @UserId) AND
(@IgnoreEntityId IS NULL OR e.EntityId <> @IgnoreEntityId) AND
(@ParentEntityId IS NULL OR e.ParentEntityId = @ParentEntityId) AND
(@SearchText IS NULL OR e.EntityName LIKE '%' + @SearchText + '%' OR e.EntityDescription LIKE '%' + @SearchText + '%') AND
e.IsActive between 
(case when @ActiveOnly = 0 then 0 else 1 end)
and 1
order by (case when @SortColumn = 'EntityName' and @DescendingOrder = 0 then e.EntityName end)  asc,
         (case when @SortColumn = 'EntityName' and @DescendingOrder = 1 then e.EntityName end) desc,
         (case when @SortColumn = 'InsertDate' and @DescendingOrder = 0 then e.InsertDate end) asc,
         (case when @SortColumn = 'InsertDate' and @DescendingOrder = 1 then e.InsertDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_SelectAllForUser] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsEntity table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_AllTopLevelEntities]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_AllTopLevelEntities]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_AllTopLevelEntities]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@ActiveOnly bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsEntity

if @PageSize = 0
	set @PageSize = 1

SELECT 
e.EntityId as EntityId
,e.EntityName as EntityName
,e.EntityDescription as EntityDescription
,e.EntityKey as EntityKey
,e.IsDefault as IsDefault
,e.IsActive as IsActive
,e.EntityType as EntityType
,e.AutoMapTimeSchedules
,e.ClusterGroupId
,e.TimeZoneId
,e.InsertName as InsertName
,e.InsertDate as InsertDate
,e.UpdateName as UpdateName
,e.UpdateDate as UpdateDate
,e.ConcurrencyValue as ConcurrencyValue
,e.BinaryResourceUid as BinaryResourceUid
,e.License as License
,e.PublicKey as PublicKey
,e.ParentEntityId as ParentEntityId
,NULL as ParentEntityName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsEntity e 
WHERE 
e.ParentEntityId IS NULL AND
e.IsActive between 
(case when @ActiveOnly = 0 then 0 else 1 end)
and 1
ORDER BY (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 0 THEN e.EntityName end) asc,
         (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 1 THEN e.EntityName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN e.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN e.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN e.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN e.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;
if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_AllTopLevelEntities] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsEntity table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_ByBinaryResourceUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_ByBinaryResourceUid]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_ByBinaryResourceUid]
@BinaryResourceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
e.EntityId as EntityId
,e.EntityName as EntityName
,e.EntityDescription as EntityDescription
,e.EntityKey as EntityKey
,e.IsDefault as IsDefault
,e.IsActive as IsActive
,e.EntityType as EntityType
,e.AutoMapTimeSchedules
,e.ClusterGroupId
,e.TimeZoneId
,e.InsertName as InsertName
,e.InsertDate as InsertDate
,e.UpdateName as UpdateName
,e.UpdateDate as UpdateDate
,e.ConcurrencyValue as ConcurrencyValue
,e.BinaryResourceUid as BinaryResourceUid
,e.License as License
,e.PublicKey as PublicKey
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
WHERE 
e.BinaryResourceUid = @BinaryResourceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_ByBinaryResourceUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_ByDescription]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_ByDescription]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_ByDescription]
@EntityDescription nvarchar(255),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@ActiveOnly bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsEntity

if @PageSize = 0
	set @PageSize = 1

SELECT 
e.EntityId as EntityId
,e.EntityName as EntityName
,e.EntityDescription as EntityDescription
,e.EntityKey as EntityKey
,e.IsDefault as IsDefault
,e.IsActive as IsActive
,e.EntityType as EntityType
,e.AutoMapTimeSchedules
,e.ClusterGroupId
,e.TimeZoneId
,e.InsertName as InsertName
,e.InsertDate as InsertDate
,e.UpdateName as UpdateName
,e.UpdateDate as UpdateDate
,e.ConcurrencyValue as ConcurrencyValue
,e.BinaryResourceUid as BinaryResourceUid
,e.License as License
,e.PublicKey as PublicKey
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
WHERE 
(@EntityDescription IS NULL OR e.EntityDescription LIKE @EntityDescription + '%') AND
e.IsActive between 
(case when @ActiveOnly = 0 then 0 else 1 end)
and 1
ORDER BY (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 0 THEN e.EntityName end) asc,
         (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 1 THEN e.EntityName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN e.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN e.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN e.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN e.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_ByDescription] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsEntity table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_ByEntityType]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_ByEntityType]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_ByEntityType]
@EntityType nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@ActiveOnly bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsEntity

if @PageSize = 0
	set @PageSize = 1

SELECT 
e.EntityId as EntityId
,e.EntityName as EntityName
,e.EntityDescription as EntityDescription
,e.EntityKey as EntityKey
,e.IsDefault as IsDefault
,e.IsActive as IsActive
,e.EntityType as EntityType
,e.AutoMapTimeSchedules
,e.ClusterGroupId
,e.TimeZoneId
,e.InsertName as InsertName
,e.InsertDate as InsertDate
,e.UpdateName as UpdateName
,e.UpdateDate as UpdateDate
,e.ConcurrencyValue as ConcurrencyValue
,e.BinaryResourceUid as BinaryResourceUid
,e.License as License
,e.PublicKey as PublicKey
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
WHERE e.EntityType = @EntityType AND
e.IsActive between 
(case when @ActiveOnly = 0 then 0 else 1 end)
and 1
ORDER BY (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 0 THEN e.EntityName end) asc,
         (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 1 THEN e.EntityName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN e.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN e.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN e.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN e.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_ByEntityType] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsEntity table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_ByParentEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_ByParentEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_ByParentEntityId]
@ParentEntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@ActiveOnly bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsEntity

if @PageSize = 0
	set @PageSize = 1

SELECT 
e.EntityId as EntityId
,e.EntityName as EntityName
,e.EntityDescription as EntityDescription
,e.EntityKey as EntityKey
,e.IsDefault as IsDefault
,e.IsActive as IsActive
,e.EntityType as EntityType
,e.AutoMapTimeSchedules
,e.ClusterGroupId
,e.TimeZoneId
,e.InsertName as InsertName
,e.InsertDate as InsertDate
,e.UpdateName as UpdateName
,e.UpdateDate as UpdateDate
,e.ConcurrencyValue as ConcurrencyValue
,e.BinaryResourceUid as BinaryResourceUid
,e.License as License
,e.PublicKey as PublicKey
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
WHERE 
e.ParentEntityId= @ParentEntityId AND
e.IsActive between 
(case when @ActiveOnly = 0 then 0 else 1 end)
and 1
ORDER BY (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 0 THEN e.EntityName end) asc,
         (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 1 THEN e.EntityName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN e.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN e.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN e.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN e.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_ByParentEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows AND the primary key column AND the 'description' column
'* in the GCS.gcsEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@ActiveOnly bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsEntity

if @PageSize = 0
	set @PageSize = 1

SELECT 
EntityId
,EntityName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsEntity 
WHERE IsActive between 
(case when @ActiveOnly = 0 then 0 else 1 end)
and 1
ORDER BY (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 0 THEN EntityName end) asc,
         (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 1 THEN EntityName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsEntity table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_SelectByPK]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
e.EntityId as EntityId
,e.EntityName as EntityName
,e.EntityDescription as EntityDescription
,e.EntityKey as EntityKey
,e.IsDefault as IsDefault
,e.IsActive as IsActive
,e.EntityType as EntityType
,e.AutoMapTimeSchedules
,e.ClusterGroupId
,e.TimeZoneId
,e.InsertName as InsertName
,e.InsertDate as InsertDate
,e.UpdateName as UpdateName
,e.UpdateDate as UpdateDate
,e.ConcurrencyValue as ConcurrencyValue
,e.BinaryResourceUid as BinaryResourceUid
,e.License as License
,e.PublicKey as PublicKey
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
,1 as TotalRowCount
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
WHERE e.EntityId = @EntityId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_SelectByPK] TO public
GO


CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_SelectNameByPK]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityName
FROM GCS.gcsEntity e
WHERE e.EntityId = @EntityId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_SelectNameByPK] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_SelectSearch]
@EntityName nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@ActiveOnly bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsEntity

if @PageSize = 0
	set @PageSize = 1

SELECT 
e.EntityId as EntityId
,e.EntityName as EntityName
,e.EntityDescription as EntityDescription
,e.EntityKey as EntityKey
,e.IsDefault as IsDefault
,e.IsActive as IsActive
,e.EntityType as EntityType
,e.AutoMapTimeSchedules
,e.ClusterGroupId
,e.TimeZoneId
,e.InsertName as InsertName
,e.InsertDate as InsertDate
,e.UpdateName as UpdateName
,e.UpdateDate as UpdateDate
,e.ConcurrencyValue as ConcurrencyValue
,e.BinaryResourceUid as BinaryResourceUid
,e.License as License
,e.PublicKey as PublicKey
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
WHERE 
(@EntityName IS NULL OR e.EntityName LIKE @EntityName + '%') AND
e.IsActive between 
(case when @ActiveOnly = 0 then 0 else 1 end)
and 1
ORDER BY (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 0 THEN e.EntityName end) asc,
         (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 1 THEN e.EntityName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN e.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN e.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN e.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN e.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_SearchNameDesc]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_SearchNameDesc]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_SearchNameDesc]
@SearchText nvarchar(255),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@ActiveOnly bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsEntity

if @PageSize = 0
	set @PageSize = 1

SELECT 
e.EntityId as EntityId
,e.EntityName as EntityName
,e.EntityDescription as EntityDescription
,e.EntityKey as EntityKey
,e.IsDefault as IsDefault
,e.IsActive as IsActive
,e.EntityType as EntityType
,e.AutoMapTimeSchedules
,e.ClusterGroupId
,e.TimeZoneId
,e.InsertName as InsertName
,e.InsertDate as InsertDate
,e.UpdateName as UpdateName
,e.UpdateDate as UpdateDate
,e.ConcurrencyValue as ConcurrencyValue
,e.BinaryResourceUid as BinaryResourceUid
,e.License as License
,e.PublicKey as PublicKey
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
WHERE 
(@SearchText IS NULL OR e.EntityName LIKE '%' + @SearchText + '%' OR e.EntityDescription LIKE '%' + @SearchText + '%') AND
e.IsActive between 
(case when @ActiveOnly = 0 then 0 else 1 end)
and 1
ORDER BY (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 0 THEN e.EntityName end) asc,
         (CASE WHEN @SortColumn = 'EntityName' AND @DescendingOrder = 1 THEN e.EntityName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN e.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN e.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN e.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN e.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_SearchNameDesc] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.gcsEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_Insert]
@EntityId uniqueidentifier 
,@EntityName nvarchar(65) 
,@EntityDescription nvarchar(255) 
,@EntityKey nvarchar(255) 
,@IsDefault bit 
,@IsActive bit 
,@EntityType nvarchar(65) 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
,@BinaryResourceUid uniqueidentifier  = null
,@License nvarchar(max)  = null
,@PublicKey nvarchar(max)  = null
,@ParentEntityId uniqueidentifier  = null
,@AutoMapTimeSchedules bit = 1
,@ClusterGroupId int = 0
,@TimeZoneId nvarchar(65) = '*'
AS

declare @ret int;
select @ret = 0;

if @EntityId = '00000000-0000-0000-0000-000000000000'
	SET @EntityId = NULL
if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @BinaryResourceUid = NULL
if @ParentEntityId = '00000000-0000-0000-0000-000000000000'
	SET @ParentEntityId = NULL

if @EntityId = '00000000-0000-0000-0000-000000000000' OR @EntityId IS NULL
	SET @EntityId = NewID()

if @ClusterGroupId < 1
	set @ClusterGroupId = GCS.fnChooseAvailableClusterGroupId()

INSERT INTO GCS.gcsEntity
(
EntityId
,EntityName
,EntityDescription
,EntityKey
,IsDefault
,IsActive
,EntityType
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,BinaryResourceUid
,License
,PublicKey
,ParentEntityId
,AutoMapTimeSchedules
,ClusterGroupId
,TimeZoneId
) 
VALUES 
(
@EntityId
,@EntityName
,@EntityDescription
,@EntityKey
,@IsDefault
,@IsActive
,@EntityType
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
,@BinaryResourceUid
,@License
,@PublicKey
,@ParentEntityId
,@AutoMapTimeSchedules
,@ClusterGroupId
,@TimeZoneId
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsEntity table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_Update]
@EntityId uniqueidentifier 
,@EntityName nvarchar(65)
,@EntityDescription nvarchar(255)
,@EntityKey nvarchar(255)
,@IsDefault bit
,@IsActive bit
,@EntityType nvarchar(65) 
,@AutoMapTimeSchedules bit
,@ClusterGroupId int
,@TimeZoneId nvarchar(65)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@BinaryResourceUid uniqueidentifier
,@License nvarchar(max)
,@PublicKey nvarchar(max)
,@ParentEntityId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @BinaryResourceUid = NULL
if @ParentEntityId = '00000000-0000-0000-0000-000000000000'
	SET @ParentEntityId = NULL


UPDATE GCS.gcsEntity
SET 
EntityName = @EntityName
,EntityDescription = @EntityDescription
,EntityKey = @EntityKey
,IsDefault = @IsDefault
,IsActive = @IsActive
,EntityType = @EntityType
,AutoMapTimeSchedules = @AutoMapTimeSchedules
,ClusterGroupId = @ClusterGroupId
,TimeZoneId = @TimeZoneId
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,BinaryResourceUid = @BinaryResourceUid
,License = @License
,PublicKey = @PublicKey
,ParentEntityId = @ParentEntityId
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
EntityId = @EntityId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsEntity table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_UpdateConcurrency]
@EntityId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsEntity
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
EntityId = @EntityId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsEntity table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_DeleteByPK]
@EntityId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsEntity
WHERE
EntityId = @EntityId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[gcsEntityPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntityPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsEntity

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntityPDSA_RowCount] TO public
GO



if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.Credential_PanelLoadData')
            AND   type = 'V')
   drop view GCS.[Credential_PanelLoadData]
go


/****** Object:  View [GCS].[Credential_PanelLoadData]    Script Date: 8/31/2020 2:21:59 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create or alter view [GCS].[Credential_PanelLoadData] as
select p.PersonUid, p.FirstName, p.LastName, p.PersonId, p.ActivationDateTime as PersonActivationDateTime, p.ExpirationDateTime as PersonExpirationDateTime, p.EmploymentDate as PersonEmploymentDate, p.TerminationDate as PersonTerminationDate,
p.VeryImportantPerson, p.HasPhysicalDisability, p.HasVertigo,
ISNULL(past.PersonInactiveState,0) AS PersonInactiveState,
pacp.PINExempt, pacp.PassbackExempt, pacp.CanToggleLockState, pacp.IsActive as PersonAccessControlPropertiesIsActive, pacp.PIN, pacp.AccessProfileUid as PersonAccessControlPropertiesAccessProfileUid,
pc.PersonCredentialUid, pc.CredentialUid,
pc.ActivationDateTime as CredentialActivationDateTime, pc.ExpirationDateTime as CredentialExpirationDateTime, pc.UsageCount as CredentialUsageCount, pc.DuressEnabled, pc.ReverseBits, pc.TraceEnabled, pc.IsActive as PersonCredentialIsActive,
pcr.Code as CredentialRoleCode,
pam.Code as CredentialActivationModeCode,
pem.Code as CredentialExpirationModeCode,
apnsrb.Code as NoServerReplyBehaviorCode,
apdtsb.Code as DeferToServerBehaviorCode,
personclusterPermission.LastPanelImpactingChangeDate, 
ISNULL(personclusterPermission.CredentialBits, cred.CardBinaryData) as CredentialBits,
credFormat.Display as CredentialFormatDisplay, credFormat.CredentialFormatCode,
cred.BitCount, cred.CardBinaryData, cred.CardNumber, cred.CardNumberIsHex,
CASE WHEN credFormat.CredentialFormatCode = 3 THEN cred26BitStandard.FacilityCode
     WHEN credFormat.CredentialFormatCode = 6 THEN cred35BitHidCorp1k.CompanyCode
     WHEN credFormat.CredentialFormatCode = 8 THEN cred36BitBqt.FacilityCode
     WHEN credFormat.CredentialFormatCode = 9 THEN cred40BitXceed.SiteCode
     WHEN credFormat.CredentialFormatCode = 11 THEN cred48BitHidCorp1k.CompanyCode
     WHEN credFormat.CredentialFormatCode = 12 THEN cred37BitCypress.FacilityCode
     WHEN credFormat.CredentialFormatCode = 13 THEN cred37BitH10304.FacilityCode
     WHEN credFormat.CredentialFormatCode = -1 THEN credData.Number1
     ELSE 0
END as FacCompSiteCode,
CASE WHEN credFormat.CredentialFormatCode = 3 THEN cred26BitStandard.IdCode
     WHEN credFormat.CredentialFormatCode = 6 THEN cred35BitHidCorp1k.IdCode
     WHEN credFormat.CredentialFormatCode = 8 THEN cred36BitBqt.IdCode
     WHEN credFormat.CredentialFormatCode = 9 THEN cred40BitXceed.IdCode
     WHEN credFormat.CredentialFormatCode = 11 THEN cred48BitHidCorp1k.IdCode
     WHEN credFormat.CredentialFormatCode = 12 THEN cred37BitCypress.IdCode
     WHEN credFormat.CredentialFormatCode = 13 THEN cred37BitH10304.IdCode
     WHEN credFormat.CredentialFormatCode = -1 THEN credData.Number2
     ELSE 0
END as IdCode,
CASE WHEN credFormat.CredentialFormatCode = 8 THEN cred36BitBqt.IssueCode
     WHEN credFormat.CredentialFormatCode = -1 THEN credData.Number3
     ELSE 0
END as IssueCode,
ISNULL(plcdmsg.StartingDate, '1753-01-01') as LcdStartingDate, ISNULL(plcdmsg.EndingDate, '9999-12-31') as LcdEndingDate, ISNULL(plcdmsg.Message, N'') as LcdMessage,
ISNULL(plcdmsgdm.Code, 0) as LcdMessageDisplayModeCode,
cluster.ClusterUid, cluster.ClusterName, cluster.ClusterGroupId, cluster.ClusterNumber, clusterType.TypeCode as ClusterTypeCode, cluster.IsActive as ClusterIsActive,
credentialDataLength.DataLength as CredentialDataLength,
255 as PanelNumber, 3 as CpuNumber,
ag1.AccessGroupNumber as AccessGroup1, ag2.AccessGroupNumber as AccessGroup2, ag3.AccessGroupNumber as AccessGroup3, ag4.AccessGroupNumber as AccessGroup4, personalAg.PersonalAccessGroupNumber,
iog1.IOGroupNumber as InputOutputGroup1, iog2.IOGroupNumber as InputOutputGroup2, iog3.IOGroupNumber as InputOutputGroup3, iog4.IOGroupNumber as InputOutputGroup4,
ISNULL(personOtisElevator.SplitGroupOperation, 0) as OtisSplitGroupOperation,
ISNULL(personOtisElevator.CimOverride,0) as OtisCimOverride,
'00000000-0000-0000-0000-000000000000' as CpuUid,
'' as ServerAddress,
0 as IsConnected
FROM GCS.Person p
JOIN GCS.PersonAccessControlProperties pacp ON pacp.PersonUid = p.PersonUid
LEFT OUTER JOIN GCS.PersonActiveStatusType past on past.PersonActiveStatusTypeUid = p.PersonActiveStatusTypeUid
JOIN GCS.PersonCredential pc on pc.PersonUid = p.PersonUid
JOIN GCS.PersonCredentialRole pcr on pcr.PersonCredentialRoleUid = pc.PersonCredentialRoleUid
JOIN GCS.PersonActivationMode pam on pam.PersonActivationModeUid = pc.PersonActivationModeUid
JOIN GCS.PersonExpirationMode pem on pem.PersonExpirationModeUid = pc.PersonExpirationModeUid
JOIN GCS.AccessPortalNoServerReplyBehavior apnsrb on apnsrb.AccessPortalNoServerReplyBehaviorUid = pc.AccessPortalNoServerReplyBehaviorUid
JOIN GCS.AccessPortalDeferToServerBehavior apdtsb on apdtsb.AccessPortalDeferToServerBehaviorUid = pc.AccessPortalDeferToServerBehaviorUid
JOIN GCS.Credential cred on cred.CredentialUid = pc.CredentialUid
JOIN GCS.CredentialFormat credFormat on credFormat.CredentialFormatUid = cred.CredentialFormatUid
LEFT OUTER JOIN GCS.Credential26BitStandard cred26BitStandard on cred26BitStandard.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialCorporate1K35Bit cred35BitHidCorp1k on cred35BitHidCorp1k.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialBqt36Bit cred36BitBqt on cred36BitBqt.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialXceedId40Bit cred40BitXceed on cred40BitXceed.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialCorporate1K48Bit cred48BitHidCorp1k on cred48BitHidCorp1k.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialCypress37Bit cred37BitCypress on cred37BitCypress.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialH1030437Bit cred37BitH10304 on cred37BitH10304.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialData credData on credData.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.PersonLcdMessage plcdmsg on plcdmsg.PersonUid = p.PersonUid
LEFT OUTER JOIN GCS.PersonLcdMessageDisplayMode plcdmsgdm on plcdmsgdm.PersonLcdMessageDisplayModeUid = plcdmsg.PersonLcdMessageDisplayModeUid
JOIN GCS.PersonClusterPermission personclusterPermission on personclusterPermission.PersonUid = p.PersonUid
JOIN GCS.Cluster cluster on cluster.ClusterUid = personclusterPermission.ClusterUid
JOIN GCS.ClusterType clusterType on clusterType.ClusterTypeUid = cluster.ClusterTypeUid
JOIN GCS.CredentialDataLength credentialDataLength on credentialDataLength.CredentialDataLengthUid = cluster.CredentialDataLengthUid
LEFT OUTER JOIN GCS.PersonAccessGroup pag1 on pag1.PersonClusterPermissionUid = personclusterPermission.PersonClusterPermissionUid AND pag1.OrderNumber = 1
LEFT OUTER JOIN GCS.AccessGroup ag1 on ag1.AccessGroupUid = pag1.AccessGroupUid
LEFT OUTER JOIN GCS.PersonAccessGroup pag2 on pag2.PersonClusterPermissionUid = personclusterPermission.PersonClusterPermissionUid AND pag2.OrderNumber = 2
LEFT OUTER JOIN GCS.AccessGroup ag2 on ag2.AccessGroupUid = pag2.AccessGroupUid
LEFT OUTER JOIN GCS.PersonAccessGroup pag3 on pag3.PersonClusterPermissionUid = personclusterPermission.PersonClusterPermissionUid AND pag3.OrderNumber = 3
LEFT OUTER JOIN GCS.AccessGroup ag3 on ag3.AccessGroupUid = pag3.AccessGroupUid
LEFT OUTER JOIN GCS.PersonAccessGroup pag4 on pag4.PersonClusterPermissionUid = personclusterPermission.PersonClusterPermissionUid AND pag4.OrderNumber = 4
LEFT OUTER JOIN GCS.AccessGroup ag4 on ag4.AccessGroupUid = pag4.AccessGroupUid
LEFT OUTER JOIN GCS.PersonPersonalAccessGroup personalAg on personalAg.PersonClusterPermissionUid = personclusterPermission.PersonClusterPermissionUid
LEFT OUTER JOIN GCS.PersonInputOutputGroup piog1 on piog1.PersonClusterPermissionUid = personclusterPermission.PersonClusterPermissionUid AND piog1.OrderNumber = 1
LEFT OUTER JOIN GCS.InputOutputGroup  iog1 on iog1.InputOutputGroupUid = piog1.InputOutputGroupUid
LEFT OUTER JOIN GCS.PersonInputOutputGroup piog2 on piog2.PersonClusterPermissionUid = personclusterPermission.PersonClusterPermissionUid AND piog2.OrderNumber = 2
LEFT OUTER JOIN GCS.InputOutputGroup iog2 on iog2.InputOutputGroupUid = piog2.InputOutputGroupUid
LEFT OUTER JOIN GCS.PersonInputOutputGroup piog3 on piog3.PersonClusterPermissionUid = personclusterPermission.PersonClusterPermissionUid AND piog3.OrderNumber = 3
LEFT OUTER JOIN GCS.InputOutputGroup iog3 on iog3.InputOutputGroupUid = piog3.InputOutputGroupUid
LEFT OUTER JOIN GCS.PersonInputOutputGroup piog4 on piog4.PersonClusterPermissionUid = personclusterPermission.PersonClusterPermissionUid AND piog4.OrderNumber = 4
LEFT OUTER JOIN GCS.InputOutputGroup iog4 on iog4.InputOutputGroupUid = piog4.InputOutputGroupUid
LEFT OUTER JOIN GCS.PersonOtisElevator personOtisElevator on personOtisElevator.PersonUid = p.PersonUid
WHERE CardBinaryData <> 0x0000000000000000000000000000000000000000000000000000000000000000
GO
ALTER AUTHORIZATION ON [GCS].[Credential_PanelLoadData] TO  SCHEMA OWNER 
GO


if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.Credential_PanelLoadDataChangesForCpu')
            AND   type = 'V')
   drop view GCS.[Credential_PanelLoadDataChangesForCpu]
go

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create OR ALTER view [GCS].[Credential_PanelLoadDataChangesForCpu] as
select ctltcpu.CredentialToLoadToCpuUid, ctltcpu.LastCredentialChangeDate, ctltcpu.LastCredentialLoadedDate, pcp.LastPanelImpactingChangeDate, cpu.CpuUid,
p.PersonUid, p.FirstName, p.LastName, p.PersonId, p.ActivationDateTime as PersonActivationDateTime, p.ExpirationDateTime as PersonExpirationDateTime, p.EmploymentDate as PersonEmploymentDate, p.TerminationDate as PersonTerminationDate,
p.VeryImportantPerson, p.HasPhysicalDisability, p.HasVertigo,ISNULL(past.PersonInactiveState,0) AS PersonInactiveState,
pacp.PINExempt, pacp.PassbackExempt, pacp.CanToggleLockState, pacp.IsActive as PersonAccessControlPropertiesIsActive, pacp.PIN, pacp.AccessProfileUid as PersonAccessControlPropertiesAccessProfileUid,
pc.PersonCredentialUid, pc.CredentialUid,pc.ActivationDateTime as CredentialActivationDateTime, pc.ExpirationDateTime as CredentialExpirationDateTime, pc.UsageCount as CredentialUsageCount, pc.DuressEnabled, pc.ReverseBits, pc.TraceEnabled, pc.IsActive as PersonCredentialIsActive,
pcr.Code as CredentialRoleCode,
pam.Code as CredentialActivationModeCode,
pem.Code as CredentialExpirationModeCode,
apnsrb.Code as NoServerReplyBehaviorCode,apdtsb.Code as DeferToServerBehaviorCode,
ISNULL(pcp.CredentialBits, cred.CardBinaryData) as CredentialBits,credFormat.Display as CredentialFormatDisplay, credFormat.CredentialFormatCode,cred.BitCount, cred.CardBinaryData, cred.CardNumber, cred.CardNumberIsHex,
CASE WHEN credFormat.CredentialFormatCode = 3 THEN cred26BitStandard.FacilityCode
     WHEN credFormat.CredentialFormatCode = 6 THEN cred35BitHidCorp1k.CompanyCode
     WHEN credFormat.CredentialFormatCode = 8 THEN cred36BitBqt.FacilityCode
     WHEN credFormat.CredentialFormatCode = 9 THEN cred40BitXceed.SiteCode
     WHEN credFormat.CredentialFormatCode = 11 THEN cred48BitHidCorp1k.CompanyCode
     WHEN credFormat.CredentialFormatCode = 12 THEN cred37BitCypress.FacilityCode
     WHEN credFormat.CredentialFormatCode = 13 THEN cred37BitH10304.FacilityCode
     WHEN credFormat.CredentialFormatCode = 15 THEN cred37BitSoftwareHouse.FacilityCode
     WHEN credFormat.CredentialFormatCode = -1 THEN credData.Number1
     ELSE 0
END as FacCompSiteCode,
CASE WHEN credFormat.CredentialFormatCode = 3 THEN cred26BitStandard.IdCode
     WHEN credFormat.CredentialFormatCode = 6 THEN cred35BitHidCorp1k.IdCode
     WHEN credFormat.CredentialFormatCode = 8 THEN cred36BitBqt.IdCode
     WHEN credFormat.CredentialFormatCode = 9 THEN cred40BitXceed.IdCode
     WHEN credFormat.CredentialFormatCode = 11 THEN cred48BitHidCorp1k.IdCode
     WHEN credFormat.CredentialFormatCode = 12 THEN cred37BitCypress.IdCode
     WHEN credFormat.CredentialFormatCode = 13 THEN cred37BitH10304.IdCode
     WHEN credFormat.CredentialFormatCode = 14 THEN cred37BitH10302.IdCode
     WHEN credFormat.CredentialFormatCode = 15 THEN cred37BitSoftwareHouse.IdCode
     WHEN credFormat.CredentialFormatCode = -1 THEN credData.Number2
     ELSE 0
END as IdCode,
CASE WHEN credFormat.CredentialFormatCode = 8 THEN cred36BitBqt.IssueCode
     WHEN credFormat.CredentialFormatCode = -1 THEN credData.Number3
     ELSE 0
END as IssueCode,
ISNULL(plcdmsg.StartingDate, '1753-01-01') as LcdStartingDate, ISNULL(plcdmsg.EndingDate, '9999-12-31') as LcdEndingDate, ISNULL(plcdmsg.Message, N'') as LcdMessage,
ISNULL(plcdmsgdm.Code, 0) as LcdMessageDisplayModeCode,cluster.ClusterUid, cluster.ClusterName, cluster.ClusterGroupId, cluster.ClusterNumber, clusterType.TypeCode as ClusterTypeCode, cluster.IsActive as ClusterIsActive,cluster.TimeZoneId, cluster.CurrentTimeForCluster,credentialDataLength.DataLength as CredentialDataLength,cpu.PanelNumber, cpu.CpuNumber,
ag1.AccessGroupNumber as AccessGroup1, ag2.AccessGroupNumber as AccessGroup2, ag3.AccessGroupNumber as AccessGroup3, ag4.AccessGroupNumber as AccessGroup4, personalAg.PersonalAccessGroupNumber,iog1.IOGroupNumber as InputOutputGroup1, iog2.IOGroupNumber as InputOutputGroup2, iog3.IOGroupNumber as InputOutputGroup3, iog4.IOGroupNumber as InputOutputGroup4,
ISNULL(personOtisElevator.SplitGroupOperation, 0) as OtisSplitGroupOperation,ISNULL(personOtisElevator.CimOverride,0) as OtisCimOverride,
gcc.ServerAddress,
gcc.IsConnected,
cred.IsExtended
FROM GCS.CredentialToLoadToCpu ctltcpu 
JOIN GCS.GalaxyCpu cpu on cpu.CpuUid = ctltcpu.CpuUid
LEFT OUTER JOIN GCS.GalaxyCpuConnection gcc on gcc.CpuUid = cpu.CpuUid
join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = cpu.GalaxyPanelUid
JOIN GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
JOIN GCS.Credential cred on cred.CredentialUid = ctltcpu.CredentialUid
JOIN GCS.PersonCredential pc on pc.CredentialUid = cred.CredentialUid
join GCS.Person p on p.PersonUid = pc.PersonUid
JOIN GCS.PersonAccessControlProperties pacp ON pacp.PersonUid = p.PersonUid
LEFT OUTER JOIN GCS.PersonActiveStatusType past on past.PersonActiveStatusTypeUid = p.PersonActiveStatusTypeUid
JOIN GCS.PersonCredentialRole pcr on pcr.PersonCredentialRoleUid = pc.PersonCredentialRoleUid
JOIN GCS.PersonActivationMode pam on pam.PersonActivationModeUid = pc.PersonActivationModeUid
JOIN GCS.PersonExpirationMode pem on pem.PersonExpirationModeUid = pc.PersonExpirationModeUid
JOIN GCS.AccessPortalNoServerReplyBehavior apnsrb on apnsrb.AccessPortalNoServerReplyBehaviorUid = pc.AccessPortalNoServerReplyBehaviorUid
JOIN GCS.AccessPortalDeferToServerBehavior apdtsb on apdtsb.AccessPortalDeferToServerBehaviorUid = pc.AccessPortalDeferToServerBehaviorUid
JOIN GCS.CredentialFormat credFormat on credFormat.CredentialFormatUid = cred.CredentialFormatUid
LEFT OUTER JOIN GCS.Credential26BitStandard cred26BitStandard on cred26BitStandard.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialCorporate1K35Bit cred35BitHidCorp1k on cred35BitHidCorp1k.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialBqt36Bit cred36BitBqt on cred36BitBqt.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialXceedId40Bit cred40BitXceed on cred40BitXceed.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialCorporate1K48Bit cred48BitHidCorp1k on cred48BitHidCorp1k.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialCypress37Bit cred37BitCypress on cred37BitCypress.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialH1030437Bit cred37BitH10304 on cred37BitH10304.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialH1030237Bit cred37BitH10302 on cred37BitH10302.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialSoftwareHouse37Bit cred37BitSoftwareHouse on cred37BitSoftwareHouse.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.CredentialData credData on credData.CredentialUid = cred.CredentialUid
LEFT OUTER JOIN GCS.PersonLcdMessage plcdmsg on plcdmsg.PersonUid = p.PersonUid
LEFT OUTER JOIN GCS.PersonLcdMessageDisplayMode plcdmsgdm on plcdmsgdm.PersonLcdMessageDisplayModeUid = plcdmsg.PersonLcdMessageDisplayModeUid
JOIN GCS.PersonClusterPermission pcp on pcp.PersonUid = p.PersonUid AND pcp.ClusterUid = cluster.ClusterUid
JOIN GCS.ClusterType clusterType on clusterType.ClusterTypeUid = cluster.ClusterTypeUid
JOIN GCS.CredentialDataLength credentialDataLength on credentialDataLength.CredentialDataLengthUid = cluster.CredentialDataLengthUid
LEFT OUTER JOIN GCS.PersonAccessGroup pag1 on pag1.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid AND pag1.OrderNumber = 1
LEFT OUTER JOIN GCS.AccessGroup ag1 on ag1.AccessGroupUid = pag1.AccessGroupUid
LEFT OUTER JOIN GCS.PersonAccessGroup pag2 on pag2.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid AND pag2.OrderNumber = 2
LEFT OUTER JOIN GCS.AccessGroup ag2 on ag2.AccessGroupUid = pag2.AccessGroupUid
LEFT OUTER JOIN GCS.PersonAccessGroup pag3 on pag3.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid AND pag3.OrderNumber = 3
LEFT OUTER JOIN GCS.AccessGroup ag3 on ag3.AccessGroupUid = pag3.AccessGroupUid
LEFT OUTER JOIN GCS.PersonAccessGroup pag4 on pag4.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid AND pag4.OrderNumber = 4
LEFT OUTER JOIN GCS.AccessGroup ag4 on ag4.AccessGroupUid = pag4.AccessGroupUid
LEFT OUTER JOIN GCS.PersonPersonalAccessGroup personalAg on personalAg.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid
LEFT OUTER JOIN GCS.PersonInputOutputGroup piog1 on piog1.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid AND piog1.OrderNumber = 1
LEFT OUTER JOIN GCS.InputOutputGroup  iog1 on iog1.InputOutputGroupUid = piog1.InputOutputGroupUid
LEFT OUTER JOIN GCS.PersonInputOutputGroup piog2 on piog2.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid AND piog2.OrderNumber = 2
LEFT OUTER JOIN GCS.InputOutputGroup iog2 on iog2.InputOutputGroupUid = piog2.InputOutputGroupUid
LEFT OUTER JOIN GCS.PersonInputOutputGroup piog3 on piog3.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid AND piog3.OrderNumber = 3
LEFT OUTER JOIN GCS.InputOutputGroup iog3 on iog3.InputOutputGroupUid = piog3.InputOutputGroupUid
LEFT OUTER JOIN GCS.PersonInputOutputGroup piog4 on piog4.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid AND piog4.OrderNumber = 4
LEFT OUTER JOIN GCS.InputOutputGroup iog4 on iog4.InputOutputGroupUid = piog4.InputOutputGroupUid
LEFT OUTER JOIN GCS.PersonOtisElevator personOtisElevator on personOtisElevator.PersonUid = p.PersonUid
WHERE 
cred.CardBinaryData <> 0x0000000000000000000000000000000000000000000000000000000000000000 AND
((ctltcpu.LastCredentialChangeDate > ctltcpu.LastCredentialLoadedDate) OR ctltcpu.LastCredentialLoadedDate IS NULL or (pcp.LastPanelImpactingChangeDate > ctltcpu.LastCredentialLoadedDate) OR
--(ctltcpu.LastCredentialLoadedDate < pc.ExpirationDateTime AND pem.Code = 3 AND pc.ExpirationDateTime < cluster.CurrentTimeForCluster) OR	-- Credential level Expiration by date & tiime
--(ctltcpu.LastCredentialLoadedDate < pc.ActivationDateTime AND pam.Code = 1 AND pc.ActivationDateTime < cluster.CurrentTimeForCluster) OR	-- Credential level Activation
(ctltcpu.LastCredentialLoadedDate < pc.ExpirationDateTime AND pem.Code in (3,4) AND pc.ExpirationDateTime < cluster.CurrentTimeForCluster) OR	-- Credential level Expiration by date & tiime
(ctltcpu.LastCredentialLoadedDate < pc.ActivationDateTime AND pam.Code in (1,2) AND pc.ActivationDateTime < cluster.CurrentTimeForCluster) OR	-- Credential level Activation
(ctltcpu.LastCredentialLoadedDate < p.ExpirationDateTime AND p.ExpirationDateTime < cluster.CurrentTimeForCluster) OR	-- Person level Expiration
(ctltcpu.LastCredentialLoadedDate < p.ActivationDateTime AND p.ActivationDateTime < cluster.CurrentTimeForCluster) OR	-- Person level Activation
(ctltcpu.LastCredentialLoadedDate < p.TerminationDate AND p.TerminationDate < cluster.CurrentTimeForCluster) OR	-- Person level Expiration
(ctltcpu.LastForceLoadDate IS NOT NULL AND ctltcpu.LastForceLoadDate > ctltcpu.LastCredentialLoadedDate) )
AND (cred.IsExtended = 0 OR (cred.IsExtended = 1 AND credentialDataLength.DataLength > 6))
GO
ALTER AUTHORIZATION ON [GCS].[Credential_PanelLoadDataChangesForCpu] TO  SCHEMA OWNER 
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForPerson]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForPerson
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForPerson 
@personUid uniqueidentifier
AS

	select EntityId from GCS.Person where PersonUid = @personUid
GO

GRANT EXECUTE ON GCS.GetEntityIdForPerson TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetPersonIdForPerson]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetPersonIdForPerson
GO

CREATE OR ALTER PROCEDURE GCS.GetPersonIdForPerson 
@personUid uniqueidentifier
AS
	select PersonId from GCS.Person where PersonUid = @personUid
GO

GRANT EXECUTE ON GCS.GetPersonIdForPerson TO public
GO

--IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetPersonUidFromPersonId]') AND type in (N'P', N'PC'))
--DROP PROCEDURE GCS.GetPersonUidFromPersonId
--GO

CREATE OR ALTER PROCEDURE GCS.GetPersonUidFromPersonId 
@entityId uniqueidentifier,
@personId nvarchar(65)
AS
	select PersonUid from GCS.Person where EntityId = @entityId and PersonId = @personId AND @personId is not null
GO

GRANT EXECUTE ON GCS.GetPersonUidFromPersonId TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForPersonPhoto]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForPersonPhoto
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForPersonPhoto 
@uid uniqueidentifier
AS
	select EntityId from GCS.PersonPhoto pp  
	JOIN GCS.Person p on p.PersonUid = pp.PersonUid where pp.PersonPhotoUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForPersonPhoto TO public
GO

--IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GenerateUniquePersonIdForEntity]') AND type in (N'P', N'PC'))
--DROP PROCEDURE GCS.GenerateUniquePersonIdForEntity
--GO

--CREATE OR ALTER PROCEDURE GCS.GenerateUniquePersonIdForEntity 
--@entityId uniqueidentifier
--AS
--	select PersonId from GCS.Person where PersonUid = @personUid
--GO

--GRANT EXECUTE ON GCS.GenerateUniquePersonIdForEntity TO public
--GO


IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[dbo].[gcs_GenerateRandomPassword]') AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE [dbo].gcs_GenerateRandomPassword
GO

CREATE OR ALTER PROCEDURE dbo.gcs_GenerateRandomPassword ( @length int, @generatedPassword nvarchar(65) out)
AS
BEGIN
  if @length < 10
	set @length = 10
  if @length > 65
	set @length = 65

Declare     @chars nchar(92)
           ,@bytes binary(128)
           ,@password nvarchar(128)
 
Set         @chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!"$%^*()_+-={[}]:;@~#,.?/'
Set         @bytes = Crypt_Gen_Random(128)
   
;With cte_numbers (number) As
(
    Select      Cast(1 As int)
    Union All
    Select      number + 1
    From        cte_numbers
    Where       number < @length
)
Select      @password = 
            (
                Select      SubString(@chars, (SubString(@bytes, n.Number, 1) % Len(@chars)) + 1, 1)
                From        cte_numbers n
                For         XML Path ('')
            )
select @generatedPassword = @password
END;
GO

GRANT EXECUTE ON [dbo].gcs_GenerateRandomPassword TO public
GO 


IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[dbo].[gcs_GenerateRandomFilename]') AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE [dbo].gcs_GenerateRandomFilename
GO

CREATE OR ALTER PROCEDURE dbo.gcs_GenerateRandomFilename ( @length int, @generatedFilename nvarchar(65) out)
AS
BEGIN
  if @length < 10
	set @length = 10
  if @length > 65
	set @length = 65

Declare     @chars nchar(92)
           ,@bytes binary(128)
           ,@filename nvarchar(128)
 
Set         @chars = 'abcdefghijklmnopqrstuvwxyz0123456789'
Set         @bytes = Crypt_Gen_Random(128)
   
;With cte_numbers (number) As
(
    Select      Cast(1 As int)
    Union All
    Select      number + 1
    From        cte_numbers
    Where       number < @length
)
Select      @filename = 
            (
                Select      SubString(@chars, (SubString(@bytes, n.Number, 1) % Len(@chars)) + 1, 1)
                From        cte_numbers n
                For         XML Path ('')
            )
select @generatedFilename = @filename
END;
GO

GRANT EXECUTE ON [dbo].gcs_GenerateRandomFilename TO public
GO 


IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[dbo].[gcs_GenerateRandomFilename]') AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
DROP PROCEDURE [dbo].gcs_GenerateRandomFilename
GO

CREATE OR ALTER PROCEDURE dbo.gcs_GenerateRandomFilename ( @length int, @generatedFilename nvarchar(65) out)
AS
BEGIN
  if @length < 10
	set @length = 10
  if @length > 65
	set @length = 65

Declare     @chars nchar(92)
           ,@bytes binary(128)
           ,@filename nvarchar(128)
 
Set         @chars = 'abcdefghijklmnopqrstuvwxyz0123456789'
Set         @bytes = Crypt_Gen_Random(128)
   
;With cte_numbers (number) As
(
    Select      Cast(1 As int)
    Union All
    Select      number + 1
    From        cte_numbers
    Where       number < @length
)
Select      @filename = 
            (
                Select      SubString(@chars, (SubString(@bytes, n.Number, 1) % Len(@chars)) + 1, 1)
                From        cte_numbers n
                For         XML Path ('')
            )
select @generatedFilename = @filename
END;
GO

GRANT EXECUTE ON [dbo].gcs_GenerateRandomFilename TO public
GO 




-- If this column doesn't exist, that means that PhotoImage is also not configured for FILESTREAM
-- Must rename table, create new table AND THEN transfer data
if dbo.fn_GCSDoesColumnExist('PersonPhoto', 'UniqueFilename') = 0
begin
-- Start by renaming original table. 
-- This assumes AND requires that FILESTREAM is already configured 
	exec sp_rename 'GCS.PersonPhoto', 'PersonPhotoOrig'
	
	ALTER TABLE GCS.PersonPhotoOrig DROP CONSTRAINT [PK_PERSONPHOTO];  
 	
	ALTER TABLE GCS.PersonPhotoOrig DROP CONSTRAINT FK_PersonPhotoPerson;  

	CREATE TABLE [GCS].[PersonPhoto](
	[PersonPhotoUid] [uniqueidentifier] ROWGUIDCOL  NOT NULL UNIQUE,
	[PersonUid] [uniqueidentifier] NOT NULL,
	[Tag] [nvarchar](65) NOT NULL,
	[UniqueFilename]       GCS.Text255              not null,
	[OriginalFilename]     GCS.Text255              null,
	[ContentType]          GCS.Text255              not null,
	[IsDefault]				bit					not null,
	[PhotoImage]           varbinary(Max)       filestream not null,
	[PublicUrl]            nvarchar(2048)       null,
	[InsertName] [nvarchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
	[InsertDate] [datetimeoffset] NOT NULL,
	[UpdateName] [nvarchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
	[UpdateDate] [datetimeoffset] NULL,
	[ConcurrencyValue] [smallint] NULL,
	 CONSTRAINT [PK_PERSONPHOTO] PRIMARY KEY CLUSTERED 
	(
		[PersonPhotoUid] ASC
	)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
	) ON [PRIMARY]
	EXEC sys.sp_bindefault @defname=N'[GCS].[D_NewID]', @objname=N'[GCS].[PersonPhoto].[PersonPhotoUid]' , @futureonly='futureonly'

	EXEC sys.sp_bindefault @defname=N'[GCS].[D_NewID]', @objname=N'[GCS].[PersonPhoto].[PersonUid]' , @futureonly='futureonly'
	ALTER AUTHORIZATION ON [GCS].[PersonPhoto] TO  SCHEMA OWNER 

	create unique nonclustered index idxPersonPhotoFilename on GCS.PersonPhoto (UniqueFilename ASC,
	  PersonUid ASC)

	create unique nonclustered index idxPersonPhotoTag on GCS.PersonPhoto (PersonUid ASC,
	  Tag ASC)

	alter table GCS.PersonPhoto
	   add constraint FK_PersonPhotoPerson foreign key (PersonUid)
		  references GCS.Person (PersonUid)
			 on update cascade on delete cascade
end
go

-- If PersonPhotoOrig table exists, copy the data into the new PersonPhoto table, generating new random filename as well
if dbo.fn_GCSDoesTableExist('PersonPhotoOrig') = 1
BEGIN
	INSERT INTO GCS.PersonPhoto ( PersonPhotoUid, PersonUid, Tag, UniqueFilename, ContentType, PhotoImage, IsDefault, InsertName, InsertDate, UpdateName, UpdateDate, ConcurrencyValue)
	select PersonPhotoUid, PersonUid, Tag, '*', 'jpg', PhotoImage, 1, InsertName, InsertDate, UpdateName, UpdateDate,1 from GCS.PersonPhotoOrig where PhotoImage is not null

	declare @ppid uniqueidentifier

	DECLARE genRandomFilenamesCursor CURSOR FOR SELECT PersonPhotoUid from GCS.PersonPhoto where UniqueFilename = '*' 
	OPEN genRandomFilenamesCursor
	FETCH NEXT FROM genRandomFilenamesCursor INTO @ppid
	WHILE @@FETCH_STATUS = 0
	BEGIN
		declare @fname nvarchar(255)
		exec dbo.gcs_GenerateRandomFilename 40, @fname out
		update GCS.PersonPhoto set UniqueFilename = @fname + '.jpg' where current of genRandomFilenamesCursor
		FETCH NEXT FROM genRandomFilenamesCursor INTO @ppid
	end
	CLOSE genRandomFilenamesCursor;
	DEALLOCATE genRandomFilenamesCursor;

	declare @origCnt int
	declare @photoCnt int
	select @origCnt = COUNT(*) FROM GCS.PersonPhotoOrig where PhotoImage is not null
	select @photoCnt = COUNT(*) FROM GCS.PersonPhoto where PhotoImage is not null
	if @origCnt = @photoCnt
	begin
		drop table GCS.PersonPhotoOrig
	end
END
GO


if dbo.fn_GCSDoesTableExist('PersonPhotoScaled') = 0
BEGIN
	/*==============================================================*/
	/* Table: PersonPhotoScaled                                     */
	/*==============================================================*/
	create table [GCS].[PersonPhotoScaled] (
		[PersonPhotoScaledUid] [uniqueidentifier]    ROWGUIDCOL not null UNIQUE,
		[PersonPhotoUid]       [uniqueidentifier]    not null,
		[UniqueFilename]       GCS.Text255              not null,
		[Tag]				   GCS.Text65			not null,
		[PhotoImage]           varbinary(Max)       filestream not null,
		[PublicUrl]            nvarchar(2048)       null,
		[InsertName] [nvarchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
		[InsertDate] [datetimeoffset] NOT NULL,
		[UpdateName] [nvarchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
		[UpdateDate] [datetimeoffset] NULL,
		[ConcurrencyValue] [smallint] NULL,
		constraint PK_PERSONPHOTOSCALED primary key (PersonPhotoScaledUid)
	)

	/*==============================================================*/
	/* Index: idxPersonPhotoScaledFilename                          */
	/*==============================================================*/
	create unique nonclustered index idxPersonPhotoScaledFilename on GCS.PersonPhotoScaled (PersonPhotoUid ASC,
	  UniqueFilename ASC)

	/*==============================================================*/
	/* Index: idxPersonPhotoScaledTag                               */
	/*==============================================================*/
	create unique nonclustered index idxPersonPhotoScaledTag on GCS.PersonPhotoScaled (PersonPhotoUid ASC,
	  Tag ASC)


	alter table GCS.PersonPhotoScaled
	   add constraint FK_PersonPhotoScaledPersonPhoto foreign key (PersonPhotoUid)
		  references GCS.PersonPhoto (PersonPhotoUid)
			 on update cascade on delete cascade
end
go

/* All Stored Procedures for table: PersonPhotoScaled */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.PersonPhotoScaled table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoScaledUid
,PersonPhotoUid
,UniqueFilename
,Tag
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhotoScaled

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhotoScaled table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUid]
@PersonPhotoUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoScaledUid
,PersonPhotoUid
,UniqueFilename
,Tag
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhotoScaled
WHERE 
PersonPhotoUid = @PersonPhotoUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhotoScaled table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidOmitImage]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidOmitImage]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidOmitImage]
@PersonPhotoUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoScaledUid
,PersonPhotoUid
,UniqueFilename
,Tag
,PublicUrl
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhotoScaled
WHERE 
PersonPhotoUid = @PersonPhotoUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidOmitImage] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhotoScaled table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidAndTag]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidAndTag]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidAndTag]
@PersonPhotoUid uniqueidentifier,
@Tag nvarchar(65)
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoScaledUid
,PersonPhotoUid
,UniqueFilename
,Tag
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhotoScaled
WHERE 
PersonPhotoUid = @PersonPhotoUid and Tag = @Tag

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidAndTag] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhotoScaled table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidAndTagOmitImage]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidAndTagOmitImage]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidAndTagOmitImage]
@PersonPhotoUid uniqueidentifier,
@Tag nvarchar(65)
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoScaledUid
,PersonPhotoUid
,UniqueFilename
,Tag
,PublicUrl
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhotoScaled
WHERE 
PersonPhotoUid = @PersonPhotoUid and Tag = @Tag

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_ByPersonPhotoUidAndTagOmitImage] TO public
GO










/************************************************************
'* This stored procedure is used to retrieve all rows AND the primary key column AND the 'description' column
'* in the GCS.PersonPhotoScaled table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoScaledUid
,UniqueFilename
,Tag
,PublicUrl
FROM GCS.PersonPhotoScaled

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhotoScaled table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_SelectByPK]
@PersonPhotoScaledUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoScaledUid
,PersonPhotoUid
,UniqueFilename
,Tag
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhotoScaled
WHERE 
PersonPhotoScaledUid = @PersonPhotoScaledUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.PersonPhotoScaled table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_SelectSearch]
@UniqueFilename nvarchar(255) 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoScaledUid
,PersonPhotoUid
,UniqueFilename
,Tag
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhotoScaled
WHERE 
(@UniqueFilename IS NULL OR UniqueFilename LIKE @UniqueFilename + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_SelectSearch] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_SelectSearch]
@UniqueFilename nvarchar(255) 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoScaledUid
,PersonPhotoUid
,UniqueFilename
,Tag
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhotoScaled
WHERE 
(@UniqueFilename IS NULL OR UniqueFilename LIKE @UniqueFilename + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_SelectSearch] TO public
GO


/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.PersonPhotoScaled table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_Insert]
@PersonPhotoScaledUid uniqueidentifier 
,@PersonPhotoUid uniqueidentifier 
,@UniqueFilename nvarchar(255) 
,@Tag nvarchar(65)
,@PublicUrl nvarchar(2048)
,@PhotoImage varbinary(max)
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @PersonPhotoScaledUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonPhotoScaledUid = NULL

if @PersonPhotoScaledUid = '00000000-0000-0000-0000-000000000000' OR @PersonPhotoScaledUid IS NULL
	SET @PersonPhotoScaledUid = NewID()

INSERT INTO GCS.PersonPhotoScaled
(
PersonPhotoScaledUid
,PersonPhotoUid
,UniqueFilename
,Tag
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@PersonPhotoScaledUid
,@PersonPhotoUid
,@UniqueFilename
,@Tag
,@PublicUrl
,@PhotoImage
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.PersonPhotoScaled table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_Update]
@PersonPhotoScaledUid uniqueidentifier 
,@PersonPhotoUid uniqueidentifier
,@UniqueFilename nvarchar(255)
,@Tag nvarchar(65)
,@PublicUrl nvarchar(2048)
,@PhotoImage varbinary(max)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.PersonPhotoScaled
SET 
PersonPhotoScaledUid = @PersonPhotoScaledUid
,PersonPhotoUid = @PersonPhotoUid
,UniqueFilename = @UniqueFilename
,Tag = @Tag
,PublicUrl = @PublicUrl
,PhotoImage = @PhotoImage
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
PersonPhotoScaledUid = @PersonPhotoScaledUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_Update] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_UpdatePublicUrlByPk]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_UpdatePublicUrlByPk]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_UpdatePublicUrlByPk]
@PersonPhotoScaledUid uniqueidentifier 
,@PublicUrl nvarchar(2048)
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.PersonPhotoScaled
SET 
PublicUrl = @PublicUrl
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
PersonPhotoScaledUid = @PersonPhotoScaledUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_UpdatePublicUrlByPk] TO public
GO


/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.PersonPhotoScaled table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_UpdateConcurrency]
@PersonPhotoScaledUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.PersonPhotoScaled
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
PersonPhotoScaledUid = @PersonPhotoScaledUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.PersonPhotoScaled table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_DeleteByPK]
@PersonPhotoScaledUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.PersonPhotoScaled
WHERE
PersonPhotoScaledUid = @PersonPhotoScaledUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.PersonPhotoScaled table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoScaledPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoScaledPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoScaledPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.PersonPhotoScaled

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoScaledPDSA_RowCount] TO public
GO

/* All Stored Procedures for table: PersonPhoto */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.PersonPhoto table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,PersonUid
,Tag
,PublicUrl
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoto table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ByPersonUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUid]
@PersonUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
PersonUid = @PersonUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ByPersonUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoto table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ByPersonUidAndTag]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidAndTag]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidAndTag]
@PersonUid uniqueidentifier,
@Tag nvarchar(65)
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
PersonUid = @PersonUid AND
Tag = @Tag

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ByPersonUidAndTag] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoto table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ByPersonUidAndTagOmitImage]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidAndTagOmitImage]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidAndTagOmitImage]
@PersonUid uniqueidentifier,
@Tag nvarchar(65)
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
PersonUid = @PersonUid AND Tag = @Tag

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ByPersonUidAndTagOmitImage] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoto table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ByPersonUidLastUpdated]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidLastUpdated]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidLastUpdated]
@PersonUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT Top(1) 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
PersonUid = @PersonUid ORDER BY UpdateDate desc

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ByPersonUidLastUpdated] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoto table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ByPersonUidLastUpdatedOmitImage]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidLastUpdatedOmitImage]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidLastUpdatedOmitImage]
@PersonUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT Top(1) 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
--,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
PersonUid = @PersonUid ORDER BY UpdateDate desc

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ByPersonUidLastUpdatedOmitImage] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ByPersonUidIsDefault]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidIsDefault]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidIsDefault]
@PersonUid uniqueidentifier,
@IsDefault bit
AS

declare @ret int;
select @ret = 0;

SELECT Top(1) 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
PersonUid = @PersonUid AND IsDefault = @IsDefault

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ByPersonUidIsDefault] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoto table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ByPersonUidIsDefaultOmitImage]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidIsDefaultOmitImage]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidIsDefaultOmitImage]
@PersonUid uniqueidentifier,
@IsDefault bit
AS

declare @ret int;
select @ret = 0;

SELECT Top(1) 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
--,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
PersonUid = @PersonUid AND IsDefault = @IsDefault

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ByPersonUidIsDefaultOmitImage] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoto table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ByPersonUidOmitImage]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidOmitImage]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ByPersonUidOmitImage]
@PersonUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
PersonUid = @PersonUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ByPersonUidOmitImage] TO public
GO


/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoto table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ByTag]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ByTag]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ByTag]
@Tag nvarchar(65)
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
Tag = @Tag

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ByTag] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows AND the primary key column AND the 'description' column
'* in the GCS.PersonPhoto table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,Tag
,PublicUrl
FROM GCS.PersonPhoto

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows AND the primary key column AND the 'description' column
'* in the GCS.PersonPhoto table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ListForPerson]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ListForPerson]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ListForPerson]
@PersonUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,PersonUid
,Tag
,IsDefault
,UniqueFilename
,PublicUrl
FROM GCS.PersonPhoto
where PersonUid = @PersonUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ListForPerson] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonPhoto table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_SelectByPK]
@PersonPhotoUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
PersonPhotoUid = @PersonPhotoUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.PersonPhoto table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_SelectSearch]
@Tag nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
(@Tag IS NULL OR Tag LIKE @Tag + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_SelectSearch] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ByNoPublicUrl]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ByNoPublicUrl]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ByNoPublicUrl]
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault
,PublicUrl
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.PersonPhoto
WHERE 
PublicUrl IS NULL OR LEN(PublicUrl) = 0

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ByNoPublicUrl] TO public
GO


/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.PersonPhoto table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_Insert]
@PersonPhotoUid uniqueidentifier 
,@PersonUid uniqueidentifier 
,@Tag nvarchar(65) 
,@UniqueFilename nvarchar(255)
,@OriginalFilename nvarchar(255)
,@ContentType nvarchar(255)
,@IsDefault bit
,@PublicUrl nvarchar(2048)
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint
,@PhotoImage varbinary(max)
AS

declare @ret int;
select @ret = 0;


if @PersonPhotoUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonPhotoUid = NULL

if @PersonPhotoUid = '00000000-0000-0000-0000-000000000000' OR @PersonPhotoUid IS NULL
	SET @PersonPhotoUid = NewID()

INSERT INTO GCS.PersonPhoto
(
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,IsDefault 
,PublicUrl
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,PhotoImage
) 
VALUES 
(
@PersonPhotoUid
,@PersonUid
,@Tag
,@UniqueFilename
,@OriginalFilename
,@ContentType
,@IsDefault 
,@PublicUrl
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
,@PhotoImage
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.PersonPhoto table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_Update]
@PersonPhotoUid uniqueidentifier 
,@PersonUid uniqueidentifier
,@Tag nvarchar(65)
,@UniqueFilename nvarchar(255)
,@OriginalFilename nvarchar(255)
,@ContentType nvarchar(255)
,@IsDefault bit
,@PublicUrl nvarchar(2048)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
,@PhotoImage varbinary(max)
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.PersonPhoto
SET 
PersonUid = @PersonUid
,Tag = @Tag
,UniqueFilename = @UniqueFilename
,OriginalFilename = @OriginalFilename
,ContentType = @ContentType
,IsDefault = @IsDefault
,PublicUrl = @PublicUrl
,PhotoImage = @PhotoImage
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
PersonPhotoUid = @PersonPhotoUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_Update] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_UpdatePublicUrlByPk]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_UpdatePublicUrlByPk]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_UpdatePublicUrlByPk]
@PersonPhotoUid uniqueidentifier 
,@PublicUrl nvarchar(2048)
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.PersonPhoto
SET 
PublicUrl = @PublicUrl
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
PersonPhotoUid = @PersonPhotoUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_UpdatePublicUrlByPk] TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_UpdateIsDefaultByPk]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_UpdateIsDefaultByPk]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_UpdateIsDefaultByPk]
@PersonPhotoUid uniqueidentifier 
,@IsDefault bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.PersonPhoto
SET 
IsDefault = @IsDefault
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
PersonPhotoUid = @PersonPhotoUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_UpdateIsDefaultByPk] TO public
GO



/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.PersonPhoto table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_UpdateConcurrency]
@PersonPhotoUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.PersonPhoto
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
PersonPhotoUid = @PersonPhotoUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.PersonPhoto table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_DeleteByPK]
@PersonPhotoUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.PersonPhoto
WHERE
PersonPhotoUid = @PersonPhotoUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.PersonPhoto table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.PersonPhoto

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_RowCount] TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsPersonPhotoUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsPersonPhotoUnique]
GO

CREATE OR ALTER PROCEDURE [GCS].[IsPersonPhotoUnique]
	@PersonPhotoUid [uniqueidentifier],
	@PersonUid [uniqueidentifier],
	@UniqueFilename nvarchar(255),
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from GCS.PersonPhoto where PersonPhotoUid <> @PersonPhotoUid AND (PersonUid = @PersonUid AND UniqueFilename = @UniqueFilename )
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsPersonPhotoUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsPersonPhotoUnique] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsPersonPhotoScaledUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsPersonPhotoScaledUnique]
GO

CREATE OR ALTER PROCEDURE [GCS].[IsPersonPhotoScaledUnique]
	@PersonPhotoScaledUid [uniqueidentifier],
	@PersonPhotoUid [uniqueidentifier],
	@UniqueFilename nvarchar(255),
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from GCS.PersonPhotoScaled where PersonPhotoScaledUid <> @PersonPhotoScaledUid AND (PersonPhotoUid = @PersonPhotoUid AND UniqueFilename = @UniqueFilename )
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsPersonPhotoScaledUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsPersonPhotoScaledUnique] TO [public] AS [dbo]
GO

/************************************************************
'* This stored procedure is used to retrieve all rows AND the primary key column AND the 'description' column
'* in the GCS.PersonPhoto table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPhotoPDSA_ListForPerson]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPhotoPDSA_ListForPerson]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonPhotoPDSA_ListForPerson]
@PersonUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonPhotoUid
,PersonUid
,Tag
,UniqueFilename
,IsDefault
FROM GCS.PersonPhoto
where PersonUid = @PersonUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonPhotoPDSA_ListForPerson] TO public
GO

if dbo.fn_GCSDoesTableExist('UploadedFile') = 0
BEGIN
	/*==============================================================*/
	/* Table: UploadedFile                                          */
	/*==============================================================*/
	create table GCS.UploadedFile (
	   UploadedFileUid      GCS.UniversalUniqueId    RowGuidCol not null UNIQUE,
	   Tag                  GCS.Text65               not null,
	   UniqueFilename       GCS.Text255              not null,
	   OriginalFilename     GCS.Text255              null,
	   ContentType          GCS.Text255              not null,
	   PhotoImage           varbinary(Max)       filestream not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1
	)

	alter table GCS.UploadedFile
	   add constraint PK_UPLOADEDFILE primary key (UploadedFileUid)

	/*==============================================================*/
	/* Index: idxUploadedFileUniqueFilename                         */
	/*==============================================================*/
	create unique nonclustered index idxUploadedFileUniqueFilename on GCS.UploadedFile (UniqueFilename ASC)
end
go

/* All Stored Procedures for table: UploadedFile */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.UploadedFile table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
UploadedFileUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.UploadedFile

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows AND the primary key column AND the 'description' column
'* in the GCS.UploadedFile table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
UploadedFileUid
,Tag
FROM GCS.UploadedFile

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.UploadedFile table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_SelectByPK]
@UploadedFileUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
UploadedFileUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.UploadedFile
WHERE 
UploadedFileUid = @UploadedFileUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.UploadedFile table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_SelectSearch]
@Tag nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
UploadedFileUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.UploadedFile
WHERE 
(@Tag IS NULL OR Tag LIKE @Tag + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.UploadedFile table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_ByUniqueFilename]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_ByUniqueFilename]
GO
CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_ByUniqueFilename]
@UniqueFilename nvarchar(255) 
AS

declare @ret int;
select @ret = 0;

SELECT 
UploadedFileUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.UploadedFile
WHERE 
UniqueFilename = @UniqueFilename 

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_ByUniqueFilename] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.UploadedFile table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_ByTag]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_ByTag]
GO
CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_ByTag]
@Tag nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
UploadedFileUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.UploadedFile
WHERE 
Tag = @Tag

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_ByTag] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.UploadedFile table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_ByOriginalFilename]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_ByOriginalFilename]
GO
CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_ByOriginalFilename]
@OriginalFilename nvarchar(255) 
AS

declare @ret int;
select @ret = 0;

SELECT 
UploadedFileUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.UploadedFile
WHERE 
OriginalFilename = @OriginalFilename 

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_ByOriginalFilename] TO public
GO


/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.UploadedFile table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_Insert]
@UploadedFileUid uniqueidentifier 
,@Tag nvarchar(65) 
,@UniqueFilename nvarchar(255) 
,@OriginalFilename nvarchar(255)  = null
,@ContentType nvarchar(255) 
,@PhotoImage varbinary(max)
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @UploadedFileUid = '00000000-0000-0000-0000-000000000000'
	SET @UploadedFileUid = NULL

if @UploadedFileUid = '00000000-0000-0000-0000-000000000000' OR @UploadedFileUid IS NULL
	SET @UploadedFileUid = NewID()

INSERT INTO GCS.UploadedFile
(
UploadedFileUid
,Tag
,UniqueFilename
,OriginalFilename
,ContentType
,PhotoImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@UploadedFileUid
,@Tag
,@UniqueFilename
,@OriginalFilename
,@ContentType
,@PhotoImage
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.UploadedFile table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_Update]
@UploadedFileUid uniqueidentifier 
,@Tag nvarchar(65)
,@UniqueFilename nvarchar(255)
,@OriginalFilename nvarchar(255)
,@ContentType nvarchar(255)
,@PhotoImage varbinary(max)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.UploadedFile
SET 
UploadedFileUid = @UploadedFileUid
,Tag = @Tag
,UniqueFilename = @UniqueFilename
,OriginalFilename = @OriginalFilename
,ContentType = @ContentType
,PhotoImage = @PhotoImage
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
UploadedFileUid = @UploadedFileUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.UploadedFile table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_UpdateConcurrency]
@UploadedFileUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.UploadedFile
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
UploadedFileUid = @UploadedFileUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.UploadedFile table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_DeleteByPK]
@UploadedFileUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.UploadedFile
WHERE
UploadedFileUid = @UploadedFileUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.UploadedFile table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFilePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFilePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[UploadedFilePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.UploadedFile

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[UploadedFilePDSA_RowCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[UploadedFile_DeleteStaleItems]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[UploadedFile_DeleteStaleItems]
GO
CREATE OR ALTER PROCEDURE GCS.[UploadedFile_DeleteStaleItems] @staleDays int
AS

declare @ret int;
select @ret = 0;

declare @staleDate datetime
set @staleDate = DATEADD(d, -@staleDays, getdate())

delete from GCS.UploadedFile where InsertDate < @staleDate

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[UploadedFile_DeleteStaleItems] TO public
GO


/****** Object:  StoredProcedure [GCS].[gcs_SelectEntitiesByUserId]    Script Date: 8/31/2020 2:22:23 PM ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_SelectEntitiesByUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_SelectEntitiesByUserId]
GO

CREATE OR ALTER PROCEDURE [GCS].[gcs_SelectEntitiesByUserId]
	@UserId [uniqueidentifier],
	@PageNumber int,
	@PageSize int 
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsEntity

if @PageSize = 0
	set @PageSize = 1

SELECT 
EntityId
,EntityName
,EntityDescription
,EntityKey
,IsDefault
,IsActive
,e.BinaryResourceUid
,License
,PublicKey
,BinaryResource as Photo
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsBinaryResource br on 
br.BinaryResourceUid = e.BinaryResourceUid
WHERE 
EntityId IN (SELECT EntityId from GCS.gcsUserEntity WHERE UserId = @UserId)
ORDER BY EntityName
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[gcs_SelectEntitiesByUserId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_SelectEntitiesByUserId] TO [public] AS [dbo]
GO


if dbo.fn_GCSDoesColumnExist('gcsUser', 'IsLockedOutClearedDate') = 0
BEGIN
	ALTER TABLE GCS.gcsUser
	ADD [IsLockedOutClearedDate] datetimeoffset NULL;
END
GO

/* All Stored Procedures for table: gcsUser */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsUser table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsUser

if @PageSize = 0
	set @PageSize = 1

SELECT 
UserId
,t.LanguageId
,FirstName
,LastName
,UserInitials
,Email
,UserName
,DisplayName
,UserPassword
,LastLoginDate
,UserTheme
,IsLockedOut
,IsLockedOutClearedDate
,t.IsActive
,ResetPasswordFlag
,LastPasswordResetDate
,UserActivationDate
,UserExpirationDate
,ImportedFromActiveDirectory
,SecurityImage
,UserImage
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ActiveDirectoryObjectGuid
,PrimaryEntityId
,AccessFailedCount
,ConcurrencyStamp
,EmailConfirmed
,LockoutEnabled
,LockoutEnd
,NormalizedEmail
,NormalizedUserName
,PhoneNumber
,PhoneNumberConfirmed
,SecurityStamp
,TwoFactorEnabled
,PasswordHash
,LanguageName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsUser t
LEFT OUTER JOIN GCS.gcsLanguage l on l.LanguageId = t.LanguageId
ORDER BY (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 0 THEN UserName end) asc,
         (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 1 THEN UserName end) desc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 0 THEN Email end) asc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 1 THEN Email end) desc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 0 THEN LastLoginDate end) asc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 1 THEN LastLoginDate end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUser table 
'* for a single row of data based on a email value passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_SelectByEmail]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_SelectByEmail]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_SelectByEmail]
@Email nvarchar(256),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsUser

if @PageSize = 0
	set @PageSize = 1

SELECT 
UserId
,t.LanguageId
,FirstName
,LastName
,UserInitials
,Email
,UserName
,DisplayName
,UserPassword
,LastLoginDate
,UserTheme
,IsLockedOut
,IsLockedOutClearedDate
,t.IsActive
,ResetPasswordFlag
,LastPasswordResetDate
,UserActivationDate
,UserExpirationDate
,ImportedFromActiveDirectory
,SecurityImage
,UserImage
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ActiveDirectoryObjectGuid
,PrimaryEntityId
,AccessFailedCount
,ConcurrencyStamp
,EmailConfirmed
,LockoutEnabled
,LockoutEnd
,NormalizedEmail
,NormalizedUserName
,PhoneNumber
,PhoneNumberConfirmed
,SecurityStamp
,TwoFactorEnabled
,PasswordHash
,LanguageName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsUser t
LEFT OUTER JOIN GCS.gcsLanguage l on l.LanguageId = t.LanguageId
WHERE 
Email = @Email
ORDER BY (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 0 THEN UserName end) asc,
         (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 1 THEN UserName end) desc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 0 THEN Email end) asc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 1 THEN Email end) desc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 0 THEN LastLoginDate end) asc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 1 THEN LastLoginDate end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_SelectByEmail] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUser table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_ByLanguageId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_ByLanguageId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_ByLanguageId]
@LanguageId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsUser

if @PageSize = 0
	set @PageSize = 1

SELECT 
UserId
,t.LanguageId
,FirstName
,LastName
,UserInitials
,Email
,UserName
,DisplayName
,UserPassword
,LastLoginDate
,UserTheme
,IsLockedOut
,IsLockedOutClearedDate
,t.IsActive
,ResetPasswordFlag
,LastPasswordResetDate
,UserActivationDate
,UserExpirationDate
,ImportedFromActiveDirectory
,SecurityImage
,UserImage
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ActiveDirectoryObjectGuid
,PrimaryEntityId
,AccessFailedCount
,ConcurrencyStamp
,EmailConfirmed
,LockoutEnabled
,LockoutEnd
,NormalizedEmail
,NormalizedUserName
,PhoneNumber
,PhoneNumberConfirmed
,SecurityStamp
,TwoFactorEnabled
,PasswordHash
,LanguageName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsUser t
LEFT OUTER JOIN GCS.gcsLanguage l on l.LanguageId = t.LanguageId
WHERE 
t.LanguageId = @LanguageId
ORDER BY (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 0 THEN UserName end) asc,
         (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 1 THEN UserName end) desc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 0 THEN Email end) asc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 1 THEN Email end) desc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 0 THEN LastLoginDate end) asc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 1 THEN LastLoginDate end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_ByLanguageId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUser table 
'* for a single row of data based on a email value passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_SelectByUserPassword]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_SelectByUserPassword]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_SelectByUserPassword]
@UserPassword nvarchar(1024),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsUser

if @PageSize = 0
	set @PageSize = 1

SELECT 
UserId
,t.LanguageId
,FirstName
,LastName
,UserInitials
,Email
,UserName
,DisplayName
,UserPassword
,LastLoginDate
,UserTheme
,IsLockedOut
,IsLockedOutClearedDate
,t.IsActive
,ResetPasswordFlag
,LastPasswordResetDate
,UserActivationDate
,UserExpirationDate
,ImportedFromActiveDirectory
,SecurityImage
,UserImage
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ActiveDirectoryObjectGuid
,PrimaryEntityId
,AccessFailedCount
,ConcurrencyStamp
,EmailConfirmed
,LockoutEnabled
,LockoutEnd
,NormalizedEmail
,NormalizedUserName
,PhoneNumber
,PhoneNumberConfirmed
,SecurityStamp
,TwoFactorEnabled
,PasswordHash
,LanguageName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsUser t
LEFT OUTER JOIN GCS.gcsLanguage l on l.LanguageId = t.LanguageId
WHERE 
UserPassword = @UserPassword
ORDER BY (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 0 THEN UserName end) asc,
         (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 1 THEN UserName end) desc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 0 THEN Email end) asc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 1 THEN Email end) desc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 0 THEN LastLoginDate end) asc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 1 THEN LastLoginDate end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_SelectByUserPassword] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.gcsUser table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsUser

if @PageSize = 0
	set @PageSize = 1

SELECT 
UserId
,FirstName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsUser
ORDER BY (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 0 THEN UserName end) asc,
         (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 1 THEN UserName end) desc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 0 THEN Email end) asc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 1 THEN Email end) desc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 0 THEN LastLoginDate end) asc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 1 THEN LastLoginDate end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUser table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_SelectByPK]
@UserId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
UserId
,t.LanguageId
,FirstName
,LastName
,UserInitials
,Email
,UserName
,DisplayName
,UserPassword
,LastLoginDate
,UserTheme
,IsLockedOut
,IsLockedOutClearedDate
,t.IsActive
,ResetPasswordFlag
,LastPasswordResetDate
,UserActivationDate
,UserExpirationDate
,ImportedFromActiveDirectory
,SecurityImage
,UserImage
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ActiveDirectoryObjectGuid
,PrimaryEntityId
,AccessFailedCount
,ConcurrencyStamp
,EmailConfirmed
,LockoutEnabled
,LockoutEnd
,NormalizedEmail
,NormalizedUserName
,PhoneNumber
,PhoneNumberConfirmed
,SecurityStamp
,TwoFactorEnabled
,PasswordHash
,LanguageName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsUser t
LEFT OUTER JOIN GCS.gcsLanguage l on l.LanguageId = t.LanguageId
WHERE 
UserId = @UserId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsUser table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_SelectSearch]
@UserName nvarchar(30),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsUser

if @PageSize = 0
	set @PageSize = 1

SELECT 
UserId
,t.LanguageId
,FirstName
,LastName
,UserInitials
,Email
,UserName
,DisplayName
,UserPassword
,LastLoginDate
,UserTheme
,IsLockedOut
,IsLockedOutClearedDate
,t.IsActive
,ResetPasswordFlag
,LastPasswordResetDate
,UserActivationDate
,UserExpirationDate
,ImportedFromActiveDirectory
,SecurityImage
,UserImage
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ActiveDirectoryObjectGuid
,PrimaryEntityId
,AccessFailedCount
,ConcurrencyStamp
,EmailConfirmed
,LockoutEnabled
,LockoutEnd
,NormalizedEmail
,NormalizedUserName
,PhoneNumber
,PhoneNumberConfirmed
,SecurityStamp
,TwoFactorEnabled
,PasswordHash
,LanguageName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsUser t
LEFT OUTER JOIN GCS.gcsLanguage l on l.LanguageId = t.LanguageId
WHERE 
(@UserName IS NULL OR UserName LIKE @UserName + '%')
ORDER BY (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 0 THEN UserName end) asc,
         (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 1 THEN UserName end) desc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 0 THEN Email end) asc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 1 THEN Email end) desc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 0 THEN LastLoginDate end) asc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 1 THEN LastLoginDate end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUser table 
'* for a single row of data based on a email value passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_SelectByUserName]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_SelectByUserName]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_SelectByUserName]
@UserName nvarchar(100),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsUser

if @PageSize = 0
	set @PageSize = 1

SELECT 
UserId
,t.LanguageId
,FirstName
,LastName
,UserInitials
,Email
,UserName
,DisplayName
,UserPassword
,LastLoginDate
,UserTheme
,IsLockedOut
,IsLockedOutClearedDate
,t.IsActive
,ResetPasswordFlag
,LastPasswordResetDate
,UserActivationDate
,UserExpirationDate
,ImportedFromActiveDirectory
,SecurityImage
,UserImage
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ActiveDirectoryObjectGuid
,PrimaryEntityId
,AccessFailedCount
,ConcurrencyStamp
,EmailConfirmed
,LockoutEnabled
,LockoutEnd
,NormalizedEmail
,NormalizedUserName
,PhoneNumber
,PhoneNumberConfirmed
,SecurityStamp
,TwoFactorEnabled
,PasswordHash
,LanguageName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsUser t
LEFT OUTER JOIN GCS.gcsLanguage l on l.LanguageId = t.LanguageId
WHERE 
UserName = @UserName
ORDER BY (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 0 THEN UserName end) asc,
         (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 1 THEN UserName end) desc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 0 THEN Email end) asc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 1 THEN Email end) desc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 0 THEN LastLoginDate end) asc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 1 THEN LastLoginDate end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_SelectByUserName] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUser table 
'* for a single row of data based on a email value passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_SelectByUserNameOrEmail]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_SelectByUserNameOrEmail]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_SelectByUserNameOrEmail]
@UserName nvarchar(100),
@Email nvarchar(256),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsUser

if @PageSize = 0
	set @PageSize = 1

SELECT 
UserId
,t.LanguageId
,FirstName
,LastName
,UserInitials
,Email
,UserName
,DisplayName
,UserPassword
,LastLoginDate
,UserTheme
,IsLockedOut
,IsLockedOutClearedDate
,t.IsActive
,ResetPasswordFlag
,LastPasswordResetDate
,UserActivationDate
,UserExpirationDate
,ImportedFromActiveDirectory
,SecurityImage
,UserImage
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ActiveDirectoryObjectGuid
,PrimaryEntityId
,AccessFailedCount
,ConcurrencyStamp
,EmailConfirmed
,LockoutEnabled
,LockoutEnd
,NormalizedEmail
,NormalizedUserName
,PhoneNumber
,PhoneNumberConfirmed
,SecurityStamp
,TwoFactorEnabled
,PasswordHash
,LanguageName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsUser t
LEFT OUTER JOIN GCS.gcsLanguage l on l.LanguageId = t.LanguageId
WHERE 
UserName = @UserName OR Email = @Email
ORDER BY (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 0 THEN UserName end) asc,
         (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 1 THEN UserName end) desc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 0 THEN Email end) asc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 1 THEN Email end) desc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 0 THEN LastLoginDate end) asc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 1 THEN LastLoginDate end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_SelectByUserNameOrEmail] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUser table 
'* for a single row of data based on a email value passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_ByPrimaryEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_ByPrimaryEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_ByPrimaryEntityId]
@PrimaryEntityId [uniqueidentifier],
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsUser

if @PageSize = 0
	set @PageSize = 1

SELECT 
UserId
,t.LanguageId
,FirstName
,LastName
,UserInitials
,Email
,UserName
,DisplayName
,UserPassword
,LastLoginDate
,UserTheme
,IsLockedOut
,IsLockedOutClearedDate
,t.IsActive
,ResetPasswordFlag
,LastPasswordResetDate
,UserActivationDate
,UserExpirationDate
,ImportedFromActiveDirectory
,SecurityImage
,UserImage
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ActiveDirectoryObjectGuid
,PrimaryEntityId
,AccessFailedCount
,ConcurrencyStamp
,EmailConfirmed
,LockoutEnabled
,LockoutEnd
,NormalizedEmail
,NormalizedUserName
,PhoneNumber
,PhoneNumberConfirmed
,SecurityStamp
,TwoFactorEnabled
,PasswordHash
,LanguageName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsUser t
LEFT OUTER JOIN GCS.gcsLanguage l on l.LanguageId = t.LanguageId
WHERE 
PrimaryEntityId = @PrimaryEntityId 
ORDER BY (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 0 THEN UserName end) asc,
         (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 1 THEN UserName end) desc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 0 THEN Email end) asc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 1 THEN Email end) desc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 0 THEN LastLoginDate end) asc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 1 THEN LastLoginDate end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_ByPrimaryEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUser table 
'* for a single row of data based on a email value passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_SelectByDisplayName]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_SelectByDisplayName]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_SelectByDisplayName]
@DisplayName [nvarchar](100),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsUser

if @PageSize = 0
	set @PageSize = 1

SELECT 
UserId
,t.LanguageId
,FirstName
,LastName
,UserInitials
,Email
,UserName
,DisplayName
,UserPassword
,LastLoginDate
,UserTheme
,IsLockedOut
,IsLockedOutClearedDate
,t.IsActive
,ResetPasswordFlag
,LastPasswordResetDate
,UserActivationDate
,UserExpirationDate
,ImportedFromActiveDirectory
,SecurityImage
,UserImage
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ActiveDirectoryObjectGuid
,PrimaryEntityId
,AccessFailedCount
,ConcurrencyStamp
,EmailConfirmed
,LockoutEnabled
,LockoutEnd
,NormalizedEmail
,NormalizedUserName
,PhoneNumber
,PhoneNumberConfirmed
,SecurityStamp
,TwoFactorEnabled
,PasswordHash
,LanguageName
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsUser t
LEFT OUTER JOIN GCS.gcsLanguage l on l.LanguageId = t.LanguageId
WHERE 
DisplayName = @DisplayName
ORDER BY (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 0 THEN UserName end) asc,
         (CASE WHEN @SortColumn = 'UserName' AND @DescendingOrder = 1 THEN UserName end) desc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 0 THEN Email end) asc,
         (CASE WHEN @SortColumn = 'Email' AND @DescendingOrder = 1 THEN Email end) desc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 0 THEN LastLoginDate end) asc,
         (CASE WHEN @SortColumn = 'LastLoginDate' AND @DescendingOrder = 1 THEN LastLoginDate end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_SelectByDisplayName] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_Insert] 
GO

/****** Object:  StoredProcedure [GCS].[gcsUserPDSA_Insert]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsUserPDSA_Insert]
	@UserId [uniqueidentifier],
	@LanguageId [uniqueidentifier] = null,
	@FirstName [nvarchar](30),
	@LastName [nvarchar](30),
	@UserInitials [nvarchar](10) = null,
	@Email [nvarchar](255),
	@UserName [nvarchar](100),
	@DisplayName [nvarchar](100),
	@UserPassword [nvarchar](1024) = null,
	@LastLoginDate [datetimeoffset] = null,
	@UserTheme [nvarchar](65) = null,
	@IsLockedOut [bit],
	@IsLockedOutClearedDate [datetimeoffset],
	@IsActive [bit],
	@ResetPasswordFlag [bit],
	@LastPasswordResetDate [datetimeoffset] = null,
	@UserActivationDate [datetime] = null,
	@UserExpirationDate [datetime] = null,
	@ImportedFromActiveDirectory [bit],
	@SecurityImage [varbinary](max) = null,
	@UserImage [varbinary](max) = null,
	@InsertName [nvarchar](100),
	@InsertDate [datetimeoffset],
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint],
	@ActiveDirectoryObjectGuid [uniqueidentifier] = null,
	@PrimaryEntityId [uniqueidentifier],
	@AccessFailedCount [int],
	@ConcurrencyStamp [nvarchar](max) = null,
	@EmailConfirmed [bit],
	@LockoutEnabled [bit],
	@LockoutEnd [datetimeoffset](7) = null,
	@NormalizedEmail [nvarchar](256),
	@NormalizedUserName [nvarchar](256),
	@PhoneNumber [nvarchar](max) = null,
	@PhoneNumberConfirmed [bit],
	@SecurityStamp [nvarchar](max) = null,
	@TwoFactorEnabled [bit],
	@PasswordHash [nvarchar](max) = null
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @UserId = '00000000-0000-0000-0000-000000000000'
	SET @UserId = NULL
if @LanguageId = '00000000-0000-0000-0000-000000000000'
	SET @LanguageId = NULL
if @ActiveDirectoryObjectGuid = '00000000-0000-0000-0000-000000000000'
	SET @ActiveDirectoryObjectGuid = NULL
if @PrimaryEntityId = '00000000-0000-0000-0000-000000000000'
	SET @PrimaryEntityId = NULL


if @UserId = '00000000-0000-0000-0000-000000000000' OR @UserId IS NULL
	SET @UserId = NewID()

INSERT INTO GCS.gcsUser
(
UserId
,LanguageId
,FirstName
,LastName
,UserInitials
,Email
,UserName
,DisplayName
,UserPassword
,LastLoginDate
,UserTheme
,IsLockedOut
,IsLockedOutClearedDate
,IsActive
,ResetPasswordFlag
,LastPasswordResetDate
,UserActivationDate
,UserExpirationDate
,ImportedFromActiveDirectory
,SecurityImage
,UserImage
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,ActiveDirectoryObjectGuid
,PrimaryEntityId
,AccessFailedCount
,ConcurrencyStamp
,EmailConfirmed
,LockoutEnabled
,LockoutEnd
,NormalizedEmail
,NormalizedUserName
,PhoneNumber
,PhoneNumberConfirmed
,SecurityStamp
,TwoFactorEnabled
,PasswordHash
) 
VALUES 
(
@UserId
,@LanguageId
,@FirstName
,@LastName
,@UserInitials
,@Email
,@UserName
,@DisplayName
,@UserPassword
,@LastLoginDate
,@UserTheme
,@IsLockedOut
,@IsLockedOutClearedDate
,@IsActive
,@ResetPasswordFlag
,@LastPasswordResetDate
,@UserActivationDate
,@UserExpirationDate
,@ImportedFromActiveDirectory
,@SecurityImage
,@UserImage
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
,@ActiveDirectoryObjectGuid
,@PrimaryEntityId
,@AccessFailedCount
,@ConcurrencyStamp
,@EmailConfirmed
,@LockoutEnabled
,@LockoutEnd
,@NormalizedEmail
,@NormalizedUserName
,@PhoneNumber
,@PhoneNumberConfirmed
,@SecurityStamp
,@TwoFactorEnabled
,@PasswordHash
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[gcsUserPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsUserPDSA_Insert] TO [public] AS [dbo]
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsUser table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_Update]
GO
/****** Object:  StoredProcedure [GCS].[gcsUserPDSA_Update]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsUserPDSA_Update]
	@UserId [uniqueidentifier],
	@LanguageId [uniqueidentifier],
	@FirstName [nvarchar](30),
	@LastName [nvarchar](30),
	@UserInitials [nvarchar](10),
	@Email [nvarchar](255),
	@UserName [nvarchar](100),
	@DisplayName [nvarchar](100),
	@UserPassword [nvarchar](1024),
	@LastLoginDate [datetimeoffset],
	@UserTheme [nvarchar](65),
	@IsLockedOut [bit],
	@IsLockedOutClearedDate [datetimeoffset],
	@IsActive [bit],
	@ResetPasswordFlag [bit],
	@LastPasswordResetDate [datetimeoffset],
	@UserActivationDate [datetime],
	@UserExpirationDate [datetime],
	@ImportedFromActiveDirectory [bit],
	@SecurityImage [varbinary](max),
	@UserImage [varbinary](max),
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ActiveDirectoryObjectGuid [uniqueidentifier],
	@PrimaryEntityId [uniqueidentifier],
	@AccessFailedCount [int],
	@ConcurrencyStamp [nvarchar](max),
	@EmailConfirmed [bit],
	@LockoutEnabled [bit],
	@LockoutEnd [datetimeoffset](7),
	@NormalizedEmail [nvarchar](256),
	@NormalizedUserName [nvarchar](256),
	@PhoneNumber [nvarchar](max),
	@PhoneNumberConfirmed [bit],
	@SecurityStamp [nvarchar](max),
	@TwoFactorEnabled [bit],
	@PasswordHash [nvarchar](max),
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

UPDATE GCS.gcsUser
SET 
--UserId = @UserId,
LanguageId = @LanguageId
,FirstName = @FirstName
,LastName = @LastName
,UserInitials = @UserInitials
,Email = @Email
,UserName = @UserName
,DisplayName = @DisplayName
,UserPassword = @UserPassword
,LastLoginDate = @LastLoginDate
,UserTheme = @UserTheme
,IsLockedOut = @IsLockedOut
,IsLockedOutClearedDate = @IsLockedOutClearedDate
,IsActive = @IsActive
,ResetPasswordFlag = @ResetPasswordFlag
,LastPasswordResetDate = @LastPasswordResetDate
,UserActivationDate = @UserActivationDate
,UserExpirationDate = @UserExpirationDate
,ImportedFromActiveDirectory = @ImportedFromActiveDirectory
,SecurityImage = @SecurityImage
,UserImage = @UserImage
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ActiveDirectoryObjectGuid = @ActiveDirectoryObjectGuid
,PrimaryEntityId = @PrimaryEntityId
,AccessFailedCount = @AccessFailedCount
,ConcurrencyStamp = @ConcurrencyStamp
,EmailConfirmed = @EmailConfirmed
,LockoutEnabled = @LockoutEnabled
,LockoutEnd = @LockoutEnd
,NormalizedEmail = @NormalizedEmail
,NormalizedUserName = @NormalizedUserName
,PhoneNumber = @PhoneNumber
,PhoneNumberConfirmed = @PhoneNumberConfirmed
,SecurityStamp = @SecurityStamp
,TwoFactorEnabled = @TwoFactorEnabled
,PasswordHash = @PasswordHash
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
UserId = @UserId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[gcsUserPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsUserPDSA_Update] TO [public] AS [dbo]
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsUser table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_UpdateConcurrency]
@UserId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsUser
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
UserId = @UserId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_UpdateConcurrency] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUser_UpdateIsLockedOut]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUser_UpdateIsLockedOut]
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsUser_UpdateIsLockedOut]
	@UserId [uniqueidentifier],
	@IsLockedOut bit
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @IsLockedOut = 1
BEGIN
      UPDATE GCS.gcsUser SET IsLockedOut = @IsLockedOut
      WHERE UserId = @UserId
END
ELSE
BEGIN
      UPDATE GCS.gcsUser SET IsLockedOut = @IsLockedOut, IsLockedOutClearedDate = SYSDATETIMEOFFSET()
      WHERE UserId = @UserId
END

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[gcsUser_UpdateIsLockedOut] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsUser_UpdateIsLockedOut] TO [public] AS [dbo]
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsUser table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_DeleteByPK]
@UserId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsUser
WHERE
UserId = @UserId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsUser table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsUser

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserPDSA_RowCount] TO public
GO

/****** Object:  StoredProcedure [GCS].[gcsUserPDSA_UpdatePassword]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsUserPDSA_UpdatePassword]
	@UserId [uniqueidentifier],
	@LanguageId [uniqueidentifier],
	@FirstName [nvarchar](30),
	@LastName [nvarchar](30),
	@UserInitials [nvarchar](10),
	@Email [nvarchar](255),
	@UserName [nvarchar](100),
	@DisplayName [nvarchar](100),
	@UserPassword [nvarchar](1024),
	@LastLoginDate [datetimeoffset],
	@UserTheme [nvarchar](65),
	@IsLockedOut [bit],
	@IsActive [bit],
	@ResetPasswordFlag [bit],
	@LastPasswordResetDate [datetimeoffset],
	@UserActivationDate [datetime],
	@UserExpirationDate [datetime],
	@ImportedFromActiveDirectory [bit],
	@SecurityImage [varbinary](max),
	@UserImage [varbinary](max),
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ActiveDirectoryObjectGuid [uniqueidentifier],
	@PrimaryEntityId [uniqueidentifier],
	@AccessFailedCount [int],
	@ConcurrencyStamp [nvarchar](max),
	@EmailConfirmed [bit],
	@LockoutEnabled [bit],
	@LockoutEnd [datetimeoffset](7),
	@NormalizedEmail [nvarchar](256),
	@NormalizedUserName [nvarchar](256),
	@PhoneNumber [nvarchar](max),
	@PhoneNumberConfirmed [bit],
	@SecurityStamp [nvarchar](max),
	@TwoFactorEnabled [bit],
	@PasswordHash [nvarchar](max),
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

UPDATE GCS.gcsUser
SET 
UserId = @UserId
,LanguageId = @LanguageId
,FirstName = @FirstName
,LastName = @LastName
,UserInitials = @UserInitials
,Email = @Email
,UserName = @UserName
,DisplayName = @DisplayName
,UserPassword = @UserPassword
,LastLoginDate = @LastLoginDate
,UserTheme = @UserTheme
,IsLockedOut = @IsLockedOut
,IsActive = @IsActive
,ResetPasswordFlag = @ResetPasswordFlag
,LastPasswordResetDate = @LastPasswordResetDate
,UserActivationDate = @UserActivationDate
,UserExpirationDate = @UserExpirationDate
,ImportedFromActiveDirectory = @ImportedFromActiveDirectory
,SecurityImage = @SecurityImage
,UserImage = @UserImage
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ActiveDirectoryObjectGuid = @ActiveDirectoryObjectGuid
,PrimaryEntityId = @PrimaryEntityId
,AccessFailedCount = @AccessFailedCount
,ConcurrencyStamp = @ConcurrencyStamp
,EmailConfirmed = @EmailConfirmed
,LockoutEnabled = @LockoutEnabled
,LockoutEnd = @LockoutEnd
,NormalizedEmail = @NormalizedEmail
,NormalizedUserName = @NormalizedUserName
,PhoneNumber = @PhoneNumber
,PhoneNumberConfirmed = @PhoneNumberConfirmed
,SecurityStamp = @SecurityStamp
,TwoFactorEnabled = @TwoFactorEnabled
,PasswordHash = @PasswordHash
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
UserId = @UserId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[gcsUserPDSA_UpdatePassword] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsUserPDSA_UpdatePassword] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_ByApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_ByApplicationId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_ByApplicationIdEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_ByApplicationIdEntityId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_ByUserEntityIdApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_ByUserEntityIdApplicationId]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_ByUserIdEntityIdApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_ByUserIdEntityIdApplicationId] 
GO

if dbo.fn_GCSDoesColumnExist('gcsRole', 'IsTemplateRole') = 1
BEGIN
	EXEC sp_rename 'GCS.gcsRole.IsTemplateRole', 'IsDefault', 'COLUMN';
END
go  


/* All Stored Procedures for table: gcsRole */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsRole table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsRole

if @PageSize = 0
	set @PageSize = 1

SELECT 
RoleId
,EntityId
,RoleName
,RoleDescription
,IsActive
,IsDefault
,IsAdministratorRole
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsRole
ORDER BY (CASE WHEN @SortColumn = 'RoleName' AND @DescendingOrder = 0 THEN RoleName end) asc,
         (CASE WHEN @SortColumn = 'RoleName' AND @DescendingOrder = 1 THEN RoleName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsRole table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_ByEntityId]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsRole

if @PageSize = 0
	set @PageSize = 1

SELECT 
RoleId
,EntityId
,RoleName
,RoleDescription
,IsActive
,IsDefault
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,IsAdministratorRole
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsRole
WHERE EntityId = @EntityId
ORDER BY (CASE WHEN @SortColumn = 'RoleName' AND @DescendingOrder = 0 THEN RoleName end) asc,
         (CASE WHEN @SortColumn = 'RoleName' AND @DescendingOrder = 1 THEN RoleName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_ByEntityId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_ByEntityIdForUser]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_ByEntityIdForUser]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_ByEntityIdForUser]
@EntityId uniqueidentifier,
@UserId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsRole

if @PageSize = 0
	set @PageSize = 1


SELECT 
RoleId
,EntityId
,RoleName
,RoleDescription
,IsActive
,IsDefault
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,IsAdministratorRole
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsRole
WHERE EntityId = @EntityId and RoleId in (select RoleId from GCS.UserEntityRoleView where UserId = @UserId and EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'RoleName' AND @DescendingOrder = 0 THEN RoleName end) asc,
         (CASE WHEN @SortColumn = 'RoleName' AND @DescendingOrder = 1 THEN RoleName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_ByEntityIdForUser] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.gcsRole table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.gcsRole

if @PageSize = 0
	set @PageSize = 1

SELECT 
RoleId
,EntityId
,RoleName
,IsAdministratorRole
,IsActive
,COUNT(*) OVER() TotalRowCount
FROM GCS.gcsRole
ORDER BY (CASE WHEN @SortColumn = 'RoleName' AND @DescendingOrder = 0 THEN RoleName end) asc,
         (CASE WHEN @SortColumn = 'RoleName' AND @DescendingOrder = 1 THEN RoleName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsRole table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_SelectByPK]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleId
,EntityId
,RoleName
,RoleDescription
,IsActive
,IsDefault
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,IsAdministratorRole
FROM GCS.gcsRole
WHERE 
RoleId = @RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_SelectByPK] TO public
GO

CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_SelectNameByPK]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleName
FROM GCS.gcsRole
WHERE 
RoleId = @RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_SelectNameByPK] TO public
GO



/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsRole table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_SelectSearch]
@RoleName nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleId
,EntityId
,RoleName
,RoleDescription
,IsActive
,IsDefault
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,IsAdministratorRole
FROM GCS.gcsRole
WHERE 
(@RoleName IS NULL OR RoleName LIKE @RoleName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.gcsRole table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_Insert]
@RoleId uniqueidentifier 
,@EntityId uniqueidentifier 
,@RoleName nvarchar(65) 
,@RoleDescription nvarchar(255) 
,@IsActive bit 
,@IsDefault bit 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
,@IsAdministratorRole bit 
AS

declare @ret int;
select @ret = 0;

if @RoleId = '00000000-0000-0000-0000-000000000000'
	SET @RoleId = NULL

if @RoleId = '00000000-0000-0000-0000-000000000000' OR @RoleId IS NULL
	SET @RoleId = NewID()

INSERT INTO GCS.gcsRole
(
RoleId
,EntityId
,RoleName
,RoleDescription
,IsActive
,IsDefault
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,IsAdministratorRole
) 
VALUES 
(
@RoleId
,@EntityId
,@RoleName
,@RoleDescription
,@IsActive
,@IsDefault
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
,@IsAdministratorRole
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsRole table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_Update]
@RoleId uniqueidentifier 
,@EntityId uniqueidentifier
,@RoleName nvarchar(65)
,@RoleDescription nvarchar(255)
,@IsActive bit
,@IsDefault bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@IsAdministratorRole bit
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsRole
SET 
RoleId = @RoleId
,EntityId = @EntityId
,RoleName = @RoleName
,RoleDescription = @RoleDescription
,IsActive = @IsActive
,IsDefault = @IsDefault
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,IsAdministratorRole = @IsAdministratorRole
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
RoleId = @RoleId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsRole table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_UpdateConcurrency]
@RoleId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsRole
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
RoleId = @RoleId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_UpdateConcurrency] TO public
GO


/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsRole table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_DeleteByPK]
@RoleId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsRole
WHERE
RoleId = @RoleId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsRole table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsRole

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePDSA_RowCount] TO public
GO

if dbo.fn_GCSDoesColumnExist('AccessGroup', 'DefaultTimeScheduleUid') = 0
BEGIN
	ALTER TABLE GCS.AccessGroup
	add DefaultTimeScheduleUid [uniqueidentifier] NOT NULL default 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF'
END
go  



/* All Stored Procedures for table: AccessGroup */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.AccessGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@IncludeSystemGroups bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessGroup

if @PageSize = 0
	set @PageSize = 1

DECLARE @minAgNumber int = 0
declare @maxAgNumber int = 65535
declare @excludeUnlimitedAg int = 65536

if @IncludeSystemGroups = 0
begin
	set @minAgNumber = 1
	set @maxAgNumber = 2000
	set @excludeUnlimitedAg = 255
end

SELECT 
AccessGroupUid
,t.ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,AccessGroupNumber
,Display
,t.Description
,ServiceComment
,Comment
,IsEnabled
,ActivationDate
,ExpirationDate
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,CrisisModeAccessGroupUid
,t.EntityId
,DefaultTimeScheduleUid
,ClusterName
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessGroup t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE AccessGroupNumber BETWEEN @minAgNumber and @maxAgNumber AND AccessGroupNumber <> @excludeUnlimitedAg
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 0 THEN AccessGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 1 THEN AccessGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_ByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL,
@IncludeSystemGroups bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessGroup

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

DECLARE @minAgNumber int = 0
declare @maxAgNumber int = 65535
declare @excludeUnlimitedAg int = 65536

if @IncludeSystemGroups = 0
begin
	set @minAgNumber = 1
	set @maxAgNumber = 2000
	set @excludeUnlimitedAg = 255
end

SELECT 
AccessGroupUid
,t.ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,CrisisModeAccessGroupUid
,t.EntityId
,AccessGroupNumber
,ServiceComment
,Comment
,IsEnabled
,ActivationDate
,ExpirationDate
,DefaultTimeScheduleUid
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessGroup t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
t.ClusterUid = @ClusterUid AND AccessGroupNumber BETWEEN @minAgNumber and @maxAgNumber AND AccessGroupNumber <> @excludeUnlimitedAg
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 0 THEN AccessGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 1 THEN AccessGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_ByClusterEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_ByClusterEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_ByClusterEntityId]
@ClusterUid uniqueidentifier,
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL,
@IncludeSystemGroups bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessGroup

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

DECLARE @minAgNumber int = 0
declare @maxAgNumber int = 65535
declare @excludeUnlimitedAg int = 65536

if @IncludeSystemGroups = 0
begin
	set @minAgNumber = 1
	set @maxAgNumber = 2000
	set @excludeUnlimitedAg = 255
end

SELECT 
AccessGroupUid
,t.ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,CrisisModeAccessGroupUid
,t.EntityId
,AccessGroupNumber
,ServiceComment
,Comment
,IsEnabled
,ActivationDate
,ExpirationDate
,DefaultTimeScheduleUid
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessGroup t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
t.ClusterUid = @ClusterUid AND
( t.EntityId = @EntityId OR
AccessGroupUid in (SELECT AccessGroupUid FROM GCS.AccessGroupEntityMap WHERE EntityId = @EntityId))
AND AccessGroupNumber BETWEEN @minAgNumber and @maxAgNumber AND AccessGroupNumber <> @excludeUnlimitedAg
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 0 THEN AccessGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 1 THEN AccessGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_ByClusterEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL,
@IncludeSystemGroups bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessGroup

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

DECLARE @minAgNumber int = 0
declare @maxAgNumber int = 65535
declare @excludeUnlimitedAg int = 65536

if @IncludeSystemGroups = 0
begin
	set @minAgNumber = 1
	set @maxAgNumber = 2000
	set @excludeUnlimitedAg = 255
end

SELECT 
AccessGroupUid
,t.ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,CrisisModeAccessGroupUid
,t.EntityId
,AccessGroupNumber
,ServiceComment
,Comment
,IsEnabled
,ActivationDate
,ExpirationDate
,DefaultTimeScheduleUid
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessGroup t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
(t.EntityId = @EntityId OR 
AccessGroupUid in (SELECT DISTINCT AccessGroupUid FROM GCS.AccessGroupEntityMap WHERE EntityId = @EntityId))
AND AccessGroupNumber BETWEEN @minAgNumber and @maxAgNumber AND AccessGroupNumber <> @excludeUnlimitedAg
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 0 THEN AccessGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 1 THEN AccessGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_ByEntityId] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_GetSpecialGroupsByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_GetSpecialGroupsByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_GetSpecialGroupsByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessGroup

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
AccessGroupUid
,t.ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,CrisisModeAccessGroupUid
,t.EntityId
,AccessGroupNumber
,ServiceComment
,Comment
,IsEnabled
,ActivationDate
,ExpirationDate
,DefaultTimeScheduleUid
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessGroup t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
t.ClusterUid = @ClusterUid AND t.AccessGroupNumber in ( 0, 255, 2001)
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 0 THEN AccessGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 1 THEN AccessGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_GetSpecialGroupsByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.AccessGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@IncludeSystemGroups bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessGroup

if @PageSize = 0
	set @PageSize = 1

DECLARE @minAgNumber int = 0
declare @maxAgNumber int = 65535
declare @excludeUnlimitedAg int = 65536

if @IncludeSystemGroups = 0
begin
	set @minAgNumber = 1
	set @maxAgNumber = 2000
	set @excludeUnlimitedAg = 255
end

SELECT 
AccessGroupUid
,Display
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessGroup
WHERE AccessGroupNumber BETWEEN @minAgNumber and @maxAgNumber AND AccessGroupNumber <> @excludeUnlimitedAg
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 0 THEN AccessGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 1 THEN AccessGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessGroup table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_SelectByPK]
@AccessGroupUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT
ag.AccessGroupUid
,ag.ClusterUid
,ag.DisplayResourceKey
,ag.DescriptionResourceKey
,ag.CrisisModeAccessGroupUid
,ag.EntityId
,ag.AccessGroupNumber
,ag.Display
,ag.Description
,ag.ServiceComment
,ag.Comment
,ag.IsEnabled
,ag.ActivationDate
,ag.ExpirationDate
,ag.DefaultTimeScheduleUid
,ag.InsertName
,ag.InsertDate
,ag.UpdateName
,ag.UpdateDate
,ag.ConcurrencyValue
,c.ClusterName
,crisisAg.AccessGroupNumber as CrisisModeAccessGroupNumber
,crisisAg.Display as CrisisModeAccessGroupName
,ts.Display as DefaultTimeScheduleName
,1 as TotalRowCount
FROM GCS.AccessGroup ag
LEFT OUTER JOIN GCS.AccessGroup crisisAg on crisisAg.AccessGroupUid = ag.CrisisModeAccessGroupUid
JOIN GCS.Cluster c on c.ClusterUid = ag.ClusterUid
JOIN GCS.TimeSchedule ts on ts.TimeScheduleUid = ag.DefaultTimeScheduleUid
WHERE ag.AccessGroupUid = @AccessGroupUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.AccessGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_SelectSearch]
@Display nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessGroup

if @PageSize = 0
	set @PageSize = 1

SELECT 
AccessGroupUid
,t.ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,CrisisModeAccessGroupUid
,t.EntityId
,AccessGroupNumber
,Display
,t.Description
,ServiceComment
,Comment
,IsEnabled
,ActivationDate
,ExpirationDate
,DefaultTimeScheduleUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessGroup t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
(@Display IS NULL OR Display LIKE @Display + '%')
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 0 THEN AccessGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'AccessGroupNumber' AND @DescendingOrder = 1 THEN AccessGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.AccessGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_Insert]
@AccessGroupUid uniqueidentifier 
,@ClusterUid uniqueidentifier 
,@DisplayResourceKey uniqueidentifier  = null
,@DescriptionResourceKey uniqueidentifier  = null
,@CrisisModeAccessGroupUid uniqueidentifier  = null
,@EntityId uniqueidentifier 
,@AccessGroupNumber int 
,@Display nvarchar(65) 
,@Description nvarchar(1000)  = null
,@ServiceComment nvarchar(1000)  = null
,@Comment nvarchar(1000)  = null
,@IsEnabled bit 
,@ActivationDate datetime 
,@ExpirationDate datetime 
,@DefaultTimeScheduleUid uniqueidentifier
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @AccessGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessGroupUid = NULL
if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL
if @CrisisModeAccessGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @CrisisModeAccessGroupUid = NULL

if @DefaultTimeScheduleUid IS NULL
	SET @DefaultTimeScheduleUid = 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF'

if @ActivationDate = dbo.[DateTime_MinValue]()
	SET @ActivationDate = NULL
	
if @ExpirationDate = dbo.[DateTime_MinValue]()
	SET @ExpirationDate = NULL

if @AccessGroupUid = '00000000-0000-0000-0000-000000000000' OR @AccessGroupUid IS NULL
	SET @AccessGroupUid = NewID()

INSERT INTO GCS.AccessGroup
(
AccessGroupUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,CrisisModeAccessGroupUid 
,EntityId
,AccessGroupNumber
,Display
,Description
,ServiceComment
,Comment
,IsEnabled
,ActivationDate
,ExpirationDate
,DefaultTimeScheduleUid
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@AccessGroupUid
,@ClusterUid
,@DisplayResourceKey
,@DescriptionResourceKey
,@CrisisModeAccessGroupUid 
,@EntityId 
,@AccessGroupNumber
,@Display
,@Description
,@ServiceComment
,@Comment
,@IsEnabled
,@ActivationDate
,@ExpirationDate
,@DefaultTimeScheduleUid
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.AccessGroup table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_Update]
@AccessGroupUid uniqueidentifier 
,@ClusterUid uniqueidentifier
,@DisplayResourceKey uniqueidentifier
,@DescriptionResourceKey uniqueidentifier
,@CrisisModeAccessGroupUid uniqueidentifier
,@EntityId uniqueidentifier
,@AccessGroupNumber int
,@Display nvarchar(65)
,@Description nvarchar(1000)
,@ServiceComment nvarchar(1000)
,@Comment nvarchar(1000)
,@IsEnabled bit
,@ActivationDate datetime
,@ExpirationDate datetime
,@DefaultTimeScheduleUid uniqueidentifier
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL
if @CrisisModeAccessGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @CrisisModeAccessGroupUid = NULL

if @DefaultTimeScheduleUid IS NULL
	SET @DefaultTimeScheduleUid = 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF'

if @ActivationDate = dbo.[DateTime_MinValue]()
	SET @ActivationDate = NULL
	
if @ExpirationDate = dbo.[DateTime_MinValue]()
	SET @ExpirationDate = NULL
UPDATE GCS.AccessGroup
SET 
ClusterUid = @ClusterUid
,DisplayResourceKey = @DisplayResourceKey
,DescriptionResourceKey = @DescriptionResourceKey
,CrisisModeAccessGroupUid = @CrisisModeAccessGroupUid 
,EntityId = @EntityId
,AccessGroupNumber = @AccessGroupNumber
,Display = @Display
,Description = @Description
,ServiceComment = @ServiceComment
,Comment = @Comment
,IsEnabled = @IsEnabled
,ActivationDate = @ActivationDate
,ExpirationDate = @ExpirationDate
,DefaultTimeScheduleUid = @DefaultTimeScheduleUid
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
AccessGroupUid = @AccessGroupUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.AccessGroup table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_UpdateConcurrency]
@AccessGroupUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.AccessGroup
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
AccessGroupUid = @AccessGroupUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.AccessGroup table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_DeleteByPK]
@AccessGroupUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.AccessGroup
WHERE
AccessGroupUid = @AccessGroupUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[AccessGroupPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.AccessGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroupPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessGroupPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.AccessGroup

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessGroupPDSA_RowCount] TO public
GO

if dbo.fn_GCSDoesViewExist('AccessPortalView') = 1
BEGIN
	DROP VIEW GCS.AccessPortalView
END
go

create view [GCS].[AccessPortalView] as
SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
GO

ALTER AUTHORIZATION ON [GCS].[AccessPortalView] TO  SCHEMA OWNER 
GO


/* All Stored Procedures for table: AccessPortal */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.AccessPortal table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_SelectAll] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
c.ClusterUid = @ClusterUid
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;



if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE ap.EntityId = @EntityId or ap.AccessPortalUid IN (SELECT AccessPortalUid FROM GCS.AccessPortalEntityMap WHERE EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;



if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ByEntityId] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ByGalaxyPanelAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ByGalaxyPanelAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ByGalaxyPanelAddress]
@ClusterGroupId int,
@ClusterNumber int,
@PanelNumber int,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
c.ClusterGroupId = @ClusterGroupId AND
c.ClusterNumber = @ClusterNumber AND
p.PanelNumber = @PanelNumber
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ByGalaxyPanelAddress] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ByGalaxyPanelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ByGalaxyPanelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ByGalaxyPanelUid]
@GalaxyPanelUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
p.GalaxyPanelUid = @GalaxyPanelUid
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ByGalaxyPanelUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ByHardwareAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ByHardwareAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ByHardwareAddress]
@ClusterGroupId int,
@ClusterNumber int,
@PanelNumber int,
@BoardNumber int,
@SectionNumber int,
@ModuleNumber int,
@NodeNumber int
AS

declare @ret int;
select @ret = 0;

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
c.ClusterGroupId = @ClusterGroupId AND
c.ClusterNumber = @ClusterNumber AND
p.PanelNumber = @PanelNumber AND
gib.BoardNumber = @BoardNumber AND
gibs.SectionNumber = @SectionNumber AND
m.ModuleNumber = @ModuleNumber AND
n.NodeNumber = @NodeNumber
ORDER BY r.RegionName, s.SiteName, ap.PortalName


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ByHardwareAddress] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_SearchByName]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_SearchByName]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_SearchByName]
@PortalName nvarchar(65) 
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
(@PortalName IS NULL OR ap.PortalName LIKE '%' + @PortalName + '%')
 And (ap.EntityId = @EntityId OR (ap.AccessPortalUid IN (SELECT AccessPortalUid FROM GCS.AccessPortalEntityMap WHERE EntityId = @EntityId)))
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_SearchByName] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_SearchByNameOrComments]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_SearchByNameOrComments]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_SearchByNameOrComments]
@PortalName nvarchar(65) 
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
(@PortalName IS NULL OR ap.PortalName LIKE '%' + @PortalName + '%' or ap.Location LIKE '%' + @PortalName + '%' or ap.CriticalityComment LIKE '%' + @PortalName + '%' or ap.ServiceComment LIKE '%' + @PortalName + '%' or ap.Comment LIKE '%' + @PortalName + '%')
 And (ap.EntityId = @EntityId OR (ap.AccessPortalUid IN (SELECT AccessPortalUid FROM GCS.AccessPortalEntityMap WHERE EntityId = @EntityId)))
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_SearchByNameOrComments] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ByRegionUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ByRegionUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ByRegionUid]
@RegionUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
ap.SiteUid IN (SELECT SiteUid FROM GCS.Site WHERE RegionUid = @RegionUid)
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;



if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ByRegionUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_BySiteUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_BySiteUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_BySiteUid]
@SiteUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
ap.SiteUid = @SiteUid
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_BySiteUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.AccessPortal table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
AccessPortalUid
,PortalName
,IsEnabled
,IsBoundToHardware
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ListBoxByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ListBoxByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ListBoxByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.EntityId
,ap.AccessPortalUid
,ap.PortalName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,ap.IsEnabled
,ap.IsBoundToHardware
,apBoardType.TypeCode as InterfaceBoardTypeCode
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType apBoardType on apBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
c.ClusterUid = @ClusterUid 
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;



if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ListBoxByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ListBoxByGalaxyPanelAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ListBoxByGalaxyPanelAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ListBoxByGalaxyPanelAddress]
 @ClusterGroupId int,
@ClusterNumber int,
@PanelNumber int,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.EntityId
,ap.AccessPortalUid
,ap.PortalName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,ap.IsEnabled
,ap.IsBoundToHardware
,apBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType apBoardType on apBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE 
c.ClusterGroupId = @ClusterGroupId AND
c.ClusterNumber = @ClusterNumber AND
p.PanelNumber = @PanelNumber
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;



if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ListBoxByGalaxyPanelAddress] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ListBoxByGalaxyPanelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ListBoxByGalaxyPanelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ListBoxByGalaxyPanelUid]
@GalaxyPanelUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.EntityId
,ap.AccessPortalUid
,ap.PortalName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,ap.IsEnabled
,ap.IsBoundToHardware
,apBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType apBoardType on apBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE 
p.GalaxyPanelUid = @GalaxyPanelUid 
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ListBoxByGalaxyPanelUid] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ListBoxByName]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ListBoxByName]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ListBoxByName]
@PortalName nvarchar(65) 
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.EntityId
,ap.AccessPortalUid
,ap.PortalName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apBoardType.TypeCode as InterfaceBoardTypeCode
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsEnabled
,ap.IsBoundToHardware
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType apBoardType on apBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
(@PortalName IS NULL OR ap.PortalName LIKE '%' + @PortalName + '%')
 And (ap.EntityId = @EntityId OR (ap.AccessPortalUid IN (SELECT AccessPortalUid FROM GCS.AccessPortalEntityMap WHERE EntityId = @EntityId)))
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ListBoxByName] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ListBoxByNameOrComments]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ListBoxByNameOrComments]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ListBoxByNameOrComments]
@PortalName nvarchar(65) 
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.EntityId
,ap.AccessPortalUid
,ap.PortalName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apBoardType.TypeCode as InterfaceBoardTypeCode
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsEnabled
,ap.IsBoundToHardware
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType apBoardType on apBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
(@PortalName IS NULL OR ap.PortalName LIKE '%' + @PortalName + '%' or ap.Location LIKE '%' + @PortalName + '%' or ap.CriticalityComment LIKE '%' + @PortalName + '%' or ap.ServiceComment LIKE '%' + @PortalName + '%' or ap.Comment LIKE '%' + @PortalName + '%')
 And (ap.EntityId = @EntityId OR (ap.AccessPortalUid IN (SELECT AccessPortalUid FROM GCS.AccessPortalEntityMap WHERE EntityId = @EntityId)))
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ListBoxByNameOrComments] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_ListBoxByPrimaryKey]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_ListBoxByPrimaryKey]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_ListBoxByPrimaryKey]
@AccessPortalUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
ap.EntityId
,ap.AccessPortalUid
,ap.PortalName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,ap.IsEnabled
,ap.IsBoundToHardware
,apBoardType.TypeCode as InterfaceBoardTypeCode
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
FROM GCS.AccessPortal ap
JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType apBoardType on apBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
ap.AccessPortalUid  = @AccessPortalUid  
ORDER BY ap.PortalName


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ListBoxByPrimaryKey] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortal table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_SelectByPK]
@AccessPortalUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,1 as TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
ap.AccessPortalUid = @AccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.AccessPortal table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_SelectSearch]
@PortalName nvarchar(65) 
,@SiteName char(100) 
,@RegionName char(100),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.BinaryResourceUid
,ap.SiteUid
,ap.EntityId
,ap.PortalName
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsTemplate
,ap.IsEnabled
,ap.IsBoundToHardware
,ap.InsertName
,ap.InsertDate
,ap.UpdateName
,ap.UpdateDate
,ap.ConcurrencyValue
,r.RegionUid
,s.SiteName
,r.RegionName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,n.IsNodeActive
,apgha.DoorNumber
,n.GalaxyInterfaceBoardSectionNodeUid
,m.GalaxyHardwareModuleUid
,gibs.GalaxyInterfaceBoardSectionUid
,gib.GalaxyInterfaceBoardUid
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
(@PortalName IS NULL OR PortalName LIKE @PortalName + '%')
 And (@SiteName IS NULL OR SiteName LIKE @SiteName + '%')
 And (@RegionName IS NULL OR RegionName LIKE @RegionName + '%')
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_SelectSearch] TO public
GO

CREATE OR ALTER PROCEDURE [GCS].[AccessPortalPDSA_ListBySiteUidAndName]
@PortalName nvarchar(65),
@SiteUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessPortal

if @PageSize = 0
	set @PageSize = 1

SELECT 
ap.EntityId
,ap.AccessPortalUid
,ap.PortalName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,p.GalaxyPanelUid
,p.PanelName
,c.ClusterUid
,c.ClusterName
,apBoardType.TypeCode as InterfaceBoardTypeCode
,ap.Location
,ap.ServiceComment
,ap.CriticalityComment
,ap.Comment
,ap.IsEnabled
,ap.IsBoundToHardware
,apaeLastEvent.ActivityDateTime as LastEventTime
,apaeLastAccessGrantedEvent.ActivityDateTime as LastAccessGrantedTime,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessPortal ap
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.InterfaceBoardType apBoardType on apBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.AccessPortalLastUsage aplu on aplu.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastEvent on apaeLastEvent.AccessPortalActivityEventUid = aplu.LastActivityEventUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent apaeLastAccessGrantedEvent on apaeLastAccessGrantedEvent.AccessPortalActivityEventUid = aplu.LastAccessGrantedActivityEventUid
WHERE 
(@PortalName IS NULL OR ap.PortalName LIKE '%' + @PortalName + '%')
 And (ap.SiteUid = @SiteUid)
ORDER BY (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 0 THEN PortalName end) asc,
         (CASE WHEN @SortColumn = 'PortalName' AND @DescendingOrder = 1 THEN PortalName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN ap.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN ap.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN ap.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN ap.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_ListBySiteUidAndName] TO public
GO




/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.AccessPortal table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_Insert]
@AccessPortalUid uniqueidentifier 
,@AccessPortalTypeUid uniqueidentifier 
,@BinaryResourceUid uniqueidentifier  = null
,@SiteUid uniqueidentifier  
,@EntityId uniqueidentifier  
,@PortalName nvarchar(65) 
,@Location nvarchar(255)  = null
,@ServiceComment nvarchar(255)  = null
,@CriticalityComment nvarchar(255)  = null
,@Comment nvarchar(255)  = null
,@IsTemplate bit 
,@IsEnabled bit
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @AccessPortalUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalUid = NULL
if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @BinaryResourceUid = NULL

if @AccessPortalUid = '00000000-0000-0000-0000-000000000000' OR @AccessPortalUid IS NULL
	SET @AccessPortalUid = NewID()

INSERT INTO GCS.AccessPortal
(
AccessPortalUid
,AccessPortalTypeUid
,BinaryResourceUid
,SiteUid
,EntityId
,PortalName
,Location
,ServiceComment
,CriticalityComment
,Comment
,IsTemplate
,IsEnabled
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@AccessPortalUid
,@AccessPortalTypeUid
,@BinaryResourceUid
,@SiteUid
,@EntityId
,@PortalName
,@Location
,@ServiceComment
,@CriticalityComment
,@Comment
,@IsTemplate
,@IsEnabled
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.AccessPortal table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_Update]
@AccessPortalUid uniqueidentifier 
,@AccessPortalTypeUid uniqueidentifier
,@BinaryResourceUid uniqueidentifier
,@SiteUid uniqueidentifier
,@EntityId uniqueidentifier
,@PortalName nvarchar(65)
,@Location nvarchar(255)
,@ServiceComment nvarchar(255)
,@CriticalityComment nvarchar(255)
,@Comment nvarchar(255)
,@IsTemplate bit
,@IsEnabled bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @BinaryResourceUid = NULL

UPDATE GCS.AccessPortal
SET 
AccessPortalTypeUid = @AccessPortalTypeUid
,BinaryResourceUid = @BinaryResourceUid
,SiteUid = @SiteUid 
,EntityId = EntityId
,PortalName = @PortalName
,Location = @Location
,ServiceComment = @ServiceComment
,CriticalityComment = @CriticalityComment
,Comment = @Comment
,IsTemplate = @IsTemplate
,IsEnabled = @IsEnabled
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
AccessPortalUid = @AccessPortalUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.AccessPortal table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_UpdateConcurrency]
@AccessPortalUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.AccessPortal
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
AccessPortalUid = @AccessPortalUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.AccessPortal table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_DeleteByPK]
@AccessPortalUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.AccessPortal
WHERE
AccessPortalUid = @AccessPortalUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[AccessPortalPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.AccessPortal table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.AccessPortal

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalPDSA_RowCount] TO public
GO

/* All Stored Procedures for table: AccessProfile */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.AccessProfile table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfilePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfilePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessProfilePDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@OmitNone bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessProfile

if @PageSize = 0
	set @PageSize = 1

SELECT 
t.AccessProfileUid
,t.EntityId
,t.AccessProfileName
,t.Comments
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.PersonAccessControlProperties where AccessProfileUid = t.AccessProfileUid) as PersonCount
FROM GCS.AccessProfile t
WHERE t.AccessProfileUid <> 
 CASE @OmitNone
          WHEN 0 THEN '00000000-0000-0000-0000-000000000000'
          WHEN 1 THEN '00000000-0000-0000-0000-000000000001'
		END
ORDER BY (CASE WHEN @SortColumn = 'AccessProfileName' AND @DescendingOrder = 0 THEN t.AccessProfileName end) asc,
         (CASE WHEN @SortColumn = 'AccessProfileName' AND @DescendingOrder = 1 THEN t.AccessProfileName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfilePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessProfile table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfilePDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfilePDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfilePDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@OmitNone bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessProfile

if @PageSize = 0
	set @PageSize = 1

SELECT 
t.AccessProfileUid
,t.EntityId
,t.AccessProfileName
,t.Comments
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.PersonAccessControlProperties where AccessProfileUid = t.AccessProfileUid) as PersonCount
FROM GCS.AccessProfile t
WHERE 
(t.EntityId = @EntityId OR t.EntityId = '00000000-0000-0000-0000-000000000001' OR
t.AccessProfileUid in (SELECT DISTINCT AccessProfileUid FROM AccessProfileEntityMap WHERE EntityId = @EntityId))
AND t.AccessProfileUid <> 
 CASE @OmitNone
          WHEN 0 THEN '00000000-0000-0000-0000-000000000000'
          WHEN 1 THEN '00000000-0000-0000-0000-000000000001'
		END
ORDER BY (CASE WHEN @SortColumn = 'AccessProfileName' AND @DescendingOrder = 0 THEN t.AccessProfileName end) asc,
         (CASE WHEN @SortColumn = 'AccessProfileName' AND @DescendingOrder = 1 THEN t.AccessProfileName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfilePDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessProfile table 
'* based on a id value passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfilePDSA_ByMappedEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfilePDSA_ByMappedEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfilePDSA_ByMappedEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@OmitNone bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessProfile

if @PageSize = 0
	set @PageSize = 1

SELECT 
t.AccessProfileUid
,t.EntityId
,t.AccessProfileName
,t.Comments
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.PersonAccessControlProperties where AccessProfileUid = t.AccessProfileUid) as PersonCount
FROM GCS.AccessProfile t
WHERE 
(t.EntityId = @EntityId OR
t.AccessProfileUid in (SELECT AccessProfileUid FROM GCS.AccessProfileEntityMap WHERE EntityId = @EntityId))
AND t.AccessProfileUid <> 
 CASE @OmitNone
          WHEN 0 THEN '00000000-0000-0000-0000-000000000000'
          WHEN 1 THEN '00000000-0000-0000-0000-000000000001'
		END
ORDER BY (CASE WHEN @SortColumn = 'AccessProfileName' AND @DescendingOrder = 0 THEN t.AccessProfileName end) asc,
         (CASE WHEN @SortColumn = 'AccessProfileName' AND @DescendingOrder = 1 THEN t.AccessProfileName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfilePDSA_ByMappedEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.AccessProfile table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfilePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfilePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessProfilePDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@OmitNone bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessProfile

if @PageSize = 0
	set @PageSize = 1

SELECT 
AccessProfileUid
,AccessProfileName
,COUNT(*) OVER() TotalRowCount
FROM GCS.AccessProfile
WHERE
 AccessProfileUid <> 
 CASE @OmitNone
          WHEN 0 THEN '00000000-0000-0000-0000-000000000000'
          WHEN 1 THEN '00000000-0000-0000-0000-000000000001'
		END
ORDER BY (CASE WHEN @SortColumn = 'AccessProfileName' AND @DescendingOrder = 0 THEN AccessProfileName end) asc,
         (CASE WHEN @SortColumn = 'AccessProfileName' AND @DescendingOrder = 1 THEN AccessProfileName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfilePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessProfile table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfilePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfilePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfilePDSA_SelectByPK]
@AccessProfileUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
t.AccessProfileUid
,t.EntityId
,t.AccessProfileName
,t.Comments
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.PersonAccessControlProperties where AccessProfileUid = t.AccessProfileUid) as PersonCount
FROM GCS.AccessProfile t
WHERE 
t.AccessProfileUid = @AccessProfileUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfilePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.AccessProfile table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfilePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfilePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfilePDSA_SelectSearch]
@AccessProfileName nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@OmitNone bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.AccessProfile

if @PageSize = 0
	set @PageSize = 1

SELECT 
t.AccessProfileUid
,t.EntityId
,t.AccessProfileName
,t.Comments
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
,(SELECT COUNT(*) from GCS.PersonAccessControlProperties where AccessProfileUid = t.AccessProfileUid) as PersonCount
FROM GCS.AccessProfile t
WHERE 
(@AccessProfileName IS NULL OR t.AccessProfileName LIKE @AccessProfileName + '%')
AND t.AccessProfileUid <> 
 CASE @OmitNone
          WHEN 0 THEN '00000000-0000-0000-0000-000000000000'
          WHEN 1 THEN '00000000-0000-0000-0000-000000000001'
	END
ORDER BY (CASE WHEN @SortColumn = 'AccessProfileName' AND @DescendingOrder = 0 THEN t.AccessProfileName end) asc,
         (CASE WHEN @SortColumn = 'AccessProfileName' AND @DescendingOrder = 1 THEN t.AccessProfileName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfilePDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.AccessProfile table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfilePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfilePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfilePDSA_Insert]
@AccessProfileUid uniqueidentifier 
,@EntityId uniqueidentifier 
,@AccessProfileName nvarchar(65) 
,@Comments nvarchar(255)  = null
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @AccessProfileUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessProfileUid = NULL

if @AccessProfileUid = '00000000-0000-0000-0000-000000000000' OR @AccessProfileUid IS NULL
	SET @AccessProfileUid = NewID()

INSERT INTO GCS.AccessProfile
(
AccessProfileUid
,EntityId
,AccessProfileName
,Comments
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@AccessProfileUid
,@EntityId
,@AccessProfileName
,@Comments
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfilePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.AccessProfile table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfilePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfilePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfilePDSA_Update]
@AccessProfileUid uniqueidentifier 
,@EntityId uniqueidentifier
,@AccessProfileName nvarchar(65)
,@Comments nvarchar(255)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.AccessProfile
SET 
EntityId = @EntityId
,AccessProfileName = @AccessProfileName
,Comments = @Comments
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
AccessProfileUid = @AccessProfileUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessProfilePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.AccessProfile table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfilePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfilePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfilePDSA_UpdateConcurrency]
@AccessProfileUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.AccessProfile
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
AccessProfileUid = @AccessProfileUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessProfilePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.AccessProfile table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfilePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfilePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfilePDSA_DeleteByPK]
@AccessProfileUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.AccessProfile
WHERE
AccessProfileUid = @AccessProfileUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[AccessProfilePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.AccessProfile table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfilePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfilePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfilePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.AccessProfile

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfilePDSA_RowCount] TO public
GO

/* All Stored Procedures for table: InputOutputGroup */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.InputOutputGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputOutputGroup

if @PageSize = 0
	set @PageSize = 1

SELECT 
InputOutputGroupUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,TimeScheduleUid
,IOGroupNumber
,LocalIOGroup
,Display
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.InputOutputGroup
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 0 THEN IOGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 1 THEN IOGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_SelectAll] TO public
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_ByClusterAndInputOuputGroupNumber]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_ByClusterAndInputOuputGroupNumber]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_ByClusterAndInputOuputGroupNumber]
@ClusterGroupId int,
@ClusterNumber int,
@IOGroupNumber int,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputOutputGroup

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
InputOutputGroupUid
,t.ClusterUid
,t.EntityId
,TimeScheduleUid
,IOGroupNumber
,LocalIOGroup
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputOutputGroup t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
WHERE 
c.ClusterGroupId = @ClusterGroupId and c.ClusterNumber = @ClusterNumber and t.IOGroupNumber = @IOGroupNumber
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 0 THEN IOGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 1 THEN IOGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_ByClusterAndInputOuputGroupNumber] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputOutputGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_ByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputOutputGroup

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
InputOutputGroupUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,TimeScheduleUid
,IOGroupNumber
,LocalIOGroup
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputOutputGroup t
WHERE 
ClusterUid = @ClusterUid
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 0 THEN IOGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 1 THEN IOGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputOutputGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_ByClusterUidEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_ByClusterUidEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_ByClusterUidEntityId]
@ClusterUid uniqueidentifier 
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputOutputGroup

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
InputOutputGroupUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,TimeScheduleUid
,IOGroupNumber
,LocalIOGroup
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputOutputGroup t
WHERE 
ClusterUid = @ClusterUid AND (EntityId = @EntityId OR
InputOutputGroupUid in (SELECT DISTINCT InputOutputGroupUid  FROM GCS.InputOutputGroupEntityMap WHERE EntityId = @EntityId))
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 0 THEN IOGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 1 THEN IOGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_ByClusterUidEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputOutputGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputOutputGroup

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT
InputOutputGroupUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,TimeScheduleUid
,IOGroupNumber
,LocalIOGroup
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputOutputGroup t
WHERE EntityId = @EntityId OR
InputOutputGroupUid in (SELECT DISTINCT InputOutputGroupUid FROM GCS.InputOutputGroupEntityMap WHERE EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 0 THEN IOGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 1 THEN IOGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputOutputGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_GetSpecialGroupsByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_GetSpecialGroupsByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_GetSpecialGroupsByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputOutputGroup

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
InputOutputGroupUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,TimeScheduleUid
,IOGroupNumber
,LocalIOGroup
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputOutputGroup t
WHERE 
ClusterUid = @ClusterUid and IOGroupNumber IN (0)
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 0 THEN IOGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 1 THEN IOGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_GetSpecialGroupsByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.InputOutputGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputOutputGroup

if @PageSize = 0
	set @PageSize = 1

SELECT 
InputOutputGroupUid
,Display
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputOutputGroup
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 0 THEN IOGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 1 THEN IOGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputOutputGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_ListBoxByClusterAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_ListBoxByClusterAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_ListBoxByClusterAddress]
@ClusterGroupId int,
@ClusterNumber int,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputOutputGroup

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
InputOutputGroupUid
,t.ClusterUid
,t.EntityId
,TimeScheduleUid
,IOGroupNumber
,LocalIOGroup
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputOutputGroup t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
WHERE 
c.ClusterGroupId = @ClusterGroupId and c.ClusterNumber = @ClusterNumber
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 0 THEN IOGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 1 THEN IOGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_ListBoxByClusterAddress] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputOutputGroup table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_SelectByPK]
@InputOutputGroupUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
InputOutputGroupUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,TimeScheduleUid
,IOGroupNumber
,LocalIOGroup
,Display
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,1 as TotalRowCount
FROM GCS.InputOutputGroup
WHERE 
InputOutputGroupUid = @InputOutputGroupUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.InputOutputGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_SelectSearch]
@Display nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputOutputGroup

if @PageSize = 0
	set @PageSize = 1

SELECT 
InputOutputGroupUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,TimeScheduleUid
,IOGroupNumber
,LocalIOGroup
,Display
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputOutputGroup
WHERE 
(@Display IS NULL OR Display LIKE @Display + '%')
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 0 THEN IOGroupNumber end) asc,
         (CASE WHEN @SortColumn = 'IOGroupNumber' AND @DescendingOrder = 1 THEN IOGroupNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.InputOutputGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_Insert]
@InputOutputGroupUid uniqueidentifier 
,@ClusterUid uniqueidentifier 
,@DisplayResourceKey uniqueidentifier  = null
,@DescriptionResourceKey uniqueidentifier  = null
,@EntityId uniqueidentifier 
,@TimeScheduleUid uniqueidentifier
,@IOGroupNumber int 
,@LocalIOGroup bit
,@Display nvarchar(65) 
,@Description nvarchar(255)  = null
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @InputOutputGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @InputOutputGroupUid = NULL

if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

if @InputOutputGroupUid = '00000000-0000-0000-0000-000000000000' OR @InputOutputGroupUid IS NULL
	SET @InputOutputGroupUid = NewID()

INSERT INTO GCS.InputOutputGroup
(
InputOutputGroupUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,TimeScheduleUid
,EntityId
,IOGroupNumber
,LocalIOGroup
,Display
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@InputOutputGroupUid
,@ClusterUid
,@DisplayResourceKey
,@DescriptionResourceKey
,@TimeScheduleUid
,@EntityId
,@IOGroupNumber
,@LocalIOGroup
,@Display
,@Description
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.InputOutputGroup table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_Update]
@InputOutputGroupUid uniqueidentifier 
,@ClusterUid uniqueidentifier
,@DisplayResourceKey uniqueidentifier
,@DescriptionResourceKey uniqueidentifier
,@TimeScheduleUid uniqueidentifier
,@EntityId uniqueidentifier
,@IOGroupNumber int
,@LocalIOGroup bit
,@Display nvarchar(65)
,@Description nvarchar(255)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @InputOutputGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @InputOutputGroupUid = NULL
if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

UPDATE GCS.InputOutputGroup
SET 
ClusterUid = @ClusterUid
,DisplayResourceKey = @DisplayResourceKey
,DescriptionResourceKey = @DescriptionResourceKey
,TimeScheduleUid = @TimeScheduleUid
,EntityId = @EntityId
,IOGroupNumber = @IOGroupNumber
,LocalIOGroup =@LocalIOGroup 
,Display = @Display
,Description = @Description
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
InputOutputGroupUid = @InputOutputGroupUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.InputOutputGroup table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_UpdateConcurrency]
@InputOutputGroupUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.InputOutputGroup
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
InputOutputGroupUid = @InputOutputGroupUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.InputOutputGroup table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_DeleteByPK]
@InputOutputGroupUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.InputOutputGroup
WHERE
InputOutputGroupUid = @InputOutputGroupUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.InputOutputGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroupPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroupPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[InputOutputGroupPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.InputOutputGroup

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputOutputGroupPDSA_RowCount] TO public
GO

/* All Stored Procedures for table: Area */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.Area table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Area

if @PageSize = 0
	set @PageSize = 1

SELECT 
AreaUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,AreaNumber
,Display
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.Area
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 0 THEN AreaNumber end) asc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 1 THEN AreaNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AreaPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Area table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_ByClusterUid]
@ClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL 
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Area

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
AreaUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,AreaNumber
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.Area t
WHERE 
ClusterUid = @ClusterUid
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 0 THEN AreaNumber end) asc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 1 THEN AreaNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AreaPDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Area table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_ByClusterUidEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_ByClusterUidEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_ByClusterUidEntityId]
@ClusterUid uniqueidentifier
,@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Area

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
AreaUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,AreaNumber
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.Area t
WHERE ClusterUid = @ClusterUid AND ( EntityId = @EntityId OR
AreaUid IN (SELECT AreaUid FROM GCS.AreaEntityMap WHERE EntityId = @EntityId))
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 0 THEN AreaNumber end) asc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 1 THEN AreaNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AreaPDSA_ByClusterUidEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Area table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL 
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Area

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
AreaUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,AreaNumber
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.Area t
WHERE 
EntityId = @EntityId OR AreaUid IN (SELECT DISTINCT AreaUid FROM GCS.AreaEntityMap WHERE EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 0 THEN AreaNumber end) asc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 1 THEN AreaNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN t.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN t.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN t.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN t.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AreaPDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.Area table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Area

if @PageSize = 0
	set @PageSize = 1

SELECT 
AreaUid
,Display
,COUNT(*) OVER() TotalRowCount
FROM GCS.Area
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 0 THEN AreaNumber end) asc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 1 THEN AreaNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AreaPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Area table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_SelectByPK]
@AreaUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AreaUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,AreaNumber
,Display
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,1 as TotalRowCount
FROM GCS.Area
WHERE 
AreaUid = @AreaUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AreaPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.Area table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_SelectSearch]
@Display nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Area

if @PageSize = 0
	set @PageSize = 1

SELECT 
AreaUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,AreaNumber
,Display
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.Area
WHERE 
(@Display IS NULL OR Display LIKE @Display + '%')
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 0 THEN AreaNumber end) asc,
         (CASE WHEN @SortColumn = 'AreaNumber' AND @DescendingOrder = 1 THEN AreaNumber end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AreaPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.Area table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_Insert]
@AreaUid uniqueidentifier 
,@ClusterUid uniqueidentifier 
,@DisplayResourceKey uniqueidentifier  = null
,@DescriptionResourceKey uniqueidentifier  = null
,@EntityId uniqueidentifier 
,@AreaNumber int 
,@Display nvarchar(65) 
,@Description nvarchar(255)  = null
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @AreaUid = '00000000-0000-0000-0000-000000000000'
	SET @AreaUid = NULL
if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

if @AreaUid = '00000000-0000-0000-0000-000000000000' OR @AreaUid IS NULL
	SET @AreaUid = NewID()

INSERT INTO GCS.Area
(
AreaUid
,ClusterUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId 
,AreaNumber
,Display
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@AreaUid
,@ClusterUid
,@DisplayResourceKey
,@DescriptionResourceKey
,@EntityId 
,@AreaNumber
,@Display
,@Description
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AreaPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.Area table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_Update]
@AreaUid uniqueidentifier 
,@ClusterUid uniqueidentifier
,@DisplayResourceKey uniqueidentifier
,@DescriptionResourceKey uniqueidentifier
,@EntityId uniqueidentifier
,@AreaNumber int
,@Display nvarchar(65)
,@Description nvarchar(255)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

UPDATE GCS.Area
SET 
ClusterUid = @ClusterUid
,DisplayResourceKey = @DisplayResourceKey
,DescriptionResourceKey = @DescriptionResourceKey
,@EntityId = EntityId
,AreaNumber = @AreaNumber
,Display = @Display
,Description = @Description
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
AreaUid = @AreaUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AreaPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.Area table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_UpdateConcurrency]
@AreaUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.Area
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
AreaUid = @AreaUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AreaPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.Area table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_DeleteByPK]
@AreaUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.Area
WHERE
AreaUid = @AreaUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[AreaPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.Area table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AreaPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AreaPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[AreaPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.Area

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AreaPDSA_RowCount] TO public
GO

/* All Stored Procedures for table: Department */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.Department table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DepartmentPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DepartmentPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[DepartmentPDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Department

if @PageSize = 0
	set @PageSize = 1

SELECT 
DepartmentUid
,EntityId
,DepartmentName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.Department
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN DepartmentName end) asc,
         (CASE WHEN @SortColumn = 'DepartmentName' AND @DescendingOrder = 1 THEN DepartmentName end) desc,
         (CASE WHEN @SortColumn = 'DepartmentName' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DepartmentPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Department table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DepartmentPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DepartmentPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[DepartmentPDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Department

if @PageSize = 0
	set @PageSize = 1

SELECT 
DepartmentUid
,EntityId
,DepartmentName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.Department
WHERE 
EntityId = @EntityId
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN DepartmentName end) asc,
         (CASE WHEN @SortColumn = 'DepartmentName' AND @DescendingOrder = 1 THEN DepartmentName end) desc,
         (CASE WHEN @SortColumn = 'DepartmentName' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DepartmentPDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.Department table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DepartmentPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DepartmentPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[DepartmentPDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Department

if @PageSize = 0
	set @PageSize = 1

SELECT 
DepartmentUid
,DepartmentName
,COUNT(*) OVER() TotalRowCount
FROM GCS.Department
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN DepartmentName end) asc,
         (CASE WHEN @SortColumn = 'DepartmentName' AND @DescendingOrder = 1 THEN DepartmentName end) desc,
         (CASE WHEN @SortColumn = 'DepartmentName' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DepartmentPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.Department table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DepartmentPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DepartmentPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[DepartmentPDSA_SelectByPK]
@DepartmentUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
DepartmentUid
,EntityId
,DepartmentName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.Department
WHERE 
DepartmentUid = @DepartmentUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DepartmentPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.Department table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DepartmentPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DepartmentPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[DepartmentPDSA_SelectSearch]
@DepartmentName nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.Department

if @PageSize = 0
	set @PageSize = 1

SELECT 
DepartmentUid
,EntityId
,DepartmentName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.Department
WHERE 
(@DepartmentName IS NULL OR DepartmentName LIKE @DepartmentName + '%')
ORDER BY (CASE WHEN @SortColumn = 'PanelName' AND @DescendingOrder = 0 THEN DepartmentName end) asc,
         (CASE WHEN @SortColumn = 'DepartmentName' AND @DescendingOrder = 1 THEN DepartmentName end) desc,
         (CASE WHEN @SortColumn = 'DepartmentName' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DepartmentPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.Department table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DepartmentPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DepartmentPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[DepartmentPDSA_Insert]
@DepartmentUid uniqueidentifier 
,@EntityId uniqueidentifier 
,@DepartmentName nvarchar(65) 
,@Description nvarchar(1000) 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @DepartmentUid = '00000000-0000-0000-0000-000000000000'
	SET @DepartmentUid = NULL

if @DepartmentUid = '00000000-0000-0000-0000-000000000000' OR @DepartmentUid IS NULL
	SET @DepartmentUid = NewID()

INSERT INTO GCS.Department
(
DepartmentUid
,EntityId
,DepartmentName
,Description
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@DepartmentUid
,@EntityId
,@DepartmentName
,@Description
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DepartmentPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.Department table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DepartmentPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DepartmentPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[DepartmentPDSA_Update]
@DepartmentUid uniqueidentifier 
,@EntityId uniqueidentifier
,@DepartmentName nvarchar(65)
,@Description nvarchar(1000)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.Department
SET 
EntityId = @EntityId
,DepartmentName = @DepartmentName
,Description = @Description
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
DepartmentUid = @DepartmentUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[DepartmentPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.Department table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DepartmentPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DepartmentPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[DepartmentPDSA_UpdateConcurrency]
@DepartmentUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.Department
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
DepartmentUid = @DepartmentUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[DepartmentPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.Department table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DepartmentPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DepartmentPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[DepartmentPDSA_DeleteByPK]
@DepartmentUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.Department
WHERE
DepartmentUid = @DepartmentUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[DepartmentPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.Department table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DepartmentPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DepartmentPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[DepartmentPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.Department

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DepartmentPDSA_RowCount] TO public
GO

if exists (select 1
          from sysobjects
          where id = object_id('GCS.ti_accessportalcommandchoice')
          and type = 'TR')
   drop trigger GCS.ti_accessportalcommandchoice
go

if exists (select 1
          from sysobjects
          where id = object_id('GCS.tu_accessportalcommandchoice')
          and type = 'TR')
   drop trigger GCS.tu_accessportalcommandchoice
go

if dbo.fn_GCSDoesTableExist('AccessPortalCommandChoice') = 0
BEGIN
	/*==============================================================*/
	/* Table: AccessPortalCommandChoice                             */
	/*==============================================================*/
	create table GCS.AccessPortalCommandChoice (
	   AccessPortalCommandChoiceUid GCS.UniversalUniqueId    RowGuidCol not null,
	   AccessPortalCommandUid GCS.UniversalUniqueId    not null,
	   Display              GCS.Text65               not null,
	   DisplayResourceKey   GCS.UniversalUniqueId    null,
	   Description          GCS.Text1000             not null,
	   DescriptionResourceKey GCS.UniversalUniqueId  null,
	   ChoiceTypeCode       int                  not null,
	   ApproxWaitTime       int                  not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1,
	   constraint PK_ACCESSPORTALCOMMANDCHOICE primary key (AccessPortalCommandChoiceUid)
	   )

	/*==============================================================*/
	/* Index: idxAccessPortalCommandChoiceType                      */
	/*==============================================================*/
	create unique nonclustered index idxAccessPortalCommandChoiceType on GCS.AccessPortalCommandChoice (AccessPortalCommandUid ASC,
	  ChoiceTypeCode ASC)

	alter table GCS.AccessPortalCommandChoice
	   add constraint FK_AccessPortalCommandChoiceAccessPortal foreign key (AccessPortalCommandUid)
		  references GCS.AccessPortalCommand (AccessPortalCommandUid)
			 on update cascade on delete cascade

	alter table GCS.AccessPortalCommandChoice
	   add constraint FK_AccessPortalCommandChoiceDisplayResourceKey foreign key (DisplayResourceKey)
		  references GCS.gcsResourceString (ResourceId)
			 on update cascade on delete cascade
END
GO



create trigger GCS.ti_accessportalcommandchoice on GCS.AccessPortalCommandChoice for insert as
begin
    declare
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.gcsResourceString" must exist when inserting a child in "GCS.AccessPortalCommandChoice"  */
    if update(DescriptionResourceKey)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  DescriptionResourceKey is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.gcsResourceString t1, inserted t2
              where  t1.ResourceId = t2.DescriptionResourceKey) != @numrows - @numnull
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.gcsResourceString". Cannot create child in "GCS.AccessPortalCommandChoice".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


create trigger GCS.tu_accessportalcommandchoice on GCS.AccessPortalCommandChoice for update as
begin
   declare
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.gcsResourceString" must exist when updating a child in "GCS.AccessPortalCommandChoice"  */
      if update(DescriptionResourceKey)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  DescriptionResourceKey is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.gcsResourceString t1, inserted t2
                where  t1.ResourceId = t2.DescriptionResourceKey) != @numrows - @numnull
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.gcsResourceString" does not exist. Cannot modify child in "GCS.AccessPortalCommandChoice".'
               goto error
            end
      end

      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go

/* All Stored Procedures for table: AccessPortalCommandChoice */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.AccessPortalCommandChoice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalCommandChoicePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalCommandChoicePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessPortalCommandChoicePDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalCommandChoiceUid
,AccessPortalCommandUid
,Display
,DisplayResourceKey
,Description
,DescriptionResourceKey
,ChoiceTypeCode
,ApproxWaitTime
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.AccessPortalCommandChoice

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalCommandChoicePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.AccessPortalCommandChoice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalCommandChoicePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalCommandChoicePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessPortalCommandChoicePDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalCommandChoiceUid
,Display
FROM GCS.AccessPortalCommandChoice

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalCommandChoicePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortalCommandChoice table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalCommandChoicePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalCommandChoicePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalCommandChoicePDSA_SelectByPK]
@AccessPortalCommandChoiceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalCommandChoiceUid
,AccessPortalCommandUid
,Display
,DisplayResourceKey
,Description
,DescriptionResourceKey
,ChoiceTypeCode
,ApproxWaitTime
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.AccessPortalCommandChoice
WHERE 
AccessPortalCommandChoiceUid = @AccessPortalCommandChoiceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalCommandChoicePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.AccessPortalCommandChoice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalCommandChoicePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalCommandChoicePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalCommandChoicePDSA_SelectSearch]
@Display nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalCommandChoiceUid
,AccessPortalCommandUid
,Display
,DisplayResourceKey
,Description
,DescriptionResourceKey
,ChoiceTypeCode
,ApproxWaitTime
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.AccessPortalCommandChoice
WHERE 
(@Display IS NULL OR Display LIKE @Display + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalCommandChoicePDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortalCommandChoice table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalCommandChoicePDSA_ByAccessPortalCommandUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalCommandChoicePDSA_ByAccessPortalCommandUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalCommandChoicePDSA_ByAccessPortalCommandUid]
@AccessPortalCommandUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalCommandChoiceUid
,AccessPortalCommandUid
,Display
,DisplayResourceKey
,Description
,DescriptionResourceKey
,ChoiceTypeCode
,ApproxWaitTime
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.AccessPortalCommandChoice
WHERE 
AccessPortalCommandUid = @AccessPortalCommandUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalCommandChoicePDSA_ByAccessPortalCommandUid] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.AccessPortalCommandChoice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalCommandChoicePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalCommandChoicePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalCommandChoicePDSA_Insert]
@AccessPortalCommandChoiceUid uniqueidentifier 
,@AccessPortalCommandUid uniqueidentifier 
,@Display nvarchar(65) 
,@DisplayResourceKey uniqueidentifier  = null
,@Description nvarchar(1000) 
,@DescriptionResourceKey uniqueidentifier  = null
,@ChoiceTypeCode int 
,@ApproxWaitTime int 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @AccessPortalCommandChoiceUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalCommandChoiceUid = NULL
if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

if @AccessPortalCommandChoiceUid = '00000000-0000-0000-0000-000000000000' OR @AccessPortalCommandChoiceUid IS NULL
	SET @AccessPortalCommandChoiceUid = NewID()

INSERT INTO GCS.AccessPortalCommandChoice
(
AccessPortalCommandChoiceUid
,AccessPortalCommandUid
,Display
,DisplayResourceKey
,Description
,DescriptionResourceKey
,ChoiceTypeCode
,ApproxWaitTime
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@AccessPortalCommandChoiceUid
,@AccessPortalCommandUid
,@Display
,@DisplayResourceKey
,@Description
,@DescriptionResourceKey
,@ChoiceTypeCode
,@ApproxWaitTime
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalCommandChoicePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.AccessPortalCommandChoice table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalCommandChoicePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalCommandChoicePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalCommandChoicePDSA_Update]
@AccessPortalCommandChoiceUid uniqueidentifier 
,@AccessPortalCommandUid uniqueidentifier
,@Display nvarchar(65)
,@DisplayResourceKey uniqueidentifier
,@Description nvarchar(1000)
,@DescriptionResourceKey uniqueidentifier
,@ChoiceTypeCode int
,@ApproxWaitTime int
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

UPDATE GCS.AccessPortalCommandChoice
SET 
AccessPortalCommandChoiceUid = @AccessPortalCommandChoiceUid
,AccessPortalCommandUid = @AccessPortalCommandUid
,Display = @Display
,DisplayResourceKey = @DisplayResourceKey
,Description = @Description
,DescriptionResourceKey = @DescriptionResourceKey
,ChoiceTypeCode = @ChoiceTypeCode
,ApproxWaitTime = @ApproxWaitTime
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
AccessPortalCommandChoiceUid = @AccessPortalCommandChoiceUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessPortalCommandChoicePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.AccessPortalCommandChoice table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalCommandChoicePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalCommandChoicePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalCommandChoicePDSA_UpdateConcurrency]
@AccessPortalCommandChoiceUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.AccessPortalCommandChoice
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
AccessPortalCommandChoiceUid = @AccessPortalCommandChoiceUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessPortalCommandChoicePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.AccessPortalCommandChoice table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalCommandChoicePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalCommandChoicePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalCommandChoicePDSA_DeleteByPK]
@AccessPortalCommandChoiceUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.AccessPortalCommandChoice
WHERE
AccessPortalCommandChoiceUid = @AccessPortalCommandChoiceUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalCommandChoicePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.AccessPortalCommandChoice table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalCommandChoicePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalCommandChoicePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalCommandChoicePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.AccessPortalCommandChoice

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalCommandChoicePDSA_RowCount] TO public
GO



IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[GCS].[IsAccessPortalCommandChoiceUnique]') AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [GCS].[IsAccessPortalCommandChoiceUnique]
go

CREATE OR ALTER PROCEDURE [GCS].[IsAccessPortalCommandChoiceUnique]
	(@AccessPortalCommandChoiceUid uniqueidentifier,
	@AccessPortalCommandUid uniqueidentifier,
	@ChoiceTypeCode int,
	@Result int output
	)
AS
	select @Result = count(*) from GCS.AccessPortalCommandChoice where AccessPortalCommandChoiceUid <> @AccessPortalCommandChoiceUid AND (AccessPortalCommandUid = @AccessPortalCommandUid AND ChoiceTypeCode = @ChoiceTypeCode)
	select @Result as Result
go

GRANT EXECUTE ON [GCS].[IsAccessPortalCommandChoiceUnique] TO public
GO


/****** Object:  StoredProcedure [GCS].[[InputOutputGroupAssignment_GetInputOutputGroupUid]]    Script Date: 8/31/2020 2:22:23 PM ******/

IF EXISTS (SELECT * FROM dbo.sysobjects WHERE id = object_id(N'[GCS].[InputOutputGroupAssignment_GetInputOutputGroupUid]') AND OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [GCS].[InputOutputGroupAssignment_GetInputOutputGroupUid]
go


CREATE OR ALTER PROCEDURE [GCS].[InputOutputGroupAssignment_GetInputOutputGroupUid]
	@InputOutputGroupAssignmentUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
SELECT TOP 1 InputOutputGroupUid 
	FROM GCS.InputOutputGroupAssignment 
	WHERE InputOutputGroupAssignmentUid = @InputOutputGroupAssignmentUid
GO
ALTER AUTHORIZATION ON [GCS].[InputOutputGroupAssignment_GetInputOutputGroupUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputOutputGroupAssignment_GetInputOutputGroupUid] TO [public] AS [dbo]
GO



if dbo.fn_GCSDoesColumnExist('GalaxyPanelAlertEvent', 'IsActive') = 0
BEGIN
	ALTER TABLE GCS.GalaxyPanelAlertEvent
	ADD [IsActive] [bit] NOT NULL DEFAULT 1;
END
GO

if dbo.fn_GCSDoesColumnExist('AccessPortalAlertEvent', 'IsActive') = 0
BEGIN
	ALTER TABLE GCS.AccessPortalAlertEvent
	ADD [IsActive] [bit] NOT NULL DEFAULT 1;
END
GO


if dbo.fn_GCSDoesColumnExist('InputDeviceAlertEvent', 'IsActive') = 0
BEGIN
	ALTER TABLE GCS.InputDeviceAlertEvent
	ADD [IsActive] [bit] NOT NULL DEFAULT 1;
END
GO

if dbo.fn_GCSDoesColumnExist('InputDeviceAlertEvent', 'AcknowledgePriority') = 0
BEGIN
	ALTER TABLE GCS.InputDeviceAlertEvent
	ADD [AcknowledgePriority] [int] NOT NULL DEFAULT 0;
END
GO


if dbo.fn_GCSDoesColumnExist('InputDeviceEventProperties', 'IsActive') = 0
BEGIN
	ALTER TABLE GCS.InputDeviceEventProperties
	ADD [IsActive] [bit] NOT NULL DEFAULT 1;
END
GO



if dbo.fn_GCSDoesColumnExist('InputDeviceEventProperties', 'ResponseRequired') = 0
BEGIN
	ALTER TABLE GCS.InputDeviceEventProperties
	ADD ResponseRequired bit not null default 0;
END
GO


/* All Stored Procedures for table: GalaxyPanelAlertEvent */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.GalaxyPanelAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyPanelAlertEventUid
,GalaxyPanelUid
,GalaxyPanelAlertEventTypeUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,UserInstructionsNoteUid
,InputOutputGroupAssignmentUid
,InputOutputGroupUid
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyPanelAlertEvent

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanelAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_ByAudioBinaryResourceUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByAudioBinaryResourceUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByAudioBinaryResourceUid]
@AudioBinaryResourceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyPanelAlertEventUid
,GalaxyPanelUid
,GalaxyPanelAlertEventTypeUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,UserInstructionsNoteUid
,InputOutputGroupAssignmentUid
,InputOutputGroupUid
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyPanelAlertEvent
WHERE 
AudioBinaryResourceUid = @AudioBinaryResourceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_ByAudioBinaryResourceUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanelAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_ByGalaxyPanelAlertEventTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByGalaxyPanelAlertEventTypeUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByGalaxyPanelAlertEventTypeUid]
@GalaxyPanelAlertEventTypeUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyPanelAlertEventUid
,GalaxyPanelUid
,GalaxyPanelAlertEventTypeUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,UserInstructionsNoteUid
,InputOutputGroupAssignmentUid
,InputOutputGroupUid
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyPanelAlertEvent
WHERE 
GalaxyPanelAlertEventTypeUid = @GalaxyPanelAlertEventTypeUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_ByGalaxyPanelAlertEventTypeUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanelAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_ByGalaxyPanelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByGalaxyPanelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByGalaxyPanelUid]
@GalaxyPanelUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
t.GalaxyPanelAlertEventUid
,GalaxyPanelUid
,GalaxyPanelAlertEventTypeUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,UserInstructionsNoteUid
,t.InputOutputGroupAssignmentUid
,t.InputOutputGroupUid
,AcknowledgePriority
,ResponseRequired
,IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,OffsetIndex
FROM GCS.GalaxyPanelAlertEvent t
LEFT OUTER JOIN GCS.InputOutputGroupAssignment ass on ass.InputOutputGroupAssignmentUid = t.InputOutputGroupAssignmentUid
WHERE 
GalaxyPanelUid = @GalaxyPanelUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_ByGalaxyPanelUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanelAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_ByInputOutputGroupAssignmentUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByInputOutputGroupAssignmentUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByInputOutputGroupAssignmentUid]
@InputOutputGroupAssignmentUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyPanelAlertEventUid
,GalaxyPanelUid
,GalaxyPanelAlertEventTypeUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,UserInstructionsNoteUid
,InputOutputGroupAssignmentUid
,InputOutputGroupUid
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyPanelAlertEvent
WHERE 
InputOutputGroupAssignmentUid = @InputOutputGroupAssignmentUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_ByInputOutputGroupAssignmentUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanelAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_ByUserInstructionsNoteUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByUserInstructionsNoteUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByUserInstructionsNoteUid]
@UserInstructionsNoteUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyPanelAlertEventUid
,GalaxyPanelUid
,GalaxyPanelAlertEventTypeUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,UserInstructionsNoteUid
,InputOutputGroupAssignmentUid
,InputOutputGroupUid
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyPanelAlertEvent
WHERE 
UserInstructionsNoteUid = @UserInstructionsNoteUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_ByUserInstructionsNoteUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.GalaxyPanelAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyPanelAlertEventUid
,InsertName
FROM GCS.GalaxyPanelAlertEvent

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanelAlertEvent table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_SelectByPK]
@GalaxyPanelAlertEventUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyPanelAlertEventUid
,GalaxyPanelUid
,GalaxyPanelAlertEventTypeUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,UserInstructionsNoteUid
,InputOutputGroupAssignmentUid
,InputOutputGroupUid
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyPanelAlertEvent
WHERE 
GalaxyPanelAlertEventUid = @GalaxyPanelAlertEventUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.GalaxyPanelAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyPanelAlertEventUid
,GalaxyPanelUid
,GalaxyPanelAlertEventTypeUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,UserInstructionsNoteUid
,InputOutputGroupAssignmentUid
,InputOutputGroupUid
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyPanelAlertEvent
WHERE 
(@InsertName IS NULL OR InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.GalaxyPanelAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_Insert]
@GalaxyPanelAlertEventUid uniqueidentifier 
,@GalaxyPanelUid uniqueidentifier 
,@GalaxyPanelAlertEventTypeUid uniqueidentifier 
,@AcknowledgeTimeScheduleUid uniqueidentifier 
,@AudioBinaryResourceUid uniqueidentifier  = null
,@UserInstructionsNoteUid uniqueidentifier  = null
,@InputOutputGroupAssignmentUid uniqueidentifier  = null
,@InputOutputGroupUid uniqueidentifier
,@AcknowledgePriority int
,@ResponseRequired bit
,@IsActive bit
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @GalaxyPanelAlertEventUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyPanelAlertEventUid = NULL
if @AudioBinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @AudioBinaryResourceUid = NULL
if @UserInstructionsNoteUid = '00000000-0000-0000-0000-000000000000'
	SET @UserInstructionsNoteUid = NULL
if @InputOutputGroupAssignmentUid = '00000000-0000-0000-0000-000000000000'
	SET @InputOutputGroupAssignmentUid = NULL

if @GalaxyPanelAlertEventUid = '00000000-0000-0000-0000-000000000000' OR @GalaxyPanelAlertEventUid IS NULL
	SET @GalaxyPanelAlertEventUid = NewID()

INSERT INTO GCS.GalaxyPanelAlertEvent
(
GalaxyPanelAlertEventUid
,GalaxyPanelUid
,GalaxyPanelAlertEventTypeUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,UserInstructionsNoteUid
,InputOutputGroupAssignmentUid
,InputOutputGroupUid 
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@GalaxyPanelAlertEventUid
,@GalaxyPanelUid
,@GalaxyPanelAlertEventTypeUid
,@AcknowledgeTimeScheduleUid
,@AudioBinaryResourceUid
,@UserInstructionsNoteUid
,@InputOutputGroupAssignmentUid
,@InputOutputGroupUid
,@AcknowledgePriority
,@ResponseRequired
,@IsActive
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.GalaxyPanelAlertEvent table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_Update]
@GalaxyPanelAlertEventUid uniqueidentifier 
,@GalaxyPanelUid uniqueidentifier
,@GalaxyPanelAlertEventTypeUid uniqueidentifier
,@AcknowledgeTimeScheduleUid uniqueidentifier
,@AudioBinaryResourceUid uniqueidentifier
,@UserInstructionsNoteUid uniqueidentifier
,@InputOutputGroupAssignmentUid uniqueidentifier
,@InputOutputGroupUid uniqueidentifier
,@AcknowledgePriority int
,@ResponseRequired bit
,@IsActive bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @AudioBinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @AudioBinaryResourceUid = NULL
if @UserInstructionsNoteUid = '00000000-0000-0000-0000-000000000000'
	SET @UserInstructionsNoteUid = NULL
if @InputOutputGroupAssignmentUid = '00000000-0000-0000-0000-000000000000'
	SET @InputOutputGroupAssignmentUid = NULL

UPDATE GCS.GalaxyPanelAlertEvent
SET 
GalaxyPanelAlertEventUid = @GalaxyPanelAlertEventUid
,GalaxyPanelUid = @GalaxyPanelUid
,GalaxyPanelAlertEventTypeUid = @GalaxyPanelAlertEventTypeUid
,AcknowledgeTimeScheduleUid = @AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid = @AudioBinaryResourceUid
,UserInstructionsNoteUid = @UserInstructionsNoteUid
,InputOutputGroupAssignmentUid = @InputOutputGroupAssignmentUid
,InputOutputGroupUid = @InputOutputGroupUid
,AcknowledgePriority = @AcknowledgePriority
,ResponseRequired = @ResponseRequired
,IsActive = @IsActive
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
GalaxyPanelAlertEventUid = @GalaxyPanelAlertEventUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.GalaxyPanelAlertEvent table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_UpdateConcurrency]
@GalaxyPanelAlertEventUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.GalaxyPanelAlertEvent
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
GalaxyPanelAlertEventUid = @GalaxyPanelAlertEventUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.GalaxyPanelAlertEvent table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_DeleteByPK]
@GalaxyPanelAlertEventUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.GalaxyPanelAlertEvent
WHERE
GalaxyPanelAlertEventUid = @GalaxyPanelAlertEventUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.GalaxyPanelAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.GalaxyPanelAlertEvent

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_RowCount] TO public
GO

/* All Stored Procedures for table: InputDeviceAlertEvent */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.InputDeviceAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceAlertEventPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceAlertEventPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[InputDeviceAlertEventPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceAlertEventUid
,InputDeviceUid
,InputOutputGroupUid
,InputOutputGroupAssignmentUid
,InputDeviceAlertEventTypeUid
,Tag
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.InputDeviceAlertEvent

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceAlertEventPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDeviceAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceAlertEventPDSA_ByInputDeviceAlertEventTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceAlertEventPDSA_ByInputDeviceAlertEventTypeUid]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceAlertEventPDSA_ByInputDeviceAlertEventTypeUid]
@InputDeviceAlertEventTypeUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceAlertEventUid
,InputDeviceUid
,InputOutputGroupUid
,InputOutputGroupAssignmentUid
,InputDeviceAlertEventTypeUid
,Tag
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.InputDeviceAlertEvent
WHERE 
InputDeviceAlertEventTypeUid = @InputDeviceAlertEventTypeUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceAlertEventPDSA_ByInputDeviceAlertEventTypeUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDeviceAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceAlertEventPDSA_ByInputDeviceUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceAlertEventPDSA_ByInputDeviceUid]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceAlertEventPDSA_ByInputDeviceUid]
@InputDeviceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceAlertEventUid
,InputDeviceUid
,InputOutputGroupUid
,InputOutputGroupAssignmentUid
,InputDeviceAlertEventTypeUid
,Tag
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.InputDeviceAlertEvent
WHERE 
InputDeviceUid = @InputDeviceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceAlertEventPDSA_ByInputDeviceUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.InputDeviceAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceAlertEventPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceAlertEventPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[InputDeviceAlertEventPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceAlertEventUid
,Tag
FROM GCS.InputDeviceAlertEvent

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceAlertEventPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDeviceAlertEvent table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceAlertEventPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceAlertEventPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceAlertEventPDSA_SelectByPK]
@InputDeviceAlertEventUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceAlertEventUid
,InputDeviceUid
,InputOutputGroupUid
,InputOutputGroupAssignmentUid
,InputDeviceAlertEventTypeUid
,Tag
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.InputDeviceAlertEvent
WHERE 
InputDeviceAlertEventUid = @InputDeviceAlertEventUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceAlertEventPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.InputDeviceAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceAlertEventPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceAlertEventPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceAlertEventPDSA_SelectSearch]
@Tag nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceAlertEventUid
,InputDeviceUid
,InputOutputGroupUid
,InputOutputGroupAssignmentUid
,InputDeviceAlertEventTypeUid
,Tag
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.InputDeviceAlertEvent
WHERE 
(@Tag IS NULL OR Tag LIKE @Tag + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceAlertEventPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.InputDeviceAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceAlertEventPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceAlertEventPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceAlertEventPDSA_Insert]
@InputDeviceAlertEventUid uniqueidentifier 
,@InputDeviceUid uniqueidentifier 
,@InputOutputGroupUid uniqueidentifier 
,@InputOutputGroupAssignmentUid uniqueidentifier  = null
,@InputDeviceAlertEventTypeUid uniqueidentifier 
,@Tag nvarchar(65) 
,@AcknowledgePriority int
,@ResponseRequired bit
,@IsActive bit
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @InputDeviceAlertEventUid = '00000000-0000-0000-0000-000000000000'
	SET @InputDeviceAlertEventUid = NULL
if @InputOutputGroupAssignmentUid = '00000000-0000-0000-0000-000000000000'
	SET @InputOutputGroupAssignmentUid = NULL

if @InputDeviceAlertEventUid = '00000000-0000-0000-0000-000000000000' OR @InputDeviceAlertEventUid IS NULL
	SET @InputDeviceAlertEventUid = NewID()

INSERT INTO GCS.InputDeviceAlertEvent
(
InputDeviceAlertEventUid
,InputDeviceUid
,InputOutputGroupUid
,InputOutputGroupAssignmentUid
,InputDeviceAlertEventTypeUid
,Tag
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@InputDeviceAlertEventUid
,@InputDeviceUid
,@InputOutputGroupUid
,@InputOutputGroupAssignmentUid
,@InputDeviceAlertEventTypeUid
,@Tag
,@AcknowledgePriority
,@ResponseRequired
,@IsActive
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceAlertEventPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.InputDeviceAlertEvent table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceAlertEventPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceAlertEventPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceAlertEventPDSA_Update]
@InputDeviceAlertEventUid uniqueidentifier 
,@InputDeviceUid uniqueidentifier
,@InputOutputGroupUid uniqueidentifier
,@InputOutputGroupAssignmentUid uniqueidentifier
,@InputDeviceAlertEventTypeUid uniqueidentifier
,@Tag nvarchar(65)
,@AcknowledgePriority int
,@ResponseRequired bit
,@IsActive bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;


if @InputOutputGroupAssignmentUid = '00000000-0000-0000-0000-000000000000'
	SET @InputOutputGroupAssignmentUid = NULL

UPDATE GCS.InputDeviceAlertEvent
SET 
InputDeviceAlertEventUid = @InputDeviceAlertEventUid
,InputDeviceUid = @InputDeviceUid
,InputOutputGroupUid = @InputOutputGroupUid
,InputOutputGroupAssignmentUid = @InputOutputGroupAssignmentUid
,InputDeviceAlertEventTypeUid = @InputDeviceAlertEventTypeUid
,Tag = @Tag
,AcknowledgePriority = @AcknowledgePriority
,ResponseRequired = @ResponseRequired
,IsActive = @IsActive
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
InputDeviceAlertEventUid = @InputDeviceAlertEventUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[InputDeviceAlertEventPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.InputDeviceAlertEvent table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceAlertEventPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceAlertEventPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceAlertEventPDSA_UpdateConcurrency]
@InputDeviceAlertEventUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.InputDeviceAlertEvent
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
InputDeviceAlertEventUid = @InputDeviceAlertEventUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[InputDeviceAlertEventPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.InputDeviceAlertEvent table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceAlertEventPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceAlertEventPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceAlertEventPDSA_DeleteByPK]
@InputDeviceAlertEventUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.InputDeviceAlertEvent
WHERE
InputDeviceAlertEventUid = @InputDeviceAlertEventUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[InputDeviceAlertEventPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.InputDeviceAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceAlertEventPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceAlertEventPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceAlertEventPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.InputDeviceAlertEvent

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceAlertEventPDSA_RowCount] TO public
GO



update GCS.TimeScheduleType set TimeScheduleTypeUid = '00000000-0000-0000-0000-00000000000f' where TimeScheduleTypeUid = '91A4E660-DE07-4B07-96E5-0A10F5B28F5A'
go


update GCS.TimeScheduleType set TimeScheduleTypeUid = '00000000-0000-0000-0000-000000000001' where TimeScheduleTypeUid = '3F442B47-9DF3-475F-B787-89ABC3063273'
go


update GCS.TimeScheduleType set TimeScheduleTypeUid = '00000000-0000-0000-0001-000000000000' where TimeScheduleTypeUid = 'A67A4264-7ACD-4937-BDB8-CE1AC1C1312D'
go

update GCS.PersonCredentialRole set PersonCredentialRoleUid = '00000000-0000-0000-0000-000000000001' where Code = 0 and PersonCredentialRoleUid != '00000000-0000-0000-0000-000000000001'
go

update GCS.PersonCredentialRole set PersonCredentialRoleUid = '00000000-0000-0000-0000-000000000002' where Code = 1 and PersonCredentialRoleUid != '00000000-0000-0000-0000-000000000002'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000000' where CredentialFormatCode = 0 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000000'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000001' where CredentialFormatCode = 1 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000001'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000003' where CredentialFormatCode = 3 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000003'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000005' where CredentialFormatCode = 5 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000005'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000006' where CredentialFormatCode = 6 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000006'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000007' where CredentialFormatCode = 7 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000007'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000008' where CredentialFormatCode = 8 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000008'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000009' where CredentialFormatCode = 9 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000009'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-00000000000a' where CredentialFormatCode = 10 and CredentialFormatUid <> '00000000-0000-0000-0001-00000000000a'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-00000000000b' where CredentialFormatCode = 11 and CredentialFormatUid <> '00000000-0000-0000-0001-00000000000b'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-00000000000c' where CredentialFormatCode = 12 and CredentialFormatUid <> '00000000-0000-0000-0001-00000000000c'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-00000000000d' where CredentialFormatCode = 13 and CredentialFormatUid <> '00000000-0000-0000-0001-00000000000d'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-00000000000e' where CredentialFormatCode = 14 and CredentialFormatUid <> '00000000-0000-0000-0001-00000000000e'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-00000000000f' where CredentialFormatCode = 15 and CredentialFormatUid <> '00000000-0000-0000-0001-00000000000f'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000010' where CredentialFormatCode = 16 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000010'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000011' where CredentialFormatCode = 17and CredentialFormatUid <> '00000000-0000-0000-0001-000000000011'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000012' where CredentialFormatCode = 18 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000012'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000013' where CredentialFormatCode = 19 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000013'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000014' where CredentialFormatCode = 20 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000014'
go

update GCS.CredentialFormat set CredentialFormatUid = '00000000-0000-0000-0001-000000000015' where CredentialFormatCode = 21 and CredentialFormatUid <> '00000000-0000-0000-0001-000000000015'
go

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.PersonCredential table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonCredentialPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonCredentialPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonCredentialPDSA_Insert]
@PersonCredentialUid uniqueidentifier 
,@CredentialUid uniqueidentifier 
,@PersonUid uniqueidentifier 
,@PersonCredentialRoleUid uniqueidentifier 
,@PersonActivationModeUid uniqueidentifier 
,@PersonExpirationModeUid uniqueidentifier 
,@BadgeTemplateUid uniqueidentifier 
,@DossierBadgeTemplateUid uniqueidentifier 
,@AccessPortalNoServerReplyBehaviorUid uniqueidentifier 
,@AccessPortalDeferToServerBehaviorUid uniqueidentifier 
,@CredentialDescription nvarchar(65) 
,@ActivationDateTime datetimeoffset  = null
,@ExpirationDateTime datetimeoffset  = null
,@UsageCount smallint 
,@TraceEnabled bit 
,@DuressEnabled bit 
,@ReverseBits bit 
,@IsActive bit
,@BiometricEnrollmentStatus smallint  = null
,@BadgePrintLimit int  = null
,@BadgePrintCount int  = null
,@BadgeLastPrinted [datetimeoffset]  = null
,@DossierPrintLimit int  = null
,@DossierPrintCount int  = null
,@DossierLastPrinted [datetimeoffset]  = null
,@SysGalCardId smallint = 0
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @PersonCredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonCredentialUid = NULL

if @PersonCredentialUid = '00000000-0000-0000-0000-000000000000' OR @PersonCredentialUid IS NULL
	SET @PersonCredentialUid = NewID()

INSERT INTO GCS.PersonCredential
(
PersonCredentialUid
,CredentialUid
,PersonUid
,PersonCredentialRoleUid
,PersonActivationModeUid
,PersonExpirationModeUid
,BadgeTemplateUid
,DossierBadgeTemplateUid
,AccessPortalNoServerReplyBehaviorUid
,AccessPortalDeferToServerBehaviorUid
,CredentialDescription
,ActivationDateTime
,ExpirationDateTime
,UsageCount
,TraceEnabled
,DuressEnabled
,ReverseBits
,IsActive
,BiometricEnrollmentStatus
,BadgePrintLimit
,BadgePrintCount
,BadgeLastPrinted
,DossierPrintLimit
,DossierPrintCount
,DossierLastPrinted
,SysGalCardId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@PersonCredentialUid
,@CredentialUid
,@PersonUid
,@PersonCredentialRoleUid
,@PersonActivationModeUid
,@PersonExpirationModeUid
,@BadgeTemplateUid
,@DossierBadgeTemplateUid
,@AccessPortalNoServerReplyBehaviorUid
,@AccessPortalDeferToServerBehaviorUid
,@CredentialDescription
,@ActivationDateTime
,@ExpirationDateTime
,@UsageCount
,@TraceEnabled
,@DuressEnabled
,@ReverseBits
,@IsActive
,@BiometricEnrollmentStatus
,@BadgePrintLimit
,@BadgePrintCount
,@BadgeLastPrinted
,@DossierPrintLimit
,@DossierPrintCount
,@DossierLastPrinted
,@SysGalCardId
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonCredentialPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.PersonCredential table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonCredentialPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonCredentialPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonCredentialPDSA_Update]
@PersonCredentialUid uniqueidentifier 
,@CredentialUid uniqueidentifier
,@PersonUid uniqueidentifier
,@PersonCredentialRoleUid uniqueidentifier
,@PersonActivationModeUid uniqueidentifier
,@PersonExpirationModeUid uniqueidentifier
,@BadgeTemplateUid uniqueidentifier
,@DossierBadgeTemplateUid uniqueidentifier
,@AccessPortalNoServerReplyBehaviorUid uniqueidentifier
,@AccessPortalDeferToServerBehaviorUid uniqueidentifier
,@CredentialDescription nvarchar(65)
,@ActivationDateTime datetimeoffset
,@ExpirationDateTime datetimeoffset
,@UsageCount smallint
,@TraceEnabled bit
,@DuressEnabled bit
,@ReverseBits bit
,@IsActive bit
,@BiometricEnrollmentStatus smallint
,@BadgePrintLimit int
,@BadgePrintCount int
,@BadgeLastPrinted [datetimeoffset]
,@DossierPrintLimit int
,@DossierPrintCount int
,@DossierLastPrinted [datetimeoffset]
,@SysGalCardId smallint
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;

UPDATE GCS.PersonCredential
SET 
CredentialUid = @CredentialUid
,PersonUid = @PersonUid
,PersonCredentialRoleUid = @PersonCredentialRoleUid
,PersonActivationModeUid = @PersonActivationModeUid
,PersonExpirationModeUid = @PersonExpirationModeUid
,BadgeTemplateUid = @BadgeTemplateUid
,DossierBadgeTemplateUid = @DossierBadgeTemplateUid
,AccessPortalNoServerReplyBehaviorUid = @AccessPortalNoServerReplyBehaviorUid
,AccessPortalDeferToServerBehaviorUid = @AccessPortalDeferToServerBehaviorUid
,CredentialDescription = @CredentialDescription
,ActivationDateTime = @ActivationDateTime
,ExpirationDateTime = @ExpirationDateTime
,UsageCount = @UsageCount
,TraceEnabled = @TraceEnabled
,DuressEnabled = @DuressEnabled
,ReverseBits = @ReverseBits
,IsActive = @IsActive
,BiometricEnrollmentStatus = @BiometricEnrollmentStatus
,BadgePrintLimit = @BadgePrintLimit
,BadgePrintCount = @BadgePrintCount
,BadgeLastPrinted = @BadgeLastPrinted
,DossierPrintLimit = @DossierPrintLimit
,DossierPrintCount = @DossierPrintCount
,DossierLastPrinted = @DossierLastPrinted
,SysGalCardId = @SysGalCardId
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
PersonCredentialUid = @PersonCredentialUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonCredentialPDSA_Update] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPDSA_ByEntityId]
GO

CREATE OR ALTER PROCEDURE [GCS].[PersonPDSA_ByEntityId]
	@EntityId [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
PersonUid
,CountryOfBirthUid
,PersonActiveStatusTypeUid
,GenderUid
,t.DepartmentUid
,PersonRecordTypeUid
,t.EntityId
,RowOrigin
,OriginId
,PersonId
,FirstName
,MiddleName
,LastName
,Initials
,NickName
,LegalName
,FullName
,PreferredName
,Company
,HomeOfficeLocation
,JobTitle
,Race
,Nationality
,Ethnicity
,PrimaryLanguage
,SecondaryLanguage
,NationalIdentificationNumber
,DateOfBirth
,EmploymentDate
,TerminationDate
,ActivationDateTime
,ExpirationDateTime
,Trace
,TextData1
,TextData2
,TextData3
,TextData4
,TextData5
,TextData6
,TextData7
,TextData8
,TextData9
,TextData10
,TextData11
,TextData12
,TextData13
,TextData14
,TextData15
,TextData16
,TextData17
,TextData18
,TextData19
,TextData20
,TextData22
,TextData23
,TextData24
,TextData25
,TextData26
,TextData27
,TextData28
,TextData29
,TextData21
,TextData30
,TextData31
,TextData32
,TextData33
,TextData34
,TextData35
,TextData36
,TextData37
,TextData38
,TextData39
,TextData40
,TextData41
,TextData42
,TextData43
,TextData44
,TextData45
,TextData46
,TextData47
,TextData48
,TextData49
,TextData50
,SysGalEmployeeId
,VeryImportantPerson
,HasPhysicalDisability
,HasVertigo
,ActiveStatusCode
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,DepartmentName
FROM GCS.Person t
LEFT OUTER JOIN GCS.Department d on d.DepartmentUid = t.DepartmentUid
WHERE 
t.EntityId = @EntityId OR PersonUid in (SELECT DISTINCT(PersonUid) FROM GCS.PersonEntityMap WHERE EntityId = @EntityId)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[PersonPDSA_ByEntityId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonPDSA_ByEntityId] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPDSA_SelectAll]
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonPDSA_SelectAll]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
PersonUid
,CountryOfBirthUid
,PersonActiveStatusTypeUid
,GenderUid
,t.DepartmentUid
,PersonRecordTypeUid
,t.EntityId
,RowOrigin
,OriginId
,PersonId
,FirstName
,MiddleName
,LastName
,Initials
,NickName
,LegalName
,FullName
,PreferredName
,Company
,HomeOfficeLocation
,JobTitle
,Race
,Nationality
,Ethnicity
,PrimaryLanguage
,SecondaryLanguage
,NationalIdentificationNumber
,DateOfBirth
,EmploymentDate
,TerminationDate
,ActivationDateTime
,ExpirationDateTime
,Trace
,TextData1
,TextData2
,TextData3
,TextData4
,TextData5
,TextData6
,TextData7
,TextData8
,TextData9
,TextData10
,TextData11
,TextData12
,TextData13
,TextData14
,TextData15
,TextData16
,TextData17
,TextData18
,TextData19
,TextData20
,TextData22
,TextData23
,TextData24
,TextData25
,TextData26
,TextData27
,TextData28
,TextData29
,TextData21
,TextData30
,TextData31
,TextData32
,TextData33
,TextData34
,TextData35
,TextData36
,TextData37
,TextData38
,TextData39
,TextData40
,TextData41
,TextData42
,TextData43
,TextData44
,TextData45
,TextData46
,TextData47
,TextData48
,TextData49
,TextData50
,SysGalEmployeeId
,VeryImportantPerson
,HasPhysicalDisability
,HasVertigo
,ActiveStatusCode
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,DepartmentName
FROM GCS.Person t
LEFT OUTER JOIN GCS.Department d on d.DepartmentUid = t.DepartmentUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[PersonPDSA_SelectAll] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonPDSA_SelectAll] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonPDSA_SelectByPK]
	@PersonUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
PersonUid
,CountryOfBirthUid
,PersonActiveStatusTypeUid
,GenderUid
,t.DepartmentUid
,PersonRecordTypeUid
,t.EntityId
,RowOrigin
,OriginId
,PersonId
,FirstName
,MiddleName
,LastName
,Initials
,NickName
,LegalName
,FullName
,PreferredName
,Company
,HomeOfficeLocation
,JobTitle
,Race
,Nationality
,Ethnicity
,PrimaryLanguage
,SecondaryLanguage
,NationalIdentificationNumber
,DateOfBirth
,EmploymentDate
,TerminationDate
,ActivationDateTime
,ExpirationDateTime
,Trace
,TextData1
,TextData2
,TextData3
,TextData4
,TextData5
,TextData6
,TextData7
,TextData8
,TextData9
,TextData10
,TextData11
,TextData12
,TextData13
,TextData14
,TextData15
,TextData16
,TextData17
,TextData18
,TextData19
,TextData20
,TextData22
,TextData23
,TextData24
,TextData25
,TextData26
,TextData27
,TextData28
,TextData29
,TextData21
,TextData30
,TextData31
,TextData32
,TextData33
,TextData34
,TextData35
,TextData36
,TextData37
,TextData38
,TextData39
,TextData40
,TextData41
,TextData42
,TextData43
,TextData44
,TextData45
,TextData46
,TextData47
,TextData48
,TextData49
,TextData50
,SysGalEmployeeId
,VeryImportantPerson
,HasPhysicalDisability
,HasVertigo
,ActiveStatusCode
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,DepartmentName
FROM GCS.Person t
LEFT OUTER JOIN GCS.Department d on d.DepartmentUid = t.DepartmentUid
WHERE PersonUid = @PersonUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[PersonPDSA_SelectByPK] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonPDSA_SelectByPK] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonPDSA_SelectSearch]
	@RowOrigin [nvarchar](100)
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
PersonUid
,CountryOfBirthUid
,PersonActiveStatusTypeUid
,GenderUid
,t.DepartmentUid
,PersonRecordTypeUid
,t.EntityId
,RowOrigin
,OriginId
,PersonId
,FirstName
,MiddleName
,LastName
,Initials
,NickName
,LegalName
,FullName
,PreferredName
,Company
,HomeOfficeLocation
,JobTitle
,Race
,Nationality
,Ethnicity
,PrimaryLanguage
,SecondaryLanguage
,NationalIdentificationNumber
,DateOfBirth
,EmploymentDate
,TerminationDate
,ActivationDateTime
,ExpirationDateTime
,Trace
,TextData1
,TextData2
,TextData3
,TextData4
,TextData5
,TextData6
,TextData7
,TextData8
,TextData9
,TextData10
,TextData11
,TextData12
,TextData13
,TextData14
,TextData15
,TextData16
,TextData17
,TextData18
,TextData19
,TextData20
,TextData22
,TextData23
,TextData24
,TextData25
,TextData26
,TextData27
,TextData28
,TextData29
,TextData21
,TextData30
,TextData31
,TextData32
,TextData33
,TextData34
,TextData35
,TextData36
,TextData37
,TextData38
,TextData39
,TextData40
,TextData41
,TextData42
,TextData43
,TextData44
,TextData45
,TextData46
,TextData47
,TextData48
,TextData49
,TextData50
,SysGalEmployeeId
,VeryImportantPerson
,HasPhysicalDisability
,HasVertigo
,ActiveStatusCode
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,DepartmentName
FROM GCS.Person t
LEFT OUTER JOIN GCS.Department d on d.DepartmentUid = t.DepartmentUid
WHERE 
(@RowOrigin IS NULL OR RowOrigin LIKE @RowOrigin + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[PersonPDSA_SelectSearch] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonPDSA_SelectSearch] TO [public] AS [dbo]
GO

/****** Object:  Index [idxCredentiaH1030237Bit]    Script Date: 3/17/2022 2:26:40 PM ******/
DROP INDEX [idxCredentiaH1030237Bit] ON [GCS].[CredentialH1030237Bit]
GO

ALTER TABLE [GCS].[CredentialH1030237Bit] DROP CONSTRAINT [CKC_IDCODE_H1030237Bit]
GO

EXEC sp_rename 'GCS.CredentialH1030237Bit.IDCode', 'IdCode';
go

ALTER TABLE [GCS].[CredentialH1030237Bit]  WITH CHECK ADD  CONSTRAINT [CKC_IDCODE_H1030237Bit] CHECK  (([IdCode]>=(0) AND [IdCode]<=(34359738367.)))
GO

ALTER TABLE [GCS].[CredentialH1030237Bit] CHECK CONSTRAINT [CKC_IDCODE_H1030237Bit]
GO

/****** Object:  Index [idxCredentiaH1030237Bit]    Script Date: 3/17/2022 2:26:41 PM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxCredentiaH1030237Bit] ON [GCS].[CredentialH1030237Bit]
(
	[IdCode] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO


/****** Object:  Index [idxCredentialSoftwareHouse37Bit]    Script Date: 3/17/2022 2:30:17 PM ******/
DROP INDEX [idxCredentialSoftwareHouse37Bit] ON [GCS].[CredentialSoftwareHouse37Bit]
GO

ALTER TABLE [GCS].[CredentialSoftwareHouse37Bit] DROP CONSTRAINT [CKC_IDCODE_CSoftwareHouse37Bit]
GO

EXEC sp_rename 'GCS.CredentialSoftwareHouse37Bit.IDCode', 'IdCode';
go

ALTER TABLE [GCS].[CredentialSoftwareHouse37Bit]  WITH CHECK ADD  CONSTRAINT [CKC_IDCODE_CSoftwareHouse37Bit] CHECK  (([IdCode]>=(0) AND [IdCode]<=(65535)))
GO

ALTER TABLE [GCS].[CredentialSoftwareHouse37Bit] CHECK CONSTRAINT [CKC_IDCODE_CSoftwareHouse37Bit]
GO

/****** Object:  Index [idxCredentialSoftwareHouse37Bit]    Script Date: 3/17/2022 2:30:17 PM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxCredentialSoftwareHouse37Bit] ON [GCS].[CredentialSoftwareHouse37Bit]
(
	[FacilityCode] ASC,
	[SiteCode] ASC,
	[IdCode] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO

/* All Stored Procedures for table: CredentialH1030237Bit */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.CredentialH1030237Bit table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialH1030237BitPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialH1030237BitPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[CredentialH1030237BitPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialH1030237Bit

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialH1030237BitPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.CredentialH1030237Bit table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialH1030237BitPDSA_ByCredentialUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialH1030237BitPDSA_ByCredentialUid]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialH1030237BitPDSA_ByCredentialUid]
@CredentialUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialH1030237Bit
WHERE 
CredentialUid = @CredentialUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialH1030237BitPDSA_ByCredentialUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.CredentialH1030237Bit table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialH1030237BitPDSA_ByIdCode]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialH1030237BitPDSA_ByIdCode]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialH1030237BitPDSA_ByIdCode]
@IdCode bigint 
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialH1030237Bit
WHERE 
IdCode = @IdCode 

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialH1030237BitPDSA_ByIdCode] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.CredentialH1030237Bit table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialH1030237BitPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialH1030237BitPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[CredentialH1030237BitPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,InsertName
FROM GCS.CredentialH1030237Bit

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialH1030237BitPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.CredentialH1030237Bit table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialH1030237BitPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialH1030237BitPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialH1030237BitPDSA_SelectByPK]
@CredentialUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialH1030237Bit
WHERE 
CredentialUid = @CredentialUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialH1030237BitPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.CredentialH1030237Bit table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialH1030237BitPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialH1030237BitPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialH1030237BitPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialH1030237Bit
WHERE 
(@InsertName IS NULL OR InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialH1030237BitPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.CredentialH1030237Bit table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialH1030237BitPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialH1030237BitPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialH1030237BitPDSA_Insert]
@CredentialUid uniqueidentifier 
,@IdCode bigint 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL

if @CredentialUid = '00000000-0000-0000-0000-000000000000' OR @CredentialUid IS NULL
	SET @CredentialUid = NewID()

INSERT INTO GCS.CredentialH1030237Bit
(
CredentialUid
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@CredentialUid
,@IdCode
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialH1030237BitPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.CredentialH1030237Bit table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialH1030237BitPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialH1030237BitPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialH1030237BitPDSA_Update]
@CredentialUid uniqueidentifier 
,@IdCode bigint
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.CredentialH1030237Bit
SET 
CredentialUid = @CredentialUid
,IdCode = @IdCode
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
CredentialUid = @CredentialUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[CredentialH1030237BitPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.CredentialH1030237Bit table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialH1030237BitPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialH1030237BitPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialH1030237BitPDSA_UpdateConcurrency]
@CredentialUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.CredentialH1030237Bit
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
CredentialUid = @CredentialUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[CredentialH1030237BitPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.CredentialH1030237Bit table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialH1030237BitPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialH1030237BitPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialH1030237BitPDSA_DeleteByPK]
@CredentialUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.CredentialH1030237Bit
WHERE
CredentialUid = @CredentialUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialH1030237BitPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.CredentialH1030237Bit table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialH1030237BitPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialH1030237BitPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialH1030237BitPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.CredentialH1030237Bit

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialH1030237BitPDSA_RowCount] TO public
GO

/* All Stored Procedures for table: CredentialSoftwareHouse37Bit */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.CredentialSoftwareHouse37Bit table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,FacilityCode
,SiteCode
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialSoftwareHouse37Bit

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.CredentialSoftwareHouse37Bit table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_ByCredentialUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_ByCredentialUid]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_ByCredentialUid]
@CredentialUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,FacilityCode
,SiteCode
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialSoftwareHouse37Bit
WHERE 
CredentialUid = @CredentialUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_ByCredentialUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.CredentialSoftwareHouse37Bit table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_ByFacilitySiteIdCode]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_ByFacilitySiteIdCode]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_ByFacilitySiteIdCode]
@FacilityCode int,
@SiteCode smallint,
@IdCode int
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,FacilityCode
,SiteCode
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialSoftwareHouse37Bit
WHERE 
IdCode = @IdCode and FacilityCode = @FacilityCode and SiteCode = @SiteCode

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_ByFacilitySiteIdCode] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.CredentialSoftwareHouse37Bit table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_ByIdCode]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_ByIdCode]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_ByIdCode]
@IdCode int
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,FacilityCode
,SiteCode
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialSoftwareHouse37Bit
WHERE 
IdCode = @IdCode 

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_ByIdCode] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.CredentialSoftwareHouse37Bit table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,InsertName
FROM GCS.CredentialSoftwareHouse37Bit

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.CredentialSoftwareHouse37Bit table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_SelectByPK]
@CredentialUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,FacilityCode
,SiteCode
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialSoftwareHouse37Bit
WHERE 
CredentialUid = @CredentialUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.CredentialSoftwareHouse37Bit table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialUid
,FacilityCode
,SiteCode
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialSoftwareHouse37Bit
WHERE 
(@InsertName IS NULL OR InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.CredentialSoftwareHouse37Bit table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_Insert]
@CredentialUid uniqueidentifier 
,@FacilityCode int 
,@SiteCode smallint 
,@IdCode int 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL

if @CredentialUid = '00000000-0000-0000-0000-000000000000' OR @CredentialUid IS NULL
	SET @CredentialUid = NewID()

INSERT INTO GCS.CredentialSoftwareHouse37Bit
(
CredentialUid
,FacilityCode
,SiteCode
,IdCode
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@CredentialUid
,@FacilityCode
,@SiteCode
,@IdCode
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.CredentialSoftwareHouse37Bit table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_Update]
@CredentialUid uniqueidentifier 
,@FacilityCode int
,@SiteCode smallint
,@IdCode int
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.CredentialSoftwareHouse37Bit
SET 
CredentialUid = @CredentialUid
,FacilityCode = @FacilityCode
,SiteCode = @SiteCode
,IdCode = @IdCode
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
CredentialUid = @CredentialUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.CredentialSoftwareHouse37Bit table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_UpdateConcurrency]
@CredentialUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.CredentialSoftwareHouse37Bit
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
CredentialUid = @CredentialUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.CredentialSoftwareHouse37Bit table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_DeleteByPK]
@CredentialUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.CredentialSoftwareHouse37Bit
WHERE
CredentialUid = @CredentialUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.CredentialSoftwareHouse37Bit table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialSoftwareHouse37BitPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialSoftwareHouse37BitPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.CredentialSoftwareHouse37Bit

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialSoftwareHouse37BitPDSA_RowCount] TO public
GO


ALTER TABLE [GCS].[GalaxyInterfaceBoardSectionNode] DROP CONSTRAINT [CKC_NODENUMBER_GALAXYIN]
GO

ALTER TABLE [GCS].[GalaxyInterfaceBoardSectionNode]  WITH CHECK ADD  CONSTRAINT [CKC_NODENUMBER_GALAXYIN] CHECK  (([NodeNumber]>=(0) AND [NodeNumber]<=(120)))
GO

ALTER TABLE [GCS].[GalaxyInterfaceBoardSectionNode] CHECK CONSTRAINT [CKC_NODENUMBER_GALAXYIN]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.PersonCredential_DecrimentUsageCount') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonCredential_DecrimentUsageCount]
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonCredential_DecrimentUsageCount]
	@PersonCredentialUid [uniqueidentifier],
	@StartingUsageCount [smallint]
WITH EXECUTE AS CALLER
AS
declare @usageCount smallint
	select @usageCount = UsageCount FROM GCS.PersonCredential where PersonCredentialUid = @PersonCredentialUid AND PersonExpirationModeUid in ('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-000000000004')
	IF @usageCount IS NOT NULL
	BEGIN
		IF @usageCount > 0
		BEGIN
			update GCS.PersonCredential set UsageCount = UsageCount - 1
			where PersonCredentialUid = @PersonCredentialUid AND UsageCount > 0
		END
		IF @usageCount <= 1
		BEGIN
			update GCS.PersonCredential set IsActive = 0
			where PersonCredentialUid = @PersonCredentialUid
		END
	END
	ELSE
	BEGIN
		update GCS.PersonCredential set UsageCount = 0
		where PersonCredentialUid = @PersonCredentialUid
	END
GO
ALTER AUTHORIZATION ON [GCS].[PersonCredential_DecrimentUsageCount] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonCredential_DecrimentUsageCount] TO [public] AS [dbo]
GO

if dbo.fn_GCSDoesColumnExist('CredentialFormat', 'UseFullCardCode') = 1
BEGIN
	EXEC sp_rename 'GCS.CredentialFormat.UseFullCardCode', 'UseCardNumber';
END
go  

/* All Stored Procedures for table: CredentialFormat */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.CredentialFormat table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialFormatPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialFormatPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[CredentialFormatPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialFormatUid
,DisplayResourceKey
,DescriptionResourceKey
,Display
,Description
,CredentialFormatCode
,BitLength
,IsEnabled
,BiometricEnrollmentSupported
,BiometricIdField
,UseCardNumber
,BatchLoadSupported
,BatchLoadIncrementField
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialFormat

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialFormatPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.CredentialFormat table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialFormatPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialFormatPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialFormatPDSA_ByEntityId]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
cf.CredentialFormatUid
,DisplayResourceKey
,DescriptionResourceKey
,Display
,Description
,CredentialFormatCode
,BitLength
,IsEnabled
,BiometricEnrollmentSupported
,BiometricIdField
,UseCardNumber
,BatchLoadSupported
,BatchLoadIncrementField
,cf.InsertName
,cf.InsertDate
,cf.UpdateName
,cf.UpdateDate
,cf.ConcurrencyValue
,IsAllowed
,EntityId
FROM GCS.CredentialFormat cf left outer join GCS.CredentialFormatEntityMap cfem on cfem.CredentialFormatUid = cf.CredentialFormatUid
WHERE 
EntityId = @EntityId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialFormatPDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.CredentialFormat table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialFormatPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialFormatPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[CredentialFormatPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialFormatUid
,Display
FROM GCS.CredentialFormat

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialFormatPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.CredentialFormat table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialFormatPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialFormatPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialFormatPDSA_SelectByPK]
@CredentialFormatUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialFormatUid
,DisplayResourceKey
,DescriptionResourceKey
,Display
,Description
,CredentialFormatCode
,BitLength
,IsEnabled
,BiometricEnrollmentSupported
,BiometricIdField
,UseCardNumber
,BatchLoadSupported
,BatchLoadIncrementField
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialFormat
WHERE 
CredentialFormatUid = @CredentialFormatUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialFormatPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.CredentialFormat table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialFormatPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialFormatPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialFormatPDSA_SelectSearch]
@Display nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
CredentialFormatUid
,DisplayResourceKey
,DescriptionResourceKey
,Display
,Description
,CredentialFormatCode
,BitLength
,IsEnabled
,BiometricEnrollmentSupported
,BiometricIdField
,UseCardNumber
,BatchLoadSupported
,BatchLoadIncrementField
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.CredentialFormat
WHERE 
(@Display IS NULL OR Display LIKE @Display + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialFormatPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.CredentialFormat table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialFormatPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialFormatPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialFormatPDSA_Insert]
@CredentialFormatUid uniqueidentifier 
,@DisplayResourceKey uniqueidentifier  = null
,@DescriptionResourceKey uniqueidentifier  = null
,@Display nvarchar(65) 
,@Description nvarchar(1000) 
,@CredentialFormatCode smallint 
,@BitLength smallint 
,@IsEnabled bit 
,@BiometricEnrollmentSupported bit 
,@BiometricIdField smallint 
,@UseCardNumber bit 
,@BatchLoadSupported bit 
,@BatchLoadIncrementField smallint 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @CredentialFormatUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialFormatUid = NULL
if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

if @CredentialFormatUid = '00000000-0000-0000-0000-000000000000' OR @CredentialFormatUid IS NULL
	SET @CredentialFormatUid = NewID()

INSERT INTO GCS.CredentialFormat
(
CredentialFormatUid
,DisplayResourceKey
,DescriptionResourceKey
,Display
,Description
,CredentialFormatCode
,BitLength
,IsEnabled
,BiometricEnrollmentSupported
,BiometricIdField
,UseCardNumber
,BatchLoadSupported
,BatchLoadIncrementField
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@CredentialFormatUid
,@DisplayResourceKey
,@DescriptionResourceKey
,@Display
,@Description
,@CredentialFormatCode
,@BitLength
,@IsEnabled
,@BiometricEnrollmentSupported
,@BiometricIdField
,@UseCardNumber
,@BatchLoadSupported
,@BatchLoadIncrementField
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialFormatPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.CredentialFormat table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialFormatPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialFormatPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialFormatPDSA_Update]
@CredentialFormatUid uniqueidentifier 
,@DisplayResourceKey uniqueidentifier
,@DescriptionResourceKey uniqueidentifier
,@Display nvarchar(65)
,@Description nvarchar(1000)
,@CredentialFormatCode smallint
,@BitLength smallint
,@IsEnabled bit
,@BiometricEnrollmentSupported bit
,@BiometricIdField smallint
,@UseCardNumber bit
,@BatchLoadSupported bit
,@BatchLoadIncrementField smallint
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

UPDATE GCS.CredentialFormat
SET 
CredentialFormatUid = @CredentialFormatUid
,DisplayResourceKey = @DisplayResourceKey
,DescriptionResourceKey = @DescriptionResourceKey
,Display = @Display
,Description = @Description
,CredentialFormatCode = @CredentialFormatCode
,BitLength = @BitLength
,IsEnabled = @IsEnabled
,BiometricEnrollmentSupported = @BiometricEnrollmentSupported
,BiometricIdField = @BiometricIdField
,UseCardNumber = @UseCardNumber
,BatchLoadSupported = @BatchLoadSupported
,BatchLoadIncrementField = @BatchLoadIncrementField
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
CredentialFormatUid = @CredentialFormatUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[CredentialFormatPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.CredentialFormat table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialFormatPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialFormatPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialFormatPDSA_UpdateConcurrency]
@CredentialFormatUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.CredentialFormat
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
CredentialFormatUid = @CredentialFormatUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[CredentialFormatPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.CredentialFormat table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialFormatPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialFormatPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialFormatPDSA_DeleteByPK]
@CredentialFormatUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.CredentialFormat
WHERE
CredentialFormatUid = @CredentialFormatUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialFormatPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.CredentialFormat table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[CredentialFormatPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[CredentialFormatPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[CredentialFormatPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.CredentialFormat

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[CredentialFormatPDSA_RowCount] TO public
GO

/* All Stored Procedures for table: AccessProfileCluster */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.AccessProfileCluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessProfileClusterPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessProfileClusterUid
,AccessProfileUid
,apc.ClusterUid
,apc.InsertName
,apc.InsertDate
,apc.UpdateName
,apc.UpdateDate
,apc.ConcurrencyValue
,ClusterName
FROM GCS.AccessProfileCluster apc
JOIN GCS.Cluster c on c.ClusterUid = apc.ClusterUid


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfileClusterPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessProfileCluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_ByAccessProfileUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_ByAccessProfileUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfileClusterPDSA_ByAccessProfileUid]
@AccessProfileUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessProfileClusterUid
,AccessProfileUid
,apc.ClusterUid
,apc.InsertName
,apc.InsertDate
,apc.UpdateName
,apc.UpdateDate
,apc.ConcurrencyValue
,ClusterName
FROM GCS.AccessProfileCluster apc
JOIN GCS.Cluster c on c.ClusterUid = apc.ClusterUid
WHERE 
AccessProfileUid = @AccessProfileUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfileClusterPDSA_ByAccessProfileUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessProfileCluster table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfileClusterPDSA_ByClusterUid]
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessProfileClusterUid
,AccessProfileUid
,apc.ClusterUid
,apc.InsertName
,apc.InsertDate
,apc.UpdateName
,apc.UpdateDate
,apc.ConcurrencyValue
,ClusterName
FROM GCS.AccessProfileCluster apc
JOIN GCS.Cluster c on c.ClusterUid = apc.ClusterUid
WHERE 
apc.ClusterUid = @ClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfileClusterPDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.AccessProfileCluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessProfileClusterPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessProfileClusterUid
,InsertName
FROM GCS.AccessProfileCluster

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfileClusterPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessProfileCluster table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfileClusterPDSA_SelectByPK]
@AccessProfileClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessProfileClusterUid
,AccessProfileUid
,apc.ClusterUid
,apc.InsertName
,apc.InsertDate
,apc.UpdateName
,apc.UpdateDate
,apc.ConcurrencyValue
,ClusterName
FROM GCS.AccessProfileCluster apc
JOIN GCS.Cluster c on c.ClusterUid = apc.ClusterUid
WHERE 
AccessProfileClusterUid = @AccessProfileClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfileClusterPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.AccessProfileCluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfileClusterPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessProfileClusterUid
,AccessProfileUid
,apc.ClusterUid
,apc.InsertName
,apc.InsertDate
,apc.UpdateName
,apc.UpdateDate
,apc.ConcurrencyValue
,ClusterName
FROM GCS.AccessProfileCluster apc
JOIN GCS.Cluster c on c.ClusterUid = apc.ClusterUid
WHERE 
(@InsertName IS NULL OR apc.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfileClusterPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.AccessProfileCluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfileClusterPDSA_Insert]
@AccessProfileClusterUid uniqueidentifier 
,@AccessProfileUid uniqueidentifier 
,@ClusterUid uniqueidentifier 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @AccessProfileClusterUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessProfileClusterUid = NULL

if @AccessProfileClusterUid = '00000000-0000-0000-0000-000000000000' OR @AccessProfileClusterUid IS NULL
	SET @AccessProfileClusterUid = NewID()

INSERT INTO GCS.AccessProfileCluster
(
AccessProfileClusterUid
,AccessProfileUid
,ClusterUid
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@AccessProfileClusterUid
,@AccessProfileUid
,@ClusterUid
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfileClusterPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.AccessProfileCluster table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfileClusterPDSA_Update]
@AccessProfileClusterUid uniqueidentifier 
,@AccessProfileUid uniqueidentifier
,@ClusterUid uniqueidentifier
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.AccessProfileCluster
SET 
AccessProfileClusterUid = @AccessProfileClusterUid
,AccessProfileUid = @AccessProfileUid
,ClusterUid = @ClusterUid
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
AccessProfileClusterUid = @AccessProfileClusterUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessProfileClusterPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.AccessProfileCluster table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfileClusterPDSA_UpdateConcurrency]
@AccessProfileClusterUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.AccessProfileCluster
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
AccessProfileClusterUid = @AccessProfileClusterUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessProfileClusterPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.AccessProfileCluster table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfileClusterPDSA_DeleteByPK]
@AccessProfileClusterUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.AccessProfileCluster
WHERE
AccessProfileClusterUid = @AccessProfileClusterUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[AccessProfileClusterPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.AccessProfileCluster table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessProfileClusterPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.AccessProfileCluster

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessProfileClusterPDSA_RowCount] TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_AccessProfileUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_AccessProfileUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileClusterPDSA_ByPropertyTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileClusterPDSA_ByPropertyTypeUid]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsAccessGroupClusterPermissionValid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsAccessGroupClusterPermissionValid]
GO

CREATE OR ALTER PROCEDURE GCS.[IsAccessGroupClusterPermissionValid]
@ClusterUid uniqueidentifier,
@AccessGroupUid uniqueidentifier,
@OrderNumber smallint,
@Result int OUTPUT
AS

-- Result values:
-- 0 = it is ok
-- 1 = Invalid @OrderNumber
-- 2 = AccessGroup is not found in Cluster
-- 3 = AccessGroup > 255 cannot be assigned to OrderNumber 1 or 2
-- 4 = AccessGroup > 2000 cannot be assigned to OrderNumber 3
set nocount on
declare @ret int;
select @ret = 0;
select @Result = 0;

if @OrderNumber < 1 OR @OrderNumber > 4
BEGIN
	set @ret = 1
	set @Result = @ret;
	select @Result as Result
	RETURN @ret;
END

declare @accessGroupNumber int

select @accessGroupNumber = AccessGroupNumber from GCS.AccessGroup WHERE AccessGroupUid = @AccessGroupUid and ClusterUid = @ClusterUid
if @accessGroupNumber is null 
BEGIN
	set @ret = 2
	set @Result = @ret;
	select @Result as Result
	RETURN @ret;
END
ELSE
BEGIN
	IF @OrderNumber IN (1,2) AND @accessGroupNumber > 255
	BEGIN
		set @ret = 3
		set @Result = @ret;
		select @Result as Result
		RETURN @ret;
	END
	IF @OrderNumber = 3 AND @accessGroupNumber > 2000
	BEGIN
		set @ret = 4
		set @Result = @ret;
		select @Result as Result
		RETURN @ret;
	END
	
END
 -- Everything is ok
set @ret = 0
set @Result = @ret;
select @Result as Result
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[IsAccessGroupClusterPermissionValid] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsInputOutputGroupClusterPermissionValid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsInputOutputGroupClusterPermissionValid]
GO

CREATE OR ALTER PROCEDURE GCS.[IsInputOutputGroupClusterPermissionValid]
@ClusterUid uniqueidentifier,
@InputOutputGroupUid uniqueidentifier,
@OrderNumber smallint,
@Result int OUTPUT
AS

-- Result values:
-- 0 = it is ok
-- 1 = Invalid @OrderNumber
-- 2 = InputOutput is not found in Cluster

set nocount on
declare @ret int;
select @ret = 0;
select @Result = 0;

if @OrderNumber < 1 OR @OrderNumber > 4
BEGIN
	set @ret = 1
	set @Result = @ret;
	select @Result as Result
	RETURN @ret;
END

declare @ioGroupNumber int

select @ioGroupNumber = IOGroupNumber from GCS.InputOutputGroup WHERE InputOutputGroupUid = @InputOutputGroupUid and ClusterUid = @ClusterUid
if @ioGroupNumber is null 
BEGIN
	set @ret = 2
	set @Result = @ret;
	select @Result as Result
	RETURN @ret;
END
 -- Everything is ok
set @ret = 0
set @Result = @ret;
select @Result as Result
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[IsInputOutputGroupClusterPermissionValid] TO public
GO


/* All Stored Procedures for table: GalaxyInterfaceBoardSectionNode */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.GalaxyInterfaceBoardSectionNode table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
t.GalaxyInterfaceBoardSectionNodeUid
,t.GalaxyHardwareModuleUid
,t.NodeNumber
,t.IsNodeActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,b.BoardNumber
,s.SectionNumber
,m.ModuleNumber
,apgha.AccessPortalUid
,apgha.PortalName
,idgha.InputDeviceUid
,idgha.InputName
,odgha.OutputDeviceUid
,odgha.OutputName
FROM GCS.GalaxyInterfaceBoardSectionNode t
JOIN GCS.GalaxyHardwareModule m ON m.GalaxyHardwareModuleUid = t.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection s ON s.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid 
JOIN GCS.GalaxyInterfaceBoard b ON b.GalaxyInterfaceBoardUid = s.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = b.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddressView apgha on apgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddressView idgha on idgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddressView odgha on odgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyInterfaceBoardSectionNode table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByClusterUid]
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
t.GalaxyInterfaceBoardSectionNodeUid
,t.GalaxyHardwareModuleUid
,t.NodeNumber
,t.IsNodeActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,b.BoardNumber
,s.SectionNumber
,m.ModuleNumber
,apgha.AccessPortalUid
,apgha.PortalName
,idgha.InputDeviceUid
,idgha.InputName
,odgha.OutputDeviceUid
,odgha.OutputName
FROM GCS.GalaxyInterfaceBoardSectionNode t
JOIN GCS.GalaxyHardwareModule m ON m.GalaxyHardwareModuleUid = t.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection s ON s.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid 
JOIN GCS.GalaxyInterfaceBoard b ON b.GalaxyInterfaceBoardUid = s.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = b.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddressView apgha on apgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddressView idgha on idgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddressView odgha on odgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
WHERE p.ClusterUid = @ClusterUid 
ORDER BY p.PanelNumber, b.BoardNumber, s.SectionNumber, m.ModuleNumber, t.NodeNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyInterfaceBoardSectionNode table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_GalaxyHardwareModuleUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_GalaxyHardwareModuleUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_GalaxyHardwareModuleUid]
@GalaxyHardwareModuleUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;


SELECT 
t.GalaxyInterfaceBoardSectionNodeUid
,t.GalaxyHardwareModuleUid
,t.NodeNumber
,t.IsNodeActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,b.BoardNumber
,s.SectionNumber
,m.ModuleNumber
,apgha.AccessPortalUid
,apgha.PortalName
,idgha.InputDeviceUid
,idgha.InputName
,odgha.OutputDeviceUid
,odgha.OutputName
FROM GCS.GalaxyInterfaceBoardSectionNode t
JOIN GCS.GalaxyHardwareModule m ON m.GalaxyHardwareModuleUid = t.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection s ON s.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid 
JOIN GCS.GalaxyInterfaceBoard b ON b.GalaxyInterfaceBoardUid = s.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = b.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddressView apgha on apgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddressView idgha on idgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddressView odgha on odgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
WHERE 
t.GalaxyHardwareModuleUid = @GalaxyHardwareModuleUid
ORDER BY NodeNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_GalaxyHardwareModuleUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyInterfaceBoardSectionNode table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyInterfaceBoardSectionUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyInterfaceBoardSectionUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyInterfaceBoardSectionUid]
@GalaxyInterfaceBoardSectionUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;


SELECT 
t.GalaxyInterfaceBoardSectionNodeUid
,t.GalaxyHardwareModuleUid
,t.NodeNumber
,t.IsNodeActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,b.BoardNumber
,s.SectionNumber
,m.ModuleNumber
,apgha.AccessPortalUid
,apgha.PortalName
,idgha.InputDeviceUid
,idgha.InputName
,odgha.OutputDeviceUid
,odgha.OutputName
FROM GCS.GalaxyInterfaceBoardSectionNode t
JOIN GCS.GalaxyHardwareModule m ON m.GalaxyHardwareModuleUid = t.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection s ON s.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid 
JOIN GCS.GalaxyInterfaceBoard b ON b.GalaxyInterfaceBoardUid = s.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = b.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddressView apgha on apgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddressView idgha on idgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddressView odgha on odgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
WHERE s.GalaxyInterfaceBoardSectionUid  = @GalaxyInterfaceBoardSectionUid  
ORDER BY m.ModuleNumber, NodeNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyInterfaceBoardSectionUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyInterfaceBoardSectionNode table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyInterfaceBoardUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyInterfaceBoardUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyInterfaceBoardUid]
@GalaxyInterfaceBoardUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;


SELECT 
t.GalaxyInterfaceBoardSectionNodeUid
,t.GalaxyHardwareModuleUid
,t.NodeNumber
,t.IsNodeActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,b.BoardNumber
,s.SectionNumber
,m.ModuleNumber
,apgha.AccessPortalUid
,apgha.PortalName
,idgha.InputDeviceUid
,idgha.InputName
,odgha.OutputDeviceUid
,odgha.OutputName
FROM GCS.GalaxyInterfaceBoardSectionNode t
JOIN GCS.GalaxyHardwareModule m ON m.GalaxyHardwareModuleUid = t.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection s ON s.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid 
JOIN GCS.GalaxyInterfaceBoard b ON b.GalaxyInterfaceBoardUid = s.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = b.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddressView apgha on apgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddressView idgha on idgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddressView odgha on odgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
WHERE b.GalaxyInterfaceBoardUid = @GalaxyInterfaceBoardUid 
ORDER BY s.SectionNumber, m.ModuleNumber, t.NodeNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyInterfaceBoardUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyInterfaceBoardSectionNode table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyPanelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyPanelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyPanelUid]
@GalaxyPanelUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;


SELECT 
t.GalaxyInterfaceBoardSectionNodeUid
,t.GalaxyHardwareModuleUid
,t.NodeNumber
,t.IsNodeActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,b.BoardNumber
,s.SectionNumber
,m.ModuleNumber
,apgha.AccessPortalUid
,apgha.PortalName
,idgha.InputDeviceUid
,idgha.InputName
,odgha.OutputDeviceUid
,odgha.OutputName
FROM GCS.GalaxyInterfaceBoardSectionNode t
JOIN GCS.GalaxyHardwareModule m ON m.GalaxyHardwareModuleUid = t.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection s ON s.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid 
JOIN GCS.GalaxyInterfaceBoard b ON b.GalaxyInterfaceBoardUid = s.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = b.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddressView apgha on apgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddressView idgha on idgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddressView odgha on odgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
WHERE b.GalaxyPanelUid = @GalaxyPanelUid 
ORDER BY b.BoardNumber, s.SectionNumber, m.ModuleNumber, t.NodeNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByGalaxyPanelUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyInterfaceBoardSectionNode table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByPanelAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByPanelAddress]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByPanelAddress]
@ClusterGroupId int,
@ClusterNumber int,
@PanelNumber int 
AS

declare @ret int;
select @ret = 0;


SELECT 
t.GalaxyInterfaceBoardSectionNodeUid
,t.GalaxyHardwareModuleUid
,t.NodeNumber
,t.IsNodeActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,b.BoardNumber
,s.SectionNumber
,m.ModuleNumber
,apgha.AccessPortalUid
,apgha.PortalName
,idgha.InputDeviceUid
,idgha.InputName
,odgha.OutputDeviceUid
,odgha.OutputName
FROM GCS.GalaxyInterfaceBoardSectionNode t
JOIN GCS.GalaxyHardwareModule m ON m.GalaxyHardwareModuleUid = t.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection s ON s.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid 
JOIN GCS.GalaxyInterfaceBoard b ON b.GalaxyInterfaceBoardUid = s.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = b.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddressView apgha on apgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddressView idgha on idgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddressView odgha on odgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
WHERE
c.ClusterGroupId = @ClusterGroupId AND
c.ClusterNumber = @ClusterNumber AND
p.PanelNumber = @PanelNumber
ORDER BY b.BoardNumber, s.SectionNumber, m.ModuleNumber, t.NodeNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_ByPanelAddress] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.GalaxyInterfaceBoardSectionNode table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyInterfaceBoardSectionNodeUid
,InsertName
FROM GCS.GalaxyInterfaceBoardSectionNode

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyInterfaceBoardSectionNode table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectByPK]
@GalaxyInterfaceBoardSectionNodeUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;


SELECT 
t.GalaxyInterfaceBoardSectionNodeUid
,t.GalaxyHardwareModuleUid
,t.NodeNumber
,t.IsNodeActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,b.BoardNumber
,s.SectionNumber
,m.ModuleNumber
,apgha.AccessPortalUid
,apgha.PortalName
,idgha.InputDeviceUid
,idgha.InputName
,odgha.OutputDeviceUid
,odgha.OutputName
FROM GCS.GalaxyInterfaceBoardSectionNode t
JOIN GCS.GalaxyHardwareModule m ON m.GalaxyHardwareModuleUid = t.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection s ON s.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid 
JOIN GCS.GalaxyInterfaceBoard b ON b.GalaxyInterfaceBoardUid = s.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = b.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddressView apgha on apgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddressView idgha on idgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddressView odgha on odgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
WHERE 
t.GalaxyInterfaceBoardSectionNodeUid = @GalaxyInterfaceBoardSectionNodeUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.GalaxyInterfaceBoardSectionNode table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;


SELECT 
t.GalaxyInterfaceBoardSectionNodeUid
,t.GalaxyHardwareModuleUid
,t.NodeNumber
,t.IsNodeActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,b.BoardNumber
,s.SectionNumber
,m.ModuleNumber
,apgha.AccessPortalUid
,apgha.PortalName
,idgha.InputDeviceUid
,idgha.InputName
,odgha.OutputDeviceUid
,odgha.OutputName
FROM GCS.GalaxyInterfaceBoardSectionNode t
JOIN GCS.GalaxyHardwareModule m ON m.GalaxyHardwareModuleUid = t.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection s ON s.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid 
JOIN GCS.GalaxyInterfaceBoard b ON b.GalaxyInterfaceBoardUid = s.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = b.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddressView apgha on apgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.InputDeviceGalaxyHardwareAddressView idgha on idgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.OutputDeviceGalaxyHardwareAddressView odgha on odgha.GalaxyInterfaceBoardSectionNodeUid = t.GalaxyInterfaceBoardSectionNodeUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.GalaxyInterfaceBoardSectionNode table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_Insert]
@GalaxyInterfaceBoardSectionNodeUid uniqueidentifier 
,@GalaxyHardwareModuleUid uniqueidentifier 
,@NodeNumber smallint 
,@IsNodeActive bit 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @GalaxyInterfaceBoardSectionNodeUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyInterfaceBoardSectionNodeUid = NULL

if @GalaxyInterfaceBoardSectionNodeUid = '00000000-0000-0000-0000-000000000000' OR @GalaxyInterfaceBoardSectionNodeUid IS NULL
	SET @GalaxyInterfaceBoardSectionNodeUid = NewID()

INSERT INTO GCS.GalaxyInterfaceBoardSectionNode
(
GalaxyInterfaceBoardSectionNodeUid
,GalaxyHardwareModuleUid
,NodeNumber
,IsNodeActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@GalaxyInterfaceBoardSectionNodeUid
,@GalaxyHardwareModuleUid
,@NodeNumber
,@IsNodeActive
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.GalaxyInterfaceBoardSectionNode table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_Update]
@GalaxyInterfaceBoardSectionNodeUid uniqueidentifier 
,@GalaxyHardwareModuleUid uniqueidentifier
,@NodeNumber smallint
,@IsNodeActive bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;


UPDATE GCS.GalaxyInterfaceBoardSectionNode
SET 
GalaxyHardwareModuleUid = @GalaxyHardwareModuleUid
,NodeNumber = @NodeNumber
,IsNodeActive = @IsNodeActive
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
GalaxyInterfaceBoardSectionNodeUid = @GalaxyInterfaceBoardSectionNodeUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.GalaxyInterfaceBoardSectionNode table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_UpdateConcurrency]
@GalaxyInterfaceBoardSectionNodeUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.GalaxyInterfaceBoardSectionNode
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
GalaxyInterfaceBoardSectionNodeUid = @GalaxyInterfaceBoardSectionNodeUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.GalaxyInterfaceBoardSectionNode table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_DeleteByPK]
@GalaxyInterfaceBoardSectionNodeUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.GalaxyInterfaceBoardSectionNode
WHERE
GalaxyInterfaceBoardSectionNodeUid = @GalaxyInterfaceBoardSectionNodeUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.GalaxyInterfaceBoardSectionNode table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardSectionNodePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyInterfaceBoardSectionNodePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.GalaxyInterfaceBoardSectionNode

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyInterfaceBoardSectionNodePDSA_RowCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyInterfaceBoardPDSA_ByGalaxyPanelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyInterfaceBoardPDSA_ByGalaxyPanelUid]
GO

CREATE OR ALTER PROCEDURE [GCS].[GalaxyInterfaceBoardPDSA_ByGalaxyPanelUid]
	@GalaxyPanelUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
GalaxyInterfaceBoardUid
,t.GalaxyPanelUid
,InterfaceBoardTypeUid
,BoardNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
FROM GCS.GalaxyInterfaceBoard t
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = t.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
WHERE 
t.GalaxyPanelUid = @GalaxyPanelUid
order by BoardNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyInterfaceBoardPDSA_ByGalaxyPanelUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyInterfaceBoardPDSA_ByGalaxyPanelUid] TO [public] AS [dbo]
GO

/* All Stored Procedures for table: PersonClusterPermission */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.PersonClusterPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT
PersonClusterPermissionUid
,PersonUid
,pcp.ClusterUid
,PersonCredentialUid
,pcp.InsertName
,pcp.InsertDate
,pcp.UpdateName
,pcp.UpdateDate
,pcp.ConcurrencyValue
,CredentialClusterTourUid
,CredentialBits
,PersonUidClusterUidCredentialUidCombined
,ClusterName
FROM GCS.PersonClusterPermission pcp
JOIN GCS.Cluster c on c.ClusterUid = pcp.ClusterUid


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonClusterPermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_ByClusterUid]
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT
PersonClusterPermissionUid
,PersonUid
,pcp.ClusterUid
,PersonCredentialUid
,pcp.InsertName
,pcp.InsertDate
,pcp.UpdateName
,pcp.UpdateDate
,pcp.ConcurrencyValue
,CredentialClusterTourUid
,CredentialBits
,PersonUidClusterUidCredentialUidCombined
,ClusterName
FROM GCS.PersonClusterPermission pcp
JOIN GCS.Cluster c on c.ClusterUid = pcp.ClusterUid
WHERE 
pcp.ClusterUid = @ClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonClusterPermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_ByPersonCredentialUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_ByPersonCredentialUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_ByPersonCredentialUid]
@PersonCredentialUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT
PersonClusterPermissionUid
,PersonUid
,pcp.ClusterUid
,PersonCredentialUid
,pcp.InsertName
,pcp.InsertDate
,pcp.UpdateName
,pcp.UpdateDate
,pcp.ConcurrencyValue
,CredentialClusterTourUid
,CredentialBits
,PersonUidClusterUidCredentialUidCombined
,ClusterName
FROM GCS.PersonClusterPermission pcp
JOIN GCS.Cluster c on c.ClusterUid = pcp.ClusterUid
WHERE 
PersonCredentialUid = @PersonCredentialUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_ByPersonCredentialUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonClusterPermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_ByPersonCredentialUidAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_ByPersonCredentialUidAndClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_ByPersonCredentialUidAndClusterUid]
@PersonCredentialUid uniqueidentifier,
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT
PersonClusterPermissionUid
,PersonUid
,pcp.ClusterUid
,PersonCredentialUid
,pcp.InsertName
,pcp.InsertDate
,pcp.UpdateName
,pcp.UpdateDate
,pcp.ConcurrencyValue
,CredentialClusterTourUid
,CredentialBits
,PersonUidClusterUidCredentialUidCombined
,ClusterName
FROM GCS.PersonClusterPermission pcp
JOIN GCS.Cluster c on c.ClusterUid = pcp.ClusterUid
WHERE 
PersonCredentialUid = @PersonCredentialUid AND pcp.ClusterUid = @ClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_ByPersonCredentialUidAndClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonClusterPermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_ByPersonUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_ByPersonUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_ByPersonUid]
@PersonUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT
PersonClusterPermissionUid
,PersonUid
,pcp.ClusterUid
,PersonCredentialUid
,pcp.InsertName
,pcp.InsertDate
,pcp.UpdateName
,pcp.UpdateDate
,pcp.ConcurrencyValue
,CredentialClusterTourUid
,CredentialBits
,PersonUidClusterUidCredentialUidCombined
,ClusterName
FROM GCS.PersonClusterPermission pcp
JOIN GCS.Cluster c on c.ClusterUid = pcp.ClusterUid
WHERE 
PersonUid = @PersonUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_ByPersonUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonClusterPermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_ByPersonUidAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_ByPersonUidAndClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_ByPersonUidAndClusterUid]
@PersonUid uniqueidentifier,
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT
PersonClusterPermissionUid
,PersonUid
,pcp.ClusterUid
,PersonCredentialUid
,pcp.InsertName
,pcp.InsertDate
,pcp.UpdateName
,pcp.UpdateDate
,pcp.ConcurrencyValue
,CredentialClusterTourUid
,CredentialBits
,PersonUidClusterUidCredentialUidCombined
,ClusterName
FROM GCS.PersonClusterPermission pcp
JOIN GCS.Cluster c on c.ClusterUid = pcp.ClusterUid
WHERE 
PersonUid = @PersonUid AND pcp.ClusterUid = @ClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_ByPersonUidAndClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.PersonClusterPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonClusterPermissionUid
,InsertName
FROM GCS.PersonClusterPermission

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonClusterPermission table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_SelectByPK]
@PersonClusterPermissionUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT
PersonClusterPermissionUid
,PersonUid
,pcp.ClusterUid
,PersonCredentialUid
,pcp.InsertName
,pcp.InsertDate
,pcp.UpdateName
,pcp.UpdateDate
,pcp.ConcurrencyValue
,CredentialClusterTourUid
,CredentialBits
,PersonUidClusterUidCredentialUidCombined
,ClusterName
FROM GCS.PersonClusterPermission pcp
JOIN GCS.Cluster c on c.ClusterUid = pcp.ClusterUid
WHERE 
PersonClusterPermissionUid = @PersonClusterPermissionUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.PersonClusterPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT
PersonClusterPermissionUid
,PersonUid
,pcp.ClusterUid
,PersonCredentialUid
,pcp.InsertName
,pcp.InsertDate
,pcp.UpdateName
,pcp.UpdateDate
,pcp.ConcurrencyValue
,CredentialClusterTourUid
,CredentialBits
,PersonUidClusterUidCredentialUidCombined
,ClusterName
FROM GCS.PersonClusterPermission pcp
JOIN GCS.Cluster c on c.ClusterUid = pcp.ClusterUid
WHERE 
(@InsertName IS NULL OR pcp.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.PersonClusterPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_Insert]
@PersonClusterPermissionUid uniqueidentifier 
,@PersonUid uniqueidentifier 
,@ClusterUid uniqueidentifier 
,@PersonCredentialUid uniqueidentifier  = null
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
,@CredentialClusterTourUid uniqueidentifier  = null
AS

declare @ret int;
select @ret = 0;


if @PersonClusterPermissionUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonClusterPermissionUid = NULL
if @PersonCredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonCredentialUid = NULL
if @CredentialClusterTourUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialClusterTourUid = NULL

if @PersonClusterPermissionUid = '00000000-0000-0000-0000-000000000000' OR @PersonClusterPermissionUid IS NULL
	SET @PersonClusterPermissionUid = NewID()

INSERT INTO GCS.PersonClusterPermission
(
PersonClusterPermissionUid
,PersonUid
,ClusterUid
,PersonCredentialUid
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,CredentialClusterTourUid
) 
VALUES 
(
@PersonClusterPermissionUid
,@PersonUid
,@ClusterUid
,@PersonCredentialUid
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
,@CredentialClusterTourUid
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.PersonClusterPermission table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_Update]
@PersonClusterPermissionUid uniqueidentifier 
,@PersonUid uniqueidentifier
,@ClusterUid uniqueidentifier
,@PersonCredentialUid uniqueidentifier
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@CredentialClusterTourUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @PersonCredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonCredentialUid = NULL
if @CredentialClusterTourUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialClusterTourUid = NULL

UPDATE GCS.PersonClusterPermission
SET 
PersonUid = @PersonUid
,ClusterUid = @ClusterUid
,PersonCredentialUid = @PersonCredentialUid
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,CredentialClusterTourUid = @CredentialClusterTourUid
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
PersonClusterPermissionUid = @PersonClusterPermissionUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.PersonClusterPermission table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_UpdateConcurrency]
@PersonClusterPermissionUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.PersonClusterPermission
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
PersonClusterPermissionUid = @PersonClusterPermissionUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.PersonClusterPermission table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_DeleteByPK]
@PersonClusterPermissionUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.PersonClusterPermission
WHERE
PersonClusterPermissionUid = @PersonClusterPermissionUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.PersonClusterPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonClusterPermissionPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonClusterPermissionPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonClusterPermissionPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.PersonClusterPermission

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonClusterPermissionPDSA_RowCount] TO public
GO

/* All Stored Procedures for table: PersonalAccessGroupAccessPortal */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.PersonalAccessGroupAccessPortal table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupAccessPortalPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupAccessPortalUid
,t.AccessPortalUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.PortalName
FROM GCS.PersonalAccessGroupAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupAccessPortalPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupAccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupAccessPortalPDSA_ByAccessPortalUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByAccessPortalUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByAccessPortalUid]
@AccessPortalUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupAccessPortalUid
,t.AccessPortalUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.PortalName
FROM GCS.PersonalAccessGroupAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
t.AccessPortalUid = @AccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupAccessPortalPDSA_ByAccessPortalUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupAccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupAccessPortalPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByClusterUid]
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupAccessPortalUid
,t.AccessPortalUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.PortalName
FROM GCS.PersonalAccessGroupAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
PersonClusterPermissionUid IN (SELECT PersonClusterPermissionUid FROM GCS.PersonClusterPermission WHERE ClusterUid = @ClusterUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupAccessPortalPDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupAccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonCredentialUidAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonCredentialUidAndClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonCredentialUidAndClusterUid]
@PersonCredentialUid uniqueidentifier,
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupAccessPortalUid
,t.AccessPortalUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.PortalName
FROM GCS.PersonalAccessGroupAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
PersonClusterPermissionUid IN (SELECT PersonClusterPermissionUid FROM GCS.PersonClusterPermission WHERE PersonCredentialUid = @PersonCredentialUid AND ClusterUid = @ClusterUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonCredentialUidAndClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupAccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonClusterPermissionUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonClusterPermissionUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonClusterPermissionUid]
@PersonClusterPermissionUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupAccessPortalUid
,t.AccessPortalUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.PortalName
FROM GCS.PersonalAccessGroupAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
PersonClusterPermissionUid = @PersonClusterPermissionUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonClusterPermissionUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupAccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonCredentialUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonCredentialUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonCredentialUid]
@PersonCredentialUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupAccessPortalUid
,t.AccessPortalUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.PortalName
FROM GCS.PersonalAccessGroupAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
PersonClusterPermissionUid IN (SELECT PersonClusterPermissionUid FROM GCS.PersonClusterPermission WHERE PersonCredentialUid = @PersonCredentialUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonCredentialUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupAccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonUid]
@PersonUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupAccessPortalUid
,t.AccessPortalUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.PortalName
FROM GCS.PersonalAccessGroupAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
PersonClusterPermissionUid IN (SELECT PersonClusterPermissionUid FROM GCS.PersonClusterPermission WHERE PersonUid = @PersonUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupAccessPortal table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonUidAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonUidAndClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonUidAndClusterUid]
@PersonUid uniqueidentifier,
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupAccessPortalUid
,t.AccessPortalUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.PortalName
FROM GCS.PersonalAccessGroupAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
PersonClusterPermissionUid IN (SELECT PersonClusterPermissionUid FROM GCS.PersonClusterPermission WHERE PersonUid = @PersonUid AND ClusterUid = @ClusterUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupAccessPortalPDSA_ByPersonUidAndClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupAccessPortal table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupAccessPortalPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_SelectByPK]
@PersonalAccessGroupAccessPortalUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupAccessPortalUid
,t.AccessPortalUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.PortalName
FROM GCS.PersonalAccessGroupAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
PersonalAccessGroupAccessPortalUid = @PersonalAccessGroupAccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupAccessPortalPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.PersonalAccessGroupAccessPortal table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupAccessPortalPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupAccessPortalPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupAccessPortalUid
,t.AccessPortalUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.PortalName
FROM GCS.PersonalAccessGroupAccessPortal t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupAccessPortalPDSA_SelectSearch] TO public
GO

/* All Stored Procedures for table: PersonalAccessGroupDynamicAccessGroup */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.PersonalAccessGroupDynamicAccessGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupDynamicAccessGroupUid
,t.AccessGroupUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
FROM GCS.PersonalAccessGroupDynamicAccessGroup t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupDynamicAccessGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByAccessGroupUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByAccessGroupUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByAccessGroupUid]
@AccessGroupUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupDynamicAccessGroupUid
,t.AccessGroupUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
FROM GCS.PersonalAccessGroupDynamicAccessGroup t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
WHERE 
t.AccessGroupUid = @AccessGroupUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByAccessGroupUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupDynamicAccessGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByClusterUid]
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupDynamicAccessGroupUid
,t.AccessGroupUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
FROM GCS.PersonalAccessGroupDynamicAccessGroup t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
WHERE 
PersonClusterPermissionUid IN (SELECT PersonClusterPermissionUid FROM GCS.PersonClusterPermission WHERE ClusterUid = @ClusterUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupDynamicAccessGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonClusterPermissionUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonClusterPermissionUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonClusterPermissionUid]
@PersonClusterPermissionUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupDynamicAccessGroupUid
,t.AccessGroupUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
FROM GCS.PersonalAccessGroupDynamicAccessGroup t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
WHERE 
PersonClusterPermissionUid = @PersonClusterPermissionUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonClusterPermissionUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupDynamicAccessGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonCredentialUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonCredentialUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonCredentialUid]
@PersonCredentialUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupDynamicAccessGroupUid
,t.AccessGroupUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
FROM GCS.PersonalAccessGroupDynamicAccessGroup t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
WHERE 
PersonClusterPermissionUid IN (SELECT PersonClusterPermissionUid FROM GCS.PersonClusterPermission WHERE PersonCredentialUid = @PersonCredentialUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonCredentialUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupDynamicAccessGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonCredentiaUidAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonCredentiaUidAndClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonCredentiaUidAndClusterUid]
@PersonCredentiaUid uniqueidentifier,
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupDynamicAccessGroupUid
,t.AccessGroupUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
FROM GCS.PersonalAccessGroupDynamicAccessGroup t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
WHERE 
PersonClusterPermissionUid IN (SELECT PersonClusterPermissionUid FROM GCS.PersonClusterPermission WHERE PersonCredentialUid = @PersonCredentiaUid AND ClusterUid = @ClusterUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonCredentiaUidAndClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupDynamicAccessGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonUid]
@PersonUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupDynamicAccessGroupUid
,t.AccessGroupUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
FROM GCS.PersonalAccessGroupDynamicAccessGroup t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
WHERE 
PersonClusterPermissionUid IN (SELECT PersonClusterPermissionUid FROM GCS.PersonClusterPermission WHERE PersonUid = @PersonUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupDynamicAccessGroup table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonUidAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonUidAndClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonUidAndClusterUid]
@PersonUid uniqueidentifier,
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupDynamicAccessGroupUid
,t.AccessGroupUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
FROM GCS.PersonalAccessGroupDynamicAccessGroup t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
WHERE 
PersonClusterPermissionUid IN (SELECT PersonClusterPermissionUid FROM GCS.PersonClusterPermission WHERE PersonUid = @PersonUid AND ClusterUid = @ClusterUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_ByPersonUidAndClusterUid] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.PersonalAccessGroupDynamicAccessGroup table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectByPK]
@PersonalAccessGroupDynamicAccessGroupUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupDynamicAccessGroupUid
,t.AccessGroupUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
FROM GCS.PersonalAccessGroupDynamicAccessGroup t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
WHERE 
PersonalAccessGroupDynamicAccessGroupUid = @PersonalAccessGroupDynamicAccessGroupUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.PersonalAccessGroupDynamicAccessGroup table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
PersonalAccessGroupDynamicAccessGroupUid
,t.AccessGroupUid
,PersonClusterPermissionUid
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
FROM GCS.PersonalAccessGroupDynamicAccessGroup t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[PersonalAccessGroupDynamicAccessGroupPDSA_SelectSearch] TO public
GO

/* All Stored Procedures for table: gcsUserEntity */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsUserEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntity_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntity_SelectAll]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityId
,UserId
,t.EntityId
,t.IsAdministrator
,t.InheritParentRoles
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,EntityName
FROM GCS.gcsUserEntity t
JOIN GCS.gcsEntity e on e.EntityId = t.EntityId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUserEntity table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntity_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntity_ByEntityId]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_ByEntityId]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityId
,UserId
,t.EntityId
,t.IsAdministrator
,t.InheritParentRoles
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,EntityName
FROM GCS.gcsUserEntity t
JOIN GCS.gcsEntity e on e.EntityId = t.EntityId
WHERE 
t.EntityId = @EntityId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.gcsUserEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntity_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntity_SelectListBox]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityId
,InsertName
FROM GCS.gcsUserEntity

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUserEntity table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntity_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntity_SelectByPK]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_SelectByPK]
@UserEntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityId
,UserId
,t.EntityId
,t.IsAdministrator
,t.InheritParentRoles
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,EntityName
FROM GCS.gcsUserEntity t
JOIN GCS.gcsEntity e on e.EntityId = t.EntityId
WHERE 
UserEntityId = @UserEntityId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsUserEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntity_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntity_SelectSearch]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityId
,UserId
,t.EntityId
,t.IsAdministrator
,t.InheritParentRoles
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,EntityName
FROM GCS.gcsUserEntity t
JOIN GCS.gcsEntity e on e.EntityId = t.EntityId
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUserEntity table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntity_ByUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntity_ByUserId]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_ByUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_ByUserId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_ByUserId]
@UserId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityId
,UserId
,t.EntityId
,t.IsAdministrator
,t.InheritParentRoles
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,EntityName
FROM GCS.gcsUserEntity t
JOIN GCS.gcsEntity e on e.EntityId = t.EntityId
WHERE 
UserId = @UserId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_ByUserId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUserEntity table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_ByUserIdAndEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_ByUserIdAndEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_ByUserIdAndEntityId]
@UserId uniqueidentifier,
@EntityId uniqueidentifier
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityId
,UserId
,t.EntityId
,t.IsAdministrator
,t.InheritParentRoles
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,EntityName
FROM GCS.gcsUserEntity t
JOIN GCS.gcsEntity e on e.EntityId = t.EntityId
WHERE 
UserId = @UserId AND t.EntityId = @EntityId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_ByUserIdAndEntityId] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.gcsUserEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntity_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntity_Insert]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_Insert]
@UserEntityId uniqueidentifier 
,@UserId uniqueidentifier 
,@EntityId uniqueidentifier 
,@IsAdministrator bit
,@InheritParentRoles bit
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @UserEntityId = '00000000-0000-0000-0000-000000000000'
	SET @UserEntityId = NULL

if @UserEntityId = '00000000-0000-0000-0000-000000000000' OR @UserEntityId IS NULL
	SET @UserEntityId = NewID()

INSERT INTO GCS.gcsUserEntity
(
UserEntityId
,UserId
,EntityId
,IsAdministrator
,InheritParentRoles
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@UserEntityId
,@UserId
,@EntityId
,@IsAdministrator
,@InheritParentRoles
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsUserEntity table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntity_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntity_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_Update]
@UserEntityId uniqueidentifier 
,@UserId uniqueidentifier
,@EntityId uniqueidentifier
,@IsAdministrator bit
,@InheritParentRoles bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsUserEntity
SET 
UserEntityId = @UserEntityId
,UserId = @UserId
,EntityId = @EntityId
,IsAdministrator = @IsAdministrator
,InheritParentRoles = @InheritParentRoles
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
UserEntityId = @UserEntityId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsUserEntity table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntity_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntity_UpdateConcurrency]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_UpdateConcurrency]
@UserEntityId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsUserEntity
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
UserEntityId = @UserEntityId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsUserEntity table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntity_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntity_DeleteByPK]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_DeleteByPK]
@UserEntityId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsUserEntity
WHERE
UserEntityId = @UserEntityId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsUserEntity table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntity_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntity_RowCount]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsUserEntity

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityPDSA_RowCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_DoesUserHaveEntityApplication]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_DoesUserHaveEntityApplication]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_DoesUserHaveEntity]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_DoesUserHaveEntity]
GO

/****** Object:  StoredProcedure [GCS].[[gcs_DoesUserHaveEntity]]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcs_DoesUserHaveEntity]
	@UserId [uniqueidentifier],
	@EntityId [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
	select @Result = count(*) from gcs.gcsUserEntity ue
	join GCS.gcsEntity e on e.EntityId = ue.EntityId 
	where ue.UserId = @UserId and ue.EntityId = @EntityId and e.IsActive = 1

	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[gcs_DoesUserHaveEntity] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_DoesUserHaveEntity] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_DoesUserHaveEntityPermission]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_DoesUserHaveEntityPermission]
GO


CREATE OR ALTER PROCEDURE [GCS].[SelectParentAndChildEntitiesIdName]
	@rootEntityId [uniqueidentifier]
AS
WITH Recursive_CTE AS (
 SELECT
e.EntityId as EntityId
,e.EntityName as EntityName
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
WHERE e.EntityId = @rootEntityId

 UNION ALL

 SELECT
	e.EntityId as EntityId
	,e.EntityName as EntityName
	,e.ParentEntityId as ParentEntityId
	,parent.EntityName as ParentEntityName
 FROM Recursive_CTE parent
 INNER JOIN GCS.gcsEntity e ON e.ParentEntityId = parent.EntityId
)
SELECT * FROM Recursive_CTE

GO
--ALTER AUTHORIZATION ON [GCS].[SelectParentAndChildEntitiesIdName] TO  SCHEMA OWNER 
--GO
--GRANT EXECUTE ON [GCS].[SelectParentAndChildEntitiesIdName] TO [public] AS [dbo]
--GO



CREATE OR ALTER FUNCTION [GCS].[fn_SelectParentAndChildEntitiesIdName] (
@rootEntityId [uniqueidentifier]) --WITH EXECUTE AS CALLER
RETURNS TABLE 
AS
RETURN 
(
	WITH Recursive_CTE AS (
	 SELECT
	e.EntityId as EntityId
	,e.EntityName as EntityName
	,e.ParentEntityId as ParentEntityId
	,p.EntityName as ParentEntityName
	FROM GCS.gcsEntity e
	LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
	WHERE e.EntityId = @rootEntityId

	 UNION ALL

	 SELECT
		e.EntityId as EntityId
		,e.EntityName as EntityName
		,e.ParentEntityId as ParentEntityId
		,parent.EntityName as ParentEntityName
	 FROM Recursive_CTE parent
	 INNER JOIN GCS.gcsEntity e ON e.ParentEntityId = parent.EntityId
	)
	SELECT * FROM Recursive_CTE
	)
GO

--ALTER AUTHORIZATION ON [GCS].[fn_SelectParentAndChildEntitiesIdName] TO  SCHEMA OWNER 
--GO
--GRANT EXECUTE ON [GCS].[fn_SelectParentAndChildEntitiesIdName] TO [public] AS [dbo]
--GO



CREATE OR ALTER PROCEDURE [GCS].[SelectEntityAndParents]
	@entityId [uniqueidentifier]
AS
WITH Recursive_CTE AS (
 SELECT
e.EntityId as EntityId
,e.EntityName as EntityName
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
WHERE e.EntityId = @entityId

 UNION ALL

 SELECT
	e.EntityId as EntityId
	,e.EntityName as EntityName
	,e.ParentEntityId as ParentEntityId
	,(SELECT EntityName FROM GCS.gcsEntity WHERE EntityId = e.ParentEntityId) as ParentEntityName
 FROM Recursive_CTE parent
 INNER JOIN GCS.gcsEntity e ON e.EntityId = parent.ParentEntityId
)
SELECT * FROM Recursive_CTE
GO

ALTER AUTHORIZATION ON [GCS].[SelectEntityAndParents] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[SelectEntityAndParents] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[SelectUserEntityAndParents]
	@entityId [uniqueidentifier],
	@userId  [uniqueidentifier]
AS
WITH Recursive_CTE AS (
 SELECT
e.EntityId as EntityId
,e.EntityName as EntityName
,e.ParentEntityId as ParentEntityId
,p.EntityName as ParentEntityName
,ue.IsAdministrator
,ue.InheritParentRoles
FROM GCS.gcsEntity e
LEFT OUTER JOIN GCS.gcsEntity p ON p.EntityId = e.ParentEntityId
JOIN GCS.gcsUserEntity ue on ue.UserId = @userId AND ue.EntityId = e.EntityId
WHERE e.EntityId = @entityId

 UNION ALL

 SELECT
	e.EntityId as EntityId
	,e.EntityName as EntityName
	,e.ParentEntityId as ParentEntityId
	,(SELECT EntityName FROM GCS.gcsEntity WHERE EntityId = e.ParentEntityId) as ParentEntityName
	,ue.IsAdministrator
	,ue.InheritParentRoles
 FROM Recursive_CTE parent
 INNER JOIN GCS.gcsEntity e ON e.EntityId = parent.ParentEntityId
 JOIN GCS.gcsUserEntity ue on ue.UserId = @userId AND ue.EntityId = e.EntityId
)
SELECT * FROM Recursive_CTE
GO

ALTER AUTHORIZATION ON [GCS].[SelectUserEntityAndParents] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[SelectUserEntityAndParents] TO [public] AS [dbo]
GO








CREATE OR ALTER FUNCTION [GCS].[fn_GCSDoesUserHaveAdmin] (	
	@UserId [uniqueidentifier],
	@EntityId [uniqueidentifier])
	returns int
AS
BEGIN
declare @Result int

	-- See if the user has role for the entity that is an administrator role
		select @Result = count(*) from gcs.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity e on ue.EntityId = e.EntityId
		join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join gcs.gcsRole r on r.RoleId = uer.RoleId
			where u.UserId = @UserId AND e.EntityId = @EntityId
			AND r.IsActive = 1 and r.IsAdministratorRole = 1
	
	if @Result <> 0
	begin
		--print 'User has role that IsAdministratorRole=1'
		return 2--@Result
	end	

	-- If the @Result is 0, then see if the user has IsAdministrator=1 or if the user has the permission via inherited permissions from a higher level entity
	if @Result = 0
	BEGIN
		-- Check to see if the user has entity access and their UserEntity.IsAdministrator = 1. If so, they don't need to have explicit permissions
		select @Result = count(*) from gcs.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity e on ue.EntityId = e.EntityId
			where u.UserId = @UserId AND e.EntityId = @EntityId AND e.IsActive = 1 AND ue.IsAdministrator = 1
	END
	
	if @Result <> 0
	begin
		--print 'User has permission because they have IsAdministrator to the entity'
		return 3--@Result
	end

	if @Result = 0
	BEGIN
		-- See if the user has the permission via inherited permissions from a higher level entity		
		declare @inheritParentRoles bit
		select @inheritParentRoles = InheritParentRoles from GCS.gcsUserEntity where UserId = @UserId AND EntityId = @EntityId
		if @inheritParentRoles IS NOT NULL AND @inheritParentRoles = 1
		BEGIN
			declare @parentEntityId uniqueidentifier
			select @parentEntityId = ParentEntityId from GCS.gcsEntity where EntityId = @EntityId
			IF @parentEntityId IS NOT NULL AND @parentEntityId <> @EntityId
			BEGIN
				--print 'Checking parent level entity'
				set @Result = [GCS].[fn_GCSDoesUserHaveAdmin] ( @UserId, @parentEntityId)
				
				if @Result <> 0
				BEGIN
					--print 'User has permission because they have inherited the permission from a higher tier entity'
					return 4--@Result
				END
			END
		END
	END

	-- If @Result is still == 0, it is possible that the user does not have a UserEntity row/record for the specified entity,
	-- however, if the user has IsAdministrator=true for the specified entities parent, then allow this operation
	if @Result = 0
	BEGIN
		declare @usersPrimaryEntityId uniqueidentifier
		declare @isAdmin bit
		select @usersPrimaryEntityId = PrimaryEntityId, @isAdmin = IsAdministrator from GCS.gcsUser u 
		JOIN GCS.gcsUserEntity ue on ue.UserId = u.UserId where u.UserId = @UserId and ue.EntityId = u.PrimaryEntityId
		if @usersPrimaryEntityId is null OR @isAdmin IS NULL
			return @Result
		
		-- if the user is not an admin to his own parent entity, then return 0 (not admin)
		IF @isAdmin = 0
			return @Result

		-- The user does have admin permissions to his primary entity, so now check to see if the requested entity is in the hierarchy of the users primary entity
		select @Result = count(*) from [GCS].[fn_SelectParentAndChildEntitiesIdName] (@usersPrimaryEntityId) where EntityId = @EntityId

		if @Result <> 0
		BEGIN
			--print 'User has IsAdmin to a parent entity
			return 5--@Result
		END
	END
	return @Result
END
GO
ALTER AUTHORIZATION ON [GCS].[fn_GCSDoesUserHaveAdmin] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[fn_GCSDoesUserHaveAdmin] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_DoesUserHaveAdminRole]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_DoesUserHaveAdminRole]
GO

/****** Object:  StoredProcedure [GCS].[gcs_DoesUserHaveAdminRole]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcs_DoesUserHaveAdminRole]
	@UserId [uniqueidentifier],
	@EntityId [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
--select @Result = count(*) from gcs.gcsUser u
--	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
--	join gcs.gcsEntity e on ue.EntityId = e.EntityId
--	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
--	join gcs.gcsRole r on r.RoleId = uer.RoleId
--	where u.UserId = @UserId AND e.EntityId = @EntityId AND r.IsAdministratorRole = 1
--	and r.IsActive = 1 and e.IsActive = 1
--select @Result = count(*) from gcs.gcsUser u
--	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
--	join gcs.gcsEntity e on ue.EntityId = e.EntityId
--	left outer join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
--	left outer join gcs.gcsRole r on r.RoleId = uer.RoleId
--	where u.UserId = @UserId AND e.EntityId = @EntityId 
--	AND ((r.IsAdministratorRole = 1 and r.IsActive = 1) or ue.IsAdministrator = 1) 
--	and e.IsActive = 1
	set @Result = [GCS].[fn_GCSDoesUserHaveAdmin](@UserId, @EntityId)
	select @Result as Result
GO

ALTER AUTHORIZATION ON [GCS].[gcs_DoesUserHaveAdminRole] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_DoesUserHaveAdminRole] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetPermissionsForUserEntity]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GetPermissionsForUserEntity]
GO

CREATE OR ALTER PROCEDURE GCS.[GetPermissionsForUserEntity] 
@userId uniqueidentifier,
@entityId uniqueidentifier,
@permissionCategoryId uniqueidentifier
AS
	if @permissionCategoryId is null OR @permissionCategoryId = '00000000-0000-0000-0000-000000000000'
	BEGIN
		select ue.UserId, ent.EntityId, ent.ParentEntityId, ent.EntityName, ent.EntityDescription,
		r.RoleId, r.RoleName, r.IsAdministratorRole, permCat.PermissionCategoryId, permCat.CategoryName, rp.PermissionId, perm.PermissionName, perm.Code as PermissionCode
		from GCS.gcsUserEntity ue
		join GCS.gcsEntity ent on ent.EntityId = ue.EntityId
		join GCS.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join GCS.gcsRole r on r.RoleId = uer.RoleId
		join GCS.gcsRolePermission rp on rp.RoleId = r.RoleId
		join GCS.gcsPermission perm on perm.PermissionId = rp.PermissionId
		join GCS.gcsPermissionCategory permCat on permCat.PermissionCategoryId = perm.PermissionCategoryId
		where ue.UserId = @userId and ue.EntityId = @entityId
		and ent.IsActive = 1 and r.IsActive = 1 and perm.IsActive = 1
		order by r.RoleId, permCat.CategoryName, perm.Code
	END
	ELSE
	BEGIN
		select ue.UserId, ent.EntityId, ent.ParentEntityId, ent.EntityName, ent.EntityDescription,
		r.RoleId, r.RoleName, r.IsAdministratorRole, permCat.PermissionCategoryId, permCat.CategoryName, rp.PermissionId, perm.PermissionName, perm.Code as PermissionCode
		from GCS.gcsUserEntity ue
		join GCS.gcsEntity ent on ent.EntityId = ue.EntityId
		join GCS.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join GCS.gcsRole r on r.RoleId = uer.RoleId
		join GCS.gcsRolePermission rp on rp.RoleId = r.RoleId
		join GCS.gcsPermission perm on perm.PermissionId = rp.PermissionId
		join GCS.gcsPermissionCategory permCat on permCat.PermissionCategoryId = perm.PermissionCategoryId
		where ue.UserId = @userId and ue.EntityId = @entityId and permCat.PermissionCategoryId = @permissionCategoryId
		and ent.IsActive = 1 and r.IsActive = 1 and perm.IsActive = 1
		order by r.RoleId, permCat.CategoryName, perm.Code

	END
GO

GRANT EXECUTE ON GCS.[GetPermissionsForUserEntity] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.SelectUserEffectivePermissions') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[SelectUserEffectivePermissions]
GO

CREATE OR ALTER PROCEDURE [GCS].[SelectUserEffectivePermissions]
	@entityId [uniqueidentifier],
	@userId  [uniqueidentifier]
AS

declare @UserEntityResults TABLE
(
 EntityId uniqueidentifier,
 EntityName nvarchar(65),
 ParentEntityId uniqueidentifier,
 ParentEntityName nvarchar(65),
 IsAdministrator bit,
 InheritParentRoles bit
)

	insert into @UserEntityResults(EntityId,EntityName,ParentEntityId, ParentEntityName,IsAdministrator, InheritParentRoles)
	exec GCS.[SelectUserEntityAndParents] @entityId, @userId

	declare cursorUserRoles cursor local for 
	select * from @UserEntityResults

	declare @entId uniqueidentifier
	declare @entName nvarchar(65)
	declare @parentEntId uniqueidentifier
	declare @parentEntName nvarchar(65)
	declare @isAdmin bit
	declare @inheritParentRoles bit

	OPEN cursorUserRoles
	FETCH NEXT FROM cursorUserRoles INTO @entId, @entName, @parentEntId, @parentEntName, @isAdmin, @inheritParentRoles
	WHILE @@FETCH_STATUS = 0
	BEGIN
		if @inheritParentRoles = 0
		BEGIN
			PRINT 'Using roles from entity: ' + @entName
			exec GCS.GetPermissionsForUserEntity @userId, @entId, null
			BREAK;
		END
		ELSE
		BEGIN
			PRINT 'Skipping entity ' + @entName + ', inherits from parent entity'
		END
		FETCH NEXT FROM cursorUserRoles INTO @entId, @entName, @parentEntId, @parentEntName, @isAdmin, @inheritParentRoles
	end
	CLOSE cursorUserRoles;
	DEALLOCATE cursorUserRoles;

GO

GRANT EXECUTE ON GCS.[SelectUserEffectivePermissions] TO public
GO









if dbo.fn_GCSDoesTableExist('BackgroundJob') = 0
begin
	/*==============================================================*/
	/* Table: BackgroundJob                                         */
	/*==============================================================*/
	create table GCS.BackgroundJob (
	   BackgroundJobUid     uniqueidentifier    RowGuidCol not null,
	   UserId               uniqueidentifier     not null,
	   State                nvarchar(100)        not null,
	   JobType              nvarchar(100)        not null,
	   DataType             nvarchar(100)        not null,
	   DataItemUid          uniqueidentifier     not null,
	   EntityId             uniqueidentifier     not null,
	   ItemName             nvarchar(100)        null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1,
	   constraint PK_BACKGROUNDJOB primary key (BackgroundJobUid)
	)
end
go


if dbo.fn_GCSDoesColumnExist('BackgroundJob', 'EntityId') = 0
BEGIN
	ALTER TABLE [GCS].BackgroundJob
	ADD EntityId  uniqueidentifier null

	update GCS.BackgroundJob set EntityId = '00000000-0000-0000-0000-000000000000' where EntityId is null

	ALTER TABLE [GCS].BackgroundJob
	alter column EntityId  uniqueidentifier not null
END
go  


if dbo.fn_GCSDoesColumnExist('BackgroundJob', 'ItemName') = 0
BEGIN
	ALTER TABLE [GCS].BackgroundJob
	ADD ItemName  nvarchar(100) null
END
go  




if dbo.fn_GCSDoesTableExist('BackgroundJobStateChange') = 0
begin
	/*==============================================================*/
	/* Table: BackgroundJobStateChange                              */
	/*==============================================================*/
	create table GCS.BackgroundJobStateChange (
	   BackgroundJobStateChangeUid uniqueidentifier    RowGuidCol not null,
	   BackgroundJobUid     uniqueidentifier    not null,
	   ChangeDateTime       datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   State                nvarchar(100)        not null,
	   Info                 nvarchar(max)        null,
	   constraint PK_BACKGROUNDJOBSTATECHANGE primary key (BackgroundJobStateChangeUid)
	)

	alter table GCS.BackgroundJobStateChange
	   add constraint FK_BackgroundJobStateChange foreign key (BackgroundJobUid)
		  references GCS.BackgroundJob (BackgroundJobUid)
			 on update cascade on delete cascade
end
go



if dbo.fn_GCSDoesTableExist('BackgroundJobData') = 0
begin
	/*==============================================================*/
	/* Table: BackgroundJobData                                     */
	/*==============================================================*/
	create table GCS.BackgroundJobData (
	   BackgroundJobUid     uniqueidentifier    RowGuidCol not null,
	   Data                 nvarchar(Max)        not null
	)

	alter table GCS.BackgroundJobData
	   add constraint PK_BACKGROUNDJOBDATA primary key (BackgroundJobUid)

	alter table GCS.BackgroundJobData
	   add constraint FK_BackgroundJobJobData foreign key (BackgroundJobUid)
		  references GCS.BackgroundJob (BackgroundJobUid)
			 on update cascade on delete cascade
end
go
/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.BackgroundJob table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[BackgroundJobPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobUid
,UserId
,State
,JobType
,DataType
,DataItemUid
,EntityId
,ItemName
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.BackgroundJob

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.BackgroundJob table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[BackgroundJobPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobUid
,State
FROM GCS.BackgroundJob

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.BackgroundJob table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobPDSA_SelectByPK]
@BackgroundJobUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobUid
,UserId
,State
,JobType
,DataType
,DataItemUid
,EntityId
,ItemName
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.BackgroundJob
WHERE 
BackgroundJobUid = @BackgroundJobUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.BackgroundJob table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobPDSA_SelectSearch]
@State nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobUid
,UserId
,State
,JobType
,DataType
,DataItemUid
,EntityId
,ItemName
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.BackgroundJob
WHERE 
(@State IS NULL OR State LIKE @State + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobPDSA_SelectSearch] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobPDSA_SelectByState]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobPDSA_SelectByState]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobPDSA_SelectByState]
@State nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobUid
,UserId
,State
,JobType
,DataType
,DataItemUid
,EntityId
,ItemName
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.BackgroundJob
WHERE 
State = @State
order by UpdateDate desc

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobPDSA_SelectByState] TO public
GO


/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.BackgroundJob table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobPDSA_Insert]
@BackgroundJobUid uniqueidentifier 
,@UserId uniqueidentifier 
,@State nvarchar(100) 
,@JobType nvarchar(100) 
,@DataType nvarchar(100) 
,@DataItemUid uniqueidentifier 
,@EntityId uniqueidentifier
,@ItemName nvarchar(100)
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @BackgroundJobUid = '00000000-0000-0000-0000-000000000000'
	SET @BackgroundJobUid = NULL

if @EntityId IS NULL
	SET @EntityId = '00000000-0000-0000-0000-000000000000'

if @BackgroundJobUid = '00000000-0000-0000-0000-000000000000' OR @BackgroundJobUid IS NULL
	SET @BackgroundJobUid = NewID()

INSERT INTO GCS.BackgroundJob
(
BackgroundJobUid
,UserId
,State
,JobType
,DataType
,DataItemUid
,EntityId
,ItemName
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@BackgroundJobUid
,@UserId
,@State
,@JobType
,@DataType
,@DataItemUid
,@EntityId
,@ItemName
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.BackgroundJob table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobPDSA_Update]
@BackgroundJobUid uniqueidentifier 
,@UserId uniqueidentifier
,@State nvarchar(100)
,@JobType nvarchar(100)
,@DataType nvarchar(100)
,@DataItemUid uniqueidentifier
,@EntityId uniqueidentifier
,@ItemName nvarchar(100)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;


if @EntityId IS NULL
	SET @EntityId = '00000000-0000-0000-0000-000000000000'

UPDATE GCS.BackgroundJob
SET 
BackgroundJobUid = @BackgroundJobUid
,UserId = @UserId
,State = @State
,JobType = @JobType
,DataType = @DataType
,DataItemUid = @DataItemUid
,EntityId = @EntityId
,ItemName = @ItemName
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
BackgroundJobUid = @BackgroundJobUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[BackgroundJobPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.BackgroundJob table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobPDSA_UpdateConcurrency]
@BackgroundJobUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.BackgroundJob
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
BackgroundJobUid = @BackgroundJobUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[BackgroundJobPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.BackgroundJob table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobPDSA_DeleteByPK]
@BackgroundJobUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.BackgroundJob
WHERE
BackgroundJobUid = @BackgroundJobUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.BackgroundJob table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.BackgroundJob

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobPDSA_RowCount] TO public
GO


/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.BackgroundJobData table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobDataPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobDataPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[BackgroundJobDataPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobUid
,Data
FROM GCS.BackgroundJobData

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobDataPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.BackgroundJobData table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobDataPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobDataPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[BackgroundJobDataPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobUid
,Data
FROM GCS.BackgroundJobData

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobDataPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.BackgroundJobData table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobDataPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobDataPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobDataPDSA_SelectByPK]
@BackgroundJobUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobUid
,Data
FROM GCS.BackgroundJobData
WHERE 
BackgroundJobUid = @BackgroundJobUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobDataPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.BackgroundJobData table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobDataPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobDataPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobDataPDSA_SelectSearch]
@Data nvarchar(max) 
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobUid
,Data
FROM GCS.BackgroundJobData
WHERE 
(@Data IS NULL OR Data LIKE @Data + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobDataPDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.BackgroundJobData table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobDataPDSA_ByBackgroundJobUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobDataPDSA_ByBackgroundJobUid]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobDataPDSA_ByBackgroundJobUid]
@BackgroundJobUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobUid
,Data
FROM GCS.BackgroundJobData
WHERE 
BackgroundJobUid = @BackgroundJobUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobDataPDSA_ByBackgroundJobUid] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.BackgroundJobData table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobDataPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobDataPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobDataPDSA_Insert]
@BackgroundJobUid uniqueidentifier 
,@Data nvarchar(max) 
AS

declare @ret int;
select @ret = 0;

INSERT INTO GCS.BackgroundJobData
(
BackgroundJobUid
,Data
) 
VALUES 
(
@BackgroundJobUid
,@Data
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobDataPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.BackgroundJobData table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobDataPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobDataPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobDataPDSA_Update]
@BackgroundJobUid uniqueidentifier 
,@Data nvarchar(max)
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.BackgroundJobData
SET 
BackgroundJobUid = @BackgroundJobUid
,Data = @Data
WHERE
BackgroundJobUid = @BackgroundJobUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[BackgroundJobDataPDSA_Update] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.BackgroundJobData table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobDataPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobDataPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobDataPDSA_DeleteByPK]
@BackgroundJobUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.BackgroundJobData
WHERE
BackgroundJobUid = @BackgroundJobUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobDataPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.BackgroundJobData table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobDataPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobDataPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobDataPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.BackgroundJobData

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobDataPDSA_RowCount] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.BackgroundJobStateChange table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobStateChangePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobStateChangePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[BackgroundJobStateChangePDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobStateChangeUid
,BackgroundJobUid
,ChangeDateTime
,State
,Info
FROM GCS.BackgroundJobStateChange

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobStateChangePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.BackgroundJobStateChange table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobStateChangePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobStateChangePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[BackgroundJobStateChangePDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobStateChangeUid
,State
FROM GCS.BackgroundJobStateChange

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobStateChangePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.BackgroundJobStateChange table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobStateChangePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobStateChangePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobStateChangePDSA_SelectByPK]
@BackgroundJobStateChangeUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobStateChangeUid
,BackgroundJobUid
,ChangeDateTime
,State
,Info
FROM GCS.BackgroundJobStateChange
WHERE 
BackgroundJobStateChangeUid = @BackgroundJobStateChangeUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobStateChangePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.BackgroundJobStateChange table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobStateChangePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobStateChangePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobStateChangePDSA_SelectSearch]
@State nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobStateChangeUid
,BackgroundJobUid
,ChangeDateTime
,State
,Info
FROM GCS.BackgroundJobStateChange
WHERE 
(@State IS NULL OR State LIKE @State + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobStateChangePDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.BackgroundJobStateChange table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobStateChangePDSA_ByBackgroundJobUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobStateChangePDSA_ByBackgroundJobUid]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobStateChangePDSA_ByBackgroundJobUid]
@BackgroundJobUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
BackgroundJobStateChangeUid
,BackgroundJobUid
,ChangeDateTime
,State
,Info
FROM GCS.BackgroundJobStateChange
WHERE 
BackgroundJobUid = @BackgroundJobUid
ORDER BY ChangeDateTime

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobStateChangePDSA_ByBackgroundJobUid] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.BackgroundJobStateChange table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobStateChangePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobStateChangePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobStateChangePDSA_Insert]
@BackgroundJobStateChangeUid uniqueidentifier 
,@BackgroundJobUid uniqueidentifier 
,@ChangeDateTime datetimeoffset
,@State nvarchar(100) 
,@Info nvarchar(max)  = null
AS

declare @ret int;
select @ret = 0;


if @BackgroundJobStateChangeUid = '00000000-0000-0000-0000-000000000000'
	SET @BackgroundJobStateChangeUid = NULL

if @BackgroundJobStateChangeUid = '00000000-0000-0000-0000-000000000000' OR @BackgroundJobStateChangeUid IS NULL
	SET @BackgroundJobStateChangeUid = NewID()

INSERT INTO GCS.BackgroundJobStateChange
(
BackgroundJobStateChangeUid
,BackgroundJobUid
,ChangeDateTime
,State
,Info
) 
VALUES 
(
@BackgroundJobStateChangeUid
,@BackgroundJobUid
,@ChangeDateTime
,@State
,@Info
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobStateChangePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.BackgroundJobStateChange table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobStateChangePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobStateChangePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobStateChangePDSA_Update]
@BackgroundJobStateChangeUid uniqueidentifier 
,@BackgroundJobUid uniqueidentifier
,@ChangeDateTime datetimeoffset
,@State nvarchar(100)
,@Info nvarchar(max)
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.BackgroundJobStateChange
SET 
BackgroundJobStateChangeUid = @BackgroundJobStateChangeUid
,BackgroundJobUid = @BackgroundJobUid
,ChangeDateTime = @ChangeDateTime
,State = @State
,Info = @Info
WHERE
BackgroundJobStateChangeUid = @BackgroundJobStateChangeUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[BackgroundJobStateChangePDSA_Update] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.BackgroundJobStateChange table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobStateChangePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobStateChangePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobStateChangePDSA_DeleteByPK]
@BackgroundJobStateChangeUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.BackgroundJobStateChange
WHERE
BackgroundJobStateChangeUid = @BackgroundJobStateChangeUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobStateChangePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.BackgroundJobStateChange table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[BackgroundJobStateChangePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[BackgroundJobStateChangePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[BackgroundJobStateChangePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.BackgroundJobStateChange

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[BackgroundJobStateChangePDSA_RowCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Cluster_GetPanelCommonLoadData]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Cluster_GetPanelCommonLoadData]
GO

CREATE OR ALTER PROCEDURE [GCS].[Cluster_GetPanelCommonLoadData]
	@ClusterUid [uniqueidentifier],
	@ClusterGroupId [int],
	@ClusterNumber [int]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
t.ClusterUid
,t.ClusterNumber
,t.ClusterName
,t.InsertDate
,t.UpdateDate
,t.ClusterGroupId
,t.IsActive
,t.AbaStartDigit
,t.AbaStopDigit
,t.AbaFoldOption
,t.AbaClipOption
,t.WiegandStartBit
,t.WiegandStopBit
,t.CardaxStartBit
,t.CardaxStopBit
,t.LockoutAfterInvalidAttempts
,t.LockoutDurationSeconds
,t.AccessRuleOverrideTimeout
,t.UnlimitedCredentialTimeout
,t.TimeZoneId
,crisisActiveIOG.IOGroupNumber as ActivateCrisisIOGroupNumber
,crisisResetIOG.IOGroupNumber as ResetCrisisIOGroupNumber
,ledLocked.LedBehaviorCode as LockedLED
,ledUnlocked.LedBehaviorCode as UnlockedLED
,ct.TypeCode as ClusterTypeCode
,cdl.DataLength as CredentialDataLength
,tst.ScheduleTypeCode as TimeScheduleTypeCode
FROM GCS.Cluster t
left outer join GCS.InputOutputGroup crisisActiveIOG on crisisActiveIOG.InputOutputGroupUid = t.CrisisActivateInputOutputGroupUid
left outer join GCS.InputOutputGroup crisisResetIOG on crisisResetIOG.InputOutputGroupUid = t.CrisisResetInputOutputGroupUid
left outer join GCS.ClusterLedBehaviorMode ledLocked on ledLocked.ClusterLedBehaviorModeUid = t.AccessPortalLockedLedBehaviorModeUid
left outer join GCS.ClusterLedBehaviorMode ledUnlocked on ledUnlocked.ClusterLedBehaviorModeUid = t.AccessPortalUnlockedLedBehaviorModeUid
left outer join GCS.ClusterType ct on ct.ClusterTypeUid = t.ClusterTypeUid
left outer join GCS.CredentialDataLength cdl on cdl.CredentialDataLengthUid = t.CredentialDataLengthUid
left outer join GCS.TimeScheduleType tst on tst.TimeScheduleTypeUid = t.TimeScheduleTypeUid
WHERE t.ClusterUid = @ClusterUid OR (t.ClusterGroupId = @ClusterGroupId AND ClusterNumber = @ClusterNumber)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[Cluster_GetPanelCommonLoadData] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[Cluster_GetPanelCommonLoadData] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsClusterUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsClusterUnique]
GO

CREATE OR ALTER PROCEDURE [GCS].[IsClusterUnique]
	@ClusterUid [uniqueidentifier],
	@EntityId [uniqueidentifier],
	@ClusterName [nvarchar](65),
	@ClusterNumber [int],
	--@ClusterGroupId [int],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
	select @Result = count(*) from GCS.Cluster where ClusterUid <> @ClusterUid AND ( EntityId = @EntityId AND ClusterName = @ClusterName )
	if( @Result <> 0 )
	BEGIN
		select @Result as Result
		return
	END	

	select @Result = count(*) from GCS.Cluster where ClusterUid <> @ClusterUid AND ( EntityId = @EntityId AND ClusterNumber = @ClusterNumber )
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsClusterUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsClusterUnique] TO [public] AS [dbo]
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsClusterAddressUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsClusterAddressUnique]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[IsClusterAddressUnique]
	@ClusterUid [uniqueidentifier],
	@ClusterNumber [int],
	@ClusterGroupId [int],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
	select @Result = count(*) from GCS.Cluster where ClusterUid <> @ClusterUid AND ( ClusterGroupId = @ClusterGroupId AND ClusterNumber = @ClusterNumber )
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsClusterAddressUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsClusterAddressUnique] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsClusterNameUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsClusterNameUnique]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[IsClusterNameUnique]
	@ClusterUid [uniqueidentifier],
	@EntityId [uniqueidentifier],
	@ClusterName [nvarchar](65),
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
	select @Result = count(*) from GCS.Cluster where ClusterUid <> @ClusterUid AND ( EntityId = @EntityId AND ClusterName = @ClusterName )
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsClusterNameUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsClusterNameUnique] TO [public] AS [dbo]
GO





--update GCS.GalaxyPanel set GalaxyPanelModelUid = '00000000-0000-0000-0000-00000000027B' where GalaxyPanelModelUid = '00000000-0000-0000-0000-000000000258'
--go
---- Get rid of any 600 
--delete from GCS.GalaxyPanelModel where GalaxyPanelModelUid = '00000000-0000-0000-0000-000000000258'
--go

--update GCS.GalaxyCpu set GalaxyCpuModelUid = '00000000-0000-0000-0000-00000000027B' where GalaxyCpuModelUid = '00000000-0000-0000-0000-000000000258'
--go

---- Get rid of any 600 
--delete from GCS.GalaxyCpuModel where GalaxyCpuModelUid = '00000000-0000-0000-0000-000000000258'
--go


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'dbo.[gcs_SetTransactionIsolationLevel]') AND type in (N'P', N'PC'))
DROP PROCEDURE dbo.[gcs_SetTransactionIsolationLevel]
GO

/****** Object:  StoredProcedure [dbo].[gcs_SetTransactionIsolationLevel]   */
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [dbo].[gcs_SetTransactionIsolationLevel]
	@IsolationLevel [varchar](100)
WITH EXECUTE AS CALLER
AS
	EXEC( N'SET TRANSACTION ISOLATION LEVEL ' + @IsolationLevel)
GO
ALTER AUTHORIZATION ON [dbo].[gcs_SetTransactionIsolationLevel] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [dbo].[gcs_SetTransactionIsolationLevel] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[SelectPersonsWithPhotosMissingPublicUrl]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[SelectPersonsWithPhotosMissingPublicUrl]
GO
CREATE OR ALTER PROCEDURE GCS.[SelectPersonsWithPhotosMissingPublicUrl]
@EntityId uniqueidentifier
AS
	if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
	BEGIN
		select pp.PersonUid, LastName, FirstName, EntityId from GCS.PersonPhoto pp join GCS.Person p on p.PersonUid = pp.PersonUid
		where PublicUrl is null or LEN(PublicUrl) = 0 
		order by LastName, FirstName
	END
	ELSE
	BEGIN
		select pp.PersonUid, LastName, FirstName, EntityId from GCS.PersonPhoto pp join GCS.Person p on p.PersonUid = pp.PersonUid
		where PublicUrl is null or LEN(PublicUrl) = 0 and EntityId = @EntityId
		order by LastName, FirstName
	END
GO

GRANT EXECUTE ON GCS.[SelectPersonsWithPhotosMissingPublicUrl] TO public
GO


exec dbo.gcs_DeleteCheckConstraint 'GCS', 'AccessPortalProperties', 'CKC_UNLOCKDELAY_ACCESSPO'
go 

exec dbo.gcs_DeleteCheckConstraint 'GCS', 'AccessPortalProperties', 'CKC_UNLOCKDURATION_ACCESSPO'
go 

exec dbo.gcs_DeleteCheckConstraint 'GCS', 'AccessPortalProperties', 'CKC_RECLOSEDURATION_ACCESSPO'
go 

alter table GCS.AccessPortalProperties
   add constraint CKC_UNLOCKDELAY_ACCESSPO check (UnlockDelay between 0 and 65535)
go

alter table GCS.AccessPortalProperties
   add constraint CKC_UNLOCKDURATION_ACCESSPO check (UnlockDuration between 0 and 65535)
go

alter table GCS.AccessPortalProperties
   add constraint CKC_RECLOSEDURATION_ACCESSPO check (RecloseDuration between 0 and 65535)
go

exec dbo.gcs_DeleteDefaultConstraint 'GCS', 'AccessPortalAuxiliaryOutput', 'ActivationDelay'
go

exec dbo.gcs_DeleteDefaultConstraint 'GCS', 'AccessPortalAuxiliaryOutput', 'ActivationDuration'
go

ALTER TABLE [GCS].[AccessPortalAuxiliaryOutput] ADD  DEFAULT ((0)) FOR [ActivationDelay]
GO
ALTER TABLE [GCS].[AccessPortalAuxiliaryOutput] ADD  DEFAULT ((0)) FOR [ActivationDuration]
GO


if dbo.fn_GCSDoesColumnExist('AccessPortalProperties', 'PINSpecifiesRecloseDuration') = 1
BEGIN
	exec sp_unbindefault 'GCS.AccessPortalProperties.PINSpecifiesRecloseDuration'

	alter table GCS.AccessPortalProperties DROP Column PINSpecifiesRecloseDuration
END
go  

if dbo.fn_GCSDoesViewExist('AccessPortal_PanelLoadData') = 1
BEGIN
	DROP VIEW GCS.[AccessPortal_PanelLoadData]
END
go

create view [GCS].[AccessPortal_PanelLoadData] as
SELECT approps.AccessPortalUid
	,apCluster.ClusterUid
	,apPanel.GalaxyPanelUid
	,apBoard.GalaxyInterfaceBoardUid
	,apSection.GalaxyInterfaceBoardSectionUid
	,apModule.GalaxyHardwareModuleUid
	,apNode.GalaxyInterfaceBoardSectionNodeUid
	,ap.PortalName
	,apCluster.ClusterGroupId
	,apCluster.ClusterNumber
	,apPanel.PanelNumber
	,apBoard.BoardNumber
	,apSection.SectionNumber
	,apModule.ModuleNumber
	,apNode.NodeNumber
	,aphwaddr.DoorNumber
	,apType.AccessPortalTypeDescription
	,credReaderType.ReaderTypeName
	,crDataFormat.PanelDataFormatCode
	,crDataFormat.DataFormatName
	,apBoardSectionMode.ModeCode as AccessPortalBoardSectionMode
	,apBoardSectionMode.Display as AccessPortalBoardSectionModeDisplay
	,apPanelModel.TypeCode as AccessPortalPanelModelTypeCode
	,apCpuModel.TypeCode as AccessPortalCpuTypeCode
	,apBoardType.Model as AccessPortalBoardTypeModel
	,apBoardType.TypeCode as AccessPortalBoardTypeTypeCode
	,apBoardType.Display as AccessPortalBoardTypeDisplay
	,[UnlockDelay]
	,[UnlockDuration]
	,[RecloseDuration]
	,[AllowPassbackAccess]
	,[RequireTwoValidCredentials]
	,[UnlockOnREX]
	,[SuppressIllegalOpenLog]
	,[SuppressOpenTooLongLog]
	,[SuppressClosedLog]
	,[SuppressREXLog]
	,[GenerateDoorContactChangeLogs]
	,[LockWhenDoorCloses]
	,[EnableDuress]
	,[DoorGroupNotify]
	,[DoorGroupCanDisable]
	,[RelayOneOnDuringArmDelay]
	,[RequireValidAccessForAutoUnlock]
	--,[PINSpecifiesRecloseDuration]
	,[ValidAccessRequiresDoorOpen]
	,[DontDecrementLimitedSwipeExpireCount]
	,[IgnoreNotInSystem]
	,[ReaderSendsHeartbeat]
	,[IsEnabled]
	,approps.[UpdateDate] as PropertiesLastUpdated
	,afpf.Code as AutoForgivePassbackCode
	,afpf.Display as AutoForgivePassbackDisplay
	,prm.Code as PinRequiredModeCode
	,prm.Display as PinRequiredModeDisplay
	,apcst.Code as ContactSupervisionCode
	,apcst.Display as ContactSupervisionDisplay
	,apdf.Code as DeferToServerCode
	,apdf.Display as DeferToServerDisplay
	,apnsr.Code as NoServerReplyCode
	,apnsr.Display as NoServerReplyDisplay
	,aplpb.Code as LockPushButtonCode
	,aplpb.Display as LockPushButtonDisplay
	,apmfm.Code as MultiFactorMode
	,apmfm.Display as MultiFactorModeDisplay
	--,lcdB.BoardNumber as LCDBoardNumber
	--,lcdBS.SectionNumber as LCDSectionNumber
	--,lcdBSNode.NodeNumber as LCDNodeNumber
	,elevControlType.Code as ElevatorControlTypeCode
	,elevControlType.Display as ElevatorControlTypeDisplay
	,elevatorRelayB.BoardNumber as ElevatorRelayBoardNumber
	,elevatorRelayBS.SectionNumber as ElevatorRelaySectionNumber
	,passbackIntoArea.AreaNumber as PassbackIntoAreaNumber
	,passbackFromArea.AreaNumber as PassbackFromAreaNumber
	,clusterFreeAccessScheduleMap.PanelScheduleNumber as FreeAccessScheduleNumber
	,freeAccessSch.Display as FreeAccessScheduleDisplay
	,clusterCrisisFreeAccessScheduleMap.PanelScheduleNumber as CrisisFreeAccessScheduleNumber
	,crisisFreeAccessSch.Display as CrisisFreeAccessScheduleDisplay
	,clusterPinRequiredScheduleMap.PanelScheduleNumber as PinRequiredScheduleNumber
	,pinRequiredSch.Display as PinRequiredScheduleDisplay
	,clusterDisableForcedOpenScheduleMap.PanelScheduleNumber as DisableForcedOpenScheduleNumber
	,DisableForcedOpenSch.Display as DisableForcedOpenScheduleDisplay
	,clusterDisableOpenTooLongScheduleMap.PanelScheduleNumber as DisableOpenTooLongScheduleNumber
	,DisableOpenTooLongSch.Display as DisableOpenTooLongScheduleDisplay
	,clusterAuxiliaryOutputScheduleMap.PanelScheduleNumber as AuxiliaryOutputScheduleNumber
	,AuxiliaryOutputSch.Display as AuxiliaryOutputScheduleDisplay
	,apAuxiliaryOutput.ActivationDelay as Relay2ActivationDelay
	,apAuxiliaryOutput.ActivationDuration as Relay2ActivationDuration
	,apAuxiliaryOutput.AccessGranted as Relay2TriggerAccessGranted
	,apAuxiliaryOutput.Duress as Relay2TriggerDuress
	,apAuxiliaryOutput.IllegalOpen as Relay2TriggerForcedOpen
	,apAuxiliaryOutput.InvalidAttempt as Relay2TriggerInvalidAttempt
	,apAuxiliaryOutput.OpenTooLong as Relay2TriggerOpenTooLong
	,apAuxiliaryOutput.PassbackViolation as Relay2TriggerPassbackViolation
	,apAuxiliaryOutputMode.Code as Relay2ModeCode
	,apAuxiliaryOutputMode.Display as Relay2ModeDisplay
	,clusterRelay2ScheduleMap.PanelScheduleNumber as Relay2ScheduleNumber
	,relay2Sch.Display as Relay2ScheduleDisplay
	,apForcedOpenIOGroup.IOGroupNumber as ForcedOpenIOGroupNumber
	,apForcedOpenIOGroupAssignment.OffsetIndex as ForcedOpenIOGroupOffset
	,apOpenTooLongIOGroup.IOGroupNumber as OpenTooLongIOGroupNumber
	,apOpenTooLongIOGroupAssignment.OffsetIndex as OpenTooLongIOGroupOffset
	,apInvalidAccessAttemptIOGroup.IOGroupNumber as InvalidAccessAttemptIOGroupNumber
	,apInvalidAccessAttemptIOGroupAssignment.OffsetIndex as InvalidAccessAttemptIOGroupOffset
	,apPassbackViolationIOGroup.IOGroupNumber as PassbackViolationIOGroupNumber
	,apPassbackViolationIOGroupAssignment.OffsetIndex as PassbackViolationIOGroupOffset
	,apDuressIOGroup.IOGroupNumber as DuressIOGroupNumber
	,apDuressIOGroupAssignment.OffsetIndex as DuressIOGroupOffset
	,apMissedHeartbeatIOGroup.IOGroupNumber as MissedHeartbeatIOGroupNumber
	,apMissedHeartbeatIOGroupAssignment.OffsetIndex as MissedHeartbeatIOGroupOffset
	,apAccessGrantedIOGroup.IOGroupNumber as AccessGrantedIOGroupNumber
	,apAccessGrantedIOGroupAssignment.OffsetIndex as AccessGrantedIOGroupOffset
	,apDoorGroupIOGroup.IOGroupNumber as DoorGroupIOGroupNumber
	,apDoorGroupIOGroupAssignment.OffsetIndex as DoorGroupIOGroupOffset
	,apLockedByIOGroup.IOGroupNumber as LockedByIOGroupNumber
	,apUnlockedByIOGroup.IOGroupNumber as UnlockedByIOGroupNumber
	,apDisarm1IOGroup.IOGroupNumber as DisarmIOGroupNumber1
	,apDisarm2IOGroup.IOGroupNumber as DisarmIOGroupNumber2
	,apDisarm3IOGroup.IOGroupNumber as DisarmIOGroupNumber3
	,apDisarm4IOGroup.IOGroupNumber as DisarmIOGroupNumber4
	,ap.UpdateDate as AccessPortalLastUpdated
	,aphwaddr.UpdateDate as HardwareAddressLastUpdated
	,apPassbackIntoArea.UpdateDate as PassbackIntoAreaLastUpdated
	,apPassbackFromArea.UpdateDate as PassbackFromAreaLastUpdated
	,apFreeAccessSchedule.UpdateDate as FreeAccessSchLastUpdated
	,apCrisisFreeAccessSchedule.UpdateDate as CrisisFreeAccessSchLastUpdated
	,apPinRequiredSchedule.UpdateDate as PinRequiredSchLastUpdated
	,apDisableForcedOpenSchedule.UpdateDate as DisableForcedOpenSchLastUpdated
	,apDisableOpenTooLongSchedule.UpdateDate as DisableOpenTooLongSchLastUpdated
	,apAuxiliaryOutputSchedule.UpdateDate as AuxOutputSchLastUpdated
	,apAuxiliaryOutput.UpdateDate as AuxOutputLastUpdated
	,relay2Sch.UpdateDate as Relay2SchLastUpdated
	,apForcedOpenAlertEvent.UpdateDate as ForcedOpenAlertLastUpdated
	,apOpenTooLongAlertEvent.UpdateDate as OpenTooLongAlertLastUpdated
	,apInvalidAccessAttemptAlertEvent.UpdateDate as InvalidAccessAttemptAlertLastUpdated
	,apPassbackViolationAlertEvent.UpdateDate as PassbackViolationAlertLastUpdated
	,apDuressAlertEvent.UpdateDate as DuressAlertLastUpdated
	,apMissedHeartbeatAlertEvent.UpdateDate as MissedHeartbeatAlertLastUpdated
	,apAccessGrantedAlertEvent.UpdateDate as AccessGrantedAlertLastUpdated
	,apDoorGroupAlertEvent.UpdateDate as DoorGroupAlertLastUpdated
	,apUnlockedByAlertEvent.UpdateDate as UnlockedByIogLastUpdated
	,apLockedByAlertEvent.UpdateDate as LockedByIogLastUpdated
	,apDisarm1AlertEvent.UpdateDate as DisarmIog1LastUpdated
	,apDisarm2AlertEvent.UpdateDate as DisarmIog2LastUpdated
	,apDisarm3AlertEvent.UpdateDate as DisarmIog3LastUpdated
	,apDisarm4AlertEvent.UpdateDate as DisarmIog4LastUpdated
	,0 as CpuNumber
	,'00000000-0000-0000-0000-000000000000' as CpuUid
	,'' as ServerAddress
	,0 as IsConnected
	,apForcedOpenAlertEvent.IsActive as ForcedOpenAlertEventIsActive
	,apOpenTooLongAlertEvent.IsActive as OpenTooLongAlertEventIsActive
	,apInvalidAccessAttemptAlertEvent.IsActive as InvalidAccessAttemptAlertEventIsActive
	,apPassbackViolationAlertEvent.IsActive as PassbackViolationAlertEventIsActive
	,apDuressAlertEvent.IsActive as DuressAlertEventIsActive
	,apMissedHeartbeatAlertEvent.IsActive as MissedHeartbeatAlertEventIsActive
	,apAccessGrantedAlertEvent.IsActive as AccessGrantedAlertEventIsActive
	,apDoorGroupAlertEvent.IsActive as DoorGroupAlertEventIsActive
	,apUnlockedByAlertEvent.IsActive as UnlockedByAlertEventIsActive
	,apLockedByAlertEvent.IsActive as LockedByAlertEventIsActive
	,apDisarm1AlertEvent.IsActive as Disarm1AlertEventIsActive
	,apDisarm2AlertEvent.IsActive as Disarm2AlertEventIsActive
	,apDisarm3AlertEvent.IsActive as Disarm3AlertEventIsActive
	,apDisarm4AlertEvent.IsActive as Disarm4AlertEventIsActive
FROM GCS.AccessPortal ap
	JOIN GCS.AccessPortalType apType on apType.AccessPortalTypeUid = ap.AccessPortalTypeUid
	JOIN GCS.CredentialReaderType credReaderType ON credReaderType.CredentialReaderTypeUid = apType.CredentialReaderTypeUid
	JOIN GCS.CredentialReaderDataFormat crDataFormat on crDataFormat.CredentialReaderDataFormatUid = credReaderType.CredentialReaderDataFormatUid
	JOIN [GCS].[AccessPortalProperties] approps on approps.AccessPortalUid = ap.AccessPortalUid
	JOIN GCS.AutomaticForgivePassbackFrequency afpf on afpf.AutomaticForgivePassbackFrequencyUid = approps.AutomaticForgivePassbackFrequencyUid
	JOIN GCS.PinRequiredMode prm on prm.PinRequiredModeUid = approps.PinRequiredModeUid
	JOIN GCS.AccessPortalContactSupervisionType apcst on apcst.AccessPortalContactSupervisionTypeUid = approps.AccessPortalContactSupervisionTypeUid
	JOIN GCS.AccessPortalDeferToServerBehavior apdf on apdf.AccessPortalDeferToServerBehaviorUid = approps.AccessPortalDeferToServerBehaviorUid
	JOIN GCS.AccessPortalNoServerReplyBehavior apnsr on apnsr.AccessPortalNoServerReplyBehaviorUid = approps.AccessPortalNoServerReplyBehaviorUid
	JOIN GCS.AccessPortalLockPushButtonBehavior aplpb on aplpb.AccessPortalLockPushButtonBehaviorUid = approps.AccessPortalLockPushButtonBehaviorUid
	JOIN GCS.AccessPortalMultiFactorMode apmfm on apmfm.AccessPortalMultiFactorModeUid = approps.AccessPortalMultiFactorModeUid
	--LEFT OUTER JOIN GCS.LiquidCrystalDisplayGalaxyHardwareAddress lcdhwaddr on lcdhwaddr.LiquidCrystalDisplayUid = approps.LiquidCrystalDisplayUid
	--LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode lcdBSNode on lcdBSNode.GalaxyInterfaceBoardSectionNodeUid = lcdhwaddr.GalaxyInterfaceBoardSectionNodeUid
	--LEFT OUTER JOIN GCS.GalaxyHardwareModule lcdHWModule on lcdHWModule.GalaxyHardwareModuleUid = lcdBSNode.GalaxyHardwareModuleUid
	--LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection lcdBS on lcdBS.GalaxyInterfaceBoardSectionUid = lcdHWModule.GalaxyInterfaceBoardSectionUid
	--LEFT OUTER JOIN GCS.GalaxyInterfaceBoard lcdB on lcdB.GalaxyInterfaceBoardUid = lcdBS.GalaxyInterfaceBoardUid
	LEFT OUTER JOIN GCS.AccessPortalElevatorControlType elevControlType on elevControlType.AccessPortalElevatorControlTypeUid = approps.AccessPortalElevatorControlTypeUid
	LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection elevatorRelayBS on elevatorRelayBS.GalaxyInterfaceBoardSectionUid = approps.ElevatorRelayInterfaceBoardSectionUid
	LEFT OUTER JOIN GCS.GalaxyInterfaceBoard elevatorRelayB on elevatorRelayB.GalaxyInterfaceBoardUid = elevatorRelayBS.GalaxyInterfaceBoardUid
	JOIN GCS.AccessPortalGalaxyHardwareAddress aphwaddr on aphwaddr.AccessPortalUid = approps.AccessPortalUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode apNode on apNode.GalaxyInterfaceBoardSectionNodeUid = aphwaddr.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule apModule on apModule.GalaxyHardwareModuleUid = apNode.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyInterfaceBoardSection apSection on apSection.GalaxyInterfaceBoardSectionUid = apModule.GalaxyInterfaceBoardSectionUid
	JOIN GCS.GalaxyInterfaceBoard apBoard on apBoard.GalaxyInterfaceBoardUid = apSection.GalaxyInterfaceBoardUid
	JOIN GCS.GalaxyPanel apPanel on apPanel.GalaxyPanelUid = apBoard.GalaxyPanelUid
	JOIN GCS.Cluster apCluster on apCluster.ClusterUid = apPanel.ClusterUid
	JOIN GCS.InterfaceBoardSectionMode apBoardSectionMode on apBoardSectionMode.InterfaceBoardSectionModeUid = apSection.InterfaceBoardSectionModeUid
	JOIN GCS.GalaxyPanelModel apPanelModel on apPanelModel.GalaxyPanelModelUid = apPanel.GalaxyPanelModelUid
	JOIN GCS.GalaxyCpu apCpu on apCpu.GalaxyPanelUid = apPanel.GalaxyPanelUid AND apCpu.CpuNumber = 1
	JOIN GCS.GalaxyCpuModel apCpuModel on apCpuModel.GalaxyCpuModelUid = apCpu.GalaxyCpuModelUid
	JOIN GCS.InterfaceBoardType apBoardType on apBoardType.InterfaceBoardTypeUid = apBoard.InterfaceBoardTypeUid
	-- Passback Into Area
	LEFT OUTER JOIN GCS.AccessPortalArea apPassbackIntoArea on apPassbackIntoArea.AccessPortalUid = ap.AccessPortalUid AND apPassbackIntoArea.AccessPortalAreaTypeUid = '00000000-0000-0000-0000-000000000002'
	LEFT OUTER JOIN  GCS.Area passbackIntoArea on passbackIntoArea.AreaUid = apPassbackIntoArea.AreaUid
	-- Passback From Area
	LEFT OUTER JOIN GCS.AccessPortalArea apPassbackFromArea on apPassbackFromArea.AccessPortalUid = ap.AccessPortalUid AND apPassbackFromArea.AccessPortalAreaTypeUid = '00000000-0000-0000-0000-000000000001'
	LEFT OUTER JOIN  GCS.Area passbackFromArea on passbackFromArea.AreaUid = apPassbackFromArea.AreaUid
	-- Time Schedules
	-- Free Access Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apFreeAccessSchedule on apFreeAccessSchedule.AccessPortalUid = ap.AccessPortalUid AND apFreeAccessSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000001'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterFreeAccessScheduleMap on clusterFreeAccessScheduleMap.TimeScheduleUid = apFreeAccessSchedule.TimeScheduleUid AND clusterFreeAccessScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule freeAccessSch on freeAccessSch.TimeScheduleUid = clusterFreeAccessScheduleMap.TimeScheduleUid
	-- Crisis Mode Free Access Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apCrisisFreeAccessSchedule on apCrisisFreeAccessSchedule.AccessPortalUid = ap.AccessPortalUid AND apCrisisFreeAccessSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000005'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterCrisisFreeAccessScheduleMap on clusterCrisisFreeAccessScheduleMap.TimeScheduleUid = apCrisisFreeAccessSchedule.TimeScheduleUid AND clusterCrisisFreeAccessScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule crisisFreeAccessSch on crisisFreeAccessSch.TimeScheduleUid = clusterCrisisFreeAccessScheduleMap.TimeScheduleUid
	-- PIN Required Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apPinRequiredSchedule on apPinRequiredSchedule.AccessPortalUid = ap.AccessPortalUid AND apPinRequiredSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000002'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterPinRequiredScheduleMap on clusterPinRequiredScheduleMap.TimeScheduleUid = apPinRequiredSchedule.TimeScheduleUid AND clusterPinRequiredScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule pinRequiredSch on pinRequiredSch.TimeScheduleUid = clusterPinRequiredScheduleMap.TimeScheduleUid
	-- Disable Forced Open Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apDisableForcedOpenSchedule on apDisableForcedOpenSchedule.AccessPortalUid = ap.AccessPortalUid AND apDisableForcedOpenSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000003'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterDisableForcedOpenScheduleMap on clusterDisableForcedOpenScheduleMap.TimeScheduleUid = apDisableForcedOpenSchedule.TimeScheduleUid AND clusterDisableForcedOpenScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule DisableForcedOpenSch on DisableForcedOpenSch.TimeScheduleUid = clusterDisableForcedOpenScheduleMap.TimeScheduleUid
	-- Disable Open Too Long Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apDisableOpenTooLongSchedule on apDisableOpenTooLongSchedule.AccessPortalUid = ap.AccessPortalUid AND apDisableOpenTooLongSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000004'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterDisableOpenTooLongScheduleMap on clusterDisableOpenTooLongScheduleMap.TimeScheduleUid = apDisableOpenTooLongSchedule.TimeScheduleUid AND clusterDisableOpenTooLongScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule DisableOpenTooLongSch on DisableOpenTooLongSch.TimeScheduleUid = clusterDisableOpenTooLongScheduleMap.TimeScheduleUid
	-- Auxiliary Output Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apAuxiliaryOutputSchedule on apAuxiliaryOutputSchedule.AccessPortalUid = ap.AccessPortalUid AND apAuxiliaryOutputSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000006'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterAuxiliaryOutputScheduleMap on clusterAuxiliaryOutputScheduleMap.TimeScheduleUid = apAuxiliaryOutputSchedule.TimeScheduleUid AND clusterAuxiliaryOutputScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule AuxiliaryOutputSch on AuxiliaryOutputSch.TimeScheduleUid = clusterAuxiliaryOutputScheduleMap.TimeScheduleUid
	-- Relay 2
	LEFT OUTER JOIN GCS.AccessPortalAuxiliaryOutput apAuxiliaryOutput on apAuxiliaryOutput.AccessPortalUid = ap.AccessPortalUid AND Tag = 'Relay2'
	LEFT OUTER JOIN GCS.AccessPortalAuxiliaryOutputMode apAuxiliaryOutputMode on apAuxiliaryOutputMode.AccessPortalAuxiliaryOutputModeUid = apAuxiliaryOutput.AccessPortalAuxiliaryOutputModeUid
	-- Relay 2 Output Schedule
	LEFT OUTER JOIN GCS.TimeSchedule relay2Sch on relay2Sch.TimeScheduleUid = apAuxiliaryOutput.TimeScheduleUid
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterRelay2ScheduleMap on clusterRelay2ScheduleMap.TimeScheduleUid = relay2Sch.TimeScheduleUid AND clusterRelay2ScheduleMap.ClusterUid = apPanel.ClusterUid
	-- Input Output Groups
	-- Forced Open IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apForcedOpenAlertEvent on apForcedOpenAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apForcedOpenAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000001'
	LEFT OUTER JOIN GCS.InputOutputGroup apForcedOpenIOGroup on apForcedOpenIOGroup.InputOutputGroupUid = apForcedOpenAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apForcedOpenIOGroupAssignment on apForcedOpenIOGroupAssignment.InputOutputGroupAssignmentUid = apForcedOpenAlertEvent.InputOutputGroupAssignmentUid
	---- Open Too Long IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apOpenTooLongAlertEvent on apOpenTooLongAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apOpenTooLongAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000002'
	LEFT OUTER JOIN GCS.InputOutputGroup apOpenTooLongIOGroup on apOpenTooLongIOGroup.InputOutputGroupUid = apOpenTooLongAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apOpenTooLongIOGroupAssignment on apOpenTooLongIOGroupAssignment.InputOutputGroupAssignmentUid = apOpenTooLongAlertEvent.InputOutputGroupAssignmentUid
	---- Invalid Access Attempt IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apInvalidAccessAttemptAlertEvent on apInvalidAccessAttemptAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apInvalidAccessAttemptAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000003'
	LEFT OUTER JOIN GCS.InputOutputGroup apInvalidAccessAttemptIOGroup on apInvalidAccessAttemptIOGroup.InputOutputGroupUid = apInvalidAccessAttemptAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apInvalidAccessAttemptIOGroupAssignment on apInvalidAccessAttemptIOGroupAssignment.InputOutputGroupAssignmentUid = apInvalidAccessAttemptAlertEvent.InputOutputGroupAssignmentUid
	---- Passback Violation IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apPassbackViolationAlertEvent on apPassbackViolationAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apPassbackViolationAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000004'
	LEFT OUTER JOIN GCS.InputOutputGroup apPassbackViolationIOGroup on apPassbackViolationIOGroup.InputOutputGroupUid = apPassbackViolationAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apPassbackViolationIOGroupAssignment on apPassbackViolationIOGroupAssignment.InputOutputGroupAssignmentUid = apPassbackViolationAlertEvent.InputOutputGroupAssignmentUid
	---- Duress IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDuressAlertEvent on apDuressAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDuressAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000005'
	LEFT OUTER JOIN GCS.InputOutputGroup apDuressIOGroup on apDuressIOGroup.InputOutputGroupUid = apDuressAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apDuressIOGroupAssignment on apDuressIOGroupAssignment.InputOutputGroupAssignmentUid = apDuressAlertEvent.InputOutputGroupAssignmentUid
	---- Missed Heartbeat IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apMissedHeartbeatAlertEvent on apMissedHeartbeatAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apMissedHeartbeatAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000006'
	LEFT OUTER JOIN GCS.InputOutputGroup apMissedHeartbeatIOGroup on apMissedHeartbeatIOGroup.InputOutputGroupUid = apMissedHeartbeatAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apMissedHeartbeatIOGroupAssignment on apMissedHeartbeatIOGroupAssignment.InputOutputGroupAssignmentUid = apMissedHeartbeatAlertEvent.InputOutputGroupAssignmentUid
	---- Access Granted IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apAccessGrantedAlertEvent on apAccessGrantedAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apAccessGrantedAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000007'
	LEFT OUTER JOIN GCS.InputOutputGroup apAccessGrantedIOGroup on apAccessGrantedIOGroup.InputOutputGroupUid = apAccessGrantedAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apAccessGrantedIOGroupAssignment on apAccessGrantedIOGroupAssignment.InputOutputGroupAssignmentUid = apAccessGrantedAlertEvent.InputOutputGroupAssignmentUid
	---- Door Group IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDoorGroupAlertEvent on apDoorGroupAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDoorGroupAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-00000000000c'
	LEFT OUTER JOIN GCS.InputOutputGroup apDoorGroupIOGroup on apDoorGroupIOGroup.InputOutputGroupUid = apDoorGroupAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apDoorGroupIOGroupAssignment on apDoorGroupIOGroupAssignment.InputOutputGroupAssignmentUid = apDoorGroupAlertEvent.InputOutputGroupAssignmentUid
	---- Locked By IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apUnlockedByAlertEvent on apUnlockedByAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apUnlockedByAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-00000000000d'
	LEFT OUTER JOIN GCS.InputOutputGroup apUnlockedByIOGroup on apUnlockedByIOGroup.InputOutputGroupUid = apUnlockedByAlertEvent.InputOutputGroupUid
	---- Unlocked By IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apLockedByAlertEvent on apLockedByAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apLockedByAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-00000000000e'
	LEFT OUTER JOIN GCS.InputOutputGroup apLockedByIOGroup on apLockedByIOGroup.InputOutputGroupUid = apLockedByAlertEvent.InputOutputGroupUid
	---- Disarm IO Group 1 on Access Granted
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDisarm1AlertEvent on apDisarm1AlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDisarm1AlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000008'
	LEFT OUTER JOIN GCS.InputOutputGroup apDisarm1IOGroup on apDisarm1IOGroup.InputOutputGroupUid = apDisarm1AlertEvent.InputOutputGroupUid
	---- Disarm IO Group 2 on Access Granted
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDisarm2AlertEvent on apDisarm2AlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDisarm2AlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000009'
	LEFT OUTER JOIN GCS.InputOutputGroup apDisarm2IOGroup on apDisarm2IOGroup.InputOutputGroupUid = apDisarm2AlertEvent.InputOutputGroupUid
	---- Disarm IO Group 3 on Access Granted
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDisarm3AlertEvent on apDisarm3AlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDisarm3AlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-00000000000a'
	LEFT OUTER JOIN GCS.InputOutputGroup apDisarm3IOGroup on apDisarm3IOGroup.InputOutputGroupUid = apDisarm3AlertEvent.InputOutputGroupUid
	---- Disarm IO Group 4 on Access Granted
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDisarm4AlertEvent on apDisarm4AlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDisarm4AlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-00000000000b'
	LEFT OUTER JOIN GCS.InputOutputGroup apDisarm4IOGroup on apDisarm4IOGroup.InputOutputGroupUid = apDisarm4AlertEvent.InputOutputGroupUid
	WHERE apNode.IsNodeActive = 1
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortal_PanelLoadData] TO  SCHEMA OWNER 
GO

if dbo.fn_GCSDoesViewExist('AccessPortal_PanelLoadDataChangesForCpu') = 1
BEGIN
	DROP VIEW GCS.[AccessPortal_PanelLoadDataChangesForCpu]
END
go

create view [GCS].[AccessPortal_PanelLoadDataChangesForCpu] as
SELECT approps.AccessPortalUid
	,apCluster.ClusterUid
	,apPanel.GalaxyPanelUid
	,apBoard.GalaxyInterfaceBoardUid
	,apSection.GalaxyInterfaceBoardSectionUid
	,apModule.GalaxyHardwareModuleUid
	,apNode.GalaxyInterfaceBoardSectionNodeUid
	,ap.PortalName
	,apCluster.ClusterGroupId
	,apCluster.ClusterNumber
	,apPanel.PanelNumber
	,apBoard.BoardNumber
	,apSection.SectionNumber
	,apModule.ModuleNumber
	,apNode.NodeNumber
	,aphwaddr.DoorNumber
	,apType.AccessPortalTypeDescription
	,credReaderType.ReaderTypeName
	,crDataFormat.PanelDataFormatCode
	,crDataFormat.DataFormatName
	,apBoardSectionMode.ModeCode as AccessPortalBoardSectionMode
	,apBoardSectionMode.Display as AccessPortalBoardSectionModeDisplay
	,apPanelModel.TypeCode as AccessPortalPanelModelTypeCode
	,apCpuModel.TypeCode as AccessPortalCpuTypeCode
	,apBoardType.Model as AccessPortalBoardTypeModel
	,apBoardType.TypeCode as AccessPortalBoardTypeTypeCode
	,apBoardType.Display as AccessPortalBoardTypeDisplay
	,[UnlockDelay]
	,[UnlockDuration]
	,[RecloseDuration]
	,[AllowPassbackAccess]
	,[RequireTwoValidCredentials]
	,[UnlockOnREX]
	,[SuppressIllegalOpenLog]
	,[SuppressOpenTooLongLog]
	,[SuppressClosedLog]
	,[SuppressREXLog]
	,[GenerateDoorContactChangeLogs]
	,[LockWhenDoorCloses]
	,[EnableDuress]
	,[DoorGroupNotify]
	,[DoorGroupCanDisable]
	,[RelayOneOnDuringArmDelay]
	,[RequireValidAccessForAutoUnlock]
	--,[PINSpecifiesRecloseDuration]
	,[ValidAccessRequiresDoorOpen]
	,[DontDecrementLimitedSwipeExpireCount]
	,[IgnoreNotInSystem]
	,[ReaderSendsHeartbeat]
	,[IsEnabled]
	,approps.[UpdateDate] as PropertiesLastUpdated
	,afpf.Code as AutoForgivePassbackCode
	,afpf.Display as AutoForgivePassbackDisplay
	,prm.Code as PinRequiredModeCode
	,prm.Display as PinRequiredModeDisplay
	,apcst.Code as ContactSupervisionCode
	,apcst.Display as ContactSupervisionDisplay
	,apdf.Code as DeferToServerCode
	,apdf.Display as DeferToServerDisplay
	,apnsr.Code as NoServerReplyCode
	,apnsr.Display as NoServerReplyDisplay
	,aplpb.Code as LockPushButtonCode
	,aplpb.Display as LockPushButtonDisplay
	,apmfm.Code as MultiFactorMode
	,apmfm.Display as MultiFactorModeDisplay
	--,lcdB.BoardNumber as LCDBoardNumber
	--,lcdBS.SectionNumber as LCDSectionNumber
	--,lcdBSNode.NodeNumber as LCDNodeNumber
	,elevControlType.Code as ElevatorControlTypeCode
	,elevControlType.Display as ElevatorControlTypeDisplay
	,elevatorRelayB.BoardNumber as ElevatorRelayBoardNumber
	,elevatorRelayBS.SectionNumber as ElevatorRelaySectionNumber
	,passbackIntoArea.AreaNumber as PassbackIntoAreaNumber
	,passbackFromArea.AreaNumber as PassbackFromAreaNumber
	,clusterFreeAccessScheduleMap.PanelScheduleNumber as FreeAccessScheduleNumber
	,freeAccessSch.Display as FreeAccessScheduleDisplay
	,clusterCrisisFreeAccessScheduleMap.PanelScheduleNumber as CrisisFreeAccessScheduleNumber
	,crisisFreeAccessSch.Display as CrisisFreeAccessScheduleDisplay
	,clusterPinRequiredScheduleMap.PanelScheduleNumber as PinRequiredScheduleNumber
	,pinRequiredSch.Display as PinRequiredScheduleDisplay
	,clusterDisableForcedOpenScheduleMap.PanelScheduleNumber as DisableForcedOpenScheduleNumber
	,DisableForcedOpenSch.Display as DisableForcedOpenScheduleDisplay
	,clusterDisableOpenTooLongScheduleMap.PanelScheduleNumber as DisableOpenTooLongScheduleNumber
	,DisableOpenTooLongSch.Display as DisableOpenTooLongScheduleDisplay
	,clusterAuxiliaryOutputScheduleMap.PanelScheduleNumber as AuxiliaryOutputScheduleNumber
	,AuxiliaryOutputSch.Display as AuxiliaryOutputScheduleDisplay
	,apAuxiliaryOutput.ActivationDelay as Relay2ActivationDelay
	,apAuxiliaryOutput.ActivationDuration as Relay2ActivationDuration
	,apAuxiliaryOutput.AccessGranted as Relay2TriggerAccessGranted
	,apAuxiliaryOutput.Duress as Relay2TriggerDuress
	,apAuxiliaryOutput.IllegalOpen as Relay2TriggerForcedOpen
	,apAuxiliaryOutput.InvalidAttempt as Relay2TriggerInvalidAttempt
	,apAuxiliaryOutput.OpenTooLong as Relay2TriggerOpenTooLong
	,apAuxiliaryOutput.PassbackViolation as Relay2TriggerPassbackViolation
	,apAuxiliaryOutputMode.Code as Relay2ModeCode
	,apAuxiliaryOutputMode.Display as Relay2ModeDisplay
	,clusterRelay2ScheduleMap.PanelScheduleNumber as Relay2ScheduleNumber
	,relay2Sch.Display as Relay2ScheduleDisplay
	,apForcedOpenIOGroup.IOGroupNumber as ForcedOpenIOGroupNumber
	,apForcedOpenIOGroupAssignment.OffsetIndex as ForcedOpenIOGroupOffset
	,apOpenTooLongIOGroup.IOGroupNumber as OpenTooLongIOGroupNumber
	,apOpenTooLongIOGroupAssignment.OffsetIndex as OpenTooLongIOGroupOffset
	,apInvalidAccessAttemptIOGroup.IOGroupNumber as InvalidAccessAttemptIOGroupNumber
	,apInvalidAccessAttemptIOGroupAssignment.OffsetIndex as InvalidAccessAttemptIOGroupOffset
	,apPassbackViolationIOGroup.IOGroupNumber as PassbackViolationIOGroupNumber
	,apPassbackViolationIOGroupAssignment.OffsetIndex as PassbackViolationIOGroupOffset
	,apDuressIOGroup.IOGroupNumber as DuressIOGroupNumber
	,apDuressIOGroupAssignment.OffsetIndex as DuressIOGroupOffset
	,apMissedHeartbeatIOGroup.IOGroupNumber as MissedHeartbeatIOGroupNumber
	,apMissedHeartbeatIOGroupAssignment.OffsetIndex as MissedHeartbeatIOGroupOffset
	,apAccessGrantedIOGroup.IOGroupNumber as AccessGrantedIOGroupNumber
	,apAccessGrantedIOGroupAssignment.OffsetIndex as AccessGrantedIOGroupOffset
	,apDoorGroupIOGroup.IOGroupNumber as DoorGroupIOGroupNumber
	,apDoorGroupIOGroupAssignment.OffsetIndex as DoorGroupIOGroupOffset
	,apLockedByIOGroup.IOGroupNumber as LockedByIOGroupNumber
	,apUnlockedByIOGroup.IOGroupNumber as UnlockedByIOGroupNumber
	,apDisarm1IOGroup.IOGroupNumber as DisarmIOGroupNumber1
	,apDisarm2IOGroup.IOGroupNumber as DisarmIOGroupNumber2
	,apDisarm3IOGroup.IOGroupNumber as DisarmIOGroupNumber3
	,apDisarm4IOGroup.IOGroupNumber as DisarmIOGroupNumber4
	,ap.UpdateDate as AccessPortalLastUpdated
	,aphwaddr.UpdateDate as HardwareAddressLastUpdated
	,apPassbackIntoArea.UpdateDate as PassbackIntoAreaLastUpdated
	,apPassbackFromArea.UpdateDate as PassbackFromAreaLastUpdated
	,apFreeAccessSchedule.UpdateDate as FreeAccessSchLastUpdated
	,apCrisisFreeAccessSchedule.UpdateDate as CrisisFreeAccessSchLastUpdated
	,apPinRequiredSchedule.UpdateDate as PinRequiredSchLastUpdated
	,apDisableForcedOpenSchedule.UpdateDate as DisableForcedOpenSchLastUpdated
	,apDisableOpenTooLongSchedule.UpdateDate as DisableOpenTooLongSchLastUpdated
	,apAuxiliaryOutputSchedule.UpdateDate as AuxOutputSchLastUpdated
	,apAuxiliaryOutput.UpdateDate as AuxOutputLastUpdated
	,relay2Sch.UpdateDate as Relay2SchLastUpdated
	,apForcedOpenAlertEvent.UpdateDate as ForcedOpenAlertLastUpdated
	,apOpenTooLongAlertEvent.UpdateDate as OpenTooLongAlertLastUpdated
	,apInvalidAccessAttemptAlertEvent.UpdateDate as InvalidAccessAttemptAlertLastUpdated
	,apPassbackViolationAlertEvent.UpdateDate as PassbackViolationAlertLastUpdated
	,apDuressAlertEvent.UpdateDate as DuressAlertLastUpdated
	,apMissedHeartbeatAlertEvent.UpdateDate as MissedHeartbeatAlertLastUpdated
	,apAccessGrantedAlertEvent.UpdateDate as AccessGrantedAlertLastUpdated
	,apDoorGroupAlertEvent.UpdateDate as DoorGroupAlertLastUpdated
	,apUnlockedByAlertEvent.UpdateDate as UnlockedByIogLastUpdated
	,apLockedByAlertEvent.UpdateDate as LockedByIogLastUpdated
	,apDisarm1AlertEvent.UpdateDate as DisarmIog1LastUpdated
	,apDisarm2AlertEvent.UpdateDate as DisarmIog2LastUpdated
	,apDisarm3AlertEvent.UpdateDate as DisarmIog3LastUpdated
	,apDisarm4AlertEvent.UpdateDate as DisarmIog4LastUpdated
	,cpu.CpuNumber
	,cpu.CpuUid
	,gcc.ServerAddress
	,gcc.IsConnected
	,apForcedOpenAlertEvent.IsActive as ForcedOpenAlertEventIsActive
	,apOpenTooLongAlertEvent.IsActive as OpenTooLongAlertEventIsActive
	,apInvalidAccessAttemptAlertEvent.IsActive as InvalidAccessAttemptAlertEventIsActive
	,apPassbackViolationAlertEvent.IsActive as PassbackViolationAlertEventIsActive
	,apDuressAlertEvent.IsActive as DuressAlertEventIsActive
	,apMissedHeartbeatAlertEvent.IsActive as MissedHeartbeatAlertEventIsActive
	,apAccessGrantedAlertEvent.IsActive as AccessGrantedAlertEventIsActive
	,apDoorGroupAlertEvent.IsActive as DoorGroupAlertEventIsActive
	,apUnlockedByAlertEvent.IsActive as UnlockedByAlertEventIsActive
	,apLockedByAlertEvent.IsActive as LockedByAlertEventIsActive
	,apDisarm1AlertEvent.IsActive as Disarm1AlertEventIsActive
	,apDisarm2AlertEvent.IsActive as Disarm2AlertEventIsActive
	,apDisarm3AlertEvent.IsActive as Disarm3AlertEventIsActive
	,apDisarm4AlertEvent.IsActive as Disarm4AlertEventIsActive
FROM GCS.AccessPortal ap
	JOIN GCS.AccessPortalType apType on apType.AccessPortalTypeUid = ap.AccessPortalTypeUid
	JOIN GCS.CredentialReaderType credReaderType ON credReaderType.CredentialReaderTypeUid = apType.CredentialReaderTypeUid
	JOIN GCS.CredentialReaderDataFormat crDataFormat on crDataFormat.CredentialReaderDataFormatUid = credReaderType.CredentialReaderDataFormatUid
	JOIN [GCS].[AccessPortalProperties] approps on approps.AccessPortalUid = ap.AccessPortalUid
	JOIN GCS.AutomaticForgivePassbackFrequency afpf on afpf.AutomaticForgivePassbackFrequencyUid = approps.AutomaticForgivePassbackFrequencyUid
	JOIN GCS.PinRequiredMode prm on prm.PinRequiredModeUid = approps.PinRequiredModeUid
	JOIN GCS.AccessPortalContactSupervisionType apcst on apcst.AccessPortalContactSupervisionTypeUid = approps.AccessPortalContactSupervisionTypeUid
	JOIN GCS.AccessPortalDeferToServerBehavior apdf on apdf.AccessPortalDeferToServerBehaviorUid = approps.AccessPortalDeferToServerBehaviorUid
	JOIN GCS.AccessPortalNoServerReplyBehavior apnsr on apnsr.AccessPortalNoServerReplyBehaviorUid = approps.AccessPortalNoServerReplyBehaviorUid
	JOIN GCS.AccessPortalLockPushButtonBehavior aplpb on aplpb.AccessPortalLockPushButtonBehaviorUid = approps.AccessPortalLockPushButtonBehaviorUid
	JOIN GCS.AccessPortalMultiFactorMode apmfm on apmfm.AccessPortalMultiFactorModeUid = approps.AccessPortalMultiFactorModeUid
	--LEFT OUTER JOIN GCS.LiquidCrystalDisplayGalaxyHardwareAddress lcdhwaddr on lcdhwaddr.LiquidCrystalDisplayUid = approps.LiquidCrystalDisplayUid
	--LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode lcdBSNode on lcdBSNode.GalaxyInterfaceBoardSectionNodeUid = lcdhwaddr.GalaxyInterfaceBoardSectionNodeUid
	--LEFT OUTER JOIN GCS.GalaxyHardwareModule lcdHWModule on lcdHWModule.GalaxyHardwareModuleUid = lcdBSNode.GalaxyHardwareModuleUid
	--LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection lcdBS on lcdBS.GalaxyInterfaceBoardSectionUid = lcdHWModule.GalaxyInterfaceBoardSectionUid
	--LEFT OUTER JOIN GCS.GalaxyInterfaceBoard lcdB on lcdB.GalaxyInterfaceBoardUid = lcdBS.GalaxyInterfaceBoardUid
	LEFT OUTER JOIN GCS.AccessPortalElevatorControlType elevControlType on elevControlType.AccessPortalElevatorControlTypeUid = approps.AccessPortalElevatorControlTypeUid
	LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection elevatorRelayBS on elevatorRelayBS.GalaxyInterfaceBoardSectionUid = approps.ElevatorRelayInterfaceBoardSectionUid
	LEFT OUTER JOIN GCS.GalaxyInterfaceBoard elevatorRelayB on elevatorRelayB.GalaxyInterfaceBoardUid = elevatorRelayBS.GalaxyInterfaceBoardUid
	JOIN GCS.AccessPortalGalaxyHardwareAddress aphwaddr on aphwaddr.AccessPortalUid = approps.AccessPortalUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode apNode on apNode.GalaxyInterfaceBoardSectionNodeUid = aphwaddr.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule apModule on apModule.GalaxyHardwareModuleUid = apNode.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyInterfaceBoardSection apSection on apSection.GalaxyInterfaceBoardSectionUid = apModule.GalaxyInterfaceBoardSectionUid
	JOIN GCS.GalaxyInterfaceBoard apBoard on apBoard.GalaxyInterfaceBoardUid = apSection.GalaxyInterfaceBoardUid
	JOIN GCS.GalaxyPanel apPanel on apPanel.GalaxyPanelUid = apBoard.GalaxyPanelUid
	JOIN GCS.Cluster apCluster on apCluster.ClusterUid = apPanel.ClusterUid
	JOIN GCS.InterfaceBoardSectionMode apBoardSectionMode on apBoardSectionMode.InterfaceBoardSectionModeUid = apSection.InterfaceBoardSectionModeUid
	JOIN GCS.GalaxyPanelModel apPanelModel on apPanelModel.GalaxyPanelModelUid = apPanel.GalaxyPanelModelUid
	JOIN GCS.GalaxyCpu apCpu on apCpu.GalaxyPanelUid = apPanel.GalaxyPanelUid AND apCpu.CpuNumber = 1
	LEFT OUTER JOIN GCS.GalaxyCpuConnection gcc on gcc.CpuUid = apCpu.CpuUid

	JOIN GCS.GalaxyCpuModel apCpuModel on apCpuModel.GalaxyCpuModelUid = apCpu.GalaxyCpuModelUid
	JOIN GCS.InterfaceBoardType apBoardType on apBoardType.InterfaceBoardTypeUid = apBoard.InterfaceBoardTypeUid
	-- Passback Into Area
	LEFT OUTER JOIN GCS.AccessPortalArea apPassbackIntoArea on apPassbackIntoArea.AccessPortalUid = ap.AccessPortalUid AND apPassbackIntoArea.AccessPortalAreaTypeUid = '00000000-0000-0000-0000-000000000002'
	LEFT OUTER JOIN  GCS.Area passbackIntoArea on passbackIntoArea.AreaUid = apPassbackIntoArea.AreaUid
	-- Passback From Area
	LEFT OUTER JOIN GCS.AccessPortalArea apPassbackFromArea on apPassbackFromArea.AccessPortalUid = ap.AccessPortalUid AND apPassbackFromArea.AccessPortalAreaTypeUid = '00000000-0000-0000-0000-000000000001'
	LEFT OUTER JOIN  GCS.Area passbackFromArea on passbackFromArea.AreaUid = apPassbackFromArea.AreaUid
	-- Time Schedules
	-- Free Access Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apFreeAccessSchedule on apFreeAccessSchedule.AccessPortalUid = ap.AccessPortalUid AND apFreeAccessSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000001'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterFreeAccessScheduleMap on clusterFreeAccessScheduleMap.TimeScheduleUid = apFreeAccessSchedule.TimeScheduleUid AND clusterFreeAccessScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule freeAccessSch on freeAccessSch.TimeScheduleUid = clusterFreeAccessScheduleMap.TimeScheduleUid
	-- Crisis Mode Free Access Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apCrisisFreeAccessSchedule on apCrisisFreeAccessSchedule.AccessPortalUid = ap.AccessPortalUid AND apCrisisFreeAccessSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000005'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterCrisisFreeAccessScheduleMap on clusterCrisisFreeAccessScheduleMap.TimeScheduleUid = apCrisisFreeAccessSchedule.TimeScheduleUid AND clusterCrisisFreeAccessScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule crisisFreeAccessSch on crisisFreeAccessSch.TimeScheduleUid = clusterCrisisFreeAccessScheduleMap.TimeScheduleUid
	-- PIN Required Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apPinRequiredSchedule on apPinRequiredSchedule.AccessPortalUid = ap.AccessPortalUid AND apPinRequiredSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000002'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterPinRequiredScheduleMap on clusterPinRequiredScheduleMap.TimeScheduleUid = apPinRequiredSchedule.TimeScheduleUid AND clusterPinRequiredScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule pinRequiredSch on pinRequiredSch.TimeScheduleUid = clusterPinRequiredScheduleMap.TimeScheduleUid
	-- Disable Forced Open Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apDisableForcedOpenSchedule on apDisableForcedOpenSchedule.AccessPortalUid = ap.AccessPortalUid AND apDisableForcedOpenSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000003'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterDisableForcedOpenScheduleMap on clusterDisableForcedOpenScheduleMap.TimeScheduleUid = apDisableForcedOpenSchedule.TimeScheduleUid AND clusterDisableForcedOpenScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule DisableForcedOpenSch on DisableForcedOpenSch.TimeScheduleUid = clusterDisableForcedOpenScheduleMap.TimeScheduleUid
	-- Disable Open Too Long Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apDisableOpenTooLongSchedule on apDisableOpenTooLongSchedule.AccessPortalUid = ap.AccessPortalUid AND apDisableOpenTooLongSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000004'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterDisableOpenTooLongScheduleMap on clusterDisableOpenTooLongScheduleMap.TimeScheduleUid = apDisableOpenTooLongSchedule.TimeScheduleUid AND clusterDisableOpenTooLongScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule DisableOpenTooLongSch on DisableOpenTooLongSch.TimeScheduleUid = clusterDisableOpenTooLongScheduleMap.TimeScheduleUid
	-- Auxiliary Output Schedule
	LEFT OUTER JOIN GCS.AccessPortalTimeSchedule apAuxiliaryOutputSchedule on apAuxiliaryOutputSchedule.AccessPortalUid = ap.AccessPortalUid AND apAuxiliaryOutputSchedule.AccessPortalScheduleTypeUid  = '00000000-0000-0000-0000-000000000006'
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterAuxiliaryOutputScheduleMap on clusterAuxiliaryOutputScheduleMap.TimeScheduleUid = apAuxiliaryOutputSchedule.TimeScheduleUid AND clusterAuxiliaryOutputScheduleMap.ClusterUid = apPanel.ClusterUid
	LEFT OUTER JOIN GCS.TimeSchedule AuxiliaryOutputSch on AuxiliaryOutputSch.TimeScheduleUid = clusterAuxiliaryOutputScheduleMap.TimeScheduleUid
	-- Relay 2
	LEFT OUTER JOIN GCS.AccessPortalAuxiliaryOutput apAuxiliaryOutput on apAuxiliaryOutput.AccessPortalUid = ap.AccessPortalUid AND Tag = 'Relay2'
	LEFT OUTER JOIN GCS.AccessPortalAuxiliaryOutputMode apAuxiliaryOutputMode on apAuxiliaryOutputMode.AccessPortalAuxiliaryOutputModeUid = apAuxiliaryOutput.AccessPortalAuxiliaryOutputModeUid
	-- Relay 2 Output Schedule
	LEFT OUTER JOIN GCS.TimeSchedule relay2Sch on relay2Sch.TimeScheduleUid = apAuxiliaryOutput.TimeScheduleUid
	LEFT OUTER JOIN GCS.GalaxyClusterTimeScheduleMap clusterRelay2ScheduleMap on clusterRelay2ScheduleMap.TimeScheduleUid = relay2Sch.TimeScheduleUid AND clusterRelay2ScheduleMap.ClusterUid = apPanel.ClusterUid
	-- Input Output Groups
	-- Forced Open IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apForcedOpenAlertEvent on apForcedOpenAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apForcedOpenAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000001'
	LEFT OUTER JOIN GCS.InputOutputGroup apForcedOpenIOGroup on apForcedOpenIOGroup.InputOutputGroupUid = apForcedOpenAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apForcedOpenIOGroupAssignment on apForcedOpenIOGroupAssignment.InputOutputGroupAssignmentUid = apForcedOpenAlertEvent.InputOutputGroupAssignmentUid
	---- Open Too Long IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apOpenTooLongAlertEvent on apOpenTooLongAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apOpenTooLongAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000002'
	LEFT OUTER JOIN GCS.InputOutputGroup apOpenTooLongIOGroup on apOpenTooLongIOGroup.InputOutputGroupUid = apOpenTooLongAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apOpenTooLongIOGroupAssignment on apOpenTooLongIOGroupAssignment.InputOutputGroupAssignmentUid = apOpenTooLongAlertEvent.InputOutputGroupAssignmentUid
	---- Invalid Access Attempt IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apInvalidAccessAttemptAlertEvent on apInvalidAccessAttemptAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apInvalidAccessAttemptAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000003'
	LEFT OUTER JOIN GCS.InputOutputGroup apInvalidAccessAttemptIOGroup on apInvalidAccessAttemptIOGroup.InputOutputGroupUid = apInvalidAccessAttemptAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apInvalidAccessAttemptIOGroupAssignment on apInvalidAccessAttemptIOGroupAssignment.InputOutputGroupAssignmentUid = apInvalidAccessAttemptAlertEvent.InputOutputGroupAssignmentUid
	---- Passback Violation IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apPassbackViolationAlertEvent on apPassbackViolationAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apPassbackViolationAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000004'
	LEFT OUTER JOIN GCS.InputOutputGroup apPassbackViolationIOGroup on apPassbackViolationIOGroup.InputOutputGroupUid = apPassbackViolationAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apPassbackViolationIOGroupAssignment on apPassbackViolationIOGroupAssignment.InputOutputGroupAssignmentUid = apPassbackViolationAlertEvent.InputOutputGroupAssignmentUid
	---- Duress IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDuressAlertEvent on apDuressAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDuressAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000005'
	LEFT OUTER JOIN GCS.InputOutputGroup apDuressIOGroup on apDuressIOGroup.InputOutputGroupUid = apDuressAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apDuressIOGroupAssignment on apDuressIOGroupAssignment.InputOutputGroupAssignmentUid = apDuressAlertEvent.InputOutputGroupAssignmentUid
	---- Missed Heartbeat IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apMissedHeartbeatAlertEvent on apMissedHeartbeatAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apMissedHeartbeatAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000006'
	LEFT OUTER JOIN GCS.InputOutputGroup apMissedHeartbeatIOGroup on apMissedHeartbeatIOGroup.InputOutputGroupUid = apMissedHeartbeatAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apMissedHeartbeatIOGroupAssignment on apMissedHeartbeatIOGroupAssignment.InputOutputGroupAssignmentUid = apMissedHeartbeatAlertEvent.InputOutputGroupAssignmentUid
	---- Access Granted IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apAccessGrantedAlertEvent on apAccessGrantedAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apAccessGrantedAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000007'
	LEFT OUTER JOIN GCS.InputOutputGroup apAccessGrantedIOGroup on apAccessGrantedIOGroup.InputOutputGroupUid = apAccessGrantedAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apAccessGrantedIOGroupAssignment on apAccessGrantedIOGroupAssignment.InputOutputGroupAssignmentUid = apAccessGrantedAlertEvent.InputOutputGroupAssignmentUid
	---- Door Group IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDoorGroupAlertEvent on apDoorGroupAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDoorGroupAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-00000000000c'
	LEFT OUTER JOIN GCS.InputOutputGroup apDoorGroupIOGroup on apDoorGroupIOGroup.InputOutputGroupUid = apDoorGroupAlertEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment apDoorGroupIOGroupAssignment on apDoorGroupIOGroupAssignment.InputOutputGroupAssignmentUid = apDoorGroupAlertEvent.InputOutputGroupAssignmentUid
	---- Locked By IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apUnlockedByAlertEvent on apUnlockedByAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apUnlockedByAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-00000000000d'
	LEFT OUTER JOIN GCS.InputOutputGroup apUnlockedByIOGroup on apUnlockedByIOGroup.InputOutputGroupUid = apUnlockedByAlertEvent.InputOutputGroupUid
	---- Unlocked By IO Group
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apLockedByAlertEvent on apLockedByAlertEvent.AccessPortalUid = ap.AccessPortalUid AND apLockedByAlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-00000000000e'
	LEFT OUTER JOIN GCS.InputOutputGroup apLockedByIOGroup on apLockedByIOGroup.InputOutputGroupUid = apLockedByAlertEvent.InputOutputGroupUid
	---- Disarm IO Group 1 on Access Granted
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDisarm1AlertEvent on apDisarm1AlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDisarm1AlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000008'
	LEFT OUTER JOIN GCS.InputOutputGroup apDisarm1IOGroup on apDisarm1IOGroup.InputOutputGroupUid = apDisarm1AlertEvent.InputOutputGroupUid
	---- Disarm IO Group 2 on Access Granted
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDisarm2AlertEvent on apDisarm2AlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDisarm2AlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-000000000009'
	LEFT OUTER JOIN GCS.InputOutputGroup apDisarm2IOGroup on apDisarm2IOGroup.InputOutputGroupUid = apDisarm2AlertEvent.InputOutputGroupUid
	---- Disarm IO Group 3 on Access Granted
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDisarm3AlertEvent on apDisarm3AlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDisarm3AlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-00000000000a'
	LEFT OUTER JOIN GCS.InputOutputGroup apDisarm3IOGroup on apDisarm3IOGroup.InputOutputGroupUid = apDisarm3AlertEvent.InputOutputGroupUid
	---- Disarm IO Group 4 on Access Granted
	LEFT OUTER JOIN GCS.AccessPortalAlertEvent apDisarm4AlertEvent on apDisarm4AlertEvent.AccessPortalUid = ap.AccessPortalUid AND apDisarm4AlertEvent.AccessPortalAlertEventTypeUid = '00000000-0000-0000-0000-00000000000b'
	LEFT OUTER JOIN GCS.InputOutputGroup apDisarm4IOGroup on apDisarm4IOGroup.InputOutputGroupUid = apDisarm4AlertEvent.InputOutputGroupUid
	JOIN GCS.AccessPortalLoadToCpu apltc on apltc.AccessPortalGalaxyHardwareAddressUid = aphwaddr.AccessPortalGalaxyHardwareAddressUid
	JOIN GCS.GalaxyCpu cpu on cpu.CpuUid = apltc.CpuUid
	WHERE apNode.IsNodeActive = 1 and
	(apltc.LastLoadedDate < approps.[UpdateDate] or
	apltc.LastLoadedDate < ap.UpdateDate or
	apltc.LastLoadedDate < apPassbackIntoArea.UpdateDate or
	apltc.LastLoadedDate < apPassbackFromArea.UpdateDate or
	apltc.LastLoadedDate < apFreeAccessSchedule.UpdateDate or
	apltc.LastLoadedDate < apCrisisFreeAccessSchedule.UpdateDate or
	apltc.LastLoadedDate < apPinRequiredSchedule.UpdateDate or
	apltc.LastLoadedDate < apDisableForcedOpenSchedule.UpdateDate or
	apltc.LastLoadedDate < apDisableOpenTooLongSchedule.UpdateDate or
	apltc.LastLoadedDate < apAuxiliaryOutputSchedule.UpdateDate or
	apltc.LastLoadedDate < apAuxiliaryOutput.UpdateDate or
	apltc.LastLoadedDate < relay2Sch.UpdateDate or
	apltc.LastLoadedDate < apForcedOpenAlertEvent.UpdateDate or
	apltc.LastLoadedDate < apOpenTooLongAlertEvent.UpdateDate or
	apltc.LastLoadedDate < apInvalidAccessAttemptAlertEvent.UpdateDate or
	apltc.LastLoadedDate < apPassbackViolationAlertEvent.UpdateDate or
	apltc.LastLoadedDate < apDuressAlertEvent.UpdateDate or
	apltc.LastLoadedDate < apMissedHeartbeatAlertEvent.UpdateDate or
	apltc.LastLoadedDate < apAccessGrantedAlertEvent.UpdateDate or
	apltc.LastLoadedDate < apDoorGroupAlertEvent.UpdateDate or
	apltc.LastLoadedDate < apUnlockedByAlertEvent.UpdateDate or
	apltc.LastLoadedDate < apLockedByAlertEvent.UpdateDate or
	apltc.LastLoadedDate < apDisarm1AlertEvent.UpdateDate or
	apltc.LastLoadedDate < apDisarm2AlertEvent.UpdateDate or
	apltc.LastLoadedDate < apDisarm3AlertEvent.UpdateDate or
	apltc.LastLoadedDate < apDisarm4AlertEvent.UpdateDate or
	apltc.LastLoadedDate < aphwaddr.UpdateDate)

GO
ALTER AUTHORIZATION ON [GCS].[AccessPortal_PanelLoadDataChangesForCpu] TO  SCHEMA OWNER 
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_ByAccessPortalContactSupervisionTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_ByAccessPortalContactSupervisionTypeUid]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_ByAccessPortalDeferToServerBehaviorUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_ByAccessPortalDeferToServerBehaviorUid]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_ByAccessPortalElevatorControlTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_ByAccessPortalElevatorControlTypeUid]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_ByAccessPortalLockPushButtonBehaviorUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_ByAccessPortalLockPushButtonBehaviorUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_ByAccessPortalMultiFactorModeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_ByAccessPortalMultiFactorModeUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_ByAccessPortalNoServerReplyBehaviorUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_ByAccessPortalNoServerReplyBehaviorUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_ByElevatorRelayInterfaceBoardSectionUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_ByElevatorRelayInterfaceBoardSectionUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_ByLiquidCrystalDisplayUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_ByLiquidCrystalDisplayUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_ByResponseInstructionsUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_ByResponseInstructionsUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_ByAccessPortalContactSupervisionTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_ByAccessPortalContactSupervisionTypeUid]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_ByAccessPortalUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_ByAccessPortalUid]
GO

/****** Object:  StoredProcedure [GCS].[AccessPortalPropertiesPDSA_ByAccessPortalUid]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessPortalPropertiesPDSA_ByAccessPortalUid]
	@AccessPortalUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
AccessPortalPropertiesUid
,AccessPortalUid
,AutomaticForgivePassbackFrequencyUid
,PinRequiredModeUid
,AccessPortalContactSupervisionTypeUid
,AccessPortalDeferToServerBehaviorUid
,AccessPortalNoServerReplyBehaviorUid
,AccessPortalLockPushButtonBehaviorUid
,LiquidCrystalDisplayUid
,AccessPortalElevatorControlTypeUid
,OtisElevatorDecUid
,ElevatorRelayInterfaceBoardSectionUid
,AccessPortalMultiFactorModeUid
,UnlockDelay
,UnlockDuration
,RecloseDuration
,AllowPassbackAccess
,RequireTwoValidCredentials
,UnlockOnREX
,SuppressIllegalOpenLog
,SuppressOpenTooLongLog
,SuppressClosedLog
,SuppressREXLog
,GenerateDoorContactChangeLogs
,LockWhenDoorCloses
,EnableDuress
,DoorGroupNotify
,DoorGroupCanDisable
,RelayOneOnDuringArmDelay
,RequireValidAccessForAutoUnlock
--,PINSpecifiesRecloseDuration
,ValidAccessRequiresDoorOpen
,DontDecrementLimitedSwipeExpireCount
,IgnoreNotInSystem
,ReaderSendsHeartbeat
,PhotoVerificationEnabled
,TimeAttendancePortal
,EMailEventsEnabled
,TransmitEventsEnabled
,FileOutputEnabled
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.AccessPortalProperties
WHERE 
AccessPortalUid = @AccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalPropertiesPDSA_ByAccessPortalUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalPropertiesPDSA_ByAccessPortalUid] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_Insert]
GO

/****** Object:  StoredProcedure [GCS].[AccessPortalPropertiesPDSA_Insert]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessPortalPropertiesPDSA_Insert]
	@AccessPortalPropertiesUid [uniqueidentifier],
	@AccessPortalUid [uniqueidentifier],
	@AutomaticForgivePassbackFrequencyUid [uniqueidentifier],
	@PinRequiredModeUid [uniqueidentifier],
	@AccessPortalContactSupervisionTypeUid [uniqueidentifier],
	@AccessPortalDeferToServerBehaviorUid [uniqueidentifier],
	@AccessPortalNoServerReplyBehaviorUid [uniqueidentifier],
	@AccessPortalLockPushButtonBehaviorUid [uniqueidentifier],
	@LiquidCrystalDisplayUid [uniqueidentifier] = null,
	@AccessPortalElevatorControlTypeUid [uniqueidentifier] = null,
	@OtisElevatorDecUid [uniqueidentifier] = null,
	@ElevatorRelayInterfaceBoardSectionUid [uniqueidentifier] = null,
	@AccessPortalMultiFactorModeUid [uniqueidentifier],
	@UnlockDelay [int],
	@UnlockDuration [int],
	@RecloseDuration [int],
	@AllowPassbackAccess [bit],
	@RequireTwoValidCredentials [bit],
	@UnlockOnREX [bit],
	@SuppressIllegalOpenLog [bit],
	@SuppressOpenTooLongLog [bit],
	@SuppressClosedLog [bit],
	@SuppressREXLog [bit],
	@GenerateDoorContactChangeLogs [bit],
	@LockWhenDoorCloses [bit],
	@EnableDuress [bit],
	@DoorGroupNotify [bit],
	@DoorGroupCanDisable [bit],
	@RelayOneOnDuringArmDelay [bit],
	@RequireValidAccessForAutoUnlock [bit],
	--@PINSpecifiesRecloseDuration [bit],
	@ValidAccessRequiresDoorOpen [bit],
	@DontDecrementLimitedSwipeExpireCount [bit],
	@IgnoreNotInSystem [bit],
	@ReaderSendsHeartbeat [bit],
	@PhotoVerificationEnabled [bit],
	@TimeAttendancePortal [bit],
	@EMailEventsEnabled [bit],
	@TransmitEventsEnabled [bit],
	@FileOutputEnabled [bit],
	@InsertName [nvarchar](100),
	@InsertDate [datetimeoffset],
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @AccessPortalPropertiesUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalPropertiesUid = NULL
if @AccessPortalUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalUid = NULL
if @AutomaticForgivePassbackFrequencyUid = '00000000-0000-0000-0000-000000000000'
	SET @AutomaticForgivePassbackFrequencyUid = NULL
if @PinRequiredModeUid = '00000000-0000-0000-0000-000000000000'
	SET @PinRequiredModeUid = NULL
if @AccessPortalContactSupervisionTypeUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalContactSupervisionTypeUid = NULL
if @AccessPortalDeferToServerBehaviorUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalDeferToServerBehaviorUid = NULL
if @AccessPortalNoServerReplyBehaviorUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalNoServerReplyBehaviorUid = NULL
if @AccessPortalLockPushButtonBehaviorUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalLockPushButtonBehaviorUid = NULL
if @LiquidCrystalDisplayUid = '00000000-0000-0000-0000-000000000000'
	SET @LiquidCrystalDisplayUid = NULL
if @AccessPortalElevatorControlTypeUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalElevatorControlTypeUid = NULL
if @OtisElevatorDecUid = '00000000-0000-0000-0000-000000000000'
	SET @OtisElevatorDecUid = NULL
if @ElevatorRelayInterfaceBoardSectionUid = '00000000-0000-0000-0000-000000000000'
	SET @ElevatorRelayInterfaceBoardSectionUid = NULL
if @ElevatorRelayInterfaceBoardSectionUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalMultiFactorModeUid = NULL

if @AccessPortalPropertiesUid = '00000000-0000-0000-0000-000000000000' OR @AccessPortalPropertiesUid IS NULL
	SET @AccessPortalPropertiesUid = NewID()

INSERT INTO GCS.AccessPortalProperties
(
AccessPortalPropertiesUid
,AccessPortalUid
,AutomaticForgivePassbackFrequencyUid
,PinRequiredModeUid
,AccessPortalContactSupervisionTypeUid
,AccessPortalDeferToServerBehaviorUid
,AccessPortalNoServerReplyBehaviorUid
,AccessPortalLockPushButtonBehaviorUid
,LiquidCrystalDisplayUid
,AccessPortalElevatorControlTypeUid
,OtisElevatorDecUid
,ElevatorRelayInterfaceBoardSectionUid
,AccessPortalMultiFactorModeUid
,UnlockDelay
,UnlockDuration
,RecloseDuration
,AllowPassbackAccess
,RequireTwoValidCredentials
,UnlockOnREX
,SuppressIllegalOpenLog
,SuppressOpenTooLongLog
,SuppressClosedLog
,SuppressREXLog
,LockWhenDoorCloses
,EnableDuress
,DoorGroupNotify
,DoorGroupCanDisable
,RelayOneOnDuringArmDelay
,RequireValidAccessForAutoUnlock
--,PINSpecifiesRecloseDuration
,ValidAccessRequiresDoorOpen
,DontDecrementLimitedSwipeExpireCount
,IgnoreNotInSystem
,ReaderSendsHeartbeat
,PhotoVerificationEnabled
,TimeAttendancePortal
,EMailEventsEnabled
,TransmitEventsEnabled
,FileOutputEnabled
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,GenerateDoorContactChangeLogs
) 
VALUES 
(
@AccessPortalPropertiesUid
,@AccessPortalUid
,@AutomaticForgivePassbackFrequencyUid
,@PinRequiredModeUid
,@AccessPortalContactSupervisionTypeUid
,@AccessPortalDeferToServerBehaviorUid
,@AccessPortalNoServerReplyBehaviorUid
,@AccessPortalLockPushButtonBehaviorUid
,@LiquidCrystalDisplayUid
,@AccessPortalElevatorControlTypeUid
,@OtisElevatorDecUid
,@ElevatorRelayInterfaceBoardSectionUid
,@AccessPortalMultiFactorModeUid
,@UnlockDelay
,@UnlockDuration
,@RecloseDuration
,@AllowPassbackAccess
,@RequireTwoValidCredentials
,@UnlockOnREX
,@SuppressIllegalOpenLog
,@SuppressOpenTooLongLog
,@SuppressClosedLog
,@SuppressREXLog
,@LockWhenDoorCloses
,@EnableDuress
,@DoorGroupNotify
,@DoorGroupCanDisable
,@RelayOneOnDuringArmDelay
,@RequireValidAccessForAutoUnlock
--,@PINSpecifiesRecloseDuration
,@ValidAccessRequiresDoorOpen
,@DontDecrementLimitedSwipeExpireCount
,@IgnoreNotInSystem
,@ReaderSendsHeartbeat
,@PhotoVerificationEnabled
,@TimeAttendancePortal
,@EMailEventsEnabled
,@TransmitEventsEnabled
,@FileOutputEnabled
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
,@GenerateDoorContactChangeLogs
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalPropertiesPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalPropertiesPDSA_Insert] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_SelectAll]
GO

/****** Object:  StoredProcedure [GCS].[AccessPortalPropertiesPDSA_SelectAll]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessPortalPropertiesPDSA_SelectAll]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
AccessPortalPropertiesUid
,AccessPortalUid
,AutomaticForgivePassbackFrequencyUid
,PinRequiredModeUid
,AccessPortalContactSupervisionTypeUid
,AccessPortalDeferToServerBehaviorUid
,AccessPortalNoServerReplyBehaviorUid
,AccessPortalLockPushButtonBehaviorUid
,LiquidCrystalDisplayUid
,AccessPortalElevatorControlTypeUid
,OtisElevatorDecUid
,ElevatorRelayInterfaceBoardSectionUid
,AccessPortalMultiFactorModeUid
,UnlockDelay
,UnlockDuration
,RecloseDuration
,AllowPassbackAccess
,RequireTwoValidCredentials
,UnlockOnREX
,SuppressIllegalOpenLog
,SuppressOpenTooLongLog
,SuppressClosedLog
,SuppressREXLog
,GenerateDoorContactChangeLogs
,LockWhenDoorCloses
,EnableDuress
,DoorGroupNotify
,DoorGroupCanDisable
,RelayOneOnDuringArmDelay
,RequireValidAccessForAutoUnlock
--,PINSpecifiesRecloseDuration
,ValidAccessRequiresDoorOpen
,DontDecrementLimitedSwipeExpireCount
,IgnoreNotInSystem
,ReaderSendsHeartbeat
,PhotoVerificationEnabled
,TimeAttendancePortal
,EMailEventsEnabled
,TransmitEventsEnabled
,FileOutputEnabled
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.AccessPortalProperties

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalPropertiesPDSA_SelectAll] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalPropertiesPDSA_SelectAll] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_SelectByPK]
GO

/****** Object:  StoredProcedure [GCS].[AccessPortalPropertiesPDSA_SelectByPK]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessPortalPropertiesPDSA_SelectByPK]
	@AccessPortalPropertiesUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
AccessPortalPropertiesUid
,AccessPortalUid
,AutomaticForgivePassbackFrequencyUid
,PinRequiredModeUid
,AccessPortalContactSupervisionTypeUid
,AccessPortalDeferToServerBehaviorUid
,AccessPortalNoServerReplyBehaviorUid
,AccessPortalLockPushButtonBehaviorUid
,LiquidCrystalDisplayUid
,AccessPortalElevatorControlTypeUid
,OtisElevatorDecUid
,ElevatorRelayInterfaceBoardSectionUid
,AccessPortalMultiFactorModeUid
,UnlockDelay
,UnlockDuration
,RecloseDuration
,AllowPassbackAccess
,RequireTwoValidCredentials
,UnlockOnREX
,SuppressIllegalOpenLog
,SuppressOpenTooLongLog
,SuppressClosedLog
,SuppressREXLog
,GenerateDoorContactChangeLogs
,LockWhenDoorCloses
,EnableDuress
,DoorGroupNotify
,DoorGroupCanDisable
,RelayOneOnDuringArmDelay
,RequireValidAccessForAutoUnlock
--,PINSpecifiesRecloseDuration
,ValidAccessRequiresDoorOpen
,DontDecrementLimitedSwipeExpireCount
,IgnoreNotInSystem
,ReaderSendsHeartbeat
,PhotoVerificationEnabled
,TimeAttendancePortal
,EMailEventsEnabled
,TransmitEventsEnabled
,FileOutputEnabled
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.AccessPortalProperties
WHERE 
AccessPortalPropertiesUid = @AccessPortalPropertiesUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalPropertiesPDSA_SelectByPK] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalPropertiesPDSA_SelectByPK] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_SelectSearch]
GO

/****** Object:  StoredProcedure [GCS].[AccessPortalPropertiesPDSA_SelectSearch]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessPortalPropertiesPDSA_SelectSearch]
	@InsertName [nvarchar](100)
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
AccessPortalPropertiesUid
,AccessPortalUid
,AutomaticForgivePassbackFrequencyUid
,PinRequiredModeUid
,AccessPortalContactSupervisionTypeUid
,AccessPortalDeferToServerBehaviorUid
,AccessPortalNoServerReplyBehaviorUid
,AccessPortalLockPushButtonBehaviorUid
,LiquidCrystalDisplayUid
,AccessPortalElevatorControlTypeUid
,OtisElevatorDecUid
,ElevatorRelayInterfaceBoardSectionUid
,AccessPortalMultiFactorModeUid
,UnlockDelay
,UnlockDuration
,RecloseDuration
,AllowPassbackAccess
,RequireTwoValidCredentials
,UnlockOnREX
,SuppressIllegalOpenLog
,SuppressOpenTooLongLog
,SuppressClosedLog
,SuppressREXLog
,GenerateDoorContactChangeLogs
,LockWhenDoorCloses
,EnableDuress
,DoorGroupNotify
,DoorGroupCanDisable
,RelayOneOnDuringArmDelay
,RequireValidAccessForAutoUnlock
--,PINSpecifiesRecloseDuration
,ValidAccessRequiresDoorOpen
,DontDecrementLimitedSwipeExpireCount
,IgnoreNotInSystem
,ReaderSendsHeartbeat
,PhotoVerificationEnabled
,TimeAttendancePortal
,EMailEventsEnabled
,TransmitEventsEnabled
,FileOutputEnabled
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.AccessPortalProperties
WHERE 
(@InsertName IS NULL OR InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalPropertiesPDSA_SelectSearch] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalPropertiesPDSA_SelectSearch] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalPropertiesPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE[GCS].[AccessPortalPropertiesPDSA_Update]
GO

/****** Object:  StoredProcedure [GCS].[AccessPortalPropertiesPDSA_Update]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessPortalPropertiesPDSA_Update]
	@AccessPortalPropertiesUid [uniqueidentifier],
	@AccessPortalUid [uniqueidentifier],
	@AutomaticForgivePassbackFrequencyUid [uniqueidentifier],
	@PinRequiredModeUid [uniqueidentifier],
	@AccessPortalContactSupervisionTypeUid [uniqueidentifier],
	@AccessPortalDeferToServerBehaviorUid [uniqueidentifier],
	@AccessPortalNoServerReplyBehaviorUid [uniqueidentifier],
	@AccessPortalLockPushButtonBehaviorUid [uniqueidentifier],
	@LiquidCrystalDisplayUid [uniqueidentifier],
	@AccessPortalElevatorControlTypeUid [uniqueidentifier],
	@OtisElevatorDecUid [uniqueidentifier],
	@ElevatorRelayInterfaceBoardSectionUid [uniqueidentifier],
	@AccessPortalMultiFactorModeUid [uniqueidentifier],
	@UnlockDelay [int],
	@UnlockDuration [int],
	@RecloseDuration [int],
	@AllowPassbackAccess [bit],
	@RequireTwoValidCredentials [bit],
	@UnlockOnREX [bit],
	@SuppressIllegalOpenLog [bit],
	@SuppressOpenTooLongLog [bit],
	@SuppressClosedLog [bit],
	@SuppressREXLog [bit],
	@LockWhenDoorCloses [bit],
	@EnableDuress [bit],
	@DoorGroupNotify [bit],
	@DoorGroupCanDisable [bit],
	@RelayOneOnDuringArmDelay [bit],
	@RequireValidAccessForAutoUnlock [bit],
	--@PINSpecifiesRecloseDuration [bit],
	@ValidAccessRequiresDoorOpen [bit],
	@DontDecrementLimitedSwipeExpireCount [bit],
	@IgnoreNotInSystem [bit],
	@ReaderSendsHeartbeat [bit],
	@PhotoVerificationEnabled [bit],
	@TimeAttendancePortal [bit],
	@EMailEventsEnabled [bit],
	@TransmitEventsEnabled [bit],
	@FileOutputEnabled [bit],
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@GenerateDoorContactChangeLogs [bit],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @AccessPortalPropertiesUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalPropertiesUid = NULL
if @AccessPortalUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalUid = NULL
if @AutomaticForgivePassbackFrequencyUid = '00000000-0000-0000-0000-000000000000'
	SET @AutomaticForgivePassbackFrequencyUid = NULL
if @PinRequiredModeUid = '00000000-0000-0000-0000-000000000000'
	SET @PinRequiredModeUid = NULL
if @AccessPortalContactSupervisionTypeUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalContactSupervisionTypeUid = NULL
if @AccessPortalDeferToServerBehaviorUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalDeferToServerBehaviorUid = NULL
if @AccessPortalNoServerReplyBehaviorUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalNoServerReplyBehaviorUid = NULL
if @AccessPortalLockPushButtonBehaviorUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalLockPushButtonBehaviorUid = NULL
if @LiquidCrystalDisplayUid = '00000000-0000-0000-0000-000000000000'
	SET @LiquidCrystalDisplayUid = NULL
if @AccessPortalElevatorControlTypeUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalElevatorControlTypeUid = NULL
if @OtisElevatorDecUid = '00000000-0000-0000-0000-000000000000'
	SET @OtisElevatorDecUid = NULL
if @ElevatorRelayInterfaceBoardSectionUid = '00000000-0000-0000-0000-000000000000'
	SET @ElevatorRelayInterfaceBoardSectionUid = NULL
if @AccessPortalMultiFactorModeUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalMultiFactorModeUid = NULL

UPDATE GCS.AccessPortalProperties
SET 
AccessPortalUid = @AccessPortalUid
,AutomaticForgivePassbackFrequencyUid = @AutomaticForgivePassbackFrequencyUid
,PinRequiredModeUid = @PinRequiredModeUid
,AccessPortalContactSupervisionTypeUid = @AccessPortalContactSupervisionTypeUid
,AccessPortalDeferToServerBehaviorUid = @AccessPortalDeferToServerBehaviorUid
,AccessPortalNoServerReplyBehaviorUid = @AccessPortalNoServerReplyBehaviorUid
,AccessPortalLockPushButtonBehaviorUid = @AccessPortalLockPushButtonBehaviorUid
,LiquidCrystalDisplayUid = @LiquidCrystalDisplayUid
,AccessPortalElevatorControlTypeUid = @AccessPortalElevatorControlTypeUid
,OtisElevatorDecUid = @OtisElevatorDecUid
,ElevatorRelayInterfaceBoardSectionUid = @ElevatorRelayInterfaceBoardSectionUid
,AccessPortalMultiFactorModeUid = @AccessPortalMultiFactorModeUid
,UnlockDelay = @UnlockDelay
,UnlockDuration = @UnlockDuration
,RecloseDuration = @RecloseDuration
,AllowPassbackAccess = @AllowPassbackAccess
,RequireTwoValidCredentials = @RequireTwoValidCredentials
,UnlockOnREX = @UnlockOnREX
,SuppressIllegalOpenLog = @SuppressIllegalOpenLog
,SuppressOpenTooLongLog = @SuppressOpenTooLongLog
,SuppressClosedLog = @SuppressClosedLog
,SuppressREXLog = @SuppressREXLog
,LockWhenDoorCloses = @LockWhenDoorCloses
,EnableDuress = @EnableDuress
,DoorGroupNotify = @DoorGroupNotify
,DoorGroupCanDisable = @DoorGroupCanDisable
,RelayOneOnDuringArmDelay = @RelayOneOnDuringArmDelay
,RequireValidAccessForAutoUnlock = @RequireValidAccessForAutoUnlock
--,PINSpecifiesRecloseDuration = @PINSpecifiesRecloseDuration
,ValidAccessRequiresDoorOpen = @ValidAccessRequiresDoorOpen
,DontDecrementLimitedSwipeExpireCount = @DontDecrementLimitedSwipeExpireCount
,IgnoreNotInSystem = @IgnoreNotInSystem
,ReaderSendsHeartbeat = @ReaderSendsHeartbeat
,PhotoVerificationEnabled = @PhotoVerificationEnabled
,TimeAttendancePortal = @TimeAttendancePortal
,EMailEventsEnabled = @EMailEventsEnabled
,TransmitEventsEnabled = @TransmitEventsEnabled
,FileOutputEnabled = @FileOutputEnabled
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,GenerateDoorContactChangeLogs = @GenerateDoorContactChangeLogs
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
AccessPortalPropertiesUid = @AccessPortalPropertiesUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalPropertiesPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalPropertiesPDSA_Update] TO [public] AS [dbo]
GO

-- Beginning of moving roles from a child of gcsApplication to a child of gcsEntity
exec dbo.[gcs_DeleteIndex] 'GCS', 'gcsRole', 'index_RoleName'
go


exec dbo.gcs_DeleteTrigger 'GCS', 'td_gcsrole'
go

exec dbo.gcs_DeleteTrigger 'GCS', 'ti_gcsrole'
go

exec dbo.gcs_DeleteTrigger 'GCS', 'tu_gcsrole'
go

create trigger GCS.ti_gcsrole on GCS.gcsRole for insert as
begin
    declare
       @maxcard  int,
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.gcsEntity" must exist when inserting a child in "GCS.gcsRole"  */
    if update(EntityId)
    begin
       if (select count(*)
           from   GCS.gcsEntity t1, inserted t2
           where  t1.EntityId = t2.EntityId) != @numrows
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.gcsEntity". Cannot create child in "GCS.gcsRole".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


create trigger GCS.tu_gcsrole on GCS.gcsRole for update as
begin
   declare
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.gcsEntity" must exist when updating a child in "GCS.gcsRole"  */
      if update(EntityId)
      begin
         if (select count(*)
             from   GCS.gcsEntity t1, inserted t2
             where  t1.EntityId = t2.EntityId) != @numrows
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.gcsEntity" does not exist. Cannot modify child in "GCS.gcsRole".'
               goto error
            end
      end

      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


if dbo.fn_GCSDoesColumnExist('gcsRole', 'ApplicationId') = 1
BEGIN
	alter table GCS.gcsRole
	drop column ApplicationId 
END
go  

IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'dbo'
                    AND specific_name = 'fn_GCSDoesForeignKeyConstraintExist'
                    AND Routine_Type = 'FUNCTION' ) 
DROP FUNCTION dbo.fn_GCSDoesForeignKeyConstraintExist
go

/****** Object:  UserDefinedFunction [dbo].[fn_GCSDoesForeignKeyConstraintExist]    Script Date: 8/31/2020 2:21:51 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER FUNCTION [dbo].[fn_GCSDoesForeignKeyConstraintExist] (@schema_name varchar(65), @table_name [nvarchar](65), @constraint_name [nvarchar](65))
RETURNS [int] WITH EXECUTE AS CALLER
AS 
BEGIN
  DECLARE @result as int
  SELECT @result = count(*) from INFORMATION_SCHEMA.TABLE_CONSTRAINTS
	where CONSTRAINT_TYPE='FOREIGN KEY' and TABLE_SCHEMA = @schema_name and TABLE_NAME = @table_name and CONSTRAINT_NAME = @constraint_name;
  RETURN @result
END
GO
ALTER AUTHORIZATION ON [dbo].[fn_GCSDoesForeignKeyConstraintExist] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [dbo].[fn_GCSDoesForeignKeyConstraintExist] TO [public] AS [dbo]
GO


if dbo.[fn_GCSDoesForeignKeyConstraintExist]('GCS', 'gcsApplication', 'FK_ApplicationSystemRole') = 1
BEGIN
	exec dbo.[gcs_DeleteFKConstraint] 'GCS', 'gcsApplication', 'FK_ApplicationSystemRole'
END
go

if dbo.fn_GCSDoesColumnExist('gcsApplication', 'SystemRoleId') = 1
BEGIN
	alter table GCS.gcsApplication
	drop column SystemRoleId 
END
go  

exec dbo.gcs_DeleteTrigger 'GCS', 'td_gcsapplication'
go

exec dbo.gcs_DeleteTrigger 'GCS', 'ti_gcsapplication'
go

exec dbo.gcs_DeleteTrigger 'GCS', 'tu_gcsapplication'
go


create trigger [GCS].[td_gcsapplication] on [GCS].[gcsApplication] for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Delete all children in "GCS.gcsPermissionCategory"  */
    delete GCS.gcsPermissionCategory
    from   GCS.gcsPermissionCategory t2, deleted t1
    where  t2.ApplicationId = t1.ApplicationId

    /*  Delete all children in "GCS.gcsSerializedObject"  */
    delete GCS.gcsSerializedObject
    from   GCS.gcsSerializedObject t2, deleted t1
    where  t2.ApplicationId = t1.ApplicationId

    return

/*  Errors handling  */
error:
    rollback  transaction
    RAISERROR(@errmsg, @errno, 1)
end
go

ALTER TABLE [GCS].[gcsApplication] ENABLE TRIGGER [td_gcsapplication]
GO

create trigger [GCS].[ti_gcsapplication] on [GCS].[gcsApplication] for insert as
begin
    declare
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.gcsLanguage" must exist when inserting a child in "GCS.gcsApplication"  */
    if update(LanguageId)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  LanguageId is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.gcsLanguage t1, inserted t2
              where  t1.LanguageId = t2.LanguageId) != @numrows - @numnull
          begin
             select @errno  = 2,
                    @errmsg = 'Parent does not exist in "GCS.gcsLanguage". Cannot create child in "GCS.gcsApplication".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    rollback  transaction
    RAISERROR(@errmsg, @errno, 1)
end
GO

ALTER TABLE [GCS].[gcsApplication] ENABLE TRIGGER [ti_gcsapplication]
GO

create trigger [GCS].[tu_gcsapplication] on [GCS].[gcsApplication] for update as
begin
   declare
      @ins_ApplicationId uniqueidentifier,
      @del_ApplicationId uniqueidentifier,
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.gcsLanguage" must exist when updating a child in "GCS.gcsApplication"  */
      if update(LanguageId)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  LanguageId is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.gcsLanguage t1, inserted t2
                where  t1.LanguageId = t2.LanguageId) != @numrows - @numnull
            begin
               select @errno  = 3,
                      @errmsg = 'GCS.gcsLanguage" does not exist. Cannot modify child in "GCS.gcsApplication".'
               goto error
            end
      end
      declare cIns cursor local for select 
              ApplicationId
          from inserted
      declare cDel cursor local for select 
              ApplicationId
          from deleted

      /*  Modify parent code of "GCS.gcsApplication" for all children in "GCS.gcsPermissionCategory"  */
      if update(ApplicationId)
      begin
         if @@rowcount = 1
            update GCS.gcsPermissionCategory
               set   ApplicationId = i1.ApplicationId
            from   GCS.gcsPermissionCategory t2, inserted i1, deleted d1
               where  t2.ApplicationId = d1.ApplicationId
                AND  (i1.ApplicationId != d1.ApplicationId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_ApplicationId
            fetch cDel into @del_ApplicationId

            while (@@fetch_status = 0)
            begin
               update GCS.gcsPermissionCategory
                  set   ApplicationId = @ins_ApplicationId
               where  ApplicationId = @del_ApplicationId
               fetch cIns into @ins_ApplicationId
               fetch cDel into @del_ApplicationId
            end
            close cIns
            close cDel
         end
      end

      /*  Modify parent code of "GCS.gcsApplication" for all children in "GCS.gcsSerializedObject"  */
      if update(ApplicationId)
      begin
         if @@rowcount = 1
            update GCS.gcsSerializedObject
               set   ApplicationId = i1.ApplicationId
            from   GCS.gcsSerializedObject t2, inserted i1, deleted d1
               where  t2.ApplicationId = d1.ApplicationId
                AND  (i1.ApplicationId != d1.ApplicationId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_ApplicationId
            fetch cDel into @del_ApplicationId

            while (@@fetch_status = 0)
            begin
               update GCS.gcsSerializedObject
                  set   ApplicationId = @ins_ApplicationId
               where  ApplicationId = @del_ApplicationId
               fetch cIns into @ins_ApplicationId
               fetch cDel into @del_ApplicationId
            end
            close cIns
            close cDel
         end
      end

      return

/*  Errors handling  */
error:
     rollback  transaction
     RAISERROR(@errmsg, @errno, 1)
end
GO

ALTER TABLE [GCS].[gcsApplication] ENABLE TRIGGER [tu_gcsapplication]
GO


if dbo.fn_GCSDoesTableExist('gcsUserEntityApplicationRole') = 1
BEGIN
	drop table GCS.gcsUserEntityApplicationRole
END
GO

if dbo.fn_GCSDoesTableExist('gcsEntityApplicationRole') = 1
BEGIN
	drop table GCS.gcsEntityApplicationRole
END
GO

if dbo.fn_GCSDoesTableExist('gcsEntityApplication') = 1
BEGIN
	drop table GCS.gcsEntityApplication
END
GO


exec dbo.gcs_DeleteTrigger 'GCS', 'td_gcsentity'
go

exec dbo.gcs_DeleteTrigger 'GCS', 'ti_gcsentity'
go

exec dbo.gcs_DeleteTrigger 'GCS', 'tU_gcsentity'
go


create trigger GCS.td_gcsentity on GCS.gcsEntity for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Cannot delete parent "GCS.gcsEntity" if children still exist in "GCS.Site"  */
    if exists (select 1
               from   GCS.Site t2, deleted t1
               where  t2.EntityId = t1.EntityId)
       begin
          select @errno  = 50006,
                 @errmsg = 'Children still exist in "GCS.Site". Cannot delete parent "GCS.gcsEntity".'
          goto error
       end

    /*  Cannot delete parent "GCS.gcsEntity" if children still exist in "GCS.AssaDsr"  */
    if exists (select 1
               from   GCS.AssaDsr t2, deleted t1
               where  t2.EntityId = t1.EntityId)
       begin
          select @errno  = 50006,
                 @errmsg = 'Children still exist in "GCS.AssaDsr". Cannot delete parent "GCS.gcsEntity".'
          goto error
       end

    /*  Delete all children in "GCS.gcsEntity"  */
    delete GCS.gcsEntity
    from   GCS.gcsEntity t2, deleted t1
    where  t2.ParentEntityId = t1.EntityId

    /*  Delete all children in "GCS.gcsEntityIdProducer"  */
    delete GCS.gcsEntityIdProducer
    from   GCS.gcsEntityIdProducer t2, deleted t1
    where  t2.EntityId = t1.EntityId

    /*  Delete all children in "GCS.Cluster"  */
    delete GCS.Cluster
    from   GCS.Cluster t2, deleted t1
    where  t2.EntityId = t1.EntityId

    /*  Delete all children in "GCS.AccessPortal"  */
    delete GCS.AccessPortal
    from   GCS.AccessPortal t2, deleted t1
    where  t2.EntityId = t1.EntityId

    /*  Delete all children in "GCS.DateType"  */
    delete GCS.DateType
    from   GCS.DateType t2, deleted t1
    where  t2.EntityId = t1.EntityId

    /*  Delete all children in "GCS.InputDevice"  */
    delete GCS.InputDevice
    from   GCS.InputDevice t2, deleted t1
    where  t2.EntityId = t1.EntityId

    /*  Delete all children in "GCS.OutputDevice"  */
    delete GCS.OutputDevice
    from   GCS.OutputDevice t2, deleted t1
    where  t2.EntityId = t1.EntityId

    /*  Delete all children in "GCS.LiquidCrystalDisplay"  */
    delete GCS.LiquidCrystalDisplay
    from   GCS.LiquidCrystalDisplay t2, deleted t1
    where  t2.EntityId = t1.EntityId

    /*  Delete all children in "GCS.gcsRole"  */
    delete GCS.gcsRole
    from   GCS.gcsRole t2, deleted t1
    where  t2.EntityId = t1.EntityId


    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


create trigger GCS.ti_gcsentity on GCS.gcsEntity for insert as
begin
    declare
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.gcsEntity" must exist when inserting a child in "GCS.gcsEntity"  */
    if update(ParentEntityId)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  ParentEntityId is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.gcsEntity t1, inserted t2
              where  t1.EntityId = t2.ParentEntityId) != @numrows - @numnull
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.gcsEntity". Cannot create child in "GCS.gcsEntity".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


create trigger GCS.tu_gcsentity on GCS.gcsEntity for update as
begin
   declare
      @ins_EntityId uniqueidentifier,
      @del_EntityId uniqueidentifier,
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.gcsEntity" must exist when updating a child in "GCS.gcsEntity"  */
      if update(ParentEntityId)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  ParentEntityId is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.gcsEntity t1, inserted t2
                where  t1.EntityId = t2.ParentEntityId) != @numrows - @numnull
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.gcsEntity" does not exist. Cannot modify child in "GCS.gcsEntity".'
               goto error
            end
      end
      declare cIns cursor local for select 
              EntityId
          from inserted
      declare cDel cursor local for select 
              EntityId
          from deleted

      /*  Modify parent code of "GCS.gcsEntity" for all children in "GCS.gcsEntity"  */
      if update(EntityId)
      begin
         if @@rowcount = 1
            update GCS.gcsEntity
               set   ParentEntityId = i1.EntityId
            from   GCS.gcsEntity t2, inserted i1, deleted d1
               where  t2.ParentEntityId = d1.EntityId
                and  (i1.EntityId != d1.EntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_EntityId
            fetch cDel into @del_EntityId

            while (@@fetch_status = 0)
            begin
               update GCS.gcsEntity
                  set   ParentEntityId = @ins_EntityId
               where  ParentEntityId = @del_EntityId
               fetch cIns into @ins_EntityId
               fetch cDel into @del_EntityId
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.gcsEntity" for all children in "GCS.gcsEntityIdProducer"  */
      if update(EntityId)
      begin
         if @@rowcount = 1
            update GCS.gcsEntityIdProducer
               set   EntityId = i1.EntityId
            from   GCS.gcsEntityIdProducer t2, inserted i1, deleted d1
               where  t2.EntityId = d1.EntityId
                and  (i1.EntityId != d1.EntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_EntityId
            fetch cDel into @del_EntityId

            while (@@fetch_status = 0)
            begin
               update GCS.gcsEntityIdProducer
                  set   EntityId = @ins_EntityId
               where  EntityId = @del_EntityId
               fetch cIns into @ins_EntityId
               fetch cDel into @del_EntityId
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.gcsEntity" for all children in "GCS.Cluster"  */
      if update(EntityId)
      begin
         if @@rowcount = 1
            update GCS.Cluster
               set   EntityId = i1.EntityId
            from   GCS.Cluster t2, inserted i1, deleted d1
               where  t2.EntityId = d1.EntityId
                and  (i1.EntityId != d1.EntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_EntityId
            fetch cDel into @del_EntityId

            while (@@fetch_status = 0)
            begin
               update GCS.Cluster
                  set   EntityId = @ins_EntityId
               where  EntityId = @del_EntityId
               fetch cIns into @ins_EntityId
               fetch cDel into @del_EntityId
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.gcsEntity" for all children in "GCS.Site"  */
      if update(EntityId)
      begin
         if @@rowcount = 1
            update GCS.Site
               set   EntityId = i1.EntityId
            from   GCS.Site t2, inserted i1, deleted d1
               where  t2.EntityId = d1.EntityId
                and  (i1.EntityId != d1.EntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_EntityId
            fetch cDel into @del_EntityId

            while (@@fetch_status = 0)
            begin
               update GCS.Site
                  set   EntityId = @ins_EntityId
               where  EntityId = @del_EntityId
               fetch cIns into @ins_EntityId
               fetch cDel into @del_EntityId
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.gcsEntity" for all children in "GCS.AssaDsr"  */
      if update(EntityId)
      begin
         if @@rowcount = 1
            update GCS.AssaDsr
               set   EntityId = i1.EntityId
            from   GCS.AssaDsr t2, inserted i1, deleted d1
               where  t2.EntityId = d1.EntityId
                and  (i1.EntityId != d1.EntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_EntityId
            fetch cDel into @del_EntityId

            while (@@fetch_status = 0)
            begin
               update GCS.AssaDsr
                  set   EntityId = @ins_EntityId
               where  EntityId = @del_EntityId
               fetch cIns into @ins_EntityId
               fetch cDel into @del_EntityId
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.gcsEntity" for all children in "GCS.AccessPortal"  */
      if update(EntityId)
      begin
         if @@rowcount = 1
            update GCS.AccessPortal
               set   EntityId = i1.EntityId
            from   GCS.AccessPortal t2, inserted i1, deleted d1
               where  t2.EntityId = d1.EntityId
                and  (i1.EntityId != d1.EntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_EntityId
            fetch cDel into @del_EntityId

            while (@@fetch_status = 0)
            begin
               update GCS.AccessPortal
                  set   EntityId = @ins_EntityId
               where  EntityId = @del_EntityId
               fetch cIns into @ins_EntityId
               fetch cDel into @del_EntityId
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.gcsEntity" for all children in "GCS.DateType"  */
      if update(EntityId)
      begin
         if @@rowcount = 1
            update GCS.DateType
               set   EntityId = i1.EntityId
            from   GCS.DateType t2, inserted i1, deleted d1
               where  t2.EntityId = d1.EntityId
                and  (i1.EntityId != d1.EntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_EntityId
            fetch cDel into @del_EntityId

            while (@@fetch_status = 0)
            begin
               update GCS.DateType
                  set   EntityId = @ins_EntityId
               where  EntityId = @del_EntityId
               fetch cIns into @ins_EntityId
               fetch cDel into @del_EntityId
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.gcsEntity" for all children in "GCS.InputDevice"  */
      if update(EntityId)
      begin
         if @@rowcount = 1
            update GCS.InputDevice
               set   EntityId = i1.EntityId
            from   GCS.InputDevice t2, inserted i1, deleted d1
               where  t2.EntityId = d1.EntityId
                and  (i1.EntityId != d1.EntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_EntityId
            fetch cDel into @del_EntityId

            while (@@fetch_status = 0)
            begin
               update GCS.InputDevice
                  set   EntityId = @ins_EntityId
               where  EntityId = @del_EntityId
               fetch cIns into @ins_EntityId
               fetch cDel into @del_EntityId
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.gcsEntity" for all children in "GCS.OutputDevice"  */
      if update(EntityId)
      begin
         if @@rowcount = 1
            update GCS.OutputDevice
               set   EntityId = i1.EntityId
            from   GCS.OutputDevice t2, inserted i1, deleted d1
               where  t2.EntityId = d1.EntityId
                and  (i1.EntityId != d1.EntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_EntityId
            fetch cDel into @del_EntityId

            while (@@fetch_status = 0)
            begin
               update GCS.OutputDevice
                  set   EntityId = @ins_EntityId
               where  EntityId = @del_EntityId
               fetch cIns into @ins_EntityId
               fetch cDel into @del_EntityId
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.gcsEntity" for all children in "GCS.LiquidCrystalDisplay"  */
      if update(EntityId)
      begin
         if @@rowcount = 1
            update GCS.LiquidCrystalDisplay
               set   EntityId = i1.EntityId
            from   GCS.LiquidCrystalDisplay t2, inserted i1, deleted d1
               where  t2.EntityId = d1.EntityId
                and  (i1.EntityId != d1.EntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_EntityId
            fetch cDel into @del_EntityId

            while (@@fetch_status = 0)
            begin
               update GCS.LiquidCrystalDisplay
                  set   EntityId = @ins_EntityId
               where  EntityId = @del_EntityId
               fetch cIns into @ins_EntityId
               fetch cDel into @del_EntityId
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.gcsEntity" for all children in "GCS.gcsRole"  */
      if update(EntityId)
      begin
         if @@rowcount = 1
            update GCS.gcsRole
               set   EntityId = i1.EntityId
            from   GCS.gcsRole t2, inserted i1, deleted d1
               where  t2.EntityId = d1.EntityId
                and  (i1.EntityId != d1.EntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_EntityId
            fetch cDel into @del_EntityId

            while (@@fetch_status = 0)
            begin
               update GCS.gcsRole
                  set   EntityId = @ins_EntityId
               where  EntityId = @del_EntityId
               fetch cIns into @ins_EntityId
               fetch cDel into @del_EntityId
            end
            close cIns
            close cDel
         end
      end

      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


if dbo.fn_GCSDoesTableExist('gcsUserGroup') = 0
begin
	/*==============================================================*/
	/* Table: gcsUserGroup                                          */
	/*==============================================================*/
	create table GCS.gcsUserGroup (
	   UserGroupId          GCS.UniversalUniqueId    RowGuidCol not null,
	   Name                 GCS.Text65               not null,
	   Description          GCS.Text255              not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1,
	   constraint PK_GCSUSERGROUP primary key (UserGroupId))

	/*==============================================================*/
	/* Index: idxUserGroupName                                      */
	/*==============================================================*/
	create unique nonclustered index idxUserGroupName on GCS.gcsUserGroup (Name ASC)
end
go


if dbo.fn_GCSDoesTableExist('gcsUserGroupEntity') = 0
begin
	/*==============================================================*/
	/* Table: gcsUserGroupEntity                                    */
	/*==============================================================*/
	create table GCS.gcsUserGroupEntity (
	   UserGroupEntityId    GCS.UniversalUniqueId    RowGuidCol not null,
	   UserGroupId          uniqueidentifier     not null,
	   EntityId             uniqueidentifier     not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1,
	   constraint PK_GCSUSERGROUPENTITY primary key (UserGroupEntityId))

	/*==============================================================*/
	/* Index: idxUserGroupIdEntityId                                */
	/*==============================================================*/
	create unique nonclustered index idxUserGroupIdEntityId on GCS.gcsUserGroupEntity (UserGroupId ASC,
	  EntityId ASC)

	alter table GCS.gcsUserGroupEntity
	   add constraint FK_UserGroupEntityUserGroup foreign key (UserGroupId)
		  references GCS.gcsUserGroup (UserGroupId)
			 on update cascade on delete cascade
end
go

exec dbo.gcs_DeleteTrigger 'GCS', 'td_gcsusergroupentity'
go

create trigger GCS.td_gcsusergroupentity on GCS.gcsUserGroupEntity for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Delete all children in "GCS.gcsUserGroupEntityRole"  */
    delete GCS.gcsUserGroupEntityRole
    from   GCS.gcsUserGroupEntityRole t2, deleted t1
    where  t2.UserGroupEntityId = t1.UserGroupEntityId


    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go

exec dbo.gcs_DeleteTrigger 'GCS', 'ti_gcsusergroupentity'
go


create trigger GCS.ti_gcsusergroupentity on GCS.gcsUserGroupEntity for insert as
begin
    declare
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.gcsEntity" must exist when inserting a child in "GCS.gcsUserGroupEntity"  */
    if update(EntityId)
    begin
       if (select count(*)
           from   GCS.gcsEntity t1, inserted t2
           where  t1.EntityId = t2.EntityId) != @numrows
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.gcsEntity". Cannot create child in "GCS.gcsUserGroupEntity".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go

exec dbo.gcs_DeleteTrigger 'GCS', 'tu_gcsusergroupentity'
go

create trigger GCS.tu_gcsusergroupentity on GCS.gcsUserGroupEntity for update as
begin
   declare
      @ins_UserGroupEntityId uniqueidentifier,
      @del_UserGroupEntityId uniqueidentifier,
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.gcsEntity" must exist when updating a child in "GCS.gcsUserGroupEntity"  */
      if update(EntityId)
      begin
         if (select count(*)
             from   GCS.gcsEntity t1, inserted t2
             where  t1.EntityId = t2.EntityId) != @numrows
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.gcsEntity" does not exist. Cannot modify child in "GCS.gcsUserGroupEntity".'
               goto error
            end
      end
      declare cIns cursor local for select 
              UserGroupEntityId
          from inserted
      declare cDel cursor local for select 
              UserGroupEntityId
          from deleted

      /*  Modify parent code of "GCS.gcsUserGroupEntity" for all children in "GCS.gcsUserGroupEntityRole"  */
      if update(UserGroupEntityId)
      begin
         if @@rowcount = 1
            update GCS.gcsUserGroupEntityRole
               set   UserGroupEntityId = i1.UserGroupEntityId
            from   GCS.gcsUserGroupEntityRole t2, inserted i1, deleted d1
               where  t2.UserGroupEntityId = d1.UserGroupEntityId
                and  (i1.UserGroupEntityId != d1.UserGroupEntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_UserGroupEntityId
            fetch cDel into @del_UserGroupEntityId

            while (@@fetch_status = 0)
            begin
               update GCS.gcsUserGroupEntityRole
                  set   UserGroupEntityId = @ins_UserGroupEntityId
               where  UserGroupEntityId = @del_UserGroupEntityId
               fetch cIns into @ins_UserGroupEntityId
               fetch cDel into @del_UserGroupEntityId
            end
            close cIns
            close cDel
         end
      end

      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go

if dbo.fn_GCSDoesTableExist('gcsUserGroupEntityRole') = 0
begin
	/*==============================================================*/
	/* Table: gcsUserGroupEntityRole                                */
	/*==============================================================*/
	create table GCS.gcsUserGroupEntityRole (
	   UserGroupEntityRoleId GCS.UniversalUniqueId    RowGuidCol not null,
	   UserGroupEntityId    uniqueidentifier     not null,
	   RoleId               uniqueidentifier     not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1,
	   constraint PK_GCSUSERGROUPENTITYROLE primary key (UserGroupEntityRoleId))

	alter table GCS.gcsUserGroupEntityRole
	   add constraint FK_UserGroupEntityRoleRole foreign key (RoleId)
		  references GCS.gcsRole (RoleId)
			 on update cascade on delete cascade
end
go

exec dbo.gcs_DeleteTrigger 'GCS', 'ti_gcsusergroupentityrole'
go

create trigger GCS.ti_gcsusergroupentityrole on GCS.gcsUserGroupEntityRole for insert as
begin
    declare
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.gcsUserGroupEntity" must exist when inserting a child in "GCS.gcsUserGroupEntityRole"  */
    if update(UserGroupEntityId)
    begin
       if (select count(*)
           from   GCS.gcsUserGroupEntity t1, inserted t2
           where  t1.UserGroupEntityId = t2.UserGroupEntityId) != @numrows
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.gcsUserGroupEntity". Cannot create child in "GCS.gcsUserGroupEntityRole".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go

exec dbo.gcs_DeleteTrigger 'GCS', 'tu_gcsusergroupentityrole'
go

create trigger GCS.tu_gcsusergroupentityrole on GCS.gcsUserGroupEntityRole for update as
begin
   declare
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.gcsUserGroupEntity" must exist when updating a child in "GCS.gcsUserGroupEntityRole"  */
      if update(UserGroupEntityId)
      begin
         if (select count(*)
             from   GCS.gcsUserGroupEntity t1, inserted t2
             where  t1.UserGroupEntityId = t2.UserGroupEntityId) != @numrows
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.gcsUserGroupEntity" does not exist. Cannot modify child in "GCS.gcsUserGroupEntityRole".'
               goto error
            end
      end

      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go




if dbo.fn_GCSDoesTableExist('gcsUserUserGroup') = 0
begin
	/*==============================================================*/
	/* Table: gcsUserUserGroup                                      */
	/*==============================================================*/
	create table GCS.gcsUserUserGroup (
	   UserUserGroupId      GCS.UniversalUniqueId    RowGuidCol not null,
	   UserGroupId          uniqueidentifier     not null,
	   UserId               uniqueidentifier     not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1,
	   constraint PK_GCSUSERUSERGROUP primary key (UserUserGroupId))

	/*==============================================================*/
	/* Index: idxUserUserGroupUser                                  */
	/*==============================================================*/
	create unique nonclustered index idxUserUserGroupUser on GCS.gcsUserUserGroup (UserGroupId ASC,
	  UserId ASC)
end
go

if dbo.[fn_GCSDoesForeignKeyConstraintExist]('GCS', 'gcsUserUserGroup', 'FK_UserUserGroupUser') = 0
BEGIN
	alter table GCS.gcsUserUserGroup
	   add constraint FK_UserUserGroupUser foreign key (UserId)
		  references GCS.gcsUser (UserId)
			 on update cascade on delete cascade
END
go

if dbo.[fn_GCSDoesForeignKeyConstraintExist]('GCS', 'gcsUserUserGroup', 'FK_UserUserGroupUserGroup') = 0
BEGIN
	alter table GCS.gcsUserUserGroup
	   add constraint FK_UserUserGroupUserGroup foreign key (UserGroupId)
		  references GCS.gcsUserGroup (UserGroupId)
			 on update cascade on delete cascade
END
go

/* All Stored Procedures for table: gcsUserEntityRole */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsUserEntityRole table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityRoleId
,UserEntityId
,t.RoleId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RoleName
FROM GCS.gcsUserEntityRole t
JOIN GCS.gcsRole r on r.RoleId = t.RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.gcsUserEntityRole table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityRoleId
,InsertName
FROM GCS.gcsUserEntityRole

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUserEntityRole table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_SelectByPK]
@UserEntityRoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityRoleId
,UserEntityId
,t.RoleId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RoleName
FROM GCS.gcsUserEntityRole t
JOIN GCS.gcsRole r on r.RoleId = t.RoleId
WHERE 
UserEntityRoleId = @UserEntityRoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsUserEntityRole table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityRoleId
,UserEntityId
,t.RoleId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RoleName
FROM GCS.gcsUserEntityRole t
JOIN GCS.gcsRole r on r.RoleId = t.RoleId
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUserEntityRole table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_ByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_ByRoleId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_ByRoleId]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityRoleId
,UserEntityId
,t.RoleId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RoleName
FROM GCS.gcsUserEntityRole t
JOIN GCS.gcsRole r on r.RoleId = t.RoleId
WHERE 
t.RoleId = @RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_ByRoleId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUserEntityRole table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_ByEntityId]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityRoleId
,UserEntityId
,t.RoleId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RoleName
FROM GCS.gcsUserEntityRole t
JOIN GCS.gcsRole r on r.RoleId = t.RoleId
WHERE 
UserEntityId in (SELECT UserEntityId FROM GCS.gcsUserEntity WHERE EntityId = @EntityId)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_ByEntityId] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsUserEntityRole table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_ByUserEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_ByUserEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_ByUserEntityId]
@UserEntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityRoleId
,UserEntityId
,t.RoleId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RoleName
FROM GCS.gcsUserEntityRole t
JOIN GCS.gcsRole r on r.RoleId = t.RoleId
WHERE 
UserEntityId= @UserEntityId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_ByUserEntityId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_ByUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_ByUserId]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_ByUserId]
@UserId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
UserEntityRoleId
,UserEntityId
,t.RoleId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RoleName
FROM GCS.gcsUserEntityRole t
JOIN GCS.gcsRole r on r.RoleId = t.RoleId
WHERE 
UserEntityId in (SELECT UserEntityId FROM GCS.gcsUserEntity WHERE UserId = @UserId)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_ByUserId] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.gcsUserEntityRole table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_Insert]
@UserEntityRoleId uniqueidentifier 
,@UserEntityId uniqueidentifier 
,@RoleId uniqueidentifier 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @UserEntityRoleId = '00000000-0000-0000-0000-000000000000'
	SET @UserEntityRoleId = NULL

if @UserEntityRoleId = '00000000-0000-0000-0000-000000000000' OR @UserEntityRoleId IS NULL
	SET @UserEntityRoleId = NewID()

INSERT INTO GCS.gcsUserEntityRole
(
UserEntityRoleId
,UserEntityId
,RoleId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@UserEntityRoleId
,@UserEntityId
,@RoleId
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsUserEntityRole table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_Update]
@UserEntityRoleId uniqueidentifier 
,@UserEntityId uniqueidentifier
,@RoleId uniqueidentifier
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsUserEntityRole
SET 
UserEntityRoleId = @UserEntityRoleId
,UserEntityId = @UserEntityId
,RoleId = @RoleId
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
UserEntityRoleId = @UserEntityRoleId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsUserEntityRole table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_UpdateConcurrency]
@UserEntityRoleId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsUserEntityRole
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
UserEntityRoleId = @UserEntityRoleId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsUserEntityRole table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_DeleteByPK]
@UserEntityRoleId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsUserEntityRole
WHERE
UserEntityRoleId = @UserEntityRoleId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsUserEntityRole table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRolePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRolePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRolePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsUserEntityRole

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRolePDSA_RowCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_IsUserEntityRoleUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_IsUserEntityRoleUnique]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcs_IsUserEntityRoleUnique]
	@UserEntityRoleId [uniqueidentifier],
	@UserEntityId [uniqueidentifier],
	@RoleId [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from GCS.gcsUserEntityRole where UserEntityRoleId <> @UserEntityRoleId AND (UserEntityId = @UserEntityId AND RoleId = @RoleId)
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[gcs_IsUserEntityRoleUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_IsUserEntityRoleUnique] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_IsRoleUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_IsRoleUnique]
GO

/****** Object:  StoredProcedure [GCS].[gcs_IsRoleUnique]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcs_IsRoleUnique]
	@RoleId [uniqueidentifier],
	@RoleName [nvarchar](65),
	@EntityId [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from GCS.gcsRole where RoleId <> @RoleId AND ( RoleName = @RoleName AND EntityId = @EntityId)
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[gcs_IsRoleUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_IsRoleUnique] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_IsEntityApplicationRoleUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_IsEntityApplicationRoleUnique]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_IsEntityApplicationUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_IsEntityApplicationUnique]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_IsUserEntityApplicationRoleUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_IsUserEntityApplicationRoleUnique]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_IsUserInRole]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_IsUserInRole]
GO

/****** Object:  StoredProcedure [GCS].[gcs_IsUserInRole]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcs_IsUserInRole]
	@UserId [uniqueidentifier],
	@EntityId [uniqueidentifier],
	@RoleId [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from gcs.gcsUser u
	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
	join gcs.gcsEntity e on ue.EntityId = e.EntityId
	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	join gcs.gcsRole r on r.RoleId = uer.RoleId
	where u.UserId = @UserId AND e.EntityId = @EntityId AND r.RoleId = @RoleId

	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[gcs_IsUserInRole] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_IsUserInRole] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_IsUserInRoleName]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_IsUserInRoleName]
GO

/****** Object:  StoredProcedure [GCS].[gcs_IsUserInRoleName]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcs_IsUserInRoleName]
	@UserId [uniqueidentifier],
	@EntityId [uniqueidentifier],
	@RoleName [nvarchar](65),
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from gcs.gcsUser u
	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
	join gcs.gcsEntity e on ue.EntityId = e.EntityId
	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	join gcs.gcsRole r on r.RoleId = uer.RoleId
	where u.UserId = @UserId AND e.EntityId = @EntityId AND r.RoleName = @RoleName

	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[gcs_IsUserInRoleName] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_IsUserInRoleName] TO [public] AS [dbo]
GO

CREATE OR ALTER FUNCTION [GCS].[fn_GCSDoesUserHavePermission] (	
	@UserId [uniqueidentifier],
	@EntityId [uniqueidentifier],
	@PermissionId [uniqueidentifier])
	returns int
AS
BEGIN
declare @Result int
	select @Result = count(*) from gcs.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity e on ue.EntityId = e.EntityId
		join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join gcs.gcsRole r on r.RoleId = uer.RoleId
		join gcs.gcsRolePermission rp on rp.RoleId = r.RoleId
		join gcs.gcsPermission p on p.PermissionId = rp.PermissionId
			where u.UserId = @UserId AND e.EntityId = @EntityId AND p.PermissionId = @PermissionId
			AND r.IsActive = 1 and p.IsActive = 1 and e.IsActive = 1

	if @Result <> 0
	begin
		--print 'User has permission explicitly'
		return 1--@Result
	end	

	-- See if the user has role for the entity that is an administrator role
	if @Result = 0
	BEGIN
		select @Result = count(*) from gcs.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity e on ue.EntityId = e.EntityId
		join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
		join gcs.gcsRole r on r.RoleId = uer.RoleId
			where u.UserId = @UserId AND e.EntityId = @EntityId
			AND r.IsActive = 1 and r.IsAdministratorRole = 1
	END
	
	if @Result <> 0
	begin
		--print 'User has role that IsAdministratorRole=1'
		return 2--@Result
	end	

	-- If the @Result is 0, then see if the user has IsAdministrator=1 or if the user has the permission via inherited permissions from a higher level entity
	if @Result = 0
	BEGIN
		-- Check to see if the user has entity access and their UserEntity.IsAdministrator = 1. If so, they don't need to have explicit permissions
		select @Result = count(*) from gcs.gcsUser u
		join gcs.gcsUserEntity ue on ue.UserId = u.UserId
		join gcs.gcsEntity e on ue.EntityId = e.EntityId
			where u.UserId = @UserId AND e.EntityId = @EntityId AND e.IsActive = 1 AND ue.IsAdministrator = 1
	END
	
	if @Result <> 0
	begin
		--print 'User has permission because they have IsAdministrator to the entity'
		return 3--@Result
	end

	if @Result = 0
	BEGIN
		-- See if the user has the permission via inherited permissions from a higher level entity		
		declare @inheritParentRoles bit
		select @inheritParentRoles = InheritParentRoles from GCS.gcsUserEntity where UserId = @UserId AND EntityId = @EntityId
		if @inheritParentRoles IS NOT NULL AND @inheritParentRoles = 1
		BEGIN
			declare @parentEntityId uniqueidentifier
			select @parentEntityId = ParentEntityId from GCS.gcsEntity where EntityId = @EntityId
			IF @parentEntityId IS NOT NULL AND @parentEntityId <> @EntityId
			BEGIN
				--print 'Checking parent level entity'
				set @Result = [GCS].[fn_GCSDoesUserHavePermission] ( @UserId, @parentEntityId, @PermissionId)
				
				if @Result <> 0
				BEGIN
					--print 'User has permission because they have inherited the permission from a higher tier entity'
					return 4--@Result
				END
			END
		END
	END

	return @Result
END
GO
ALTER AUTHORIZATION ON [GCS].[fn_GCSDoesUserHavePermission] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[fn_GCSDoesUserHavePermission] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_DoesUserHavePermission]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_DoesUserHavePermission]
GO

CREATE OR ALTER PROCEDURE [GCS].[gcs_DoesUserHavePermission]
	@UserId [uniqueidentifier],
	@EntityId [uniqueidentifier],
	@PermissionId [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
	set @Result = GCS.fn_GCSDoesUserHavePermission (@UserId, @EntityId, @PermissionId)
	if @Result = 1
		print 'User has permission explicitly'
	if @Result = 2
		print 'User has permission because they have an IsAdministratorRole to the entity'
	if @Result = 3
		print 'User has permission because they have IsAdministrator to the entity'
	if @Result = 4
		print 'User has permission because they have inherited the permission from a higher tier entity'
	
	--select @Result = count(*) from gcs.gcsUser u
	--	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
	--	join gcs.gcsEntity e on ue.EntityId = e.EntityId
	--	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
	--	join gcs.gcsRole r on r.RoleId = uer.RoleId
	--	join gcs.gcsRolePermission rp on rp.RoleId = r.RoleId
	--	join gcs.gcsPermission p on p.PermissionId = rp.PermissionId
	--		where u.UserId = @UserId AND e.EntityId = @EntityId AND p.PermissionId = @PermissionId
	--		AND r.IsActive = 1 and p.IsActive = 1 and e.IsActive = 1

	--if @Result <> 0
	--begin
	--	print 'User has permission explicitly'
	--	select @Result as Result		
	--	return
	--end	

	---- If the @Result is 0, then see if the user has IsAdministrator=1 or if the user has the permission via inherited permissions from a higher level entity
	--if @Result = 0
	--BEGIN
	--	-- Check to see if the user has entity access and their UserEntity.IsAdministrator = 1. If so, they don't need to have explicit permissions
	--	select @Result = count(*) from gcs.gcsUser u
	--	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
	--	join gcs.gcsEntity e on ue.EntityId = e.EntityId
	--		where u.UserId = @UserId AND e.EntityId = @EntityId AND e.IsActive = 1 AND ue.IsAdministrator = 1
	--END
	
	--if @Result <> 0
	--begin
	--	print 'User has permission because they have IsAdministrator to the entity'
	--	select @Result as Result	
	--	return
	--end

	--if @Result = 0
	--BEGIN
	--	-- See if the user has the permission via inherited permissions from a higher level entity		
	--	declare @parentEntityId uniqueidentifier
	--	select @parentEntityId = ParentEntityId from GCS.gcsEntity where EntityId = @EntityId
	--	IF @parentEntityId IS NOT NULL AND @parentEntityId <> @EntityId
	--	BEGIN
	--		print 'Checking parent level entity'
	--		EXEC [GCS].[gcs_DoesUserHavePermission] @UserId, @parentEntityId, @PermissionId, @Result OUTPUT
				
	--		if @Result <> 0
	--		begin
	--			print 'User has permission because they have inherited the permission from a higher tier entity'
	--			select @Result as Result	
	--			return
	--		end
	--	END
	--END
	set nocount on

	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[gcs_DoesUserHavePermission] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_DoesUserHavePermission] TO [public] AS [dbo]
GO




--/****** Object:  StoredProcedure [GCS].[gcs_DoesUserHavePermission]    Script Date: 8/31/2020 2:22:23 PM ******/
--SET ANSI_NULLS ON
--GO
--SET QUOTED_IDENTIFIER ON
--GO
--CREATE OR ALTER PROCEDURE [GCS].[gcs_DoesUserHavePermission]
--	@UserId [uniqueidentifier],
--	@EntityId [uniqueidentifier],
--	@PermissionId [uniqueidentifier],
--	@Result [int] OUTPUT
--WITH EXECUTE AS CALLER
--AS
--select @Result = count(*) from gcs.gcsUser u
--	join gcs.gcsUserEntity ue on ue.UserId = u.UserId
--	join gcs.gcsEntity e on ue.EntityId = e.EntityId
--	join gcs.gcsUserEntityRole uer on uer.UserEntityId = ue.UserEntityId
--	join gcs.gcsRole r on r.RoleId = uer.RoleId
--	join gcs.gcsRolePermission rp on rp.RoleId = r.RoleId
--	join gcs.gcsPermission p on p.PermissionId = rp.PermissionId
--		where u.UserId = @UserId AND e.EntityId = @EntityId AND p.PermissionId = @PermissionId
--		AND r.IsActive = 1 and p.IsActive = 1 and e.IsActive = 1

--	select @Result as Result
--GO
ALTER AUTHORIZATION ON [GCS].[gcs_DoesUserHavePermission] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_DoesUserHavePermission] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRole_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRole_ByEntityId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRole_BySystemRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRole_BySystemRoleId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRoleEntity_BySystemRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRoleEntity_BySystemRoleId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_DeleteByPK]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_Insert]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_RowCount]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_SelectAll]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_SelectAllForApplication]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_SelectAllForApplication]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_SelectAllForEntity]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_SelectAllForEntity]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_SelectByPK]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_SelectListBox]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_SelectSearch]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_Update]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplication_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplication_UpdateConcurrency]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_DeleteByPK]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_Insert]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_RowCount]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_SelectAll]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_SelectByApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_SelectByApplicationId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_SelectByEntityApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_SelectByEntityApplicationId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_SelectByPK]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_SelectListBox]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_SelectSearch]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_Update]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntityApplicationRole_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntityApplicationRole_UpdateConcurrency]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_ByEntityApplicationRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_ByEntityApplicationRoleId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_ByUserEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_ByUserEntityId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_ByUserEntityIdApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_ByUserEntityIdApplicationId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_ByUserEntityIdRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_ByUserEntityIdRoleId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_ByUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_ByUserId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_ByUserIdEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_ByUserIdEntityId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_ByUserIdEntityIdApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_ByUserIdEntityIdApplicationId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_DeleteByPK]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_Insert]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_RowCount]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_SelectAll]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_SelectByPK]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_SelectListBox]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_SelectSearch]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_Update]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityApplicationRole_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityApplicationRole_UpdateConcurrency]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleClusterPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleClusterPDSA_Insert]
GO

CREATE OR ALTER PROCEDURE [GCS].[RoleClusterPDSA_Insert]
	@RoleClusterUid [uniqueidentifier],
	@RoleId [uniqueidentifier],
	@ClusterUid [uniqueidentifier],
	@IncludeAllAccessPortals bit,
	@IncludeAllInputOutputGroups bit,
	@IncludeAllInputDevices bit,
	@IncludeAllOutputDevices bit,
	@InsertName [nvarchar](100),
	@InsertDate [datetimeoffset],
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @RoleClusterUid = '00000000-0000-0000-0000-000000000000'
	SET @RoleClusterUid = NULL

if @RoleClusterUid = '00000000-0000-0000-0000-000000000000' OR @RoleClusterUid IS NULL
	SET @RoleClusterUid = NewID()

INSERT INTO GCS.RoleCluster
(
RoleClusterUid
,RoleId
,ClusterUid
,IncludeAllAccessPortals
,IncludeAllInputOutputGroups
,IncludeAllInputDevices
,IncludeAllOutputDevices
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@RoleClusterUid
,@RoleId
,@ClusterUid
,@IncludeAllAccessPortals
,@IncludeAllInputOutputGroups
,@IncludeAllInputDevices
,@IncludeAllOutputDevices
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[RoleClusterPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[RoleClusterPDSA_Insert] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleClusterPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleClusterPDSA_Update]
GO

CREATE OR ALTER PROCEDURE [GCS].[RoleClusterPDSA_Update]
	@RoleClusterUid [uniqueidentifier],
	@RoleId [uniqueidentifier],
	@ClusterUid [uniqueidentifier],
	@IncludeAllAccessPortals bit,
	@IncludeAllInputOutputGroups bit,
	@IncludeAllInputDevices bit,
	@IncludeAllOutputDevices bit,
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

UPDATE GCS.RoleCluster
SET 
RoleClusterUid = @RoleClusterUid
,RoleId = @RoleId
,ClusterUid = @ClusterUid
,IncludeAllAccessPortals = @IncludeAllAccessPortals
,IncludeAllInputOutputGroups = @IncludeAllInputOutputGroups
,IncludeAllInputDevices = @IncludeAllInputDevices
,IncludeAllOutputDevices = @IncludeAllOutputDevices
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
RoleClusterUid = @RoleClusterUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[RoleClusterPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[RoleClusterPDSA_Update] TO [public] AS [dbo]
GO

/* All Stored Procedures for table: RoleFilters */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.RoleFilters table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleFiltersPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleFiltersPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleFiltersPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleId
,IncludeAllRegions
,IncludeAllSites
,IncludeAllClusters
,IncludeAllAccessPortals
,IncludeAllInputOutputGroups
,IncludeAllInputDevices
,IncludeAllOutputDevices
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleFilters

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleFiltersPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.RoleFilters table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleFiltersPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleFiltersPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleFiltersPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleId
,InsertName
FROM GCS.RoleFilters

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleFiltersPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleFilters table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleFiltersPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleFiltersPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleFiltersPDSA_SelectByPK]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleId
,IncludeAllRegions
,IncludeAllSites
,IncludeAllClusters
,IncludeAllAccessPortals
,IncludeAllInputOutputGroups
,IncludeAllInputDevices
,IncludeAllOutputDevices
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleFilters
WHERE 
RoleId = @RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleFiltersPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.RoleFilters table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleFiltersPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleFiltersPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleFiltersPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleId
,IncludeAllRegions
,IncludeAllSites
,IncludeAllClusters
,IncludeAllAccessPortals
,IncludeAllInputOutputGroups
,IncludeAllInputDevices
,IncludeAllOutputDevices
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleFilters
WHERE 
(@InsertName IS NULL OR InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleFiltersPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.RoleFilters table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleFiltersPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleFiltersPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleFiltersPDSA_Insert]
@RoleId uniqueidentifier 
,@IncludeAllRegions bit 
,@IncludeAllSites bit 
,@IncludeAllClusters bit 
,@IncludeAllAccessPortals bit 
,@IncludeAllInputOutputGroups bit 
,@IncludeAllInputDevices bit 
,@IncludeAllOutputDevices bit 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

INSERT INTO GCS.RoleFilters
(
RoleId
,IncludeAllRegions
,IncludeAllSites
,IncludeAllClusters
,IncludeAllAccessPortals 
,IncludeAllInputOutputGroups 
,IncludeAllInputDevices 
,IncludeAllOutputDevices 
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@RoleId
,@IncludeAllRegions
,@IncludeAllSites
,@IncludeAllClusters
,@IncludeAllAccessPortals 
,@IncludeAllInputOutputGroups 
,@IncludeAllInputDevices 
,@IncludeAllOutputDevices 
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleFiltersPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.RoleFilters table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleFiltersPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleFiltersPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleFiltersPDSA_Update]
@RoleId uniqueidentifier 
,@IncludeAllRegions bit
,@IncludeAllSites bit
,@IncludeAllClusters bit
,@IncludeAllAccessPortals bit
,@IncludeAllInputOutputGroups bit 
,@IncludeAllInputDevices bit
,@IncludeAllOutputDevices bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.RoleFilters
SET 
RoleId = @RoleId
,IncludeAllRegions = @IncludeAllRegions
,IncludeAllSites = @IncludeAllSites
,IncludeAllClusters = @IncludeAllClusters
,IncludeAllAccessPortals = @IncludeAllAccessPortals
,IncludeAllInputOutputGroups = @IncludeAllInputOutputGroups 
,IncludeAllInputDevices = @IncludeAllInputDevices
,IncludeAllOutputDevices = @IncludeAllOutputDevices
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
RoleId = @RoleId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[RoleFiltersPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.RoleFilters table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleFiltersPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleFiltersPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleFiltersPDSA_UpdateConcurrency]
@RoleId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.RoleFilters
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
RoleId = @RoleId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[RoleFiltersPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.RoleFilters table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleFiltersPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleFiltersPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleFiltersPDSA_DeleteByPK]
@RoleId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.RoleFilters
WHERE
RoleId = @RoleId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleFiltersPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.RoleFilters table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleFiltersPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleFiltersPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleFiltersPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.RoleFilters

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleFiltersPDSA_RowCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsApplication_BySystemRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsApplication_BySystemRoleId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsApplication_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsApplication_Insert]
GO

/****** Object:  StoredProcedure [GCS].[gcsApplication_Insert]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsApplication_Insert]
	@ApplicationId [uniqueidentifier],
	@LanguageId [uniqueidentifier] = null,
	@ApplicationName [nvarchar](65),
	@ApplicationDescription [nvarchar](255),
	@InsertName [nvarchar](100),
	@InsertDate [datetimeoffset],
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @ApplicationId = '00000000-0000-0000-0000-000000000000'
	SET @ApplicationId = NULL

if @LanguageId = '00000000-0000-0000-0000-000000000000'
	SET @LanguageId = NULL

if @ApplicationId = '00000000-0000-0000-0000-000000000000' OR @ApplicationId IS NULL
	SET @ApplicationId = NewID()

INSERT INTO GCS.gcsApplication
(
ApplicationId
,LanguageId
,ApplicationName
,ApplicationDescription
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@ApplicationId
,@LanguageId
,@ApplicationName
,@ApplicationDescription
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[gcsApplication_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsApplication_Insert] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsApplication_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsApplication_SelectAll]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsApplication_SelectAll]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
ApplicationId
,LanguageId
,ApplicationName
,ApplicationDescription
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsApplication

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[gcsApplication_SelectAll] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsApplication_SelectAll] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsApplication_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsApplication_SelectByPK]
GO

/****** Object:  StoredProcedure [GCS].[gcsApplication_SelectByPK]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsApplication_SelectByPK]
	@ApplicationId [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
ApplicationId
,LanguageId
,ApplicationName
,ApplicationDescription
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsApplication
WHERE 
ApplicationId = @ApplicationId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[gcsApplication_SelectByPK] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsApplication_SelectByPK] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsApplication_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsApplication_SelectSearch]
GO

/****** Object:  StoredProcedure [GCS].[gcsApplication_SelectSearch]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsApplication_SelectSearch]
	@ApplicationName [nvarchar](65)
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
ApplicationId
,LanguageId
,ApplicationName
,ApplicationDescription
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsApplication
WHERE 
(@ApplicationName IS NULL OR ApplicationName LIKE @ApplicationName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[gcsApplication_SelectSearch] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsApplication_SelectSearch] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsApplication_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsApplication_Update]
GO

/****** Object:  StoredProcedure [GCS].[gcsApplication_Update]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsApplication_Update]
	@ApplicationId [uniqueidentifier],
	@LanguageId [uniqueidentifier],
	@ApplicationName [nvarchar](65),
	@ApplicationDescription [nvarchar](255),
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @LanguageId = '00000000-0000-0000-0000-000000000000'
	SET @LanguageId = NULL


UPDATE GCS.gcsApplication
SET 
--ApplicationId = @ApplicationId,
LanguageId = @LanguageId
,ApplicationName = @ApplicationName
,ApplicationDescription = @ApplicationDescription
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
ApplicationId = @ApplicationId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[gcsApplication_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsApplication_Update] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsApplicationSettingPDSA_BySystemRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsApplicationSettingPDSA_BySystemRoleId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Cluster_GetAllUidsFromRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Cluster_GetAllUidsFromRoleId]
GO

CREATE OR ALTER PROCEDURE [GCS].[Cluster_GetAllUidsFromRoleId]
	@RoleId [uniqueidentifier]
AS
	select ClusterUid from GCS.Cluster where EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId)
GO
ALTER AUTHORIZATION ON [GCS].[Cluster_GetAllUidsFromRoleId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[Cluster_GetAllUidsFromRoleId] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Cluster_GetAllUidsFromRoleIdAndSiteUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Cluster_GetAllUidsFromRoleIdAndSiteUid]
GO

CREATE OR ALTER PROCEDURE [GCS].[Cluster_GetAllUidsFromRoleIdAndSiteUid]
	@RoleId [uniqueidentifier],
	@SiteUid [uniqueidentifier]

AS
	select ClusterUid from GCS.Cluster where EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId) and SiteUid = @SiteUid
GO
ALTER AUTHORIZATION ON [GCS].[Cluster_GetAllUidsFromRoleIdAndSiteUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[Cluster_GetAllUidsFromRoleIdAndSiteUid] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortal_GetAllUidsFromRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortal_GetAllUidsFromRoleId]
GO

CREATE OR ALTER PROCEDURE [GCS].[AccessPortal_GetAllUidsFromRoleId]
	@RoleId [uniqueidentifier]
AS
	select AccessPortalUid from GCS.AccessPortal where EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId)
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortal_GetAllUidsFromRoleId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortal_GetAllUidsFromRoleId] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortal_GetAllUidsFromRoleIdAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortal_GetAllUidsFromRoleIdAndClusterUid]
GO

CREATE OR ALTER PROCEDURE [GCS].[AccessPortal_GetAllUidsFromRoleIdAndClusterUid]
	@RoleId [uniqueidentifier],
	@ClusterUid [uniqueidentifier]
AS
	select t.AccessPortalUid from GCS.AccessPortal t 
	join GCS.AccessPortalGalaxyHardwareAddress gha on gha.AccessPortalUid = t.AccessPortalUid 
	join GCS.GalaxyPanel p on p.GalaxyPanelUid = gha.GalaxyPanelUid
	where t.EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId)
	and p.ClusterUid = @ClusterUid
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortal_GetAllUidsFromRoleIdAndClusterUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortal_GetAllUidsFromRoleIdAndClusterUid] TO [public] AS [dbo]
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevice_GetAllUidsFromRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevice_GetAllUidsFromRoleId]
GO

CREATE OR ALTER PROCEDURE [GCS].[InputDevice_GetAllUidsFromRoleId]
	@RoleId [uniqueidentifier]
AS
	select InputDeviceUid from GCS.InputDevice where EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId)
GO
ALTER AUTHORIZATION ON [GCS].[InputDevice_GetAllUidsFromRoleId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputDevice_GetAllUidsFromRoleId] TO [public] AS [dbo]
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevice_GetAllUidsFromRoleIdAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevice_GetAllUidsFromRoleIdAndClusterUid]
GO

CREATE OR ALTER PROCEDURE [GCS].[InputDevice_GetAllUidsFromRoleIdAndClusterUid]
	@RoleId [uniqueidentifier],
	@ClusterUid [uniqueidentifier]
AS
	select t.InputDeviceUid from GCS.InputDevice t 
	join GCS.InputDeviceGalaxyHardwareAddress gha on gha.InputDeviceUid = t.InputDeviceUid 
	join GCS.GalaxyPanel p on p.GalaxyPanelUid = gha.GalaxyPanelUid
	where t.EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId)
	and p.ClusterUid = @ClusterUid
GO
ALTER AUTHORIZATION ON [GCS].[InputDevice_GetAllUidsFromRoleIdAndClusterUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputDevice_GetAllUidsFromRoleIdAndClusterUid] TO [public] AS [dbo]
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevice_GetAllUidsFromRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevice_GetAllUidsFromRoleId]
GO

CREATE OR ALTER PROCEDURE [GCS].[OutputDevice_GetAllUidsFromRoleId]
	@RoleId [uniqueidentifier]
AS
	select OutputDeviceUid from GCS.OutputDevice where EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId)
GO
ALTER AUTHORIZATION ON [GCS].[OutputDevice_GetAllUidsFromRoleId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[OutputDevice_GetAllUidsFromRoleId] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevice_GetAllUidsFromRoleIdAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevice_GetAllUidsFromRoleIdAndClusterUid]
GO

CREATE OR ALTER PROCEDURE [GCS].[OutputDevice_GetAllUidsFromRoleIdAndClusterUid]
	@RoleId [uniqueidentifier],
	@ClusterUid [uniqueidentifier]
AS
	select t.OutputDeviceUid from GCS.OutputDevice t
	join GCS.OutputDeviceGalaxyHardwareAddress gha on gha.OutputDeviceUid = t.OutputDeviceUid 
	join GCS.GalaxyPanel p on p.GalaxyPanelUid = gha.GalaxyPanelUid
	where t.EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId)
	and p.ClusterUid = @ClusterUid
GO
ALTER AUTHORIZATION ON [GCS].[OutputDevice_GetAllUidsFromRoleIdAndClusterUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[OutputDevice_GetAllUidsFromRoleIdAndClusterUid] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroup_GetAllUidsFromRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroup_GetAllUidsFromRoleId]
GO

CREATE OR ALTER PROCEDURE [GCS].[InputOutputGroup_GetAllUidsFromRoleId]
	@RoleId [uniqueidentifier]
AS
	select InputOutputGroupUid from GCS.InputOutputGroup where EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId)
GO
ALTER AUTHORIZATION ON [GCS].[InputOutputGroup_GetAllUidsFromRoleId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputOutputGroup_GetAllUidsFromRoleId] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputOutputGroup_GetAllUidsFromRoleIdAndClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputOutputGroup_GetAllUidsFromRoleIdAndClusterUid]
GO

CREATE OR ALTER PROCEDURE [GCS].[InputOutputGroup_GetAllUidsFromRoleIdAndClusterUid]
	@RoleId [uniqueidentifier],
	@ClusterUid [uniqueidentifier]
AS
	select t.InputOutputGroupUid from GCS.InputOutputGroup t
	where EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId) and t.ClusterUid = @ClusterUid
GO
ALTER AUTHORIZATION ON [GCS].[InputOutputGroup_GetAllUidsFromRoleIdAndClusterUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputOutputGroup_GetAllUidsFromRoleIdAndClusterUid] TO [public] AS [dbo]
GO


if dbo.fn_GCSDoesColumnExist('AccessPortalProperties', 'DoorNumber') = 1
BEGIN
	EXEC dbo.gcs_DeleteDefaultConstraint 'GCS', 'AccessPortalProperties', 'DoorNumber'
	EXEC dbo.gcs_DeleteCheckConstraint 'GCS', 'AccessPortalProperties', 'CKC_DOORNUMBER_ACCESSPORTAL'
	alter table GCS.AccessPortalProperties DROP Column DoorNumber
END
go  

/* All Stored Procedures for table: RoleRegion */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.RoleRegion table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleRegionPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionUid
,RoleId
,t.RegionUid
,IncludeAllSites
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RegionName
FROM GCS.RoleRegion t
JOIN GCS.Region r on r.RegionUid = t.RegionUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleRegion table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPDSA_ByRegionUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPDSA_ByRegionUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPDSA_ByRegionUid]
@RegionUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionUid
,RoleId
,t.RegionUid
,IncludeAllSites
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RegionName
FROM GCS.RoleRegion t
JOIN GCS.Region r on r.RegionUid = t.RegionUid
WHERE 
t.RegionUid = @RegionUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPDSA_ByRegionUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleRegion table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPDSA_ByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPDSA_ByRoleId]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPDSA_ByRoleId]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionUid
,RoleId
,t.RegionUid
,IncludeAllSites
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RegionName
FROM GCS.RoleRegion t
JOIN GCS.Region r on r.RegionUid = t.RegionUid
WHERE 
RoleId = @RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPDSA_ByRoleId] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleSite table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_ByRoleIdAndRegionUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_ByRoleIdAndRegionUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_ByRoleIdAndRegionUid]
@RoleId uniqueidentifier,
@RegionUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSiteUid
,RoleId
,t.SiteUid
,IncludeAllClusters
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,SiteName
FROM GCS.RoleSite t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
WHERE 
RoleId = @RoleId and r.RegionUid = @RegionUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_ByRoleIdAndRegionUid] TO public
GO




/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.RoleRegion table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleRegionPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionUid
,InsertName
FROM GCS.RoleRegion

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleRegion table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPDSA_SelectByPK]
@RoleRegionUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionUid
,RoleId
,t.RegionUid
,IncludeAllSites
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RegionName
FROM GCS.RoleRegion t
JOIN GCS.Region r on r.RegionUid = t.RegionUid
WHERE 
RoleRegionUid = @RoleRegionUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.RoleRegion table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionUid
,RoleId
,t.RegionUid
,IncludeAllSites
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,RegionName
FROM GCS.RoleRegion t
JOIN GCS.Region r on r.RegionUid = t.RegionUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.RoleRegion table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPDSA_Insert]
@RoleRegionUid uniqueidentifier 
,@RoleId uniqueidentifier 
,@RegionUid uniqueidentifier 
,@IncludeAllSites bit 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @RoleRegionUid = '00000000-0000-0000-0000-000000000000'
	SET @RoleRegionUid = NULL

if @RoleRegionUid = '00000000-0000-0000-0000-000000000000' OR @RoleRegionUid IS NULL
	SET @RoleRegionUid = NewID()

INSERT INTO GCS.RoleRegion
(
RoleRegionUid
,RoleId
,RegionUid
,IncludeAllSites
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@RoleRegionUid
,@RoleId
,@RegionUid
,@IncludeAllSites
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.RoleRegion table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPDSA_Update]
@RoleRegionUid uniqueidentifier 
,@RoleId uniqueidentifier
,@RegionUid uniqueidentifier
,@IncludeAllSites bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.RoleRegion
SET 
RoleRegionUid = @RoleRegionUid
,RoleId = @RoleId
,RegionUid = @RegionUid
,IncludeAllSites = @IncludeAllSites
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
RoleRegionUid = @RoleRegionUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[RoleRegionPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.RoleRegion table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPDSA_UpdateConcurrency]
@RoleRegionUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.RoleRegion
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
RoleRegionUid = @RoleRegionUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[RoleRegionPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.RoleRegion table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPDSA_DeleteByPK]
@RoleRegionUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.RoleRegion
WHERE
RoleRegionUid = @RoleRegionUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.RoleRegion table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.RoleRegion

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPDSA_RowCount] TO public
GO

/* All Stored Procedures for table: RoleSite */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.RoleSite table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSiteUid
,RoleId
,t.SiteUid
,IncludeAllClusters
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,SiteName
FROM GCS.RoleSite t
JOIN GCS.Site s on s.SiteUid = t.SiteUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleSite table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_ByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_ByRoleId]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_ByRoleId]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSiteUid
,RoleId
,t.SiteUid
,IncludeAllClusters
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,SiteName
FROM GCS.RoleSite t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
WHERE 
RoleId = @RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_ByRoleId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleSite table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_BySiteUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_BySiteUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_BySiteUid]
@SiteUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSiteUid
,RoleId
,t.SiteUid
,IncludeAllClusters
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,SiteName
FROM GCS.RoleSite t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
WHERE 
t.SiteUid = @SiteUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_BySiteUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.RoleSite table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSiteUid
,InsertName
FROM GCS.RoleSite

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleSite table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_SelectByPK]
@RoleSiteUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSiteUid
,RoleId
,t.SiteUid
,IncludeAllClusters
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,SiteName
FROM GCS.RoleSite t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
WHERE 
RoleSiteUid = @RoleSiteUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.RoleSite table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSiteUid
,RoleId
,t.SiteUid
,IncludeAllClusters
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,SiteName
FROM GCS.RoleSite t
JOIN GCS.Site s on s.SiteUid = t.SiteUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.RoleSite table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_Insert]
@RoleSiteUid uniqueidentifier 
,@RoleId uniqueidentifier 
,@SiteUid uniqueidentifier 
,@IncludeAllClusters bit 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @RoleSiteUid = '00000000-0000-0000-0000-000000000000'
	SET @RoleSiteUid = NULL

if @RoleSiteUid = '00000000-0000-0000-0000-000000000000' OR @RoleSiteUid IS NULL
	SET @RoleSiteUid = NewID()

INSERT INTO GCS.RoleSite
(
RoleSiteUid
,RoleId
,SiteUid
,IncludeAllClusters
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@RoleSiteUid
,@RoleId
,@SiteUid
,@IncludeAllClusters
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.RoleSite table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_Update]
@RoleSiteUid uniqueidentifier 
,@RoleId uniqueidentifier
,@SiteUid uniqueidentifier
,@IncludeAllClusters bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.RoleSite
SET 
RoleSiteUid = @RoleSiteUid
,RoleId = @RoleId
,SiteUid = @SiteUid
,IncludeAllClusters = @IncludeAllClusters
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
RoleSiteUid = @RoleSiteUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.RoleSite table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_UpdateConcurrency]
@RoleSiteUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.RoleSite
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
RoleSiteUid = @RoleSiteUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.RoleSite table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_DeleteByPK]
@RoleSiteUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.RoleSite
WHERE
RoleSiteUid = @RoleSiteUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.RoleSite table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.RoleSite

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePDSA_RowCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsRoleRegionUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsRoleRegionUnique]
GO

CREATE OR ALTER PROCEDURE [GCS].[IsRoleRegionUnique]
	@RoleRegionUid [uniqueidentifier],
	@RoleId [uniqueidentifier],
	@RegionUid [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from GCS.RoleRegion where RoleRegionUid <> @RoleRegionUid AND RoleId = @RoleId AND RegionUid = @RegionUid
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsRoleRegionUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsRoleRegionUnique] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsRoleSiteUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsRoleSiteUnique]
GO

CREATE OR ALTER PROCEDURE [GCS].[IsRoleSiteUnique]
	@RoleSiteUid [uniqueidentifier],
	@RoleId [uniqueidentifier],
	@SiteUid [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from GCS.RoleSite where RoleSiteUid <> @RoleSiteUid AND RoleId = @RoleId AND SiteUid = @SiteUid
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsRoleSiteUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsRoleSiteUnique] TO [public] AS [dbo]
GO


if dbo.fn_GCSDoesIndexExist('RoleInputOutputGroupPermission', 'idxRoleInputOutputGroupPermission') = 0
begin
	/*==============================================================*/
	/* Index: idxRoleInputOutputGroupPermissions                    */
	/*==============================================================*/
	create unique nonclustered index idxRoleInputOutputGroupPermission on GCS.RoleInputOutputGroupPermission (RoleInputOutputGroupUid ASC,
	  PermissionId ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
end
GO

if dbo.fn_GCSDoesTableExist('RoleRegionPermission') = 0
BEGIN
	/*==============================================================*/
	/* Table: RoleRegionPermission                                  */
	/*==============================================================*/
	create table GCS.RoleRegionPermission (
	   RoleRegionPermissionUid GCS.UniversalUniqueId    RowGuidCol not null,
	   RoleRegionUid        uniqueidentifier     not null,
	   PermissionId         uniqueidentifier     not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1
	)

	alter table GCS.RoleRegionPermission
	   add constraint PK_ROLEREGIONPERMISSION primary key (RoleRegionPermissionUid)

	/*==============================================================*/
	/* Index: idxRoleRegionPermission                               */
	/*==============================================================*/
	create unique nonclustered index idxRoleRegionPermission on GCS.RoleRegionPermission (RoleRegionUid ASC,
	  PermissionId ASC)

	alter table GCS.RoleRegionPermission
	   add constraint FK_RoleRegionPermissionPermission foreign key (PermissionId)
		  references GCS.gcsPermission (PermissionId)
			 on update cascade on delete cascade

	alter table GCS.RoleRegionPermission
	   add constraint FK_RoleRegionPermissionRoleRegion foreign key (RoleRegionUid)
		  references GCS.RoleRegion (RoleRegionUid)
			 on update cascade on delete cascade
END
go


if dbo.fn_GCSDoesTableExist('RoleSitePermission') = 0
BEGIN
	/*==============================================================*/
	/* Table: RoleSitePermission                                    */
	/*==============================================================*/
	create table GCS.RoleSitePermission (
	   RoleSitePermissionUid GCS.UniversalUniqueId    RowGuidCol not null,
	   RoleSiteUid          uniqueidentifier     not null,
	   PermissionId         uniqueidentifier     not null,
	   InsertName           nvarchar(100)         not null default user_name(),
	   InsertDate           datetimeoffset             not null default SYSDATETIMEOFFSET(),
	   UpdateName           nvarchar(100)         null default user_name(),
	   UpdateDate           datetimeoffset             null default SYSDATETIMEOFFSET(),
	   ConcurrencyValue     smallint             null default 1
	)

	alter table GCS.RoleSitePermission
	   add constraint PK_ROLESITEPERMISSION primary key (RoleSitePermissionUid)

	/*==============================================================*/
	/* Index: idxRoleSitePermission                                 */
	/*==============================================================*/
	create unique nonclustered index idxRoleSitePermission on GCS.RoleSitePermission (RoleSiteUid ASC,
	  PermissionId ASC)

	alter table GCS.RoleSitePermission
	   add constraint FK_RoleSitePermissionPermission foreign key (PermissionId)
		  references GCS.gcsPermission (PermissionId)
			 on update cascade on delete cascade

	alter table GCS.RoleSitePermission
	   add constraint FK_RoleSitePermissionRoleSite foreign key (RoleSiteUid)
		  references GCS.RoleSite (RoleSiteUid)
			 on update cascade on delete cascade
END
go

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsRoleRegionPermissionUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsRoleRegionPermissionUnique]
GO

CREATE OR ALTER PROCEDURE [GCS].[IsRoleRegionPermissionUnique]
	@RoleRegionPermissionUid [uniqueidentifier],
	@RoleRegionUid [uniqueidentifier],
	@PermissionId [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from GCS.RoleRegionPermission where RoleRegionPermissionUid <> @RoleRegionPermissionUid AND RoleRegionUid = @RoleRegionUid AND PermissionId = @PermissionId
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsRoleRegionPermissionUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsRoleRegionPermissionUnique] TO [public] AS [dbo]
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsRoleSitePermissionUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsRoleSitePermissionUnique]
GO

CREATE OR ALTER PROCEDURE [GCS].[IsRoleSitePermissionUnique]
	@RoleSitePermissionUid [uniqueidentifier],
	@RoleSiteUid [uniqueidentifier],
	@PermissionId [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from GCS.RoleSitePermission where RoleSitePermissionUid <> @RoleSitePermissionUid AND RoleSiteUid = @RoleSiteUid AND PermissionId = @PermissionId
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsRoleSitePermissionUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsRoleSitePermissionUnique] TO [public] AS [dbo]
GO

/* All Stored Procedures for table: RoleSitePermission */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.RoleSitePermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePermissionPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePermissionPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleSitePermissionPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSitePermissionUid
,RoleSiteUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleSitePermission

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePermissionPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.RoleSitePermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePermissionPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePermissionPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleSitePermissionPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSitePermissionUid
,InsertName
FROM GCS.RoleSitePermission

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePermissionPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleSitePermission table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePermissionPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePermissionPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePermissionPDSA_SelectByPK]
@RoleSitePermissionUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSitePermissionUid
,RoleSiteUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleSitePermission
WHERE 
RoleSitePermissionUid = @RoleSitePermissionUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePermissionPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.RoleSitePermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePermissionPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePermissionPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePermissionPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSitePermissionUid
,RoleSiteUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleSitePermission
WHERE 
(@InsertName IS NULL OR InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePermissionPDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleSitePermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePermissionPDSA_ByPermissionId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePermissionPDSA_ByPermissionId]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePermissionPDSA_ByPermissionId]
@PermissionId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSitePermissionUid
,RoleSiteUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleSitePermission
WHERE 
PermissionId = @PermissionId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePermissionPDSA_ByPermissionId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleSitePermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePermissionPDSA_ByRoleSiteUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePermissionPDSA_ByRoleSiteUid]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePermissionPDSA_ByRoleSiteUid]
@RoleSiteUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleSitePermissionUid
,RoleSiteUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleSitePermission
WHERE 
RoleSiteUid = @RoleSiteUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePermissionPDSA_ByRoleSiteUid] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.RoleSitePermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePermissionPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePermissionPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePermissionPDSA_Insert]
@RoleSitePermissionUid uniqueidentifier 
,@RoleSiteUid uniqueidentifier 
,@PermissionId uniqueidentifier 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @RoleSitePermissionUid = '00000000-0000-0000-0000-000000000000'
	SET @RoleSitePermissionUid = NULL

if @RoleSitePermissionUid = '00000000-0000-0000-0000-000000000000' OR @RoleSitePermissionUid IS NULL
	SET @RoleSitePermissionUid = NewID()

INSERT INTO GCS.RoleSitePermission
(
RoleSitePermissionUid
,RoleSiteUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@RoleSitePermissionUid
,@RoleSiteUid
,@PermissionId
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePermissionPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.RoleSitePermission table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePermissionPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePermissionPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePermissionPDSA_Update]
@RoleSitePermissionUid uniqueidentifier 
,@RoleSiteUid uniqueidentifier
,@PermissionId uniqueidentifier
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.RoleSitePermission
SET 
RoleSitePermissionUid = @RoleSitePermissionUid
,RoleSiteUid = @RoleSiteUid
,PermissionId = @PermissionId
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
RoleSitePermissionUid = @RoleSitePermissionUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[RoleSitePermissionPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.RoleSitePermission table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePermissionPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePermissionPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePermissionPDSA_UpdateConcurrency]
@RoleSitePermissionUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.RoleSitePermission
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
RoleSitePermissionUid = @RoleSitePermissionUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[RoleSitePermissionPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.RoleSitePermission table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePermissionPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePermissionPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePermissionPDSA_DeleteByPK]
@RoleSitePermissionUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.RoleSitePermission
WHERE
RoleSitePermissionUid = @RoleSitePermissionUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePermissionPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.RoleSitePermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleSitePermissionPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleSitePermissionPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleSitePermissionPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.RoleSitePermission

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleSitePermissionPDSA_RowCount] TO public
GO

/* All Stored Procedures for table: RoleRegionPermission */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.RoleRegionPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPermissionPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPermissionPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleRegionPermissionPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionPermissionUid
,RoleRegionUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleRegionPermission

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPermissionPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleRegionPermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPermissionPDSA_ByPermissionId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPermissionPDSA_ByPermissionId]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPermissionPDSA_ByPermissionId]
@PermissionId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionPermissionUid
,RoleRegionUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleRegionPermission
WHERE 
PermissionId = @PermissionId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPermissionPDSA_ByPermissionId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleRegionPermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPermissionPDSA_ByRoleRegionUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPermissionPDSA_ByRoleRegionUid]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleRegionPermissionPDSA_ByRoleRegionUid]
@RoleRegionUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionPermissionUid
,RoleRegionUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleRegionPermission
WHERE 
RoleRegionUid = @RoleRegionUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPermissionPDSA_ByRoleRegionUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.RoleRegionPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPermissionPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPermissionPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[RoleRegionPermissionPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionPermissionUid
,InsertName
FROM GCS.RoleRegionPermission

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPermissionPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.RoleRegionPermission table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPermissionPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPermissionPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPermissionPDSA_SelectByPK]
@RoleRegionPermissionUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionPermissionUid
,RoleRegionUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleRegionPermission
WHERE 
RoleRegionPermissionUid = @RoleRegionPermissionUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPermissionPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.RoleRegionPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPermissionPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPermissionPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPermissionPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RoleRegionPermissionUid
,RoleRegionUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.RoleRegionPermission
WHERE 
(@InsertName IS NULL OR InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPermissionPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.RoleRegionPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPermissionPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPermissionPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPermissionPDSA_Insert]
@RoleRegionPermissionUid uniqueidentifier 
,@RoleRegionUid uniqueidentifier 
,@PermissionId uniqueidentifier 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @RoleRegionPermissionUid = '00000000-0000-0000-0000-000000000000'
	SET @RoleRegionPermissionUid = NULL

if @RoleRegionPermissionUid = '00000000-0000-0000-0000-000000000000' OR @RoleRegionPermissionUid IS NULL
	SET @RoleRegionPermissionUid = NewID()

INSERT INTO GCS.RoleRegionPermission
(
RoleRegionPermissionUid
,RoleRegionUid
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@RoleRegionPermissionUid
,@RoleRegionUid
,@PermissionId
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPermissionPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.RoleRegionPermission table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPermissionPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPermissionPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPermissionPDSA_Update]
@RoleRegionPermissionUid uniqueidentifier 
,@RoleRegionUid uniqueidentifier
,@PermissionId uniqueidentifier
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.RoleRegionPermission
SET 
RoleRegionPermissionUid = @RoleRegionPermissionUid
,RoleRegionUid = @RoleRegionUid
,PermissionId = @PermissionId
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
RoleRegionPermissionUid = @RoleRegionPermissionUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[RoleRegionPermissionPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.RoleRegionPermission table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPermissionPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPermissionPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPermissionPDSA_UpdateConcurrency]
@RoleRegionPermissionUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.RoleRegionPermission
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
RoleRegionPermissionUid = @RoleRegionPermissionUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[RoleRegionPermissionPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.RoleRegionPermission table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPermissionPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPermissionPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPermissionPDSA_DeleteByPK]
@RoleRegionPermissionUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.RoleRegionPermission
WHERE
RoleRegionPermissionUid = @RoleRegionPermissionUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPermissionPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.RoleRegionPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[RoleRegionPermissionPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[RoleRegionPermissionPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[RoleRegionPermissionPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.RoleRegionPermission

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[RoleRegionPermissionPDSA_RowCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Region_GetAllUidsFromRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Region_GetAllUidsFromRoleId]
GO

CREATE OR ALTER PROCEDURE [GCS].[Region_GetAllUidsFromRoleId]
	@RoleId [uniqueidentifier]
AS
	select RegionUid from GCS.Region where EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId)
GO
ALTER AUTHORIZATION ON [GCS].[Region_GetAllUidsFromRoleId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[Region_GetAllUidsFromRoleId] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Site_GetAllUidsFromRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Site_GetAllUidsFromRoleId]
GO

CREATE OR ALTER PROCEDURE [GCS].[Site_GetAllUidsFromRoleId]
	@RoleId [uniqueidentifier]
AS
	select SiteUid from GCS.Site where EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId)
GO
ALTER AUTHORIZATION ON [GCS].[Site_GetAllUidsFromRoleId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[Site_GetAllUidsFromRoleId] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Site_GetAllUidsFromRoleIdAndRegionUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Site_GetAllUidsFromRoleIdAndRegionUid]
GO

CREATE OR ALTER PROCEDURE [GCS].[Site_GetAllUidsFromRoleIdAndRegionUid]
	@RoleId [uniqueidentifier],
	@RegionUid uniqueidentifier
AS
	select SiteUid from GCS.Site where EntityId = (Select EntityId from GCS.gcsRole where RoleId = @RoleId) and RegionUid = @RegionUid
GO
ALTER AUTHORIZATION ON [GCS].[Site_GetAllUidsFromRoleIdAndRegionUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[Site_GetAllUidsFromRoleIdAndRegionUid] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermission_ByPerrmissionId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermission_ByPerrmissionId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermission_ByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermission_ByRoleId]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermission_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermission_DeleteByPK]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermission_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermission_Insert]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermission_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermission_RowCount]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermission_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermission_SelectAll]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermission_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermission_SelectByPK]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermission_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermission_SelectListBox]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermission_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermission_SelectSearch]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermission_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermission_Update]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermission_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermission_UpdateConcurrency]
GO

/* All Stored Procedures for table: gcsRolePermission */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsRolePermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
RolePermissionId
,RoleId
,t.PermissionId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,p.PermissionName
FROM GCS.gcsRolePermission t
JOIN GCS.gcsPermission p on p.PermissionId = t.PermissionId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsRolePermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_ByPermissionId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_ByPermissionId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_ByPermissionId]
@PermissionId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT
RolePermissionId
,RoleId
,t.PermissionId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,p.PermissionName
FROM GCS.gcsRolePermission t
JOIN GCS.gcsPermission p on p.PermissionId = t.PermissionId
WHERE 
t.PermissionId = @PermissionId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_ByPermissionId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsRolePermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_ByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_ByRoleId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_ByRoleId]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RolePermissionId
,RoleId
,t.PermissionId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,p.PermissionName
FROM GCS.gcsRolePermission t
JOIN GCS.gcsPermission p on p.PermissionId = t.PermissionId
WHERE 
RoleId = @RoleId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_ByRoleId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.gcsRolePermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
RolePermissionId
,InsertName
FROM GCS.gcsRolePermission

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsRolePermission table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_SelectByPK]
@RolePermissionId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
RolePermissionId
,RoleId
,t.PermissionId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,p.PermissionName
FROM GCS.gcsRolePermission t
JOIN GCS.gcsPermission p on p.PermissionId = t.PermissionId
WHERE 
RolePermissionId = @RolePermissionId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsRolePermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
RolePermissionId
,RoleId
,t.PermissionId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,p.PermissionName
FROM GCS.gcsRolePermission t
JOIN GCS.gcsPermission p on p.PermissionId = t.PermissionId
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.gcsRolePermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_Insert]
@RolePermissionId uniqueidentifier 
,@RoleId uniqueidentifier 
,@PermissionId uniqueidentifier 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @RolePermissionId = '00000000-0000-0000-0000-000000000000'
	SET @RolePermissionId = NULL

if @RolePermissionId = '00000000-0000-0000-0000-000000000000' OR @RolePermissionId IS NULL
	SET @RolePermissionId = NewID()

INSERT INTO GCS.gcsRolePermission
(
RolePermissionId
,RoleId
,PermissionId
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@RolePermissionId
,@RoleId
,@PermissionId
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsRolePermission table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_Update]
@RolePermissionId uniqueidentifier 
,@RoleId uniqueidentifier
,@PermissionId uniqueidentifier
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsRolePermission
SET 
RolePermissionId = @RolePermissionId
,RoleId = @RoleId
,PermissionId = @PermissionId
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
RolePermissionId = @RolePermissionId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsRolePermission table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_UpdateConcurrency]
@RolePermissionId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsRolePermission
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
RolePermissionId = @RolePermissionId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsRolePermission table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_DeleteByPK]
@RolePermissionId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsRolePermission
WHERE
RolePermissionId = @RolePermissionId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsRolePermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsRolePermission

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_RowCount] TO public
GO

if exists (select 1
          from sysobjects
          where id = object_id('GCS.td_gcsuserentity')
          and type = 'TR')
   drop trigger GCS.td_gcsuserentity
go

if exists (select 1
          from sysobjects
          where id = object_id('GCS.ti_gcsuserentity')
          and type = 'TR')
   drop trigger GCS.ti_gcsuserentity
go

if exists (select 1
          from sysobjects
          where id = object_id('GCS.tu_gcsuserentity')
          and type = 'TR')
   drop trigger GCS.tu_gcsuserentity
go



create trigger GCS.td_gcsuserentity on GCS.gcsUserEntity for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Delete all children in "GCS.gcsUserEntityRole"  */
    delete GCS.gcsUserEntityRole
    from   GCS.gcsUserEntityRole t2, deleted t1
    where  t2.UserEntityId = t1.UserEntityId


    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


create trigger GCS.ti_gcsuserentity on GCS.gcsUserEntity for insert as
begin
    declare
       @maxcard  int,
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.gcsUser" must exist when inserting a child in "GCS.gcsUserEntity"  */
    if update(UserId)
    begin
       if (select count(*)
           from   GCS.gcsUser t1, inserted t2
           where  t1.UserId = t2.UserId) != @numrows
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.gcsUser". Cannot create child in "GCS.gcsUserEntity".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


create trigger GCS.tu_gcsuserentity on GCS.gcsUserEntity for update as
begin
   declare
      @maxcard  int,
      @ins_UserEntityId uniqueidentifier,
      @del_UserEntityId uniqueidentifier,
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.gcsUser" must exist when updating a child in "GCS.gcsUserEntity"  */
      if update(UserId)
      begin
         if (select count(*)
             from   GCS.gcsUser t1, inserted t2
             where  t1.UserId = t2.UserId) != @numrows
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.gcsUser" does not exist. Cannot modify child in "GCS.gcsUserEntity".'
               goto error
            end
      end
      declare cIns cursor local for select 
              UserEntityId
          from inserted
      declare cDel cursor local for select 
              UserEntityId
          from deleted

      /*  Modify parent code of "GCS.gcsUserEntity" for all children in "GCS.gcsUserEntityRole"  */
      if update(UserEntityId)
      begin
         if @@rowcount = 1
            update GCS.gcsUserEntityRole
               set   UserEntityId = i1.UserEntityId
            from   GCS.gcsUserEntityRole t2, inserted i1, deleted d1
               where  t2.UserEntityId = d1.UserEntityId
                and  (i1.UserEntityId != d1.UserEntityId)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_UserEntityId
            fetch cDel into @del_UserEntityId

            while (@@fetch_status = 0)
            begin
               update GCS.gcsUserEntityRole
                  set   UserEntityId = @ins_UserEntityId
               where  UserEntityId = @del_UserEntityId
               fetch cIns into @ins_UserEntityId
               fetch cDel into @del_UserEntityId
            end
            close cIns
            close cDel
         end
      end

      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go

alter table GCS.gcsRole 
alter column [RoleDescription] [nvarchar](255) NULL
go

alter table GCS.gcsEntity 
alter column [EntityDescription] [nvarchar](255) NULL
go


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsUserEntityRoles_GetMinimalInfoForUserId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsUserEntityRoles_GetMinimalInfoForUserId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsUserEntityRoles_GetMinimalInfoForUserId]
@UserId uniqueidentifier,
@EntityId uniqueidentifier
AS

declare @ret int;
select @ret = 0;

if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
begin
	select e.EntityName, ue.IsAdministrator, r.RoleName, ue.UserId, e.EntityId, r.RoleId, ue.InheritParentRoles
	from GCS.gcsUserEntityRole uer 
	JOIN GCS.gcsRole r on r.RoleId = uer.RoleId
	JOIN GCS.gcsUserEntity ue ON ue.UserEntityId = uer.UserEntityId
	join GCS.gcsEntity e on e.EntityId = ue.EntityId
	where ue.UserId = @userId
	order by EntityName, RoleName
end
else
begin
	select e.EntityName, ue.IsAdministrator, r.RoleName, ue.UserId, e.EntityId, r.RoleId, ue.InheritParentRoles
	from GCS.gcsUserEntityRole uer 
	JOIN GCS.gcsRole r on r.RoleId = uer.RoleId
	JOIN GCS.gcsUserEntity ue ON ue.UserEntityId = uer.UserEntityId
	join GCS.gcsEntity e on e.EntityId = ue.EntityId
	where ue.UserId = @userId and ue.EntityId = @EntityId
	order by EntityName, RoleName
end

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsUserEntityRoles_GetMinimalInfoForUserId] TO public
GO


if exists (select 1
          from sysobjects
          where id = object_id('GCS.ti_accessgroup')
          and type = 'TR')
   drop trigger GCS.ti_accessgroup
go


create trigger [GCS].[ti_accessgroup] on [GCS].[AccessGroup] for insert as
begin
    declare
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return
   
    /*  Parent "GCS.TimeSchedule" must exist when inserting a child in "GCS.AccessGroup"  */
    if update(DefaultTimeScheduleUid)
    begin
       if (select count(*)
           from   GCS.TimeSchedule t1, inserted t2
           where  t1.TimeScheduleUid = t2.DefaultTimeScheduleUid) != @numrows
          begin
             select @errno  = 3,
                    @errmsg = 'Parent does not exist in "GCS.TimeSchedule". Cannot create child in "GCS.AccessGroup".'
             goto error
          end
    end

    /*  Parent "GCS.gcsResourceString" must exist when inserting a child in "GCS.AccessGroup"  */
    if update(DisplayResourceKey)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  DisplayResourceKey is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.gcsResourceString t1, inserted t2
              where  t1.ResourceId = t2.DisplayResourceKey) != @numrows - @numnull
          begin
             select @errno  = 2,
                    @errmsg = 'Parent does not exist in "GCS.gcsResourceString". Cannot create child in "GCS.AccessGroup".'
             goto error
          end
    end
    /*  Parent "GCS.gcsResourceString" must exist when inserting a child in "GCS.AccessGroup"  */
    if update(DescriptionResourceKey)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  DescriptionResourceKey is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.gcsResourceString t1, inserted t2
              where  t1.ResourceId = t2.DescriptionResourceKey) != @numrows - @numnull
          begin
             select @errno  = 2,
                    @errmsg = 'Parent does not exist in "GCS.gcsResourceString". Cannot create child in "GCS.AccessGroup".'
             goto error
          end
    end
    /*  Parent "GCS.AccessGroup" must exist when inserting a child in "GCS.AccessGroup"  */
    if update(CrisisModeAccessGroupUid)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  CrisisModeAccessGroupUid is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.AccessGroup t1, inserted t2
              where  t1.AccessGroupUid = t2.CrisisModeAccessGroupUid) != @numrows - @numnull
          begin
             select @errno  = 2,
                    @errmsg = 'Parent does not exist in "GCS.AccessGroup". Cannot create child in "GCS.AccessGroup".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    rollback  transaction
    RAISERROR(@errmsg, @errno, 1)
end
GO
ALTER TABLE [GCS].[AccessGroup] ENABLE TRIGGER [ti_accessgroup]
GO
/****** Object:  Trigger [GCS].[tu_accessgroup]    Script Date: 8/31/2020 2:22:25 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

if exists (select 1
          from sysobjects
          where id = object_id('GCS.tu_accessgroup')
          and type = 'TR')
   drop trigger GCS.tu_accessgroup
go


create trigger [GCS].[tu_accessgroup] on [GCS].[AccessGroup] for update as
begin
   declare
      @ins_AccessGroupUid uniqueidentifier,
      @del_AccessGroupUid uniqueidentifier,
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.TimeSchedule" must exist when updating a child in "GCS.AccessGroup"  */
      if update(DefaultTimeScheduleUid)
      begin
         if (select count(*)
             from   GCS.TimeSchedule t1, inserted t2
             where  t1.TimeScheduleUid = t2.DefaultTimeScheduleUid) != @numrows
            begin
               select @errno  = 3,
                      @errmsg = 'GCS.TimeSchedule" does not exist. Cannot modify child in "GCS.AccessGroup".'
               goto error
            end
      end

      /*  Parent "GCS.gcsResourceString" must exist when updating a child in "GCS.AccessGroup"  */
      if update(DisplayResourceKey)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  DisplayResourceKey is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.gcsResourceString t1, inserted t2
                where  t1.ResourceId = t2.DisplayResourceKey) != @numrows - @numnull
            begin
               select @errno  = 3,
                      @errmsg = 'GCS.gcsResourceString" does not exist. Cannot modify child in "GCS.AccessGroup".'
               goto error
            end
      end
      /*  Parent "GCS.gcsResourceString" must exist when updating a child in "GCS.AccessGroup"  */
      if update(DescriptionResourceKey)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  DescriptionResourceKey is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.gcsResourceString t1, inserted t2
                where  t1.ResourceId = t2.DescriptionResourceKey) != @numrows - @numnull
            begin
               select @errno  = 3,
                      @errmsg = 'GCS.gcsResourceString" does not exist. Cannot modify child in "GCS.AccessGroup".'
               goto error
            end
      end
      /*  Parent "GCS.AccessGroup" must exist when updating a child in "GCS.AccessGroup"  */
      if update(CrisisModeAccessGroupUid)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  CrisisModeAccessGroupUid is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.AccessGroup t1, inserted t2
                where  t1.AccessGroupUid = t2.CrisisModeAccessGroupUid) != @numrows - @numnull
            begin
               select @errno  = 3,
                      @errmsg = 'GCS.AccessGroup" does not exist. Cannot modify child in "GCS.AccessGroup".'
               goto error
            end
      end
      declare cIns cursor local for select 
              AccessGroupUid
          from inserted
      declare cDel cursor local for select 
              AccessGroupUid
          from deleted

      /*  Modify parent code of "GCS.AccessGroup" for all children in "GCS.PersonAccessGroup"  */
      if update(AccessGroupUid)
      begin
         if @@rowcount = 1
            update GCS.PersonAccessGroup
               set   AccessGroupUid = i1.AccessGroupUid
            from   GCS.PersonAccessGroup t2, inserted i1, deleted d1
               where  t2.AccessGroupUid = d1.AccessGroupUid
                AND  (i1.AccessGroupUid != d1.AccessGroupUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_AccessGroupUid
            fetch cDel into @del_AccessGroupUid

            while (@@fetch_status = 0)
            begin
               update GCS.PersonAccessGroup
                  set   AccessGroupUid = @ins_AccessGroupUid
               where  AccessGroupUid = @del_AccessGroupUid
               fetch cIns into @ins_AccessGroupUid
               fetch cDel into @del_AccessGroupUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.AccessGroup" for all children in "GCS.AccessGroup"  */
      if update(AccessGroupUid)
      begin
         if @@rowcount = 1
            update GCS.AccessGroup
               set   CrisisModeAccessGroupUid = i1.AccessGroupUid
            from   GCS.AccessGroup t2, inserted i1, deleted d1
               where  t2.CrisisModeAccessGroupUid = d1.AccessGroupUid
                AND  (i1.AccessGroupUid != d1.AccessGroupUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_AccessGroupUid
            fetch cDel into @del_AccessGroupUid

            while (@@fetch_status = 0)
            begin
               update GCS.AccessGroup
                  set   CrisisModeAccessGroupUid = @ins_AccessGroupUid
               where  CrisisModeAccessGroupUid = @del_AccessGroupUid
               fetch cIns into @ins_AccessGroupUid
               fetch cDel into @del_AccessGroupUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.AccessGroup" for all children in "GCS.AccessGroupEntityMap"  */
      if update(AccessGroupUid)
      begin
         if @@rowcount = 1
            update GCS.AccessGroupEntityMap
               set   AccessGroupUid = i1.AccessGroupUid
            from   GCS.AccessGroupEntityMap t2, inserted i1, deleted d1
               where  t2.AccessGroupUid = d1.AccessGroupUid
                AND  (i1.AccessGroupUid != d1.AccessGroupUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_AccessGroupUid
            fetch cDel into @del_AccessGroupUid

            while (@@fetch_status = 0)
            begin
               update GCS.AccessGroupEntityMap
                  set   AccessGroupUid = @ins_AccessGroupUid
               where  AccessGroupUid = @del_AccessGroupUid
               fetch cIns into @ins_AccessGroupUid
               fetch cDel into @del_AccessGroupUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.AccessGroup" for all children in "GCS.AccessGroupLoadToCpu"  */
      if update(AccessGroupUid)
      begin
         if @@rowcount = 1
            update GCS.AccessGroupLoadToCpu
               set   AccessGroupUid = i1.AccessGroupUid
            from   GCS.AccessGroupLoadToCpu t2, inserted i1, deleted d1
               where  t2.AccessGroupUid = d1.AccessGroupUid
                AND  (i1.AccessGroupUid != d1.AccessGroupUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_AccessGroupUid
            fetch cDel into @del_AccessGroupUid

            while (@@fetch_status = 0)
            begin
               update GCS.AccessGroupLoadToCpu
                  set   AccessGroupUid = @ins_AccessGroupUid
               where  AccessGroupUid = @del_AccessGroupUid
               fetch cIns into @ins_AccessGroupUid
               fetch cDel into @del_AccessGroupUid
            end
            close cIns
            close cDel
         end
      end

      return

/*  Errors handling  */
error:
     rollback  transaction
     RAISERROR(@errmsg, @errno, 1)
end
GO
ALTER TABLE [GCS].[AccessGroup] ENABLE TRIGGER [tu_accessgroup]
GO

if exists (select 1
          from sysobjects
          where id = object_id('GCS.td_timeschedule')
          and type = 'TR')
   drop trigger GCS.td_timeschedule
go

create trigger GCS.td_timeschedule on GCS.TimeSchedule for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Cannot delete parent "GCS.TimeSchedule" if children still exist in "GCS.PersonPersonalAccessGroup"  */
    if exists (select 1
               from   GCS.PersonPersonalAccessGroup t2, deleted t1
               where  t2.TimeScheduleUid = t1.TimeScheduleUid)
       begin
          select @errno  = 50006,
                 @errmsg = 'Children still exist in "GCS.PersonPersonalAccessGroup". Cannot delete parent "GCS.TimeSchedule".'
          goto error
       end

    /*  Cannot delete parent "GCS.TimeSchedule" if children still exist in "GCS.InputOutputGroup"  */
    if exists (select 1
               from   GCS.InputOutputGroup t2, deleted t1
               where  t2.TimeScheduleUid = t1.TimeScheduleUid)
       begin
          select @errno  = 50006,
                 @errmsg = 'Children still exist in "GCS.InputOutputGroup". Cannot delete parent "GCS.TimeSchedule".'
          goto error
       end

    /*  Cannot delete parent "GCS.TimeSchedule" if children still exist in "GCS.AccessPortalAlertEvent"  */
    if exists (select 1
               from   GCS.AccessPortalAlertEvent t2, deleted t1
               where  t2.AcknowledgeTimeScheduleUid = t1.TimeScheduleUid)
       begin
          select @errno  = 50006,
                 @errmsg = 'Children still exist in "GCS.AccessPortalAlertEvent". Cannot delete parent "GCS.TimeSchedule".'
          goto error
       end

    /*  Cannot delete parent "GCS.TimeSchedule" if children still exist in "GCS.GalaxyPanelAlertEvent"  */
    if exists (select 1
               from   GCS.GalaxyPanelAlertEvent t2, deleted t1
               where  t2.AcknowledgeTimeScheduleUid = t1.TimeScheduleUid)
       begin
          select @errno  = 50006,
                 @errmsg = 'Children still exist in "GCS.GalaxyPanelAlertEvent". Cannot delete parent "GCS.TimeSchedule".'
          goto error
       end

    /*  Delete all children in "GCS.AccessPortalAuxiliaryOutput"  */
    delete GCS.AccessPortalAuxiliaryOutput
    from   GCS.AccessPortalAuxiliaryOutput t2, deleted t1
    where  t2.TimeScheduleUid = t1.TimeScheduleUid

    /*  Delete all children in "GCS.InputDeviceEventProperties"  */
    delete GCS.InputDeviceEventProperties
    from   GCS.InputDeviceEventProperties t2, deleted t1
    where  t2.AcknowledgeTimeScheduleUid = t1.TimeScheduleUid

    /*  Delete all children in "GCS.GalaxyOutputDevice"  */
    delete GCS.GalaxyOutputDevice
    from   GCS.GalaxyOutputDevice t2, deleted t1
    where  t2.TimeScheduleUid = t1.TimeScheduleUid

    /*  Delete all children in "GCS.TimeScheduleEntityMap"  */
    delete GCS.TimeScheduleEntityMap
    from   GCS.TimeScheduleEntityMap t2, deleted t1
    where  t2.TimeScheduleUid = t1.TimeScheduleUid

    /*  Delete all children in "GCS.GalaxyClusterTimeScheduleMap"  */
    delete GCS.GalaxyClusterTimeScheduleMap
    from   GCS.GalaxyClusterTimeScheduleMap t2, deleted t1
    where  t2.TimeScheduleUid = t1.TimeScheduleUid

    /*  Delete all children in "GCS.AssaDsrTimeScheduleMap"  */
    delete GCS.AssaDsrTimeScheduleMap
    from   GCS.AssaDsrTimeScheduleMap t2, deleted t1
    where  t2.TimeScheduleUid = t1.TimeScheduleUid

    /*  Delete all children in "GCS.AssaTimeScheduleDayPeriod"  */
    delete GCS.AssaTimeScheduleDayPeriod
    from   GCS.AssaTimeScheduleDayPeriod t2, deleted t1
    where  t2.TimeScheduleUid = t1.TimeScheduleUid

    /*  Delete all children in "GCS.TimeScheduleDayTypeTimePeriod"  */
    delete GCS.TimeScheduleDayTypeTimePeriod
    from   GCS.TimeScheduleDayTypeTimePeriod t2, deleted t1
    where  t2.TimeScheduleUid = t1.TimeScheduleUid

    /*  Delete all children in "GCS.TimeScheduleDayTypeGalaxyTimePeriod"  */
    delete GCS.TimeScheduleDayTypeGalaxyTimePeriod
    from   GCS.TimeScheduleDayTypeGalaxyTimePeriod t2, deleted t1
    where  t2.TimeScheduleUid = t1.TimeScheduleUid

    /*  Delete all children in "GCS.AccessPortalTimeSchedule"  */
    delete GCS.AccessPortalTimeSchedule
    from   GCS.AccessPortalTimeSchedule t2, deleted t1
    where  t2.TimeScheduleUid = t1.TimeScheduleUid

    /*  Set parent code of "GCS.TimeSchedule" to NULL in child "GCS.AccessGroupAccessPortal"  */
    update GCS.AccessGroupAccessPortal
     set   TimeScheduleUid = NULL
    from   GCS.AccessGroupAccessPortal t2, deleted t1
    where  t2.TimeScheduleUid = t1.TimeScheduleUid

    /*  Set parent code of "GCS.TimeSchedule" to default in "GCS.AccessGroup"  */
    update GCS.AccessGroup
     set   DefaultTimeScheduleUid = 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF'
    from   GCS.AccessGroup t2, deleted t1
    where  t2.DefaultTimeScheduleUid = t1.TimeScheduleUid


    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


if exists (select 1
          from sysobjects
          where id = object_id('GCS.tu_timeschedule')
          and type = 'TR')
   drop trigger GCS.tu_timeschedule
go


create trigger GCS.tu_timeschedule on GCS.TimeSchedule for update as
begin
   declare
      @ins_TimeScheduleUid uniqueidentifier,
      @del_TimeScheduleUid uniqueidentifier,
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.gcsResourceString" must exist when updating a child in "GCS.TimeSchedule"  */
      if update(DisplayResourceKey)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  DisplayResourceKey is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.gcsResourceString t1, inserted t2
                where  t1.ResourceId = t2.DisplayResourceKey) != @numrows - @numnull
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.gcsResourceString" does not exist. Cannot modify child in "GCS.TimeSchedule".'
               goto error
            end
      end
      /*  Parent "GCS.gcsResourceString" must exist when updating a child in "GCS.TimeSchedule"  */
      if update(DescriptionResourceKey)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  DescriptionResourceKey is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.gcsResourceString t1, inserted t2
                where  t1.ResourceId = t2.DescriptionResourceKey) != @numrows - @numnull
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.gcsResourceString" does not exist. Cannot modify child in "GCS.TimeSchedule".'
               goto error
            end
      end
      declare cIns cursor local for select 
              TimeScheduleUid
          from inserted
      declare cDel cursor local for select 
              TimeScheduleUid
          from deleted

      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.PersonPersonalAccessGroup"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.PersonPersonalAccessGroup
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.PersonPersonalAccessGroup t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.PersonPersonalAccessGroup
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.InputOutputGroup"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.InputOutputGroup
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.InputOutputGroup t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.InputOutputGroup
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.AccessGroupAccessPortal"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.AccessGroupAccessPortal
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.AccessGroupAccessPortal t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.AccessGroupAccessPortal
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.AccessPortalAuxiliaryOutput"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.AccessPortalAuxiliaryOutput
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.AccessPortalAuxiliaryOutput t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.AccessPortalAuxiliaryOutput
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.InputDeviceEventProperties"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.InputDeviceEventProperties
               set   AcknowledgeTimeScheduleUid = i1.TimeScheduleUid
            from   GCS.InputDeviceEventProperties t2, inserted i1, deleted d1
               where  t2.AcknowledgeTimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.InputDeviceEventProperties
                  set   AcknowledgeTimeScheduleUid = @ins_TimeScheduleUid
               where  AcknowledgeTimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.GalaxyOutputDevice"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.GalaxyOutputDevice
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.GalaxyOutputDevice t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.GalaxyOutputDevice
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.TimeScheduleEntityMap"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.TimeScheduleEntityMap
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.TimeScheduleEntityMap t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.TimeScheduleEntityMap
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.GalaxyClusterTimeScheduleMap"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.GalaxyClusterTimeScheduleMap
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.GalaxyClusterTimeScheduleMap t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.GalaxyClusterTimeScheduleMap
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.AssaDsrTimeScheduleMap"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.AssaDsrTimeScheduleMap
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.AssaDsrTimeScheduleMap t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.AssaDsrTimeScheduleMap
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.AssaTimeScheduleDayPeriod"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.AssaTimeScheduleDayPeriod
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.AssaTimeScheduleDayPeriod t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.AssaTimeScheduleDayPeriod
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.TimeScheduleDayTypeTimePeriod"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.TimeScheduleDayTypeTimePeriod
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.TimeScheduleDayTypeTimePeriod t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.TimeScheduleDayTypeTimePeriod
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.TimeScheduleDayTypeGalaxyTimePeriod"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.TimeScheduleDayTypeGalaxyTimePeriod
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.TimeScheduleDayTypeGalaxyTimePeriod t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.TimeScheduleDayTypeGalaxyTimePeriod
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.AccessPortalTimeSchedule"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.AccessPortalTimeSchedule
               set   TimeScheduleUid = i1.TimeScheduleUid
            from   GCS.AccessPortalTimeSchedule t2, inserted i1, deleted d1
               where  t2.TimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.AccessPortalTimeSchedule
                  set   TimeScheduleUid = @ins_TimeScheduleUid
               where  TimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.AccessPortalAlertEvent"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.AccessPortalAlertEvent
               set   AcknowledgeTimeScheduleUid = i1.TimeScheduleUid
            from   GCS.AccessPortalAlertEvent t2, inserted i1, deleted d1
               where  t2.AcknowledgeTimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.AccessPortalAlertEvent
                  set   AcknowledgeTimeScheduleUid = @ins_TimeScheduleUid
               where  AcknowledgeTimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.GalaxyPanelAlertEvent"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.GalaxyPanelAlertEvent
               set   AcknowledgeTimeScheduleUid = i1.TimeScheduleUid
            from   GCS.GalaxyPanelAlertEvent t2, inserted i1, deleted d1
               where  t2.AcknowledgeTimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.GalaxyPanelAlertEvent
                  set   AcknowledgeTimeScheduleUid = @ins_TimeScheduleUid
               where  AcknowledgeTimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.TimeSchedule" for all children in "GCS.AccessGroup"  */
      if update(TimeScheduleUid)
      begin
         if @@rowcount = 1
            update GCS.AccessGroup
               set   DefaultTimeScheduleUid = i1.TimeScheduleUid
            from   GCS.AccessGroup t2, inserted i1, deleted d1
               where  t2.DefaultTimeScheduleUid = d1.TimeScheduleUid
                and  (i1.TimeScheduleUid != d1.TimeScheduleUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_TimeScheduleUid
            fetch cDel into @del_TimeScheduleUid

            while (@@fetch_status = 0)
            begin
               update GCS.AccessGroup
                  set   DefaultTimeScheduleUid = @ins_TimeScheduleUid
               where  DefaultTimeScheduleUid = @del_TimeScheduleUid
               fetch cIns into @ins_TimeScheduleUid
               fetch cDel into @del_TimeScheduleUid
            end
            close cIns
            close cDel
         end
      end

      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessGroup_DoesClusterMatch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroup_DoesClusterMatch]
GO

CREATE OR ALTER PROCEDURE [GCS].[AccessGroup_DoesClusterMatch]
( @uid uniqueidentifier,
	@clusterUid uniqueidentifier,
	@Result [int] OUTPUT)
WITH EXECUTE AS CALLER
AS

	if exists (select ClusterUid from GCS.AccessGroup where AccessGroupUid = @uid and ClusterUid = @clusterUid)
		set @Result = 1
	else
		set @Result = 0
select @Result as Result
--print @rowCount
return @Result
GO
ALTER AUTHORIZATION ON [GCS].[AccessGroup_DoesClusterMatch] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessGroup_DoesClusterMatch] TO [public] AS [dbo]
GO

alter table GCS.AccessGroupAccessPortal
alter column TimeScheduleUid uniqueidentifier null
go


if exists (select 1
          from sysobjects
          where id = object_id('GCS.ti_accessgroupaccessportal')
          and type = 'TR')
   drop trigger GCS.ti_accessgroupaccessportal
go


create trigger GCS.ti_accessgroupaccessportal on GCS.AccessGroupAccessPortal for insert as
begin
    declare
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.AccessPortal" must exist when inserting a child in "GCS.AccessGroupAccessPortal"  */
    if update(AccessPortalUid)
    begin
       if (select count(*)
           from   GCS.AccessPortal t1, inserted t2
           where  t1.AccessPortalUid = t2.AccessPortalUid) != @numrows
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.AccessPortal". Cannot create child in "GCS.AccessGroupAccessPortal".'
             goto error
          end
    end
    /*  Parent "GCS.TimeSchedule" must exist when inserting a child in "GCS.AccessGroupAccessPortal"  */
    if update(TimeScheduleUid)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  TimeScheduleUid is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.TimeSchedule t1, inserted t2
              where  t1.TimeScheduleUid = t2.TimeScheduleUid) != @numrows - @numnull
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.TimeSchedule". Cannot create child in "GCS.AccessGroupAccessPortal".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go

if exists (select 1
          from sysobjects
          where id = object_id('GCS.tu_accessgroupaccessportal')
          and type = 'TR')
   drop trigger GCS.tu_accessgroupaccessportal
go


create trigger GCS.tu_accessgroupaccessportal on GCS.AccessGroupAccessPortal for update as
begin
   declare
      @ins_AccessGroupAccessPortalUid uniqueidentifier,
      @del_AccessGroupAccessPortalUid uniqueidentifier,
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.AccessPortal" must exist when updating a child in "GCS.AccessGroupAccessPortal"  */
      if update(AccessPortalUid)
      begin
         if (select count(*)
             from   GCS.AccessPortal t1, inserted t2
             where  t1.AccessPortalUid = t2.AccessPortalUid) != @numrows
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.AccessPortal" does not exist. Cannot modify child in "GCS.AccessGroupAccessPortal".'
               goto error
            end
      end
      /*  Parent "GCS.TimeSchedule" must exist when updating a child in "GCS.AccessGroupAccessPortal"  */
      if update(TimeScheduleUid)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  TimeScheduleUid is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.TimeSchedule t1, inserted t2
                where  t1.TimeScheduleUid = t2.TimeScheduleUid) != @numrows - @numnull
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.TimeSchedule" does not exist. Cannot modify child in "GCS.AccessGroupAccessPortal".'
               goto error
            end
      end
      declare cIns cursor local for select 
              AccessGroupAccessPortalUid
          from inserted
      declare cDel cursor local for select 
              AccessGroupAccessPortalUid
          from deleted

      /*  Modify parent code of "GCS.AccessGroupAccessPortal" for all children in "GCS.AccessGroupAccessPortalLoadToCpu"  */
      if update(AccessGroupAccessPortalUid)
      begin
         if @@rowcount = 1
            update GCS.AccessGroupAccessPortalLoadToCpu
               set   AccessGroupAccessPortalUid = i1.AccessGroupAccessPortalUid
            from   GCS.AccessGroupAccessPortalLoadToCpu t2, inserted i1, deleted d1
               where  t2.AccessGroupAccessPortalUid = d1.AccessGroupAccessPortalUid
                and  (i1.AccessGroupAccessPortalUid != d1.AccessGroupAccessPortalUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_AccessGroupAccessPortalUid
            fetch cDel into @del_AccessGroupAccessPortalUid

            while (@@fetch_status = 0)
            begin
               update GCS.AccessGroupAccessPortalLoadToCpu
                  set   AccessGroupAccessPortalUid = @ins_AccessGroupAccessPortalUid
               where  AccessGroupAccessPortalUid = @del_AccessGroupAccessPortalUid
               fetch cIns into @ins_AccessGroupAccessPortalUid
               fetch cDel into @del_AccessGroupAccessPortalUid
            end
            close cIns
            close cDel
         end
      end

      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.AccessGroupAccessPortalPDSA_Update') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupAccessPortalPDSA_Update]
GO

/****** Object:  StoredProcedure [GCS].[AccessGroupAccessPortalPDSA_Update]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessGroupAccessPortalPDSA_Update]
	@AccessGroupAccessPortalUid [uniqueidentifier],
	@AccessGroupUid [uniqueidentifier],
	@AccessPortalUid [uniqueidentifier],
	@TimeScheduleUid [uniqueidentifier],
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @TimeScheduleUid = '00000000-0000-0000-0000-000000000000'
	SET @TimeScheduleUid = NULL

UPDATE GCS.AccessGroupAccessPortal
SET 
AccessGroupUid = @AccessGroupUid
,AccessPortalUid = @AccessPortalUid
,TimeScheduleUid = @TimeScheduleUid
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
AccessGroupAccessPortalUid = @AccessGroupAccessPortalUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[AccessGroupAccessPortalPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessGroupAccessPortalPDSA_Update] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.AccessGroupAccessPortalPDSA_Insert') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupAccessPortalPDSA_Insert]
GO


/****** Object:  StoredProcedure [GCS].[AccessGroupAccessPortalPDSA_Insert]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessGroupAccessPortalPDSA_Insert]
	@AccessGroupAccessPortalUid [uniqueidentifier],
	@AccessGroupUid [uniqueidentifier],
	@AccessPortalUid [uniqueidentifier],
	@TimeScheduleUid [uniqueidentifier],
	@InsertName [nvarchar](100),
	@InsertDate [datetimeoffset],
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @AccessGroupAccessPortalUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessGroupAccessPortalUid = NULL

if @TimeScheduleUid = '00000000-0000-0000-0000-000000000000'
	SET @TimeScheduleUid = NULL

if @AccessGroupAccessPortalUid = '00000000-0000-0000-0000-000000000000' OR @AccessGroupAccessPortalUid IS NULL
	SET @AccessGroupAccessPortalUid = NewID()

INSERT INTO GCS.AccessGroupAccessPortal
(
AccessGroupAccessPortalUid
,AccessGroupUid
,AccessPortalUid
,TimeScheduleUid
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@AccessGroupAccessPortalUid
,@AccessGroupUid
,@AccessPortalUid
,@TimeScheduleUid
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessGroupAccessPortalPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessGroupAccessPortalPDSA_Insert] TO [public] AS [dbo]
GO



if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.AccessGroupAccessPortal_PanelLoadData')
            AND   type = 'V')
   drop view GCS.AccessGroupAccessPortal_PanelLoadData
go


/****** Object:  View [GCS].[AccessGroupAccessPortal_PanelLoadData]    Script Date: 8/31/2020 2:22:01 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


create or alter view [GCS].[AccessGroupAccessPortal_PanelLoadData] as
	select AccessGroupAccessPortalUid
	,ag.Display as AccessGroupName
	,ts.Display as TimeScheduleName
	,ap.PortalName as AccessPortalName
	,apCluster.ClusterGroupId
	,apCluster.ClusterNumber
	,apPanel.PanelNumber
	,apBoard.BoardNumber
	,apSection.SectionNumber
	,apModule.ModuleNumber
	,apNode.NodeNumber
	,ag.AccessGroupNumber
	,tsm.PanelScheduleNumber
	,ag.[ActivationDate]
	,ag.ExpirationDate
	,ag.IsEnabled
	,t.AccessPortalUid
	,t.TimeScheduleUid
	,t.AccessGroupUid
	,apBoardType.TypeCode as AccessPortalBoardTypeTypeCode
	,apCluster.[CurrentTimeForCluster]
	,apCluster.ClusterUid
	,apPanel.GalaxyPanelUid
	,0 as CpuNumber
	,'00000000-0000-0000-0000-000000000000' as CpuUid
	,'00000000-0000-0000-0000-000000000000' as AccessGroupLoadToCpuUid
	,'' as ServerAddress	,tsDef.Display as DefaultTimeScheduleName
	,tsmDef.PanelScheduleNumber as DefaultTimeScheduleNumber
	,0 as IsConnected
	,apNode.IsNodeActive
	from GCS.AccessGroupAccessPortal t
	join GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
	left outer join GCS.TimeSchedule ts on ts.TimeScheduleUid = t.TimeScheduleUid
	left outer join GCS.GalaxyClusterTimeScheduleMap tsm on tsm.TimeScheduleUid = t.TimeScheduleUid AND tsm.ClusterUid = ag.ClusterUid
	join GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.AccessPortalGalaxyHardwareAddress aphwaddr on aphwaddr.AccessPortalUid = ap.AccessPortalUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode apNode on apNode.GalaxyInterfaceBoardSectionNodeUid = aphwaddr.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule apModule on apModule.GalaxyHardwareModuleUid = apNode.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyInterfaceBoardSection apSection on apSection.GalaxyInterfaceBoardSectionUid = apModule.GalaxyInterfaceBoardSectionUid
	JOIN GCS.GalaxyInterfaceBoard apBoard on apBoard.GalaxyInterfaceBoardUid = apSection.GalaxyInterfaceBoardUid
	JOIN GCS.GalaxyPanel apPanel on apPanel.GalaxyPanelUid = apBoard.GalaxyPanelUid
	JOIN GCS.Cluster apCluster on apCluster.ClusterUid = apPanel.ClusterUid
	JOIN GCS.InterfaceBoardType apBoardType on apBoardType.InterfaceBoardTypeUid = apBoard.InterfaceBoardTypeUid
	join GCS.TimeSchedule tsDef on tsDef.TimeScheduleUid = ag.DefaultTimeScheduleUid
	join GCS.GalaxyClusterTimeScheduleMap tsmDef on tsmDef.TimeScheduleUid = ag.DefaultTimeScheduleUid AND tsmDef.ClusterUid = ag.ClusterUid
	WHERE ag.AccessGroupNumber > 0 AND ag.AccessGroupNumber < 2001
GO
ALTER AUTHORIZATION ON [GCS].[AccessGroupAccessPortal_PanelLoadData] TO  SCHEMA OWNER 
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.AccessGroupAccessPortalPDSA_ByAccessGroupUid') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupAccessPortalPDSA_ByAccessGroupUid]
GO

CREATE OR ALTER PROCEDURE [GCS].[AccessGroupAccessPortalPDSA_ByAccessGroupUid]
	@AccessGroupUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
t.AccessGroupAccessPortalUid
,t.AccessGroupUid
,t.AccessPortalUid
,t.TimeScheduleUid
,ag.AccessGroupNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
,ap.PortalName as AccessPortalName
,s.Display as TimeScheduleName
FROM GCS.AccessGroupAccessPortal t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
JOIN GCS.AccessPortalGalaxyHardwareAddressView apghwv on apghwv.AccessPortalUid = t.AccessPortalUid and apghwv.ClusterUid = ag.ClusterUid
LEFT OUTER JOIN GCS.TimeSchedule s on s.TimeScheduleUid = t.TimeScheduleUid
WHERE 
t.AccessGroupUid = @AccessGroupUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessGroupAccessPortalPDSA_ByAccessGroupUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessGroupAccessPortalPDSA_ByAccessGroupUid] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.AccessGroupAccessPortalPDSA_ByAccessPortalUid') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupAccessPortalPDSA_ByAccessPortalUid]
GO

/****** Object:  StoredProcedure [GCS].[AccessGroupAccessPortalPDSA_ByAccessPortalUid]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessGroupAccessPortalPDSA_ByAccessPortalUid]
	@AccessPortalUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
t.AccessGroupAccessPortalUid
,t.AccessGroupUid
,t.AccessPortalUid
,t.TimeScheduleUid
,ag.AccessGroupNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
,ap.PortalName as AccessPortalName
,s.Display as TimeScheduleName
FROM GCS.AccessGroupAccessPortal t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
LEFT OUTER JOIN GCS.TimeSchedule s on s.TimeScheduleUid = t.TimeScheduleUid
WHERE 
t.AccessPortalUid = @AccessPortalUid 

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessGroupAccessPortalPDSA_ByAccessPortalUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessGroupAccessPortalPDSA_ByAccessPortalUid] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.AccessGroupAccessPortalPDSA_SelectAll') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupAccessPortalPDSA_SelectAll]
GO

/****** Object:  StoredProcedure [GCS].[AccessGroupAccessPortalPDSA_SelectAll]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessGroupAccessPortalPDSA_SelectAll]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
t.AccessGroupAccessPortalUid
,t.AccessGroupUid
,t.AccessPortalUid
,t.TimeScheduleUid
,ag.AccessGroupNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
,ap.PortalName as AccessPortalName
,s.Display as TimeScheduleName
FROM GCS.AccessGroupAccessPortal t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
LEFT OUTER JOIN GCS.TimeSchedule s on s.TimeScheduleUid = t.TimeScheduleUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessGroupAccessPortalPDSA_SelectAll] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessGroupAccessPortalPDSA_SelectAll] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.AccessGroupAccessPortalPDSA_SelectByPK') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupAccessPortalPDSA_SelectByPK]
GO

/****** Object:  StoredProcedure [GCS].[AccessGroupAccessPortalPDSA_SelectByPK]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessGroupAccessPortalPDSA_SelectByPK]
	@AccessGroupAccessPortalUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
t.AccessGroupAccessPortalUid
,t.AccessGroupUid
,t.AccessPortalUid
,t.TimeScheduleUid
,ag.AccessGroupNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
,ap.PortalName as AccessPortalName
,s.Display as TimeScheduleName
FROM GCS.AccessGroupAccessPortal t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
LEFT OUTER JOIN GCS.TimeSchedule s on s.TimeScheduleUid = t.TimeScheduleUid
WHERE 
t.AccessGroupAccessPortalUid = @AccessGroupAccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessGroupAccessPortalPDSA_SelectByPK] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessGroupAccessPortalPDSA_SelectByPK] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.AccessGroupAccessPortalPDSA_SelectSearch') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupAccessPortalPDSA_SelectSearch]
GO

/****** Object:  StoredProcedure [GCS].[AccessGroupAccessPortalPDSA_SelectSearch]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessGroupAccessPortalPDSA_SelectSearch]
	@InsertName [nvarchar](100)
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
t.AccessGroupAccessPortalUid
,t.AccessGroupUid
,t.AccessPortalUid
,t.TimeScheduleUid
,ag.AccessGroupNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ag.Display as AccessGroupName
,ap.PortalName as AccessPortalName
,s.Display as TimeScheduleName
FROM GCS.AccessGroupAccessPortal t
JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
LEFT OUTER JOIN GCS.TimeSchedule s on s.TimeScheduleUid = t.TimeScheduleUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessGroupAccessPortalPDSA_SelectSearch] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessGroupAccessPortalPDSA_SelectSearch] TO [public] AS [dbo]
GO

IF EXISTS ( SELECT  1
            FROM    Information_schema.Routines
            WHERE   Specific_schema = 'GCS'
                    AND specific_name = 'GetAccessGroupPersonCount'
                    AND Routine_Type = 'FUNCTION' ) 
DROP FUNCTION [GCS].[GetAccessGroupPersonCount]
go

CREATE OR ALTER FUNCTION [GCS].[GetAccessGroupPersonCount] (@AccessGroupUid uniqueidentifier) 
RETURNS int
as
BEGIN
DECLARE @count int
set @count = 0

	select @count = count(distinct(pcp.PersonUid)) from 
	GCS.PersonClusterPermission pcp
	left outer join GCS.PersonAccessGroup pag on pag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid
	left outer join GCS.PersonPersonalAccessGroup ppag on ppag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid 
	left outer join GCS.PersonalAccessGroupDynamicAccessGroup pagdag on pagdag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid
	where pag.AccessGroupUid = @AccessGroupUid or (pagdag.AccessGroupUid = @AccessGroupUid and ppag.TimeScheduleUid <> '00000000-0000-0000-0000-000000000001')

	return @count
END
GO

GRANT EXECUTE ON GCS.[GetAccessGroupPersonCount] TO public
GO


--IF EXISTS ( SELECT  1
--            FROM    Information_schema.Routines
--            WHERE   Specific_schema = 'GCS'
--                    AND specific_name = 'GetAccessGroupPersonUids'
--                    AND Routine_Type = 'FUNCTION' ) 
--DROP FUNCTION [GCS].[GetAccessGroupPersonUids]
--go

--CREATE OR ALTER FUNCTION [GCS].[GetAccessGroupPersonUids] (@AccessGroupUid uniqueidentifier) 
--returns TABLE
--as
--	RETURN select distinct(pcp.PersonUid) from 
--	GCS.PersonClusterPermission pcp
--	left outer join GCS.PersonAccessGroup pag on pag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid
--	left outer join GCS.PersonPersonalAccessGroup ppag on ppag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid 
--	left outer join GCS.PersonalAccessGroupDynamicAccessGroup pagdag on pagdag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid
--	where pag.AccessGroupUid = @AccessGroupUid or (pagdag.AccessGroupUid = @AccessGroupUid and ppag.TimeScheduleUid <> '00000000-0000-0000-0000-000000000001')
--GO

--GRANT EXECUTE ON GCS.[GetAccessGroupPersonUids] TO public
--GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.AccessGroupCount_GetLatestCounts') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroupCount_GetLatestCounts]
GO

/****** Object:  StoredProcedure [GCS].[AccessGroupCount_GetLatestCounts]    Script Date: 8/31/2020 2:22:22 PM ******/
CREATE OR ALTER PROCEDURE [GCS].[AccessGroupCount_GetLatestCounts]
	@AccessGroupUid uniqueidentifier
WITH EXECUTE AS CALLER
AS

declare @personCount int;
declare @accessPortalCount int;

--select @personCount = count(distinct(pcp.PersonUid)) from 
--GCS.PersonClusterPermission pcp
--left outer join GCS.PersonAccessGroup pag on pag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid
--left outer join GCS.PersonPersonalAccessGroup ppag on ppag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid 
--left outer join GCS.PersonalAccessGroupDynamicAccessGroup pagdag on pagdag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid
--where pag.AccessGroupUid = @AccessGroupUid or (pagdag.AccessGroupUid = @AccessGroupUid and ppag.TimeScheduleUid <> '00000000-0000-0000-0000-000000000001')
set @personCount = GCS.[GetAccessGroupPersonCount] (@AccessGroupUid)

select @accessPortalCount = count(*) from GCS.AccessGroupAccessPortal apag
join GCS.AccessPortalGalaxyHardwareAddress apghwv on apghwv.AccessPortalUid = apag.AccessPortalUid where
AccessGroupUid = @AccessGroupUid and (TimeScheduleUid <> '00000000-0000-0000-0000-000000000001' OR TimeScheduleUid IS NULL)

select @personCount as PersonCount, @accessPortalCount as AccessPortalCount

GO
ALTER AUTHORIZATION ON [GCS].[AccessGroupCount_GetLatestCounts] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessGroupCount_GetLatestCounts] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.AccessGroup_GetPersonInfo') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessGroup_GetPersonInfo]
GO

/****** Object:  StoredProcedure [GCS].[AccessGroup_GetPersonInfo]    Script Date: 8/31/2020 2:22:22 PM ******/
CREATE OR ALTER PROCEDURE [GCS].[AccessGroup_GetPersonInfo]
	@AccessGroupUid uniqueidentifier,
	@PageNumber int = 0,
	@PageSize int = 0
	--@SortColumn nvarchar(255) = 'InsertDate',
	--@DescendingOrder bit = 1

WITH EXECUTE AS CALLER
AS

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	set @PageSize = GCS.[GetAccessGroupPersonCount] (@AccessGroupUid)

if @PageSize = 0
	set @PageSize = 1

SELECT p.PersonUid as Id,
p.FirstName, p.LastName, p.DepartmentUid, d.DepartmentName,
pps.PublicUrl AS SmallPhotoURL,
p.ActiveStatusCode,
ev1.ActivityDateTime as LastUsageActivityDateTime,
ap.PortalName as LastUsageAccessPortal, 
ap.ClusterName as LastUsageClusterName, 
ap.SiteName as LastUsageSiteName, 
ap.EntityName as LastUsageEntityName,
pc.CredentialDescription as LastCredentialName,
COUNT(*) OVER() TotalRowCount
from GCS.Person p 
LEFT OUTER JOIN GCS.Department d on d.DepartmentUid = p.DepartmentUid
LEFT OUTER JOIN GCS.PersonPhoto pp on pp.PersonUid = p.PersonUid
LEFT OUTER JOIN GCS.PersonPhotoScaled pps on pps.PersonPhotoUid = pp.PersonPhotoUid and pps.Tag = 'Small'
LEFT OUTER JOIN GCS.PersonLastUsage plu on plu.PersonUid = p.PersonUid
LEFT OUTER JOIN GCS.AccessPortalActivityEvent ev1 on ev1.AccessPortalActivityEventUid = plu.LastAccessGrantedAccessPortalActivityEventUid
LEFT OUTER JOIN GCS.AccessPortal_LocationData ap on ap.AccessPortalUid = ev1.AccessPortalUid
LEFT OUTER JOIN GCS.PersonCredential pc on pc.CredentialUid = ev1.CredentialUid
where p.PersonUid in 
(select distinct(pcp.PersonUid) from 
GCS.PersonClusterPermission pcp
left outer join GCS.PersonAccessGroup pag on pag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid
left outer join GCS.PersonPersonalAccessGroup ppag on ppag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid 
left outer join GCS.PersonalAccessGroupDynamicAccessGroup pagdag on pagdag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid
where pag.AccessGroupUid = @AccessGroupUid or (pagdag.AccessGroupUid = @AccessGroupUid and ppag.TimeScheduleUid <> '00000000-0000-0000-0000-000000000001'))
ORDER BY LastName, FirstName
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;
	
--DROP TABLE ##tempAccessGroupPersonUids;
GO
ALTER AUTHORIZATION ON [GCS].[AccessGroup_GetPersonInfo] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessGroup_GetPersonInfo] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForGalaxyPanel]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyPanel
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyPanel 
@uid uniqueidentifier
AS

	select EntityId from GCS.GalaxyPanel gp join GCS.Cluster c on c.ClusterUid = gp.ClusterUid where GalaxyPanelUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyPanel TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForGalaxyPanel_ByHardwareAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyPanel_ByHardwareAddress
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyPanel_ByHardwareAddress 
@clusterGroupId int,
@clusterNumber int,
@panelNumber int
AS

	select EntityId from GCS.GalaxyPanel gp join GCS.Cluster c on c.ClusterUid = gp.ClusterUid
	where  c.ClusterGroupId = @clusterGroupId AND c.ClusterNumber = @clusterNumber and gp.PanelNumber = @panelNumber
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyPanel_ByHardwareAddress TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForGalaxyCpu]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyCpu
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyCpu 
@uid uniqueidentifier
AS

	select EntityId from GCS.GalaxyCpu cpu join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = cpu.GalaxyPanelUid
	join GCS.Cluster c on c.ClusterUid = gp.ClusterUid where cpu.CpuUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyCpu TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForCluster]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForCluster
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForCluster 
@uid uniqueidentifier
AS

	select EntityId from GCS.Cluster where ClusterUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForCluster TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForCluster_ByHardwareAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForCluster_ByHardwareAddress
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForCluster_ByHardwareAddress
@clusterGroupId int,
@clusterNumber int
AS

	select EntityId from GCS.Cluster where ClusterGroupId = @clusterGroupId and ClusterNumber = @clusterNumber
GO

GRANT EXECUTE ON GCS.GetEntityIdForCluster_ByHardwareAddress TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForGalaxyHardwareModule]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyHardwareModule
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyHardwareModule 
@uid uniqueidentifier
AS

	select c.EntityId from GCS.GalaxyHardwareModule ghm
	join GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = ghm.GalaxyInterfaceBoardSectionUid
	join GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ib.GalaxyPanelUid
	join GCS.Cluster c on c.ClusterUid = gp.ClusterUid where ghm.GalaxyHardwareModuleUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyHardwareModule TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForGalaxyInterfaceBoardSectionNode]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyInterfaceBoardSectionNode
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyInterfaceBoardSectionNode 
@uid uniqueidentifier
AS

	select c.EntityId from GCS.GalaxyInterfaceBoardSectionNode n 
	join GCS.GalaxyHardwareModule ghm on ghm.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
	join GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = ghm.GalaxyInterfaceBoardSectionUid
	join GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ib.GalaxyPanelUid
	join GCS.Cluster c on c.ClusterUid = gp.ClusterUid where 
	n.GalaxyInterfaceBoardSectionNodeUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyInterfaceBoardSectionNode TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForGalaxyInterfaceBoardSection') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyInterfaceBoardSection
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyInterfaceBoardSection 
@uid uniqueidentifier
AS

	select c.EntityId from GCS.GalaxyInterfaceBoardSection ibs
	join GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ib.GalaxyPanelUid
	join GCS.Cluster c on c.ClusterUid = gp.ClusterUid where ibs.GalaxyInterfaceBoardSectionUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyInterfaceBoardSection TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForGalaxyInterfaceBoard') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyInterfaceBoard
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyInterfaceBoard 
@uid uniqueidentifier
AS

	select c.EntityId from GCS.GalaxyInterfaceBoard ib 
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ib.GalaxyPanelUid
	join GCS.Cluster c on c.ClusterUid = gp.ClusterUid where ib.GalaxyInterfaceBoardUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyInterfaceBoard TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForGalaxyAccessGroup]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyAccessGroup
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyAccessGroup 
@uid uniqueidentifier
AS

	select c.EntityId from GCS.AccessGroup ag join GCS.Cluster c on c.ClusterUid = ag.ClusterUid where AccessGroupUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyAccessGroup TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetClusterUidOfForGalaxyAccessGroup]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetClusterUidOfForGalaxyAccessGroup
GO

CREATE OR ALTER PROCEDURE GCS.GetClusterUidOfForGalaxyAccessGroup 
@uid uniqueidentifier
AS

	select ClusterUid from GCS.AccessGroup where AccessGroupUid = @uid
GO

GRANT EXECUTE ON GCS.GetClusterUidOfForGalaxyAccessGroup TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForGalaxyArea]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyArea
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyArea 
@uid uniqueidentifier
AS

	select c.EntityId from GCS.Area a join GCS.Cluster c on c.ClusterUid = a.ClusterUid where AreaUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyArea TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForGalaxyInputOutputGroup]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyInputOutputGroup
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyInputOutputGroup 
@uid uniqueidentifier
AS

	select c.EntityId from GCS.InputOutputGroup iog join GCS.Cluster c on c.ClusterUid = iog.ClusterUid where InputOutputGroupUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyInputOutputGroup TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForAccessPortal') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForAccessPortal
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForAccessPortal 
@uid uniqueidentifier
AS

	select EntityId from GCS.AccessPortal where AccessPortalUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForAccessPortal TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForInputDevice') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForInputDevice
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForInputDevice 
@uid uniqueidentifier
AS

	select EntityId from GCS.InputDevice where InputDeviceUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForInputDevice TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForOutputDevice') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForOutputDevice
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForOutputDevice 
@uid uniqueidentifier
AS

	select EntityId from GCS.OutputDevice where OutputDeviceUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForOutputDevice TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForTimeSchedule') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForTimeSchedule
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForTimeSchedule 
@uid uniqueidentifier
AS

	select EntityId from GCS.TimeSchedule where TimeScheduleUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForTimeSchedule TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForTimePeriod') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForTimePeriod
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForTimePeriod 
@uid uniqueidentifier
AS

	select EntityId from GCS.TimePeriod where TimePeriodUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForTimePeriod TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.IsTimeScheduleMappedToCluster') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.IsTimeScheduleMappedToCluster
GO

CREATE OR ALTER PROCEDURE GCS.IsTimeScheduleMappedToCluster 
@timeScheduleUid uniqueidentifier,
@clusterUid uniqueidentifier
AS
declare @panelScheduleNumber int
	SELECT @panelScheduleNumber = PanelScheduleNumber FROM GCS.GalaxyClusterTimeScheduleMap WHERE TimeScheduleUid = @timeScheduleUid and ClusterUid = @clusterUid
	IF @panelScheduleNumber IS NOT NULL
		SELECT 1 AS IsMapped
	ELSE
		SELECT 0 AS IsMapped
GO

GRANT EXECUTE ON GCS.IsTimeScheduleMappedToCluster TO public
GO




IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForAccessProfile') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForAccessProfile
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForAccessProfile 
@uid uniqueidentifier
AS

	select EntityId from GCS.AccessProfile where AccessProfileUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForAccessProfile TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForBadgeTemplate') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForBadgeTemplate
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForBadgeTemplate 
@uid uniqueidentifier
AS

	select EntityId from GCS.BadgeTemplate where BadgeTemplateUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForBadgeTemplate TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForDepartment') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForDepartment
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForDepartment 
@uid uniqueidentifier
AS

	select EntityId from GCS.Department where DepartmentUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForDepartment TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForGalaxyDayType') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyDayType
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyDayType 
@uid uniqueidentifier
AS

	select EntityId from GCS.DayType where DayTypeUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyDayType TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForGalaxyDateType') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyDateType
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyDateType 
@uid uniqueidentifier
AS

	select EntityId from GCS.DateType where DateTypeUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyDateType TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForGalaxyTimePeriod') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGalaxyTimePeriod
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGalaxyTimePeriod 
@uid uniqueidentifier
AS

	select EntityId from GCS.GalaxyTimePeriod where GalaxyTimePeriodUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGalaxyTimePeriod TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForAssaDsr') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForAssaDsr
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForAssaDsr 
@uid uniqueidentifier
AS

	select EntityId from GCS.AssaDsr where AssaDsrUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForAssaDsr TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForAssaAccessPoint') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForAssaAccessPoint
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForAssaAccessPoint 
@uid uniqueidentifier
AS

	select EntityId from GCS.AssaAccessPoint aap join GCS.Site s on s.SiteUid = aap.SiteUid where AssaAccessPointUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForAssaAccessPoint TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForAssaDayPeriod') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForAssaDayPeriod
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForAssaDayPeriod 
@uid uniqueidentifier
AS

	select EntityId from GCS.AssaDayPeriod where AssaDayPeriodUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForAssaDayPeriod TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForGender') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForGender
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForGender 
@uid uniqueidentifier
AS

	select EntityId from GCS.Gender where GenderUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForGender TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForPersonRecordType') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForPersonRecordType
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForPersonRecordType 
@uid uniqueidentifier
AS

	select EntityId from GCS.PersonRecordType where PersonRecordTypeUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForPersonRecordType TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForPersonActiveStatusType') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForPersonActiveStatusType
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForPersonActiveStatusType 
@uid uniqueidentifier
AS

	select EntityId from GCS.PersonActiveStatusType where PersonActiveStatusTypeUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForPersonActiveStatusType TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForRegion') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForRegion
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForRegion 
@uid uniqueidentifier
AS

	select EntityId from GCS.Region where RegionUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForRegion TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForSite') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForSite
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForSite 
@uid uniqueidentifier
AS

	select EntityId from GCS.Site where SiteUid = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForSite TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetPrimaryEntityIdForUser') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetPrimaryEntityIdForUser
GO

CREATE OR ALTER PROCEDURE GCS.GetPrimaryEntityIdForUser 
@uid uniqueidentifier
AS

	select PrimaryEntityId from GCS.gcsUser where UserId = @uid
GO

GRANT EXECUTE ON GCS.GetPrimaryEntityIdForUser TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.GetEntityIdForRole') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForRole
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForRole 
@uid uniqueidentifier
AS

	select EntityId from GCS.gcsRole where RoleId = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForRole TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetEntityIdForDateTypeDefaultBehavior]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetEntityIdForDateTypeDefaultBehavior
GO

CREATE OR ALTER PROCEDURE GCS.GetEntityIdForDateTypeDefaultBehavior 
@uid uniqueidentifier
AS

	select EntityId from GCS.DateTypeDefaultBehavior where EntityId = @uid
GO

GRANT EXECUTE ON GCS.GetEntityIdForDateTypeDefaultBehavior TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsRolePermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsRolePermissionPDSA_ByRoleIdAndApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsRolePermissionPDSA_ByRoleIdAndApplicationId]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsRolePermissionPDSA_ByRoleIdAndApplicationId]
@RoleId uniqueidentifier,
@ApplicationId uniqueidentifier
AS

declare @ret int;
select @ret = 0;

SELECT 
RolePermissionId
,RoleId
,t.PermissionId
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,p.PermissionName
FROM GCS.gcsRolePermission t
JOIN GCS.gcsPermission p on p.PermissionId = t.PermissionId
JOIN GCS.gcsPermissionCategory pc on pc.PermissionCategoryId = p.PermissionCategoryId
WHERE 
RoleId = @RoleId AND pc.ApplicationId = @ApplicationId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsRolePermissionPDSA_ByRoleIdAndApplicationId] TO public
GO


/****** Object:  Index [idxAccessPortalActivityEventUniqueId]    Script Date: 5/24/2021 2:58:18 PM ******/
if dbo.[fn_GCSDoesIndexExist]('DayType', 'idxDayTypeCodeEntity') = 1
BEGIN
	DROP INDEX [idxDayTypeCodeEntity] ON [GCS].[DayType]
END
GO

/*==============================================================*/
/* Index: idxDayTypeCodeEntity                                  */
/*==============================================================*/
create unique nonclustered index idxDayTypeCodeEntity on GCS.DayType (EntityId ASC,
  DayTypeCode ASC)
go


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelPDSA_ByClusterUidAndPanelNumber]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelPDSA_ByClusterUidAndPanelNumber]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelPDSA_ByClusterUidAndPanelNumber]
@ClusterUid uniqueidentifier,
@PanelNumber int
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyPanelUid
,t.ClusterUid
,GalaxyPanelModelUid
,PanelNumber
,PanelName
,Location
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,c.ClusterGroupId
,c.ClusterName
,c.EntityId
,COUNT(*) OVER() TotalRowCount
,(select count(*) from GCS.GalaxyInterfaceBoard where GalaxyPanelUid = t.GalaxyPanelUid) as InterfaceBoardCount
,(SELECT COUNT(*) from GCS.GalaxyCpu where GalaxyPanelUid = t.GalaxyPanelUid and IsActive = 1) as ActiveCpuCount
,(SELECT COUNT(*) from GCS.AccessPortalGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as AccessPortalCount
,(SELECT COUNT(*) from GCS.InputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1) as InputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode <> 64) as OutputDeviceCount
,(SELECT COUNT(*) from GCS.OutputDeviceGalaxyHardwareAddressView where GalaxyPanelUid = t.GalaxyPanelUid and IsNodeActive = 1 and InterfaceBoardSectionModeCode = 64) as ElevatorOutputCount
FROM GCS.GalaxyPanel t
JOIN GCS.Cluster c ON c.ClusterUid = t.ClusterUid
WHERE 
t.ClusterUid = @ClusterUid and t.PanelNumber = @PanelNumber


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelPDSA_ByClusterUidAndPanelNumber] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyClusterTimeScheduleMap_SelectAvailableTimeScheduleNumber]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyClusterTimeScheduleMap_SelectAvailableTimeScheduleNumber]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyClusterTimeScheduleMap_SelectAvailableTimeScheduleNumber]
@ClusterUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

SELECT TOP(1) t1.PanelScheduleNumber+1 as PanelScheduleNumber
FROM GCS.GalaxyClusterTimeScheduleMap t1
WHERE t1.ClusterUid = @ClusterUid and NOT EXISTS(SELECT * FROM GCS.GalaxyClusterTimeScheduleMap t2 WHERE t2.ClusterUid = @ClusterUid and t2.PanelScheduleNumber = t1.PanelScheduleNumber + 1)
ORDER BY t1.PanelScheduleNumber


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyClusterTimeScheduleMap_SelectAvailableTimeScheduleNumber] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_IsUserUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_IsUserUnique]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcs_IsUserUnique]
	@UserId [uniqueidentifier],
	@LoginName [nvarchar](100),
	@EmailAddress [nvarchar](255),
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from GCS.gcsUser where UserId <> @UserId AND UserName = @LoginName
	if @Result = 0
	begin
		select @Result = count(*) from GCS.gcsUser where UserId <> @UserId AND Email = @EmailAddress	
	end
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[gcs_IsUserUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_IsUserUnique] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_IsUserPropertyUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_IsUserPropertyUnique]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcs_IsUserPropertyUnique]
	@UserId [uniqueidentifier],
	@LoginName [nvarchar](100),
	@EmailAddress [nvarchar](255),
	@Result [int] OUTPUT,
	@PropName nvarchar(50) OUTPUT
WITH EXECUTE AS CALLER
AS
	select @PropName = N''

	select @Result = count(*) from GCS.gcsUser where UserId <> @UserId AND UserName = @LoginName
	if @Result = 0
	begin
		select @Result = count(*) from GCS.gcsUser where UserId <> @UserId AND Email = @EmailAddress	
		if @Result <> 0
		begin
			select @PropName = N'Email'
		end
	end
	else
	begin
		select @PropName = N'UserName'
	end
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[gcs_IsUserPropertyUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_IsUserPropertyUnique] TO [public] AS [dbo]
GO

if dbo.fn_GCSDoesColumnExist('DayType', 'IsActive') = 0
BEGIN
	ALTER TABLE [GCS].DayType
	ADD [IsActive] bit not null default 0
END
go  

--update GCS.DayType set IsActive = 0

update GCS.DayType set IsActive = 1 where DayTypeUid in (select distinct(DayTypeUid) from GCS.DateType)
go

update GCS.DayType set IsActive = 1 where DayTypeCode between 91 and 99
go

update GCS.DayType set HighlightColor = 0 where IsActive = 0
go

/* All Stored Procedures for table: DayType */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.DayType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DayType

if @PageSize = 0
	set @PageSize = 1

declare @ret int;
select @ret = 0;

SELECT 
DayTypeUid
,EntityId
,Name
,Notes
,HighlightColor
,DayTypeCode
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DayType  
ORDER BY (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Name end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Name end) desc,
		 (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 0 THEN DayTypeCode end) asc,
         (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 1 THEN DayTypeCode end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.DayType table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_ByEntityIdAndIsActive]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_ByEntityIdAndIsActive]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_ByEntityIdAndIsActive]
@EntityId uniqueidentifier,
@IsActive bit,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DayType where EntityId = @EntityId OR
DayTypeUid in (SELECT DISTINCT DayTypeUid from GCS.DayTypeEntityMap WHERE EntityId = @EntityId)


if @PageSize = 0
	set @PageSize = 1

SELECT 
DayTypeUid
,EntityId
,Name
,Notes
,HighlightColor
,DayTypeCode
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DayType
WHERE 
(EntityId = @EntityId OR
DayTypeUid in (SELECT DISTINCT DayTypeUid from GCS.DayTypeEntityMap WHERE EntityId = @EntityId))
AND IsActive = @IsActive
ORDER BY (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Name end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Name end) desc,
		 (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 0 THEN DayTypeCode end) asc,
         (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 1 THEN DayTypeCode end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_ByEntityIdAndIsActive] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.DayType table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DayType where EntityId = @EntityId

if @PageSize = 0
	set @PageSize = 1

SELECT 
DayTypeUid
,EntityId
,Name
,Notes
,HighlightColor
,DayTypeCode
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DayType
WHERE 
EntityId = @EntityId OR
DayTypeUid in (SELECT DISTINCT DayTypeUid from GCS.DayTypeEntityMap WHERE EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Name end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Name end) desc,
		 (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 0 THEN DayTypeCode end) asc,
         (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 1 THEN DayTypeCode end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.DayType table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_ByGalaxyClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_ByGalaxyClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_ByGalaxyClusterUid]
@GalaxyClusterUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DayType where EntityId = (SELECT EntityId from GCS.Cluster WHERE ClusterUid = @GalaxyClusterUid)

if @PageSize = 0
	set @PageSize = 1

SELECT 
DayTypeUid
,EntityId
,Name
,Notes
,HighlightColor
,DayTypeCode
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DayType
WHERE 
DayTypeUid in (SELECT DayTypeUid FROM GCS.GalaxyClusterDayTypeMap WHERE ClusterUid = @GalaxyClusterUid)
ORDER BY (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Name end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Name end) desc,
		 (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 0 THEN DayTypeCode end) asc,
         (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 1 THEN DayTypeCode end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_ByGalaxyClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.DayType table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_ByMappedEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_ByMappedEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_ByMappedEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DayType where EntityId = @EntityId

if @PageSize = 0
	set @PageSize = 1

SELECT 
DayTypeUid
,EntityId
,Name
,Notes
,HighlightColor
,DayTypeCode
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DayType
WHERE 
EntityId = @EntityId OR
DayTypeUid in (SELECT DISTINCT DayTypeUid from GCS.DayTypeEntityMap WHERE EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Name end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Name end) desc,
		 (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 0 THEN DayTypeCode end) asc,
         (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 1 THEN DayTypeCode end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_ByMappedEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.DayType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DayType

if @PageSize = 0
	set @PageSize = 1

SELECT 
DayTypeUid
,Name
,COUNT(*) OVER() TotalRowCount
FROM GCS.DayType
ORDER BY (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Name end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Name end) desc,
		 (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 0 THEN DayTypeCode end) asc,
         (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 1 THEN DayTypeCode end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.DayType table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_SelectByPK]
@DayTypeUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
DayTypeUid
,EntityId
,Name
,Notes
,HighlightColor
,DayTypeCode
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,1 as TotalRowCount
FROM GCS.DayType
WHERE 
DayTypeUid = @DayTypeUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_SelectByPK] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.DayType table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_ByEntityIdAndDayTypeCode]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_ByEntityIdAndDayTypeCode]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_ByEntityIdAndDayTypeCode]
@EntityId uniqueidentifier,
@DayTypeCode smallint,
@IsActive bit
AS

declare @ret int;
select @ret = 0;

SELECT 
DayTypeUid
,EntityId
,Name
,Notes
,HighlightColor
,DayTypeCode
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DayType
WHERE 
(EntityId = @EntityId OR
DayTypeUid in (SELECT DISTINCT DayTypeUid from GCS.DayTypeEntityMap WHERE EntityId = @EntityId))
AND DayTypeCode = @DayTypeCode

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_ByEntityIdAndDayTypeCode] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_GetLowestInActiveByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_GetLowestInActiveByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_GetLowestInActiveByEntityId]
@EntityId uniqueidentifier
AS

declare @ret int;
select @ret = 0;

SELECT top 1
DayTypeUid
,EntityId
,Name
,Notes
,HighlightColor
,DayTypeCode
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,1 as TotalRowCount
FROM GCS.DayType
WHERE 
(EntityId = @EntityId OR
DayTypeUid in (SELECT DISTINCT DayTypeUid from GCS.DayTypeEntityMap WHERE EntityId = @EntityId))
AND IsActive = 0
ORDER BY DayTypeCode

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_GetLowestInActiveByEntityId] TO public
GO



/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.DayType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_SelectSearch]
@Name nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DayType WHERE (@Name IS NULL OR Name LIKE @Name + '%')

if @PageSize = 0
	set @PageSize = 1

SELECT 
DayTypeUid
,EntityId
,Name
,Notes
,HighlightColor
,DayTypeCode
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DayType
WHERE 
(@Name IS NULL OR Name LIKE @Name + '%')
ORDER BY (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 0 THEN Name end) asc,
         (CASE WHEN @SortColumn = 'Name' AND @DescendingOrder = 1 THEN Name end) desc,
		 (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 0 THEN DayTypeCode end) asc,
         (CASE WHEN @SortColumn = 'Code' AND @DescendingOrder = 1 THEN DayTypeCode end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.DayType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_Insert]
@DayTypeUid uniqueidentifier 
,@EntityId uniqueidentifier 
,@Name nvarchar(65) 
,@Notes nvarchar(255)  = null
,@HighlightColor int
,@DayTypeCode smallint
,@IsActive bit
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @DayTypeUid = '00000000-0000-0000-0000-000000000000'
	SET @DayTypeUid = NULL

if @DayTypeUid = '00000000-0000-0000-0000-000000000000' OR @DayTypeUid IS NULL
	SET @DayTypeUid = NewID()

INSERT INTO GCS.DayType
(
DayTypeUid
,EntityId
,Name
,Notes
,HighlightColor
,DayTypeCode
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@DayTypeUid
,@EntityId
,@Name
,@Notes
,@HighlightColor
,@DayTypeCode
,@IsActive
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.DayType table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_Update]
@DayTypeUid uniqueidentifier 
,@EntityId uniqueidentifier
,@Name nvarchar(65)
,@Notes nvarchar(255)
,@HighlightColor int
,@DayTypeCode smallint
,@IsActive bit
,@InsertName nvarchar(100)
,@InsertDate datetimeoffset
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.DayType
SET 
EntityId = @EntityId
,Name = @Name
,Notes = @Notes
,HighlightColor = @HighlightColor
,DayTypeCode = @DayTypeCode
,IsActive = @IsActive
,InsertName = @InsertName
,InsertDate = @InsertDate
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
DayTypeUid = @DayTypeUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.DayType table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_UpdateConcurrency]
@DayTypeUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.DayType
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
DayTypeUid = @DayTypeUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.DayType table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_DeleteByPK]
@DayTypeUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.DayType
WHERE
DayTypeUid = @DayTypeUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[DayTypePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.DayType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DayTypePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DayTypePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[DayTypePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.DayType

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DayTypePDSA_RowCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateType_GetDayTypeInfo]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateType_GetDayTypeInfo]
GO
CREATE OR ALTER PROCEDURE GCS.[DateType_GetDayTypeInfo]
@EntityId uniqueidentifier,
@Date datetime
AS

declare @ret int;
select @ret = 0;

SELECT d.DayTypeUid, dt.[Name]
from GCS.DateType d 
join GCS.DayType dt on dt.DayTypeUid = d.DayTypeUid
WHERE d.EntityId = @EntityId AND d.[Date] = cast( @Date as date)

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateType_GetDayTypeInfo] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ResetConcurrencyValue]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ResetConcurrencyValue]
GO
CREATE OR ALTER PROCEDURE GCS.[ResetConcurrencyValue]
@tableName nvarchar(255),
@uidColumn nvarchar(255),
@uid uniqueidentifier
AS

declare @dynSql nvarchar(2000)
set @dynSql = N'UPDATE [GCS].[' + @tableName + N'] SET ConcurrencyValue = 0 WHERE ' + @uidColumn + N' = ''' + cast(@uid as nvarchar(50)) + ''''
print @dynSql
exec sp_executesql @dynSql
GO

GRANT EXECUTE ON GCS.[ResetConcurrencyValue] TO public
GO

if dbo.fn_GCSDoesColumnExist('DateTypeDefaultBehavior', 'DateTypeDefaultBehaviorUid') = 1
BEGIN
	exec [gcs_DeletePKConstraint] 'GCS','DateTypeDefaultBehavior', 'PK_DATETYPEDEFAULTBEHAVIOR'
	--EXEC dbo.gcs_DeleteDefaultConstraint 'GCS', 'DateTypeDefaultBehavior', 'DateTypeDefaultBehaviorUid'
	exec sp_unbindefault 'GCS.DateTypeDefaultBehavior.DateTypeDefaultBehaviorUid'

	alter table GCS.DateTypeDefaultBehavior DROP Column DateTypeDefaultBehaviorUid
	alter table GCS.DateTypeDefaultBehavior ADD CONSTRAINT [PK_DATETYPEDEFAULTBEHAVIOR] PRIMARY KEY CLUSTERED 
(
	[EntityId] ASC
) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
END
go  

--exec sp_unbindefault 'GCS.DateTypeDefaultBehavior.EntityId'
--exec sp_unbindefault 'GCS.DateTypeDefaultBehavior.SundayDayTypeUid'
--exec sp_unbindefault 'GCS.DateTypeDefaultBehavior.MondayDayTypeUid'
--exec sp_unbindefault 'GCS.DateTypeDefaultBehavior.TuesdayDayTypeUid'
--exec sp_unbindefault 'GCS.DateTypeDefaultBehavior.WednesdayDayTypeUid'
--exec sp_unbindefault 'GCS.DateTypeDefaultBehavior.ThursdayDayTypeUid'
--exec sp_unbindefault 'GCS.DateTypeDefaultBehavior.FridayDayTypeUid'
--exec sp_unbindefault 'GCS.DateTypeDefaultBehavior.SaturdayDayTypeUid'

--GO


if dbo.[fn_GCSDoesIndexExist]('DateTypeDefaultBehavior', 'idxDateTypeDefaultBehaviorEntityId') = 1
BEGIN
	DROP INDEX [idxDateTypeDefaultBehaviorEntityId] ON [GCS].[DateTypeDefaultBehavior]
END
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsDateTypeDefaultBehaviorUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsDateTypeDefaultBehaviorUnique]
GO

/****** Object:  StoredProcedure [GCS].[IsDateTypeDefaultBehaviorUnique]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[IsDateTypeDefaultBehaviorUnique]
	@EntityId [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from GCS.DateTypeDefaultBehavior where EntityId = @EntityId
if @Result = 1
	set @Result = 0
else
	set @Result = 1

select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsDateTypeDefaultBehaviorUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsDateTypeDefaultBehaviorUnique] TO [public] AS [dbo]
GO


/* All Stored Procedures for table: DateTypeDefaultBehavior */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.DateTypeDefaultBehavior table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypeDefaultBehaviorPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityId
,SundayDayTypeUid
,MondayDayTypeUid
,TuesdayDayTypeUid
,WednesdayDayTypeUid
,ThursdayDayTypeUid
,FridayDayTypeUid
,SaturdayDayTypeUid
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.DateTypeDefaultBehavior

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypeDefaultBehaviorPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.DateTypeDefaultBehavior table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypeDefaultBehaviorPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityId
,InsertName
FROM GCS.DateTypeDefaultBehavior

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypeDefaultBehaviorPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.DateTypeDefaultBehavior table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypeDefaultBehaviorPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_SelectByPK]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityId
,SundayDayTypeUid
,MondayDayTypeUid
,TuesdayDayTypeUid
,WednesdayDayTypeUid
,ThursdayDayTypeUid
,FridayDayTypeUid
,SaturdayDayTypeUid
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.DateTypeDefaultBehavior
WHERE 
EntityId = @EntityId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypeDefaultBehaviorPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.DateTypeDefaultBehavior table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypeDefaultBehaviorPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
EntityId
,SundayDayTypeUid
,MondayDayTypeUid
,TuesdayDayTypeUid
,WednesdayDayTypeUid
,ThursdayDayTypeUid
,FridayDayTypeUid
,SaturdayDayTypeUid
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.DateTypeDefaultBehavior
WHERE 
(@InsertName IS NULL OR InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypeDefaultBehaviorPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.DateTypeDefaultBehavior table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypeDefaultBehaviorPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_Insert]
@EntityId uniqueidentifier 
,@SundayDayTypeUid uniqueidentifier 
,@MondayDayTypeUid uniqueidentifier 
,@TuesdayDayTypeUid uniqueidentifier 
,@WednesdayDayTypeUid uniqueidentifier 
,@ThursdayDayTypeUid uniqueidentifier 
,@FridayDayTypeUid uniqueidentifier 
,@SaturdayDayTypeUid uniqueidentifier 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

INSERT INTO GCS.DateTypeDefaultBehavior
(
EntityId
,SundayDayTypeUid
,MondayDayTypeUid
,TuesdayDayTypeUid
,WednesdayDayTypeUid
,ThursdayDayTypeUid
,FridayDayTypeUid
,SaturdayDayTypeUid
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@EntityId
,@SundayDayTypeUid
,@MondayDayTypeUid
,@TuesdayDayTypeUid
,@WednesdayDayTypeUid
,@ThursdayDayTypeUid
,@FridayDayTypeUid
,@SaturdayDayTypeUid
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypeDefaultBehaviorPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.DateTypeDefaultBehavior table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypeDefaultBehaviorPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_Update]
@EntityId uniqueidentifier 
,@SundayDayTypeUid uniqueidentifier
,@MondayDayTypeUid uniqueidentifier
,@TuesdayDayTypeUid uniqueidentifier
,@WednesdayDayTypeUid uniqueidentifier
,@ThursdayDayTypeUid uniqueidentifier
,@FridayDayTypeUid uniqueidentifier
,@SaturdayDayTypeUid uniqueidentifier
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.DateTypeDefaultBehavior
SET 
EntityId = @EntityId
,SundayDayTypeUid = @SundayDayTypeUid
,MondayDayTypeUid = @MondayDayTypeUid
,TuesdayDayTypeUid = @TuesdayDayTypeUid
,WednesdayDayTypeUid = @WednesdayDayTypeUid
,ThursdayDayTypeUid = @ThursdayDayTypeUid
,FridayDayTypeUid = @FridayDayTypeUid
,SaturdayDayTypeUid = @SaturdayDayTypeUid
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
EntityId = @EntityId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[DateTypeDefaultBehaviorPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.DateTypeDefaultBehavior table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypeDefaultBehaviorPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_UpdateConcurrency]
@EntityId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.DateTypeDefaultBehavior
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
EntityId = @EntityId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[DateTypeDefaultBehaviorPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.DateTypeDefaultBehavior table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypeDefaultBehaviorPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_DeleteByPK]
@EntityId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.DateTypeDefaultBehavior
WHERE
EntityId = @EntityId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[DateTypeDefaultBehaviorPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.DateTypeDefaultBehavior table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypeDefaultBehaviorPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypeDefaultBehaviorPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.DateTypeDefaultBehavior

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypeDefaultBehaviorPDSA_RowCount] TO public
GO


if exists (select 1
            from  sysobjects
           where  id = object_id('GCS.DateTypeDefaultBehavior_PanelLoadData')
            AND   type = 'V')
   drop view GCS.DateTypeDefaultBehavior_PanelLoadData
go

/****** Object:  View [GCS].[DateTypeDefaultBehavior_PanelLoadData]    Script Date: 8/31/2020 2:22:03 PM ******/

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create view [GCS].[DateTypeDefaultBehavior_PanelLoadData] as
	SELECT 
	t.EntityId
	,e.EntityName
	,dtSunday.DayTypeCode as SundayDayCode
	,dtMonday.DayTypeCode as MondayDayCode
	,dtTuesday.DayTypeCode as TuesdayDayCode
	,dtWednesday.DayTypeCode as WednesdayDayCode
	,dtThursday.DayTypeCode as ThursdayDayCode
	,dtFriday.DayTypeCode as FridayDayCode
	,dtSaturday.DayTypeCode as SaturdayDayCode
	FROM GCS.DateTypeDefaultBehavior t 
	join GCS.gcsEntity e on e.EntityId = t.EntityId
	join GCS.DayType dtSunday on dtSunday.DayTypeUid = t.SundayDayTypeUid
	join GCS.DayType dtMonday on dtMonday.DayTypeUid = t.MondayDayTypeUid
	join GCS.DayType dtTuesday on dtTuesday.DayTypeUid = t.TuesdayDayTypeUid
	join GCS.DayType dtWednesday on dtWednesday.DayTypeUid = t.WednesdayDayTypeUid
	join GCS.DayType dtThursday on dtThursday.DayTypeUid = t.ThursdayDayTypeUid
	join GCS.DayType dtFriday on dtFriday.DayTypeUid = t.FridayDayTypeUid
	join GCS.DayType dtSaturday on dtSaturday.DayTypeUid = t.SaturdayDayTypeUid
GO
ALTER AUTHORIZATION ON [GCS].[DateTypeDefaultBehavior_PanelLoadData] TO  SCHEMA OWNER 
GO


/* All Stored Procedures for table: AccessPortalAlertEvent */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.AccessPortalAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalAlertEventUid
,t.AccessPortalUid
,InputOutputGroupUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AccessPortalAlertEventTypeUid
,InputOutputGroupAssignmentUid
,AcknowledgePriority
,ResponseRequired
,t.IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.EntityId
FROM GCS.AccessPortalAlertEvent t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortalAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_ByAccessPortalAlertEventTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByAccessPortalAlertEventTypeUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByAccessPortalAlertEventTypeUid]
@AccessPortalAlertEventTypeUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalAlertEventUid
,t.AccessPortalUid
,InputOutputGroupUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AccessPortalAlertEventTypeUid
,InputOutputGroupAssignmentUid
,AcknowledgePriority
,ResponseRequired
,t.IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.EntityId
FROM GCS.AccessPortalAlertEvent t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
AccessPortalAlertEventTypeUid = @AccessPortalAlertEventTypeUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_ByAccessPortalAlertEventTypeUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortalAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_ByAccessPortalUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByAccessPortalUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByAccessPortalUid]
@AccessPortalUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalAlertEventUid
,t.AccessPortalUid
,InputOutputGroupUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AccessPortalAlertEventTypeUid
,InputOutputGroupAssignmentUid
,AcknowledgePriority
,ResponseRequired
,t.IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.EntityId
FROM GCS.AccessPortalAlertEvent t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
t.AccessPortalUid = @AccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_ByAccessPortalUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortalAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_ByAudioBinaryResourceUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByAudioBinaryResourceUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByAudioBinaryResourceUid]
@AudioBinaryResourceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalAlertEventUid
,t.AccessPortalUid
,InputOutputGroupUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AccessPortalAlertEventTypeUid
,InputOutputGroupAssignmentUid
,AcknowledgePriority
,ResponseRequired
,t.IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.EntityId
FROM GCS.AccessPortalAlertEvent t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
AudioBinaryResourceUid = @AudioBinaryResourceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_ByAudioBinaryResourceUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortalAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_ByInputOutputGroupAssignmentUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByInputOutputGroupAssignmentUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByInputOutputGroupAssignmentUid]
@InputOutputGroupAssignmentUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalAlertEventUid
,t.AccessPortalUid
,InputOutputGroupUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AccessPortalAlertEventTypeUid
,InputOutputGroupAssignmentUid
,AcknowledgePriority
,ResponseRequired
,t.IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.EntityId
FROM GCS.AccessPortalAlertEvent t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
InputOutputGroupAssignmentUid = @InputOutputGroupAssignmentUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_ByInputOutputGroupAssignmentUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortalAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_ByResponseInstructionsUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByResponseInstructionsUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByResponseInstructionsUid]
@ResponseInstructionsUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalAlertEventUid
,t.AccessPortalUid
,InputOutputGroupUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AccessPortalAlertEventTypeUid
,InputOutputGroupAssignmentUid
,AcknowledgePriority
,ResponseRequired
,t.IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.EntityId
FROM GCS.AccessPortalAlertEvent t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
ResponseInstructionsUid = @ResponseInstructionsUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_ByResponseInstructionsUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.AccessPortalAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalAlertEventUid
,InsertName
FROM GCS.AccessPortalAlertEvent

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortalAlertEvent table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_SelectByPK]
@AccessPortalAlertEventUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalAlertEventUid
,t.AccessPortalUid
,InputOutputGroupUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AccessPortalAlertEventTypeUid
,InputOutputGroupAssignmentUid
,AcknowledgePriority
,ResponseRequired
,t.IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.EntityId
FROM GCS.AccessPortalAlertEvent t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
AccessPortalAlertEventUid = @AccessPortalAlertEventUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.AccessPortalAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_SelectSearch]
@InsertName nvarchar(100) 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalAlertEventUid
,t.AccessPortalUid
,InputOutputGroupUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AccessPortalAlertEventTypeUid
,InputOutputGroupAssignmentUid
,AcknowledgePriority
,ResponseRequired
,t.IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.EntityId
FROM GCS.AccessPortalAlertEvent t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.AccessPortalAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_Insert]
@AccessPortalAlertEventUid uniqueidentifier 
,@AccessPortalUid uniqueidentifier 
,@InputOutputGroupUid uniqueidentifier 
,@AcknowledgeTimeScheduleUid uniqueidentifier 
,@AudioBinaryResourceUid uniqueidentifier  = null
,@ResponseInstructionsUid uniqueidentifier  = null
,@AccessPortalAlertEventTypeUid uniqueidentifier 
,@InputOutputGroupAssignmentUid uniqueidentifier  = null
,@AcknowledgePriority int 
,@ResponseRequired bit
,@IsActive bit
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @AccessPortalAlertEventUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalAlertEventUid = NULL


if @AudioBinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @AudioBinaryResourceUid = NULL
if @ResponseInstructionsUid = '00000000-0000-0000-0000-000000000000'
	SET @ResponseInstructionsUid = NULL
if @InputOutputGroupAssignmentUid = '00000000-0000-0000-0000-000000000000'
	SET @InputOutputGroupAssignmentUid = NULL

if @AccessPortalAlertEventUid = '00000000-0000-0000-0000-000000000000' OR @AccessPortalAlertEventUid IS NULL
	SET @AccessPortalAlertEventUid = NewID()

INSERT INTO GCS.AccessPortalAlertEvent
(
AccessPortalAlertEventUid
,AccessPortalUid
,InputOutputGroupUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AccessPortalAlertEventTypeUid
,InputOutputGroupAssignmentUid
,AcknowledgePriority
,ResponseRequired
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@AccessPortalAlertEventUid
,@AccessPortalUid
,@InputOutputGroupUid
,@AcknowledgeTimeScheduleUid
,@AudioBinaryResourceUid
,@ResponseInstructionsUid
,@AccessPortalAlertEventTypeUid
,@InputOutputGroupAssignmentUid
,@AcknowledgePriority
,@ResponseRequired
,@IsActive
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.AccessPortalAlertEvent table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_Update]
@AccessPortalAlertEventUid uniqueidentifier 
,@AccessPortalUid uniqueidentifier
,@InputOutputGroupUid uniqueidentifier
,@AcknowledgeTimeScheduleUid uniqueidentifier
,@AudioBinaryResourceUid uniqueidentifier
,@ResponseInstructionsUid uniqueidentifier
,@AccessPortalAlertEventTypeUid uniqueidentifier
,@InputOutputGroupAssignmentUid uniqueidentifier
,@AcknowledgePriority int
,@ResponseRequired bit
,@IsActive bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;


if @AudioBinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @AudioBinaryResourceUid = NULL
if @ResponseInstructionsUid = '00000000-0000-0000-0000-000000000000'
	SET @ResponseInstructionsUid = NULL
if @InputOutputGroupAssignmentUid = '00000000-0000-0000-0000-000000000000'
	SET @InputOutputGroupAssignmentUid = NULL

UPDATE GCS.AccessPortalAlertEvent
SET 
AccessPortalUid = @AccessPortalUid
,InputOutputGroupUid = @InputOutputGroupUid
,AcknowledgeTimeScheduleUid = @AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid = @AudioBinaryResourceUid
,ResponseInstructionsUid = @ResponseInstructionsUid
,AccessPortalAlertEventTypeUid = @AccessPortalAlertEventTypeUid
,InputOutputGroupAssignmentUid = @InputOutputGroupAssignmentUid
,AcknowledgePriority = @AcknowledgePriority
,ResponseRequired = @ResponseRequired
,IsActive = @IsActive
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
AccessPortalAlertEventUid = @AccessPortalAlertEventUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.AccessPortalAlertEvent table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_UpdateConcurrency]
@AccessPortalAlertEventUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.AccessPortalAlertEvent
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
AccessPortalAlertEventUid = @AccessPortalAlertEventUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.AccessPortalAlertEvent table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_DeleteByPK]
@AccessPortalAlertEventUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.AccessPortalAlertEvent
WHERE
AccessPortalAlertEventUid = @AccessPortalAlertEventUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.AccessPortalAlertEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.AccessPortalAlertEvent

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_RowCount] TO public
GO


/* All Stored Procedures for table: DateType */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.DateType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_SelectAll]
@PageNumber int = 0,
@PageSize int = 0,
@SortColumn nvarchar(255) = 'Date',
@DescendingOrder bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DateType

if @PageSize = 0
	set @PageSize = 1

SELECT 
DateTypeUid
,EntityId
,DayTypeUid
,[Date]
,Title
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DateType
ORDER BY EntityId, (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 0 THEN [Date] end) asc,
         (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 1 THEN [Date] end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
	OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.DateType table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_ByDayTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_ByDayTypeUid]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_ByDayTypeUid]
@DayTypeUid uniqueidentifier,
@PageNumber int = 0,
@PageSize int = 0,
@SortColumn nvarchar(255) = 'Date',
@DescendingOrder bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DateType where DayTypeUid = @DayTypeUid

if @PageSize = 0
	set @PageSize = 1

SELECT 
DateTypeUid
,EntityId
,DayTypeUid
,[Date]
,Title
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DateType
WHERE 
DayTypeUid = @DayTypeUid
ORDER BY EntityId, (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 0 THEN [Date] end) asc,
         (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 1 THEN [Date] end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
	OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_ByDayTypeUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.DateType table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int = 0,
@PageSize int = 0,
@SortColumn nvarchar(255) = 'Date',
@DescendingOrder bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DateType where EntityId = @EntityId

if @PageSize = 0
	set @PageSize = 1

SELECT 
DateTypeUid
,EntityId
,DayTypeUid
,[Date]
,Title
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DateType
WHERE 
EntityId = @EntityId  OR
DayTypeUid in (SELECT DISTINCT DayTypeUid from GCS.DayTypeEntityMap WHERE EntityId = @EntityId)
ORDER BY EntityId, (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 0 THEN [Date] end) asc,
         (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 1 THEN [Date] end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
	OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.DateType table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_ByEntityIdAndDate]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_ByEntityIdAndDate]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_ByEntityIdAndDate]
@EntityId uniqueidentifier,
@Date date
AS

declare @ret int;
select @ret = 0;

SELECT top(1)
DateTypeUid
,EntityId
,DayTypeUid
,[Date]
,Title
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,1 as TotalRowCount
FROM GCS.DateType
WHERE 
EntityId = @EntityId AND Date = @Date

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_ByEntityIdAndDate] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.DateType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_SelectListBox]
@PageNumber int = 0,
@PageSize int = 0,
@SortColumn nvarchar(255) = 'Date',
@DescendingOrder bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DateType

if @PageSize = 0
	set @PageSize = 1

SELECT 
DateTypeUid
,Date
,Title,
DayTypeUid
,COUNT(*) OVER() TotalRowCount
FROM GCS.DateType
ORDER BY EntityId, (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 0 THEN [Date] end) asc,
         (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 1 THEN [Date] end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
	OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.DateType table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_SelectByPK]
@DateTypeUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
DateTypeUid
,EntityId
,DayTypeUid
,[Date]
,Title
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,1 as TotalRowCount
FROM GCS.DateType
WHERE 
DateTypeUid = @DateTypeUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.DateType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_SelectSearch]
@InsertName nvarchar(100),
@PageNumber int = 0,
@PageSize int = 0,
@SortColumn nvarchar(255) = 'Date',
@DescendingOrder bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DateType where InsertName = @InsertName

if @PageSize = 0
	set @PageSize = 1

SELECT 
DateTypeUid
,EntityId
,DayTypeUid
,[Date]
,Title
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DateType
WHERE 
(@InsertName IS NULL OR InsertName LIKE @InsertName + '%')
ORDER BY EntityId, (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 0 THEN [Date] end) asc,
         (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 1 THEN [Date] end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
	OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_SelectSearch] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_ByEntityAndDateRange]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_ByEntityAndDateRange]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_ByEntityAndDateRange]
@EntityId uniqueidentifier,
@StartDate date,
@EndDate date,
@PageNumber int = 0,
@PageSize int = 0,
@SortColumn nvarchar(255) = 'Date',
@DescendingOrder bit = 0
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.DateType WHERE EntityId = @EntityId  AND Date >= @StartDate AND Date <= @EndDate

if @PageSize = 0
	set @PageSize = 1

SELECT 
DateTypeUid
,EntityId
,DayTypeUid
,[Date]
,Title
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.DateType
WHERE 
EntityId = @EntityId  AND Date >= @StartDate AND Date <= @EndDate
ORDER BY EntityId, (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 0 THEN [Date] end) asc,
         (CASE WHEN @SortColumn = 'Date' AND @DescendingOrder = 1 THEN [Date] end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
	OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_ByEntityAndDateRange] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.DateType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_Insert]
@DateTypeUid uniqueidentifier 
,@EntityId uniqueidentifier 
,@DayTypeUid uniqueidentifier 
,@Date date 
,@Title nvarchar(65)
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @DateTypeUid = '00000000-0000-0000-0000-000000000000'
	SET @DateTypeUid = NULL

INSERT INTO GCS.DateType
(
DateTypeUid
,EntityId
,DayTypeUid
,[Date]
,Title
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@DateTypeUid
,@EntityId
,@DayTypeUid
,@Date
,@Title
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.DateType table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_Update]
@DateTypeUid uniqueidentifier 
,@EntityId uniqueidentifier
,@DayTypeUid uniqueidentifier
,@Date date
,@Title nvarchar(65)
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.DateType
SET 
EntityId = @EntityId
,DayTypeUid = @DayTypeUid
,[Date] = @Date
,Title = @Title
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
DateTypeUid = @DateTypeUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.DateType table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_UpdateConcurrency]
@DateTypeUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.DateType
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
DateTypeUid = @DateTypeUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.DateType table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_DeleteByPK]
@DateTypeUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.DateType
WHERE
DateTypeUid = @DateTypeUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[DateTypePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.DateType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DateTypePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DateTypePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[DateTypePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.DateType

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DateTypePDSA_RowCount] TO public
GO

UPDATE GCS.gcsEntity SET EntityType = 'administrator' WHERE EntityId = '00000000-0000-0000-0000-000000000002'
go

UPDATE GCS.gcsEntity SET EntityType = 'reserved' WHERE EntityId = '00000000-0000-0000-0000-000000000001'
go

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GetCurrentEntityInfo]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.GetCurrentEntityInfo
GO
CREATE OR ALTER PROCEDURE GCS.GetCurrentEntityInfo
@EntityId uniqueidentifier
AS
	select EntityId as CurrentEntityId, EntityName as CurrentEntityName, EntityType as CurrentEntityType from GCS.gcsEntity where EntityId = @EntityId	
GO

GRANT EXECUTE ON GCS.GetCurrentEntityInfo TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcs_IsEntityUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcs_IsEntityUnique]
GO

/****** Object:  StoredProcedure [GCS].[gcs_IsEntityUnique]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcs_IsEntityUnique]
	@EntityId [uniqueidentifier],
	@ParentEntityId [uniqueidentifier],
	@EntityName [nvarchar](65),
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
	if @ParentEntityId IS NULL OR @ParentEntityId = '00000000-0000-0000-0000-000000000000'
	begin
		select @Result = count(*) from GCS.gcsEntity where EntityId <> @EntityId AND EntityName = @EntityName and ParentEntityId IS NULL
	end
	ELSE
	BEGIN
		select @Result = count(*) from GCS.gcsEntity where EntityId <> @EntityId AND EntityName = @EntityName AND ParentEntityId = @ParentEntityId
	END
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[gcs_IsEntityUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcs_IsEntityUnique] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntity_CanBeDeleted]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntity_CanBeDeleted]
GO

/****** Object:  StoredProcedure [GCS].[gcsEntity_CanBeDeleted]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsEntity_CanBeDeleted]
	@EntityId [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
	set @Result = 1
	if exists (select top(1) * from GCS.Cluster where EntityId = @EntityId)
		set @Result = 0
	if @Result = 1
	BEGIN
		if exists (select top(1) * from GCS.Person where EntityId = @EntityId)
			set @Result = 0
	END
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[gcsEntity_CanBeDeleted] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsEntity_CanBeDeleted] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntity_DeleteSites]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntity_DeleteSites]
GO

/****** Object:  StoredProcedure [GCS].[gcsEntity_DeleteSites]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsEntity_DeleteSites]
	@EntityId [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
	delete from GCS.Site where EntityId = @EntityId
GO
ALTER AUTHORIZATION ON [GCS].[gcsEntity_DeleteSites] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsEntity_DeleteSites] TO [public] AS [dbo]
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntity_DeleteRegions]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntity_DeleteRegions]
GO

/****** Object:  StoredProcedure [GCS].[gcsEntity_DeleteRegions]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsEntity_DeleteRegions]
	@EntityId [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
	delete from GCS.Region where EntityId = @EntityId
GO
ALTER AUTHORIZATION ON [GCS].[gcsEntity_DeleteRegions] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsEntity_DeleteRegions] TO [public] AS [dbo]
GO

/****** Object:  Index [Index_EntityName]    Script Date: 9/19/2022 2:48:52 PM ******/
if dbo.[fn_GCSDoesIndexExist]('gcsEntity', 'Index_EntityName') = 1
BEGIN
	DROP INDEX [Index_EntityName] ON [GCS].[gcsEntity]
END
GO

/****** Object:  Index [Index_EntityName]    Script Date: 9/19/2022 11:01:33 AM ******/
CREATE UNIQUE NONCLUSTERED INDEX [Index_EntityName] ON [GCS].[gcsEntity]
(
	[EntityName] ASC,
	[ParentEntityId] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessProfileInputOutputGroupPDSA_ByAccessProfileClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessProfileInputOutputGroupPDSA_ByAccessProfileClusterUid]
GO


/****** Object:  StoredProcedure [GCS].[AccessProfileInputOutputGroupPDSA_ByAccessProfileClusterUid]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessProfileInputOutputGroupPDSA_ByAccessProfileClusterUid]
	@AccessProfileClusterUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
AccessProfileInputOutputGroupUid
,AccessProfileClusterUid
,t.InputOutputGroupUid
,t.OrderNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,IOGroupNumber
,Display as InputOutputGroupName
FROM GCS.AccessProfileInputOutputGroup t 
JOIN GCS.InputOutputGroup iog on iog.InputOutputGroupUid = t.InputOutputGroupUid
WHERE 
AccessProfileClusterUid = @AccessProfileClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessProfileInputOutputGroupPDSA_ByAccessProfileClusterUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessProfileInputOutputGroupPDSA_ByAccessProfileClusterUid] TO [public] AS [dbo]
GO

/* All Stored Procedures for table: GalaxyTimePeriod */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.GalaxyTimePeriod table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyTimePeriodPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyTimePeriodPDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[GalaxyTimePeriodPDSA_SelectAll]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyTimePeriod

if @PageSize = 0
	set @PageSize = 1

SELECT 
GalaxyTimePeriodUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,Display
,Description
,PanelTimePeriodNumber
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.GalaxyTimePeriod
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyTimePeriodPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyTimePeriod table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyTimePeriodPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyTimePeriodPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyTimePeriodPDSA_ByEntityId]
@EntityId uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = NULL 
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyTimePeriod where EntityId = @EntityId

if @PageSize = 0
	set @PageSize = 1

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
GalaxyTimePeriodUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,PanelTimePeriodNumber
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.GalaxyTimePeriod t
WHERE 
EntityId = @EntityId  OR
GalaxyTimePeriodUid in (SELECT DISTINCT GalaxyTimePeriodUid FROM GalaxyTimePeriodEntityMap WHERE EntityId = @EntityId)
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyTimePeriodPDSA_ByEntityId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.GalaxyTimePeriod table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyTimePeriodPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyTimePeriodPDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[GalaxyTimePeriodPDSA_SelectListBox]
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyTimePeriod

if @PageSize = 0
	set @PageSize = 1

SELECT 
GalaxyTimePeriodUid
,Display
,COUNT(*) OVER() TotalRowCount
FROM GCS.GalaxyTimePeriod
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyTimePeriodPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyTimePeriod table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyTimePeriodPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyTimePeriodPDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyTimePeriodPDSA_SelectByPK]
@GalaxyTimePeriodUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyTimePeriodUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,Display
,Description
,PanelTimePeriodNumber
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,1 as TotalRowCount
FROM GCS.GalaxyTimePeriod
WHERE 
GalaxyTimePeriodUid = @GalaxyTimePeriodUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyTimePeriodPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.GalaxyTimePeriod table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyTimePeriodPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyTimePeriodPDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyTimePeriodPDSA_SelectSearch]
@Display nvarchar(65),
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.GalaxyTimePeriod where (@Display IS NULL OR Display LIKE @Display + '%')

if @PageSize = 0
	set @PageSize = 1
SELECT 
GalaxyTimePeriodUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,Display
,Description
,PanelTimePeriodNumber
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,COUNT(*) OVER() TotalRowCount
FROM GCS.GalaxyTimePeriod
WHERE 
(@Display IS NULL OR Display LIKE @Display + '%')
ORDER BY (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 0 THEN Display end) asc,
         (CASE WHEN @SortColumn = 'Display' AND @DescendingOrder = 1 THEN Display end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyTimePeriodPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.GalaxyTimePeriod table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyTimePeriodPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyTimePeriodPDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyTimePeriodPDSA_Insert]
@GalaxyTimePeriodUid uniqueidentifier 
,@DisplayResourceKey uniqueidentifier  = null
,@DescriptionResourceKey uniqueidentifier  = null
,@EntityId uniqueidentifier 
,@Display nvarchar(65) 
,@Description nvarchar(1000) 
,@PanelTimePeriodNumber int 
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @GalaxyTimePeriodUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyTimePeriodUid = NULL
if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

if @GalaxyTimePeriodUid = '00000000-0000-0000-0000-000000000000' OR @GalaxyTimePeriodUid IS NULL
	SET @GalaxyTimePeriodUid = NewID()

INSERT INTO GCS.GalaxyTimePeriod
(
GalaxyTimePeriodUid
,DisplayResourceKey
,DescriptionResourceKey
,EntityId
,Display
,Description
,PanelTimePeriodNumber
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@GalaxyTimePeriodUid
,@DisplayResourceKey
,@DescriptionResourceKey
,@EntityId
,@Display
,@Description
,@PanelTimePeriodNumber
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyTimePeriodPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.GalaxyTimePeriod table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyTimePeriodPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyTimePeriodPDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyTimePeriodPDSA_Update]
@GalaxyTimePeriodUid uniqueidentifier 
,@DisplayResourceKey uniqueidentifier
,@DescriptionResourceKey uniqueidentifier
,@EntityId uniqueidentifier
,@Display nvarchar(65)
,@Description nvarchar(1000)
,@PanelTimePeriodNumber int
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @GalaxyTimePeriodUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyTimePeriodUid = NULL
if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

UPDATE GCS.GalaxyTimePeriod
SET 
DisplayResourceKey = @DisplayResourceKey
,DescriptionResourceKey = @DescriptionResourceKey
,EntityId = @EntityId
,Display = @Display
,Description = @Description
,PanelTimePeriodNumber = @PanelTimePeriodNumber
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
GalaxyTimePeriodUid = @GalaxyTimePeriodUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyTimePeriodPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.GalaxyTimePeriod table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyTimePeriodPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyTimePeriodPDSA_UpdateConcurrency]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyTimePeriodPDSA_UpdateConcurrency]
@GalaxyTimePeriodUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.GalaxyTimePeriod
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
GalaxyTimePeriodUid = @GalaxyTimePeriodUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyTimePeriodPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.GalaxyTimePeriod table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyTimePeriodPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyTimePeriodPDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyTimePeriodPDSA_DeleteByPK]
@GalaxyTimePeriodUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.GalaxyTimePeriod
WHERE
GalaxyTimePeriodUid = @GalaxyTimePeriodUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO


GRANT EXECUTE ON GCS.[GalaxyTimePeriodPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.GalaxyTimePeriod table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyTimePeriodPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyTimePeriodPDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyTimePeriodPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.GalaxyTimePeriod

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyTimePeriodPDSA_RowCount] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntity_GetAutoMapTimeSchedules]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntity_GetAutoMapTimeSchedules]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntity_GetAutoMapTimeSchedules]
@EntityId uniqueidentifier
AS

declare @ret int;
select @ret = 0;

SELECT AutoMapTimeSchedules from GCS.gcsEntity WHERE EntityId = @EntityId

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntity_GetAutoMapTimeSchedules] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntity_SetAutoMapTimeSchedules]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntity_SetAutoMapTimeSchedules]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntity_SetAutoMapTimeSchedules]
@EntityId uniqueidentifier,
@AutoMapTimeSchedules bit
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsEntity SET AutoMapTimeSchedules = @AutoMapTimeSchedules WHERE EntityId = @EntityId

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntity_SetAutoMapTimeSchedules] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsEntity_GetTimeScheduleCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsEntity_GetTimeScheduleCount]
GO
CREATE OR ALTER PROCEDURE GCS.[gcsEntity_GetTimeScheduleCount]
@EntityId uniqueidentifier
AS

declare @ret int;
select @ret = 0;

select count(*) AS TimeScheduleCount FROM GCS.TimeSchedule WHERE EntityId = @EntityId

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsEntity_GetTimeScheduleCount] TO public
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[Cluster_GetCounts]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[Cluster_GetCounts]
GO
CREATE OR ALTER PROCEDURE GCS.[Cluster_GetCounts]
@ClusterUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

declare @panelsCount int = 0
declare @boardsCount int = 0
declare @accessPortalsCount int = 0
declare @inputDevicesCount int = 0
declare @outputDevicesCount int = 0

select @panelsCount = count(*) FROM GCS.GalaxyPanel where ClusterUid = @ClusterUid
select @boardsCount = count(*) FROM GCS.GalaxyInterfaceBoard where GalaxyPanelUid in (SELECT GalaxyPanelUid from GCS.GalaxyPanel where ClusterUid = @ClusterUid)
select @accessPortalsCount = count(*) FROM GCS.AccessPortalGalaxyHardwareAddress where GalaxyPanelUid in (SELECT GalaxyPanelUid from GCS.GalaxyPanel where ClusterUid = @ClusterUid)
select @inputDevicesCount = count(*) FROM GCS.InputDeviceGalaxyHardwareAddress where GalaxyPanelUid in (SELECT GalaxyPanelUid from GCS.GalaxyPanel where ClusterUid = @ClusterUid)
select @outputDevicesCount = count(*) FROM  GCS.OutputDeviceGalaxyHardwareAddress where GalaxyPanelUid in (SELECT GalaxyPanelUid from GCS.GalaxyPanel where ClusterUid = @ClusterUid)

select @panelsCount as PanelsCount, @boardsCount as BoardsCount, @accessPortalsCount as AccessPortalsCount, @inputDevicesCount as InputDevicesCount, @outputDevicesCount as OutputDevicesCount
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[Cluster_GetCounts] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyClusterTimeScheduleMap table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyClusterTimeScheduleMapPDSA_ByClusterUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyClusterTimeScheduleMapPDSA_ByClusterUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyClusterTimeScheduleMapPDSA_ByClusterUid]
@ClusterUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyClusterTimeScheduleMapUid
,t.TimeScheduleUid
,t.ClusterUid
,PanelScheduleNumber
,FifteenMinuteFormatUsesHolidays
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
,Display as TimeScheduleName
FROM GCS.GalaxyClusterTimeScheduleMap t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
JOIN GCS.TimeSchedule s on s.TimeScheduleUid = t.TimeScheduleUid
WHERE 
t.ClusterUid = @ClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyClusterTimeScheduleMapPDSA_ByClusterUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyClusterTimeScheduleMap table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyClusterTimeScheduleMapPDSA_ByTimeScheduleUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyClusterTimeScheduleMapPDSA_ByTimeScheduleUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyClusterTimeScheduleMapPDSA_ByTimeScheduleUid]
@TimeScheduleUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyClusterTimeScheduleMapUid
,t.TimeScheduleUid
,t.ClusterUid
,PanelScheduleNumber
,FifteenMinuteFormatUsesHolidays
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ClusterName
,Display as TimeScheduleName
FROM GCS.GalaxyClusterTimeScheduleMap t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
JOIN GCS.TimeSchedule s on s.TimeScheduleUid = t.TimeScheduleUid
WHERE 
t.TimeScheduleUid = @TimeScheduleUid 

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyClusterTimeScheduleMapPDSA_ByTimeScheduleUid] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyClusterTimeScheduleMapPDSA_ByClusterUidAndTimeScheduleUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyClusterTimeScheduleMapPDSA_ByClusterUidAndTimeScheduleUid]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyClusterTimeScheduleMapPDSA_ByClusterUidAndTimeScheduleUid]
@ClusterUid uniqueidentifier,
@TimeScheduleUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyClusterTimeScheduleMapUid
,t.TimeScheduleUid
,c.ClusterUid
,PanelScheduleNumber
,FifteenMinuteFormatUsesHolidays
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ts.Display as TimeScheduleName
,c.ClusterName as ClusterName
FROM GCS.GalaxyClusterTimeScheduleMap t
JOIN GCS.Cluster c on c.ClusterUid = t.ClusterUid
JOIN GCS.TimeSchedule ts on ts.TimeScheduleUid = t.TimeScheduleUid
WHERE 
t.ClusterUid = @ClusterUid AND t.TimeScheduleUid = @TimeScheduleUid 

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyClusterTimeScheduleMapPDSA_ByClusterUidAndTimeScheduleUid] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DoEntityIdsMatch_ClusterUidTimeScheduleUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DoEntityIdsMatch_ClusterUidTimeScheduleUid]
GO
CREATE OR ALTER PROCEDURE GCS.[DoEntityIdsMatch_ClusterUidTimeScheduleUid]
@ClusterUid uniqueidentifier,
@TimeScheduleUid uniqueidentifier,
@PreventSystemEntityMatches bit,
@Result bit output
AS

declare @ret int;
select @ret = 0;
set @Result = 0;

declare @timeScheduleEntityId uniqueidentifier
declare @clusterEntityId uniqueidentifier

SELECT @timeScheduleEntityId = EntityId from GCS.TimeSchedule where TimeScheduleUid = @TimeScheduleUid
SELECT @clusterEntityId = EntityId from GCS.Cluster where ClusterUid = @ClusterUid

if @clusterEntityId IS NOT NULL AND @timeScheduleEntityId IS NOT NULL
BEGIN
	IF @clusterEntityId = @timeScheduleEntityId
		set @Result = 1
	ELSE IF @timeScheduleEntityId = '00000000-0000-0000-0000-000000000001' AND @PreventSystemEntityMatches = 0
		set @Result = 1
END
	
select @Result as Result

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DoEntityIdsMatch_ClusterUidTimeScheduleUid] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DoEntityIdsMatch_ClusterUidInputOutputGroupUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[DoEntityIdsMatch_ClusterUidInputOutputGroupUid]
GO
CREATE OR ALTER PROCEDURE GCS.[DoEntityIdsMatch_ClusterUidInputOutputGroupUid]
@ClusterUid uniqueidentifier,
@InputOutputGroupUid uniqueidentifier,
@PreventSystemEntityMatches bit,
@Result bit output
AS

declare @ret int;
select @ret = 0;
set @Result = 0;

declare @iogEntityId uniqueidentifier
declare @clusterEntityId uniqueidentifier

SELECT @iogEntityId = EntityId from GCS.InputOutputGroup where InputOutputGroupUid = @InputOutputGroupUid
SELECT @clusterEntityId = EntityId from GCS.Cluster where ClusterUid = @ClusterUid

if @clusterEntityId IS NOT NULL AND @iogEntityId IS NOT NULL
BEGIN
	IF @clusterEntityId = @iogEntityId
		set @Result = 1
	ELSE IF @iogEntityId = '00000000-0000-0000-0000-000000000001' AND @PreventSystemEntityMatches = 0
		set @Result = 1
END
	
select @Result as Result

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[DoEntityIdsMatch_ClusterUidInputOutputGroupUid] TO public
GO
CREATE OR ALTER FUNCTION [GCS].[fn_IsGalaxyAccessGroupAccessPortalMappingValid] (@AccessGroupUid uniqueidentifier, @AccessPortalUid uniqueidentifier, @TimeScheduleUid uniqueidentifier) 
RETURNS int
as
BEGIN
DECLARE @result int
set @result = 0
declare @accessGroupClusterUid uniqueidentifier
declare @accessPortalClusterUid uniqueidentifier
declare @timeScheduleClusterUid uniqueidentifier

-- Result codes
-- 0 = unknown
-- 1 = Valid
-- 2 = AccessGroup not found
-- 3 = AccessPortal not found or not mapped to galaxy cluster
-- 4 = TimeSchedule not found or not mapped to cluster
-- 5 = AccessGroup and AccessPortal do not belong to the same cluster
-- 6 = AccessGroup and Time Schedule do not belong to the same cluster

	select @accessGroupClusterUid = ClusterUid from GCS.AccessGroup where AccessGroupUid = @AccessGroupUid
	IF @accessGroupClusterUid IS NULL
	BEGIN
		set @result = 2
		RETURN @result
	END

	select @accessPortalClusterUid = ClusterUid from GCS.AccessPortalGalaxyHardwareAddressView where AccessPortalUid = @AccessPortalUid

	IF @accessPortalClusterUid IS NULL
	BEGIN
		set @result = 3
		RETURN @result
	END

	select @timeScheduleClusterUid = tsm.ClusterUid from GCS.GalaxyClusterTimeScheduleMap tsm join GCS.Cluster c on c.ClusterUid = tsm.ClusterUid where tsm.TimeScheduleUid = @TimeScheduleUid and tsm.ClusterUid = @accessGroupClusterUid
	IF @timeScheduleClusterUid IS NULL
	BEGIN
		set @result = 4
		RETURN @result
	END

	if @accessGroupClusterUid <> @accessPortalClusterUid
	BEGIN
		set @result = 5
		RETURN @result
	END
	
	if @accessGroupClusterUid <> @timeScheduleClusterUid
	BEGIN
		set @result = 6
		RETURN @result
	END
	
	set @result = 1
	return @result
END
GO

GRANT EXECUTE ON GCS.[fn_IsGalaxyAccessGroupAccessPortalMappingValid] TO public
GO


CREATE OR ALTER PROCEDURE GCS.[IsGalaxyAccessGroupAccessPortalMappingValid]
@AccessGroupUid uniqueidentifier, 
@AccessPortalUid uniqueidentifier,
@TimeScheduleUid uniqueidentifier,
@Result int output
AS

declare @ret int;
select @ret = 0;

select @Result = [GCS].[fn_IsGalaxyAccessGroupAccessPortalMappingValid] (@AccessGroupUid, @AccessPortalUid, @TimeScheduleUid)
	
select @Result as Result

if @@ROWCOUNT = 0
  SELECT @ret = 0;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[IsGalaxyAccessGroupAccessPortalMappingValid] TO public
GO



--IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DoEntityIdsMatch_ClusterUidAreaUid]') AND type in (N'P', N'PC'))
--DROP PROCEDURE GCS.[DoEntityIdsMatch_ClusterUidAreaUid]
--GO
--CREATE OR ALTER PROCEDURE GCS.[DoEntityIdsMatch_ClusterUidAreaUid]
--@ClusterUid uniqueidentifier,
--@AreaUid uniqueidentifier,
--@PreventSystemEntityMatches bit,
--@Result bit output
--AS

--declare @ret int;
--select @ret = 0;
--set @Result = 0;

--declare @areaEntityId uniqueidentifier
--declare @clusterEntityId uniqueidentifier

--SELECT @areaEntityId = EntityId from GCS.Area where AreaUid = @AreaUid
--SELECT @clusterEntityId = EntityId from GCS.Cluster where ClusterUid = @ClusterUid

--if @clusterEntityId IS NOT NULL AND @areaEntityId IS NOT NULL
--BEGIN
--	IF @clusterEntityId = @areaEntityId
--		set @Result = 1
--	ELSE IF @areaEntityId = '00000000-0000-0000-0000-000000000001' AND @PreventSystemEntityMatches = 0
--		set @Result = 1
--END
	
--select @Result as Result

--if @@ROWCOUNT = 0
--  SELECT @ret = -1;

--RETURN @ret;
--GO

--GRANT EXECUTE ON GCS.[DoEntityIdsMatch_ClusterUidAreaUid] TO public
--GO


--IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[DoEntityIdsMatch_ClusterUidAccessGroupUid]') AND type in (N'P', N'PC'))
--DROP PROCEDURE GCS.[DoEntityIdsMatch_ClusterUidAreaUid]
--GO
--CREATE OR ALTER PROCEDURE GCS.[DoEntityIdsMatch_ClusterUidAreaUid]
--@ClusterUid uniqueidentifier,
--@AreaUid uniqueidentifier,
--@PreventSystemEntityMatches bit,
--@Result bit output
--AS

--declare @ret int;
--select @ret = 0;
--set @Result = 0;

--declare @areaEntityId uniqueidentifier
--declare @clusterEntityId uniqueidentifier

--SELECT @areaEntityId = EntityId from GCS.Area where AreaUid = @AreaUid
--SELECT @clusterEntityId = EntityId from GCS.Cluster where ClusterUid = @ClusterUid

--if @clusterEntityId IS NOT NULL AND @areaEntityId IS NOT NULL
--BEGIN
--	IF @clusterEntityId = @areaEntityId
--		set @Result = 1
--	ELSE IF @areaEntityId = '00000000-0000-0000-0000-000000000001' AND @PreventSystemEntityMatches = 0
--		set @Result = 1
--END
	
--select @Result as Result

--if @@ROWCOUNT = 0
--  SELECT @ret = -1;

--RETURN @ret;
--GO

--GRANT EXECUTE ON GCS.[DoEntityIdsMatch_ClusterUidAreaUid] TO public
--GO






IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsGalaxyPanelNumberUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsGalaxyPanelNumberUnique]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[IsGalaxyPanelNumberUnique]
	@GalaxyPanelUid [uniqueidentifier],
	@ClusterUid [uniqueidentifier],
	@PanelNumber [int],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
	select @Result = count(*) from GCS.GalaxyPanel where GalaxyPanelUid <> @GalaxyPanelUid AND ClusterUid = @ClusterUid AND PanelNumber = @PanelNumber 
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsGalaxyPanelNumberUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsGalaxyPanelNumberUnique] TO [public] AS [dbo]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsGalaxyPanelNameUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsGalaxyPanelNameUnique]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[IsGalaxyPanelNameUnique]
	@GalaxyPanelUid [uniqueidentifier],
	@ClusterUid [uniqueidentifier],
	@PanelName nvarchar(65),
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
	select @Result = count(*) from GCS.GalaxyPanel where GalaxyPanelUid <> @GalaxyPanelUid AND ClusterUid = @ClusterUid AND PanelName = @PanelName 
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsGalaxyPanelNameUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsGalaxyPanelNameUnique] TO [public] AS [dbo]
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsInputOutputGroupValidForGalaxyPanel]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsInputOutputGroupValidForGalaxyPanel]
GO

CREATE OR ALTER PROCEDURE GCS.[IsInputOutputGroupValidForGalaxyPanel]
@InputOutputGroupUid uniqueidentifier,
@GalaxyPanelUid uniqueidentifier,
@Result int OUTPUT
AS

set nocount on
declare @ret int;
select @ret = 0;
select @Result = 0;

--if exists (select InputOutputGroupUid from GCS.InputOutputGroup iog
--where iog.ClusterUid = (select ClusterUid from GCS.GalaxyPanel where GalaxyPanelUid = @GalaxyPanelUid)
--and iog.InputOutputGroupUid = @InputOutputGroupUid)
if exists(select InputOutputGroupUid from GCS.InputOutputGroup iog
join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = @GalaxyPanelUid
where iog.ClusterUid = gp.ClusterUid
and iog.InputOutputGroupUid = @InputOutputGroupUid)
	set @ret = 1

set @Result = @ret;
select @Result as Result
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[IsInputOutputGroupValidForGalaxyPanel] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsInputOutputGroupValidForAccessPortal]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsInputOutputGroupValidForAccessPortal]
GO

CREATE OR ALTER PROCEDURE GCS.[IsInputOutputGroupValidForAccessPortal]
@InputOutputGroupUid uniqueidentifier,
@AccessPortalUid uniqueidentifier,
@Result int OUTPUT
AS

set nocount on
declare @ret int;
select @ret = 0;
select @Result = 0;

--if exists (select InputOutputGroupUid from GCS.InputOutputGroup iog
--where iog.ClusterUid = (select ClusterUid from GCS.GalaxyPanel where GalaxyPanelUid = @GalaxyPanelUid)
--and iog.InputOutputGroupUid = @InputOutputGroupUid)
if exists(select InputOutputGroupUid from GCS.InputOutputGroup iog
join GCS.AccessPortalGalaxyHardwareAddress ap on ap.AccessPortalUid = @AccessPortalUid
join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ap.GalaxyPanelUid
where iog.ClusterUid = gp.ClusterUid
and iog.InputOutputGroupUid = @InputOutputGroupUid)
	set @ret = 1

set @Result = @ret;
select @Result as Result
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[IsInputOutputGroupValidForAccessPortal] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsInputOutputGroupValidForInputDevice]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsInputOutputGroupValidForInputDevice]
GO

CREATE OR ALTER PROCEDURE GCS.[IsInputOutputGroupValidForInputDevice]
@InputOutputGroupUid uniqueidentifier,
@InputDeviceUid uniqueidentifier,
@Result int OUTPUT
AS

set nocount on
declare @ret int;
select @ret = 0;
select @Result = 0;

--if exists (select InputOutputGroupUid from GCS.InputOutputGroup iog
--where iog.ClusterUid = (select ClusterUid from GCS.GalaxyPanel where GalaxyPanelUid = @GalaxyPanelUid)
--and iog.InputOutputGroupUid = @InputOutputGroupUid)
if exists(select InputOutputGroupUid from GCS.InputOutputGroup iog
join GCS.InputDeviceGalaxyHardwareAddress id on id.InputDeviceUid = @InputDeviceUid
join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = id.GalaxyPanelUid
where iog.ClusterUid = gp.ClusterUid
and iog.InputOutputGroupUid = @InputOutputGroupUid)
	set @ret = 1

set @Result = @ret;
select @Result as Result
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[IsInputOutputGroupValidForInputDevice] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[IsInputOutputGroupValidForOutputDevice]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[IsInputOutputGroupValidForOutputDevice]
GO

CREATE OR ALTER PROCEDURE GCS.[IsInputOutputGroupValidForOutputDevice]
@InputOutputGroupUid uniqueidentifier,
@OutputDeviceUid uniqueidentifier,
@Result int OUTPUT
AS

set nocount on
declare @ret int;
select @ret = 0;
select @Result = 0;

--if exists (select InputOutputGroupUid from GCS.InputOutputGroup iog
--where iog.ClusterUid = (select ClusterUid from GCS.GalaxyPanel where GalaxyPanelUid = @GalaxyPanelUid)
--and iog.InputOutputGroupUid = @InputOutputGroupUid)
if exists(select InputOutputGroupUid from GCS.InputOutputGroup iog
join GCS.OutputDeviceGalaxyHardwareAddress od on od.OutputDeviceUid = @OutputDeviceUid
join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = od.GalaxyPanelUid
where iog.ClusterUid = gp.ClusterUid
and iog.InputOutputGroupUid = @InputOutputGroupUid)
	set @ret = 1

set @Result = @ret;
select @Result as Result
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[IsInputOutputGroupValidForOutputDevice] TO public
GO


/****** Object:  Index [idxAccessPortalActivityEventUniqueId]    Script Date: 5/24/2021 2:58:18 PM ******/
if dbo.[fn_GCSDoesIndexExist]('GalaxyPanelAlertEvent', 'idxGalaxyPanelAlertEventType') = 1
BEGIN
	DROP INDEX [idxGalaxyPanelAlertEventType] ON [GCS].[GalaxyPanelAlertEvent]
END
GO

/*==============================================================*/
/* Index: idxGalaxyPanelAlertEventType                          */
/*==============================================================*/
create unique nonclustered index idxGalaxyPanelAlertEventType on GCS.GalaxyPanelAlertEvent (GalaxyPanelUid ASC,
  GalaxyPanelAlertEventTypeUid ASC)
go




/****** Object:  StoredProcedure [GCS].[AccessPortal_GetAlertEventAcknowledgeData]    Script Date: 8/31/2020 2:22:22 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessPortal_GetAlertEventAcknowledgeData]
	@AccessPortalUid [uniqueidentifier],
	@GalaxyPanelUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
IF @AccessPortalUid IS NOT NULL AND @AccessPortalUid <> '00000000-0000-0000-0000-000000000000'
	BEGIN
		SELECT apae.AccessPortalUid, apae.AccessPortalAlertEventTypeUid, apaet.Tag, apaet.CanHaveAudio, apaet.CanHaveInstructions, apaet.CanHaveSchedule, apae.AcknowledgeTimeScheduleUid, apae.AcknowledgePriority, apae.IsActive, n.NoteText as ResponseInstructions, apae.ResponseInstructionsUid,
		apae.AudioBinaryResourceUid, hwa.GalaxyPanelUid, gp.ClusterUid, tst.ScheduleTypeCode,
		apae.ResponseRequired
		FROM GCS.AccessPortalAlertEvent apae
		JOIN GCS.AccessPortalAlertEventType apaet on apaet.AccessPortalAlertEventTypeUid = apae.AccessPortalAlertEventTypeUid
		JOIN GCS.AccessPortalGalaxyHardwareAddress hwa on hwa.AccessPortalUid = apae.AccessPortalUid
		JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = hwa.GalaxyPanelUid
		JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
		JOIN GCS.TimeScheduleType tst on tst.TimeScheduleTypeUid = c.TimeScheduleTypeUid
		LEFT OUTER JOIN GCS.gcsBinaryResource audioBr on audioBr.BinaryResourceUid = apae.AudioBinaryResourceUid
		LEFT OUTER JOIN GCS.Note n on n.NoteUid = apae.ResponseInstructionsUid
		WHERE apaet.CanAcknowledge = 1 AND apae.AccessPortalUid = @AccessPortalUid 
		ORDER BY apae.AccessPortalUid --apae.AccessPortalUid = @accessPortalUid
	END
	ELSE IF @GalaxyPanelUid IS NOT NULL AND @GalaxyPanelUid <> '00000000-0000-0000-0000-000000000000'
	BEGIN
		SELECT apae.AccessPortalUid, apae.AccessPortalAlertEventTypeUid, apaet.Tag, apaet.CanHaveAudio, apaet.CanHaveInstructions, apaet.CanHaveSchedule, apae.AcknowledgeTimeScheduleUid, apae.AcknowledgePriority, apae.IsActive, n.NoteText as ResponseInstructions, apae.ResponseInstructionsUid,
		apae.AudioBinaryResourceUid, hwa.GalaxyPanelUid, gp.ClusterUid, tst.ScheduleTypeCode,
		apae.ResponseRequired
		FROM GCS.AccessPortalAlertEvent apae
		JOIN GCS.AccessPortalAlertEventType apaet on apaet.AccessPortalAlertEventTypeUid = apae.AccessPortalAlertEventTypeUid
		JOIN GCS.AccessPortalGalaxyHardwareAddress hwa on hwa.AccessPortalUid = apae.AccessPortalUid
		JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = hwa.GalaxyPanelUid
		JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
		JOIN GCS.TimeScheduleType tst on tst.TimeScheduleTypeUid = c.TimeScheduleTypeUid
		LEFT OUTER JOIN GCS.gcsBinaryResource audioBr on audioBr.BinaryResourceUid = apae.AudioBinaryResourceUid
		LEFT OUTER JOIN GCS.Note n on n.NoteUid = apae.ResponseInstructionsUid
		WHERE apaet.CanAcknowledge = 1 AND hwa.GalaxyPanelUid = @GalaxyPanelUid
		ORDER BY apae.AccessPortalUid 
	END
	ELSE
	BEGIN
		SELECT apae.AccessPortalUid, apae.AccessPortalAlertEventTypeUid, apaet.Tag, apaet.CanHaveAudio, apaet.CanHaveInstructions, apaet.CanHaveSchedule, apae.AcknowledgeTimeScheduleUid, apae.AcknowledgePriority, apae.IsActive, n.NoteText as ResponseInstructions, apae.ResponseInstructionsUid,
		apae.AudioBinaryResourceUid, hwa.GalaxyPanelUid, gp.ClusterUid, tst.ScheduleTypeCode,
		apae.ResponseRequired
		FROM GCS.AccessPortalAlertEvent apae
		JOIN GCS.AccessPortalAlertEventType apaet on apaet.AccessPortalAlertEventTypeUid = apae.AccessPortalAlertEventTypeUid
		JOIN GCS.AccessPortalGalaxyHardwareAddress hwa on hwa.AccessPortalUid = apae.AccessPortalUid
		JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = hwa.GalaxyPanelUid
		JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
		JOIN GCS.TimeScheduleType tst on tst.TimeScheduleTypeUid = c.TimeScheduleTypeUid
		LEFT OUTER JOIN GCS.gcsBinaryResource audioBr on audioBr.BinaryResourceUid = apae.AudioBinaryResourceUid
		LEFT OUTER JOIN GCS.Note n on n.NoteUid = apae.ResponseInstructionsUid
		ORDER BY apae.AccessPortalUid 
	END
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortal_GetAlertEventAcknowledgeData] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortal_GetAlertEventAcknowledgeData] TO [public] AS [dbo]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[GalaxyPanel_GetAlertEventAcknowledgeData]
	@GalaxyPanelUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
SELECT gpae.GalaxyPanelUid, gpae.GalaxyPanelAlertEventTypeUid, gpaet.Tag, gpaet.CanHaveAudio, gpaet.CanHaveInstructions, gpaet.CanHaveSchedule, gpae.AcknowledgeTimeScheduleUid, gpae.AcknowledgePriority, gpae.IsActive, n.NoteText as ResponseInstructions, gpae.UserInstructionsNoteUid,
	gpae.AudioBinaryResourceUid, gp.ClusterUid, tst.ScheduleTypeCode,
	gpae.ResponseRequired
	FROM GCS.GalaxyPanelAlertEvent gpae
	JOIN GCS.GalaxyPanelAlertEventType gpaet on gpaet.GalaxyPanelAlertEventTypeUid = gpae.GalaxyPanelAlertEventTypeUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = gpae.GalaxyPanelUid
	JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
	JOIN GCS.TimeScheduleType tst on tst.TimeScheduleTypeUid = c.TimeScheduleTypeUid
	LEFT OUTER JOIN GCS.gcsBinaryResource audioBr on audioBr.BinaryResourceUid = gpae.AudioBinaryResourceUid
	LEFT OUTER JOIN GCS.Note n on n.NoteUid = gpae.UserInstructionsNoteUid
	WHERE gpaet.CanAcknowledge = 1 AND gpae.GalaxyPanelUid = @GalaxyPanelUid
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyPanel_GetAlertEventAcknowledgeData] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyPanel_GetAlertEventAcknowledgeData] TO [public] AS [dbo]
GO
/****** Object:  StoredProcedure [GCS].[InputDevice_GetAlertEventAcknowledgeData]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE OR ALTER PROCEDURE [GCS].[InputDevice_GetAlertEventAcknowledgeData]
	@InputDeviceUid [uniqueidentifier],
	@GalaxyPanelUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
IF @InputDeviceUid IS NOT NULL AND @InputDeviceUid <> '00000000-0000-0000-0000-000000000000'
	BEGIN
		SELECT idep.InputDeviceUid, idep.InputDeviceAlertEventTypeUid, idaet.Tag, idaet.CanHaveAudio, idaet.CanHaveInstructions, idaet.CanHaveSchedule, idep.AcknowledgeTimeScheduleUid, idep.AcknowledgePriority, idep.IsActive, n.NoteText as ResponseInstructions, idep.ResponseInstructionsUid,
		idep.AudioBinaryResourceUid, hwa.GalaxyPanelUid, gp.ClusterUid, tst.ScheduleTypeCode,
		idep.ResponseRequired
		FROM GCS.InputDeviceEventProperties idep
		JOIN GCS.InputDeviceAlertEventType idaet on idaet.InputDeviceAlertEventTypeUid = idep.InputDeviceAlertEventTypeUid
		JOIN GCS.InputDeviceGalaxyHardwareAddress hwa on hwa.InputDeviceUid = idep.InputDeviceUid
		JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = hwa.GalaxyPanelUid
		JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
		JOIN GCS.TimeScheduleType tst on tst.TimeScheduleTypeUid = c.TimeScheduleTypeUid
		LEFT OUTER JOIN GCS.gcsBinaryResource audioBr on audioBr.BinaryResourceUid = idep.AudioBinaryResourceUid
		LEFT OUTER JOIN GCS.Note n on n.NoteUid = idep.ResponseInstructionsUid
		WHERE idaet.CanAcknowledge = 1 AND idep.InputDeviceUid = @InputDeviceUid 
		ORDER BY idep.InputDeviceUid --idae.InputDeviceUid = @accessPortalUid
	END
	ELSE IF @GalaxyPanelUid IS NOT NULL AND @GalaxyPanelUid <> '00000000-0000-0000-0000-000000000000'
	BEGIN
		SELECT idep.InputDeviceUid, idep.InputDeviceAlertEventTypeUid, idaet.Tag, idaet.CanHaveAudio, idaet.CanHaveInstructions, idaet.CanHaveSchedule, idep.AcknowledgeTimeScheduleUid, idep.AcknowledgePriority, idep.IsActive, n.NoteText as ResponseInstructions, idep.ResponseInstructionsUid,
		idep.AudioBinaryResourceUid, hwa.GalaxyPanelUid, gp.ClusterUid, tst.ScheduleTypeCode,
		idep.ResponseRequired
		FROM GCS.InputDeviceEventProperties idep
		JOIN GCS.InputDeviceAlertEventType idaet on idaet.InputDeviceAlertEventTypeUid = idep.InputDeviceAlertEventTypeUid
		JOIN GCS.InputDeviceGalaxyHardwareAddress hwa on hwa.InputDeviceUid = idep.InputDeviceUid
		JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = hwa.GalaxyPanelUid
		JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
		JOIN GCS.TimeScheduleType tst on tst.TimeScheduleTypeUid = c.TimeScheduleTypeUid
		LEFT OUTER JOIN GCS.gcsBinaryResource audioBr on audioBr.BinaryResourceUid = idep.AudioBinaryResourceUid
		LEFT OUTER JOIN GCS.Note n on n.NoteUid = idep.ResponseInstructionsUid
		WHERE idaet.CanAcknowledge = 1 AND hwa.GalaxyPanelUid = @GalaxyPanelUid
		ORDER BY idep.InputDeviceUid 
	END
	ELSE
	BEGIN
		SELECT idep.InputDeviceUid, idep.InputDeviceAlertEventTypeUid, idaet.Tag, idaet.CanHaveAudio, idaet.CanHaveInstructions, idaet.CanHaveSchedule, idep.AcknowledgeTimeScheduleUid, idep.AcknowledgePriority, idep.IsActive, n.NoteText as ResponseInstructions, idep.ResponseInstructionsUid,
		idep.AudioBinaryResourceUid, hwa.GalaxyPanelUid, gp.ClusterUid, tst.ScheduleTypeCode,
		idep.ResponseRequired
		FROM GCS.InputDeviceEventProperties idep
		JOIN GCS.InputDeviceAlertEventType idaet on idaet.InputDeviceAlertEventTypeUid = idep.InputDeviceAlertEventTypeUid
		JOIN GCS.InputDeviceGalaxyHardwareAddress hwa on hwa.InputDeviceUid = idep.InputDeviceUid
		JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = hwa.GalaxyPanelUid
		JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
		JOIN GCS.TimeScheduleType tst on tst.TimeScheduleTypeUid = c.TimeScheduleTypeUid
		LEFT OUTER JOIN GCS.gcsBinaryResource audioBr on audioBr.BinaryResourceUid = idep.AudioBinaryResourceUid
		LEFT OUTER JOIN GCS.Note n on n.NoteUid = idep.ResponseInstructionsUid
		ORDER BY idep.InputDeviceUid 
	END
GO
ALTER AUTHORIZATION ON [GCS].[InputDevice_GetAlertEventAcknowledgeData] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputDevice_GetAlertEventAcknowledgeData] TO [public] AS [dbo]
GO

/* All Stored Procedures for table: InputDeviceEventProperties */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.InputDeviceEventProperties table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_SelectAll]
GO

CREATE PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceEventPropertiesUid
,InputDeviceUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AcknowledgeTimeScheduleUid
,InputDeviceAlertEventTypeUid
,AcknowledgePriority
,ResponseRequired
,Tag
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.InputDeviceEventProperties

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDeviceEventProperties table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_ByInputDeviceAlertEventTypeUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_ByInputDeviceAlertEventTypeUid]
GO
CREATE PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_ByInputDeviceAlertEventTypeUid]
@InputDeviceAlertEventTypeUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceEventPropertiesUid
,InputDeviceUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AcknowledgeTimeScheduleUid
,InputDeviceAlertEventTypeUid
,AcknowledgePriority
,ResponseRequired
,Tag
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.InputDeviceEventProperties
WHERE 
InputDeviceAlertEventTypeUid = @InputDeviceAlertEventTypeUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_ByInputDeviceAlertEventTypeUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDeviceEventProperties table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_ByInputDeviceUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_ByInputDeviceUid]
GO
CREATE PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_ByInputDeviceUid]
@InputDeviceUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceEventPropertiesUid
,InputDeviceUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AcknowledgeTimeScheduleUid
,InputDeviceAlertEventTypeUid
,AcknowledgePriority
,ResponseRequired
,Tag
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.InputDeviceEventProperties
WHERE 
InputDeviceUid = @InputDeviceUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_ByInputDeviceUid] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.InputDeviceEventProperties table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_SelectListBox]
GO

CREATE PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceEventPropertiesUid
,Tag
FROM GCS.InputDeviceEventProperties

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.InputDeviceEventProperties table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_SelectByPK]
GO
CREATE PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_SelectByPK]
@InputDeviceEventPropertiesUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceEventPropertiesUid
,InputDeviceUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AcknowledgeTimeScheduleUid
,InputDeviceAlertEventTypeUid
,AcknowledgePriority
,ResponseRequired
,Tag
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.InputDeviceEventProperties
WHERE 
InputDeviceEventPropertiesUid = @InputDeviceEventPropertiesUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.InputDeviceEventProperties table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_SelectSearch]
GO
CREATE PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_SelectSearch]
@Tag nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceEventPropertiesUid
,InputDeviceUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AcknowledgeTimeScheduleUid
,InputDeviceAlertEventTypeUid
,AcknowledgePriority
,ResponseRequired
,Tag
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.InputDeviceEventProperties
WHERE 
(@Tag IS NULL OR Tag LIKE @Tag + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.InputDeviceEventProperties table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_Insert]
GO
CREATE PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_Insert]
@InputDeviceEventPropertiesUid uniqueidentifier 
,@InputDeviceUid uniqueidentifier 
,@AudioBinaryResourceUid uniqueidentifier  = null
,@ResponseInstructionsUid uniqueidentifier  = null
,@AcknowledgeTimeScheduleUid uniqueidentifier  = null
,@InputDeviceAlertEventTypeUid uniqueidentifier 
,@AcknowledgePriority int 
,@ResponseRequired bit
,@Tag nvarchar(65) 
,@IsActive bit
,@InsertName nvarchar(100) 
,@InsertDate datetimeoffset 
,@UpdateName nvarchar(100) 
,@UpdateDate datetimeoffset 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @InputDeviceEventPropertiesUid = '00000000-0000-0000-0000-000000000000'
	SET @InputDeviceEventPropertiesUid = NULL

if @AudioBinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @AudioBinaryResourceUid = NULL
if @ResponseInstructionsUid = '00000000-0000-0000-0000-000000000000'
	SET @ResponseInstructionsUid = NULL
if @AcknowledgeTimeScheduleUid = '00000000-0000-0000-0000-000000000000'
	SET @AcknowledgeTimeScheduleUid = NULL

if @InputDeviceEventPropertiesUid = '00000000-0000-0000-0000-000000000000' OR @InputDeviceEventPropertiesUid IS NULL
	SET @InputDeviceEventPropertiesUid = NewID()

INSERT INTO GCS.InputDeviceEventProperties
(
InputDeviceEventPropertiesUid
,InputDeviceUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AcknowledgeTimeScheduleUid
,InputDeviceAlertEventTypeUid
,AcknowledgePriority
,ResponseRequired
,Tag
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@InputDeviceEventPropertiesUid
,@InputDeviceUid
,@AudioBinaryResourceUid
,@ResponseInstructionsUid
,@AcknowledgeTimeScheduleUid
,@InputDeviceAlertEventTypeUid
,@AcknowledgePriority
,@ResponseRequired
,@Tag
,@IsActive
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.InputDeviceEventProperties table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_Update]
GO
CREATE PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_Update]
@InputDeviceEventPropertiesUid uniqueidentifier 
,@InputDeviceUid uniqueidentifier
,@AudioBinaryResourceUid uniqueidentifier
,@ResponseInstructionsUid uniqueidentifier
,@AcknowledgeTimeScheduleUid uniqueidentifier
,@InputDeviceAlertEventTypeUid uniqueidentifier
,@AcknowledgePriority int
,@ResponseRequired bit
,@Tag nvarchar(65)
,@IsActive bit
,@UpdateName nvarchar(100)
,@UpdateDate datetimeoffset
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @AudioBinaryResourceUid = '00000000-0000-0000-0000-000000000000'
	SET @AudioBinaryResourceUid = NULL
if @ResponseInstructionsUid = '00000000-0000-0000-0000-000000000000'
	SET @ResponseInstructionsUid = NULL
if @AcknowledgeTimeScheduleUid = '00000000-0000-0000-0000-000000000000'
	SET @AcknowledgeTimeScheduleUid = NULL

UPDATE GCS.InputDeviceEventProperties
SET 
InputDeviceEventPropertiesUid = @InputDeviceEventPropertiesUid
,InputDeviceUid = @InputDeviceUid
,AudioBinaryResourceUid = @AudioBinaryResourceUid
,ResponseInstructionsUid = @ResponseInstructionsUid
,AcknowledgeTimeScheduleUid = @AcknowledgeTimeScheduleUid
,InputDeviceAlertEventTypeUid = @InputDeviceAlertEventTypeUid
,AcknowledgePriority = @AcknowledgePriority
,ResponseRequired = @ResponseRequired
,Tag = @Tag
,IsActive = @IsActive
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
InputDeviceEventPropertiesUid = @InputDeviceEventPropertiesUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.InputDeviceEventProperties table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_UpdateConcurrency]
GO
CREATE PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_UpdateConcurrency]
@InputDeviceEventPropertiesUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.InputDeviceEventProperties
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
InputDeviceEventPropertiesUid = @InputDeviceEventPropertiesUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.InputDeviceEventProperties table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_DeleteByPK]
GO
CREATE PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_DeleteByPK]
@InputDeviceEventPropertiesUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.InputDeviceEventProperties
WHERE
InputDeviceEventPropertiesUid = @InputDeviceEventPropertiesUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.InputDeviceEventProperties table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_RowCount]
GO
CREATE PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.InputDeviceEventProperties

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_RowCount] TO public
GO




/****** Object:  View [GCS].[GalaxyPanelAlarmSettings_PanelLoadData]    Script Date: 8/31/2020 2:21:56 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create or alter view [GCS].[GalaxyPanelAlarmSettings_PanelLoadData] as
select gp.PanelNumber, gp.GalaxyPanelUid,
e.EntityName, e.EntityId, c.ClusterUid, c.ClusterGroupId, c.ClusterNumber, c.ClusterName,
gpaet.Tag, iog.IOGroupNumber, ioga.OffsetIndex, gpae.IsActive
from GCS.GalaxyPanel gp 
join GCS.Cluster c on c.ClusterUid = gp.ClusterUid
join GCS.gcsEntity e on e.EntityId = c.EntityId
join GCS.GalaxyPanelAlertEvent gpae on gpae.GalaxyPanelUid = gp.GalaxyPanelUid
join GCS.GalaxyPanelAlertEventType gpaet on gpaet.GalaxyPanelAlertEventTypeUid = gpae.GalaxyPanelAlertEventTypeUid
left outer join GCS.InputOutputGroup iog on iog.InputOutputGroupUid = gpae.InputOutputGroupUid
left outer join GCS.InputOutputGroupAssignment ioga on ioga.InputOutputGroupAssignmentUid = gpae.InputOutputGroupAssignmentUid
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyPanelAlarmSettings_PanelLoadData] TO  SCHEMA OWNER 
GO

create or alter view [GCS].[InputDevice_PanelLoadDataChangesForCpu] as
SELECT id.InputDeviceUid
	,idCluster.ClusterUid
	,idPanel.GalaxyPanelUid
	,idBoard.GalaxyInterfaceBoardUid
	,idSection.GalaxyInterfaceBoardSectionUid
	,idModule.GalaxyHardwareModuleUid
	,idNode.GalaxyInterfaceBoardSectionNodeUid
	,id.InputName
	,idCluster.ClusterGroupId
	,idCluster.ClusterNumber
	,idPanel.PanelNumber
	,idBoard.BoardNumber
	,idSection.SectionNumber
	,idModule.ModuleNumber
	,idNode.NodeNumber
	,id.IsActive as IsInputActive
	,idNode.IsNodeActive
	,idModule.IsModuleActive
	,idBoardSectionMode.ModeCode as InputDeviceBoardSectionMode
	,idBoardSectionMode.Display as InputDeviceBoardSectionModeDisplay
	,idPanelModel.TypeCode as InputDevicePanelModelTypeCode
	,idCpuModel.TypeCode as InputDeviceCpuTypeCode
	,idBoardType.Model as InputDeviceBoardTypeModel
	,idBoardType.TypeCode as InputDeviceBoardTypeTypeCode
	,idBoardType.Display as InputDeviceBoardTypeDisplay
	,superType.Display as SupervisionTypeDisplay
	,superType.HasSeriesResistor
	,superType.HasParallelResistor
	,galinpdev.IsNormalOpen
	,galinpdev.TroubleShortThreshold
	,galinpdev.TroubleOpenThreshold
	,galinpdev.NormalChangeThreshold
	,galinpdev.AlternateNormalChangeThreshold
	,galinpdev.AlternateTroubleOpenThreshold
	,galinpdev.AlternateTroubleShortThreshold
	,galinpdev.AlternateVoltagesEnabled
	,galInputMode.Display as GalaxyInputModeDisplay
	,galInputMode.Code as GalaxyInputModeCode
	,galInputDelayType.Display as GalaxyInputDelayTypeDisplay
	,galInputDelayType.Code as GalaxyInputDelayTypeCode
	,mainInputDeviceEvent.Tag as MainIOGroupTag
	,mainIOGroup.Display as MainIOGroupDisplay
	,mainIOGroup.IOGroupNumber as MainIOGroupNumber
	,mainIOGroup.LocalIOGroup as MainIOGroupIsLocal
	,mainIOGroupAssignment.OffsetIndex as MainIOGroupOffset
	,DelayDuration
	,DisableDisarmedOnOffLogEvents
	,mainTs.Display as ArmControlScheduleDisplay
	,armControlScheduleMap.PanelScheduleNumber as ArmControlScheduleNumber
	,ioGroup1.Display as ArmingIOGroup1Display
	,ioGroup1.IOGroupNumber as ArmingIOGroupNumber1
	,ioGroup1.LocalIOGroup as ArmingIOGroup1IsLocal
	,ioGroup2.Display as ArmingIOGroup2Display
	,ioGroup2.IOGroupNumber as ArmingIOGroupNumber2
	,ioGroup2.LocalIOGroup as ArmingIOGroup2IsLocal
	,ioGroup3.Display as ArmingIOGroup3Display
	,ioGroup3.IOGroupNumber as ArmingIOGroupNumber3
	,ioGroup3.LocalIOGroup as ArmingIOGroup3IsLocal
	,ioGroup4.Display as ArmingIOGroup4Display
	,ioGroup4.IOGroupNumber as ArmingIOGroupNumber4
	,ioGroup4.LocalIOGroup as ArmingIOGroup4IsLocal
	,galinpdev.[UpdateDate] as GalaxyInputDevicePropertiesLastUpdated
	,mainInputDeviceEvent.UpdateDate as MainIOGroupLastUpdated
	,armingIoGroup1.UpdateDate as ArmingIOGroup1LastUpdated
	,armingIoGroup2.UpdateDate as ArmingIOGroup2LastUpdated
	,armingIoGroup3.UpdateDate as ArmingIOGroup3LastUpdated
	,armingIoGroup4.UpdateDate as ArmingIOGroup4LastUpdated
	,galaxyInputMainSchedule.UpdateDate as MainScheduleLastUpdated
	,cpu.CpuNumber
	,cpu.CpuUid
	,gcc.ServerAddress
	,gcc.IsConnected
	,mainInputDeviceEvent.IsActive as MainIOGroupIsActive
FROM GCS.InputDevice id
	JOIN GCS.GalaxyInputDevice galinpdev on galinpdev.InputDeviceUid = id.InputDeviceUid
	JOIN GCS.InputDeviceSupervisionType superType on superType.InputDeviceSupervisionTypeUid = galinpdev.InputDeviceSupervisionTypeUid
	JOIN GCS.GalaxyInputMode galInputMode on galInputMode.GalaxyInputModeUid = galinpdev.GalaxyInputModeUid
	JOIN GCS.GalaxyInputDelayType galInputDelayType ON galInputDelayType.GalaxyInputDelayTypeUid = galinpdev.GalaxyInputDelayTypeUid

	--JOIN GCS.GalaxyInputDeviceTimeSchedule galaxyInputMainSchedule on galaxyInputMainSchedule.InputDeviceUid = galinpdev.InputDeviceUid
	--JOIN GCS.TimeSchedule mainTs on mainTs.TimeScheduleUid = galaxyInputMainSchedule.TimeScheduleUid
	--JOIN GCS.GalaxyClusterTimeScheduleMap armControlScheduleMap on armControlScheduleMap.TimeScheduleUid = mainTs.TimeScheduleUid AND armControlScheduleMap.ClusterUid = idPanel.ClusterUid

	LEFT OUTER JOIN GCS.InputDeviceAlertEvent mainInputDeviceEvent on mainInputDeviceEvent.InputDeviceUid = galinpdev.InputDeviceUid AND mainInputDeviceEvent.InputDeviceAlertEventTypeUid = '00000000-0000-0000-0000-000000000001'
	LEFT OUTER JOIN GCS.InputOutputGroup mainIOGroup on mainIOGroup.InputOutputGroupUid = mainInputDeviceEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment mainIOGroupAssignment on mainIOGroupAssignment.InputOutputGroupAssignmentUid = mainInputDeviceEvent.InputOutputGroupAssignmentUid

	-- Arming Input IO Groups
	-- Arming IOGroup1 
	LEFT OUTER JOIN GCS.GalaxyInputArmingInputOutputGroup armingIoGroup1 on armingIoGroup1.InputDeviceUid = galinpdev.InputDeviceUid AND armingIoGroup1.OrderNumber = 1
	LEFT OUTER JOIN GCS.InputOutputGroup ioGroup1 on ioGroup1.InputOutputGroupUid = armingIoGroup1.InputOutputGroupUid
	-- Arming IOGroup2
	LEFT OUTER JOIN GCS.GalaxyInputArmingInputOutputGroup armingIoGroup2 on armingIoGroup2.InputDeviceUid = galinpdev.InputDeviceUid AND armingIoGroup2.OrderNumber = 2
	LEFT OUTER JOIN GCS.InputOutputGroup ioGroup2 on ioGroup2.InputOutputGroupUid = armingIoGroup2.InputOutputGroupUid
		-- Arming IOGroup3
	LEFT OUTER JOIN GCS.GalaxyInputArmingInputOutputGroup armingIoGroup3 on armingIoGroup3.InputDeviceUid = galinpdev.InputDeviceUid AND armingIoGroup3.OrderNumber = 3
	LEFT OUTER JOIN GCS.InputOutputGroup ioGroup3 on ioGroup3.InputOutputGroupUid = armingIoGroup3.InputOutputGroupUid
	-- Arming IOGroup4 
	LEFT OUTER JOIN GCS.GalaxyInputArmingInputOutputGroup armingIoGroup4 on armingIoGroup4.InputDeviceUid = galinpdev.InputDeviceUid AND armingIoGroup4.OrderNumber = 4
	LEFT OUTER JOIN GCS.InputOutputGroup ioGroup4 on ioGroup4.InputOutputGroupUid = armingIoGroup4.InputOutputGroupUid


	JOIN GCS.InputDeviceGalaxyHardwareAddress idhwaddr on idhwaddr.InputDeviceUid = galinpdev.InputDeviceUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode idNode on idNode.GalaxyInterfaceBoardSectionNodeUid = idhwaddr.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule idModule on idModule.GalaxyHardwareModuleUid = idNode.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyInterfaceBoardSection idSection on idSection.GalaxyInterfaceBoardSectionUid = idModule.GalaxyInterfaceBoardSectionUid
	JOIN GCS.GalaxyInterfaceBoard idBoard on idBoard.GalaxyInterfaceBoardUid = idSection.GalaxyInterfaceBoardUid
	JOIN GCS.GalaxyPanel idPanel on idPanel.GalaxyPanelUid = idBoard.GalaxyPanelUid
	JOIN GCS.Cluster idCluster on idCluster.ClusterUid = idPanel.ClusterUid
	JOIN GCS.InterfaceBoardSectionMode idBoardSectionMode on idBoardSectionMode.InterfaceBoardSectionModeUid = idSection.InterfaceBoardSectionModeUid
	JOIN GCS.GalaxyPanelModel idPanelModel on idPanelModel.GalaxyPanelModelUid = idPanel.GalaxyPanelModelUid
	JOIN GCS.GalaxyCpu idCpu on idCpu.GalaxyPanelUid = idPanel.GalaxyPanelUid AND idCpu.CpuNumber = 1
	LEFT OUTER JOIN GCS.GalaxyCpuConnection gcc on gcc.CpuUid = idCpu.CpuUid
	JOIN GCS.GalaxyCpuModel idCpuModel on idCpuModel.GalaxyCpuModelUid = idCpu.GalaxyCpuModelUid
	JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = idBoard.InterfaceBoardTypeUid

	JOIN GCS.GalaxyInputDeviceTimeSchedule galaxyInputMainSchedule on galaxyInputMainSchedule.InputDeviceUid = galinpdev.InputDeviceUid
	JOIN GCS.TimeSchedule mainTs on mainTs.TimeScheduleUid = galaxyInputMainSchedule.TimeScheduleUid
	JOIN GCS.GalaxyClusterTimeScheduleMap armControlScheduleMap on armControlScheduleMap.TimeScheduleUid = mainTs.TimeScheduleUid AND armControlScheduleMap.ClusterUid = idPanel.ClusterUid
	
	JOIN GCS.InputDeviceLoadToCpu idltc on idltc.InputDeviceGalaxyHardwareAddressUid = idhwaddr.InputDeviceGalaxyHardwareAddressUid
	JOIN GCS.GalaxyCpu cpu on cpu.CpuUid = idltc.CpuUid
	WHERE idModule.IsModuleActive = 1 and
	(idltc.LastLoadedDate < galinpdev.[UpdateDate] or
	idltc.LastLoadedDate < mainInputDeviceEvent.UpdateDate or
	idltc.LastLoadedDate < armingIoGroup1.UpdateDate or
	idltc.LastLoadedDate < armingIoGroup2.UpdateDate or
	idltc.LastLoadedDate < armingIoGroup3.UpdateDate or
	idltc.LastLoadedDate < armingIoGroup4.UpdateDate or
	idltc.LastLoadedDate < galaxyInputMainSchedule.UpdateDate)

GO
ALTER AUTHORIZATION ON [GCS].[InputDevice_PanelLoadDataChangesForCpu] TO  SCHEMA OWNER 
GO

create or alter view [GCS].[InputDevice_PanelLoadData] as
SELECT id.InputDeviceUid
	,idCluster.ClusterUid
	,idPanel.GalaxyPanelUid
	,idBoard.GalaxyInterfaceBoardUid
	,idSection.GalaxyInterfaceBoardSectionUid
	,idModule.GalaxyHardwareModuleUid
	,idNode.GalaxyInterfaceBoardSectionNodeUid
	,id.InputName
	,idCluster.ClusterGroupId
	,idCluster.ClusterNumber
	,idPanel.PanelNumber
	,idBoard.BoardNumber
	,idSection.SectionNumber
	,idModule.ModuleNumber
	,idNode.NodeNumber
	,id.IsActive as IsInputActive
	,idNode.IsNodeActive
	,idModule.IsModuleActive
	,idBoardSectionMode.ModeCode as InputDeviceBoardSectionMode
	,idBoardSectionMode.Display as InputDeviceBoardSectionModeDisplay
	,idPanelModel.TypeCode as InputDevicePanelModelTypeCode
	,idCpuModel.TypeCode as InputDeviceCpuTypeCode
	,idBoardType.Model as InputDeviceBoardTypeModel
	,idBoardType.TypeCode as InputDeviceBoardTypeTypeCode
	,idBoardType.Display as InputDeviceBoardTypeDisplay
	,superType.Display as SupervisionTypeDisplay
	,superType.HasSeriesResistor
	,superType.HasParallelResistor
	,galinpdev.IsNormalOpen
	,galinpdev.TroubleShortThreshold
	,galinpdev.TroubleOpenThreshold
	,galinpdev.NormalChangeThreshold
	,galinpdev.AlternateNormalChangeThreshold
	,galinpdev.AlternateTroubleOpenThreshold
	,galinpdev.AlternateTroubleShortThreshold
	,galinpdev.AlternateVoltagesEnabled
	,galInputMode.Display as GalaxyInputModeDisplay
	,galInputMode.Code as GalaxyInputModeCode
	,galInputDelayType.Display as GalaxyInputDelayTypeDisplay
	,galInputDelayType.Code as GalaxyInputDelayTypeCode
	,mainInputDeviceEvent.Tag as MainIOGroupTag
	,mainIOGroup.Display as MainIOGroupDisplay
	,mainIOGroup.IOGroupNumber as MainIOGroupNumber
	,mainIOGroup.LocalIOGroup as MainIOGroupIsLocal
	,mainIOGroupAssignment.OffsetIndex as MainIOGroupOffset
	,DelayDuration
	,DisableDisarmedOnOffLogEvents
	,mainTs.Display as ArmControlScheduleDisplay
	,armControlScheduleMap.PanelScheduleNumber as ArmControlScheduleNumber
	,ioGroup1.Display as ArmingIOGroup1Display
	,ioGroup1.IOGroupNumber as ArmingIOGroupNumber1
	,ioGroup1.LocalIOGroup as ArmingIOGroup1IsLocal
	,ioGroup2.Display as ArmingIOGroup2Display
	,ioGroup2.IOGroupNumber as ArmingIOGroupNumber2
	,ioGroup2.LocalIOGroup as ArmingIOGroup2IsLocal
	,ioGroup3.Display as ArmingIOGroup3Display
	,ioGroup3.IOGroupNumber as ArmingIOGroupNumber3
	,ioGroup3.LocalIOGroup as ArmingIOGroup3IsLocal
	,ioGroup4.Display as ArmingIOGroup4Display
	,ioGroup4.IOGroupNumber as ArmingIOGroupNumber4
	,ioGroup4.LocalIOGroup as ArmingIOGroup4IsLocal
	,galinpdev.[UpdateDate] as GalaxyInputDevicePropertiesLastUpdated
	,mainInputDeviceEvent.UpdateDate as MainIOGroupLastUpdated
	,armingIoGroup1.UpdateDate as ArmingIOGroup1LastUpdated
	,armingIoGroup2.UpdateDate as ArmingIOGroup2LastUpdated
	,armingIoGroup3.UpdateDate as ArmingIOGroup3LastUpdated
	,armingIoGroup4.UpdateDate as ArmingIOGroup4LastUpdated
	,galaxyInputMainSchedule.UpdateDate as MainScheduleLastUpdated
	,0 as CpuNumber
	,'00000000-0000-0000-0000-000000000000' as CpuUid
	,'' as ServerAddress,
	0 as IsConnected
	,mainInputDeviceEvent.IsActive as MainIOGroupIsActive
FROM GCS.InputDevice id
	JOIN GCS.GalaxyInputDevice galinpdev on galinpdev.InputDeviceUid = id.InputDeviceUid
	JOIN GCS.InputDeviceSupervisionType superType on superType.InputDeviceSupervisionTypeUid = galinpdev.InputDeviceSupervisionTypeUid
	JOIN GCS.GalaxyInputMode galInputMode on galInputMode.GalaxyInputModeUid = galinpdev.GalaxyInputModeUid
	JOIN GCS.GalaxyInputDelayType galInputDelayType ON galInputDelayType.GalaxyInputDelayTypeUid = galinpdev.GalaxyInputDelayTypeUid

	--JOIN GCS.GalaxyInputDeviceTimeSchedule galaxyInputMainSchedule on galaxyInputMainSchedule.InputDeviceUid = galinpdev.InputDeviceUid
	--JOIN GCS.TimeSchedule mainTs on mainTs.TimeScheduleUid = galaxyInputMainSchedule.TimeScheduleUid
	--JOIN GCS.GalaxyClusterTimeScheduleMap armControlScheduleMap on armControlScheduleMap.TimeScheduleUid = mainTs.TimeScheduleUid AND armControlScheduleMap.ClusterUid = idPanel.ClusterUid

	LEFT OUTER JOIN GCS.InputDeviceAlertEvent mainInputDeviceEvent on mainInputDeviceEvent.InputDeviceUid = galinpdev.InputDeviceUid AND mainInputDeviceEvent.InputDeviceAlertEventTypeUid = '00000000-0000-0000-0000-000000000001'
	LEFT OUTER JOIN GCS.InputOutputGroup mainIOGroup on mainIOGroup.InputOutputGroupUid = mainInputDeviceEvent.InputOutputGroupUid
	LEFT OUTER JOIN GCS.InputOutputGroupAssignment mainIOGroupAssignment on mainIOGroupAssignment.InputOutputGroupAssignmentUid = mainInputDeviceEvent.InputOutputGroupAssignmentUid

	-- Arming Input IO Groups
	-- Arming IOGroup1 
	LEFT OUTER JOIN GCS.GalaxyInputArmingInputOutputGroup armingIoGroup1 on armingIoGroup1.InputDeviceUid = galinpdev.InputDeviceUid AND armingIoGroup1.OrderNumber = 1
	LEFT OUTER JOIN GCS.InputOutputGroup ioGroup1 on ioGroup1.InputOutputGroupUid = armingIoGroup1.InputOutputGroupUid
	-- Arming IOGroup2
	LEFT OUTER JOIN GCS.GalaxyInputArmingInputOutputGroup armingIoGroup2 on armingIoGroup2.InputDeviceUid = galinpdev.InputDeviceUid AND armingIoGroup2.OrderNumber = 2
	LEFT OUTER JOIN GCS.InputOutputGroup ioGroup2 on ioGroup2.InputOutputGroupUid = armingIoGroup2.InputOutputGroupUid
		-- Arming IOGroup3
	LEFT OUTER JOIN GCS.GalaxyInputArmingInputOutputGroup armingIoGroup3 on armingIoGroup3.InputDeviceUid = galinpdev.InputDeviceUid AND armingIoGroup3.OrderNumber = 3
	LEFT OUTER JOIN GCS.InputOutputGroup ioGroup3 on ioGroup3.InputOutputGroupUid = armingIoGroup3.InputOutputGroupUid
	-- Arming IOGroup4 
	LEFT OUTER JOIN GCS.GalaxyInputArmingInputOutputGroup armingIoGroup4 on armingIoGroup4.InputDeviceUid = galinpdev.InputDeviceUid AND armingIoGroup4.OrderNumber = 4
	LEFT OUTER JOIN GCS.InputOutputGroup ioGroup4 on ioGroup4.InputOutputGroupUid = armingIoGroup4.InputOutputGroupUid


	JOIN GCS.InputDeviceGalaxyHardwareAddress idhwaddr on idhwaddr.InputDeviceUid = galinpdev.InputDeviceUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode idNode on idNode.GalaxyInterfaceBoardSectionNodeUid = idhwaddr.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule idModule on idModule.GalaxyHardwareModuleUid = idNode.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyInterfaceBoardSection idSection on idSection.GalaxyInterfaceBoardSectionUid = idModule.GalaxyInterfaceBoardSectionUid
	JOIN GCS.GalaxyInterfaceBoard idBoard on idBoard.GalaxyInterfaceBoardUid = idSection.GalaxyInterfaceBoardUid
	JOIN GCS.GalaxyPanel idPanel on idPanel.GalaxyPanelUid = idBoard.GalaxyPanelUid
	JOIN GCS.Cluster idCluster on idCluster.ClusterUid = idPanel.ClusterUid
	JOIN GCS.InterfaceBoardSectionMode idBoardSectionMode on idBoardSectionMode.InterfaceBoardSectionModeUid = idSection.InterfaceBoardSectionModeUid
	JOIN GCS.GalaxyPanelModel idPanelModel on idPanelModel.GalaxyPanelModelUid = idPanel.GalaxyPanelModelUid
	JOIN GCS.GalaxyCpu apCpu on apCpu.GalaxyPanelUid = idPanel.GalaxyPanelUid AND apCpu.CpuNumber = 1
	JOIN GCS.GalaxyCpuModel idCpuModel on idCpuModel.GalaxyCpuModelUid = apCpu.GalaxyCpuModelUid
	JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = idBoard.InterfaceBoardTypeUid

	JOIN GCS.GalaxyInputDeviceTimeSchedule galaxyInputMainSchedule on galaxyInputMainSchedule.InputDeviceUid = galinpdev.InputDeviceUid
	JOIN GCS.TimeSchedule mainTs on mainTs.TimeScheduleUid = galaxyInputMainSchedule.TimeScheduleUid
	JOIN GCS.GalaxyClusterTimeScheduleMap armControlScheduleMap on armControlScheduleMap.TimeScheduleUid = mainTs.TimeScheduleUid AND armControlScheduleMap.ClusterUid = idPanel.ClusterUid

	WHERE idModule.IsModuleActive = 1
GO
ALTER AUTHORIZATION ON [GCS].[InputDevice_PanelLoadData] TO  SCHEMA OWNER 
GO

if dbo.[fn_GCSDoesIndexExist]('Person', 'idxPersonId') = 1
BEGIN
	DROP INDEX [idxPersonId] ON [GCS].[Person]
END
GO

ALTER TABLE GCS.Person
ALTER COLUMN PersonId [nvarchar](65) NULL
GO

--CREATE UNIQUE NONCLUSTERED INDEX [idxPersonId] ON [GCS].[Person]
--(
--	[EntityId] ASC,
--	[PersonId] ASC
--) WHERE PersonId IS NOT NULL WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
--GO

CREATE OR ALTER PROCEDURE [GCS].[IsPersonUnique]
	@PersonUid [uniqueidentifier],
	@PersonId [nvarchar](65),
	@EntityId [uniqueidentifier],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
	if @PersonId is not null AND LEN(@PersonId) > 0
		select @Result = count(*) from GCS.Person where PersonUid <> @PersonUid AND (PersonId = @PersonId AND EntityId = @EntityId )
	else
		select @Result = 0
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsPersonUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsPersonUnique] TO [public] AS [dbo]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[GalaxyCpu_UpdateInformation]
	@CpuUid [uniqueidentifier],
	@SerialNumber [nvarchar](30),
	@IpAddress [nvarchar](30),
	@Model [int],
	@Version [nvarchar](65)
WITH EXECUTE AS CALLER
AS
if exists ( select CpuUid from GCS.GalaxyCpu where CpuUid = @CpuUid)
	begin
		update GCS.GalaxyCpu set SerialNumber = @SerialNumber, IpAddress = @IpAddress, Model = @Model, [Version] = @Version where CpuUid = @CpuUid
	end
	
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyCpu_UpdateInformation] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyCpu_UpdateInformation] TO [public] AS [dbo]
GO



create or alter trigger GCS.td_accessportalactivityevent on GCS.AccessPortalActivityEvent for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Delete all children in "GCS.AccessPortalLastUsage"  */
    delete GCS.AccessPortalLastUsage
    from   GCS.AccessPortalLastUsage t2, deleted t1
    where  t2.LastAccessGrantedActivityEventUid = t1.AccessPortalActivityEventUid

    /*  Set parent code of "GCS.AccessPortalActivityEvent" to NULL in child "GCS.PersonLastUsage"  */
    update GCS.PersonLastUsage
     set   LastAccessPortalActivityEventUid = NULL
    from   GCS.PersonLastUsage t2, deleted t1
    where  t2.LastAccessPortalActivityEventUid = t1.AccessPortalActivityEventUid

    /*  Set parent code of "GCS.AccessPortalActivityEvent" to NULL in child "GCS.PersonLastUsage"  */
    update GCS.PersonLastUsage
     set   LastAccessGrantedAccessPortalActivityEventUid = NULL
    from   GCS.PersonLastUsage t2, deleted t1
    where  t2.LastAccessGrantedAccessPortalActivityEventUid = t1.AccessPortalActivityEventUid

    /*  Set parent code of "GCS.AccessPortalActivityEvent" to NULL in child "GCS.AccessPortalLastUsage"  */
    update GCS.AccessPortalLastUsage
     set   LastActivityEventUid = NULL
    from   GCS.AccessPortalLastUsage t2, deleted t1
    where  t2.LastActivityEventUid = t1.AccessPortalActivityEventUid


    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


create or alter trigger GCS.ti_accessportalactivityevent on GCS.AccessPortalActivityEvent for insert as
begin
    declare
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Parent "GCS.GalaxyActivityEventType" must exist when inserting a child in "GCS.AccessPortalActivityEvent"  */
    if update(GalaxyActivityEventTypeUid)
    begin
       if (select count(*)
           from   GCS.GalaxyActivityEventType t1, inserted t2
           where  t1.GalaxyActivityEventTypeUid = t2.GalaxyActivityEventTypeUid) != @numrows
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.GalaxyActivityEventType". Cannot create child in "GCS.AccessPortalActivityEvent".'
             goto error
          end
    end
    /*  Parent "GCS.Credential" must exist when inserting a child in "GCS.AccessPortalActivityEvent"  */
    if update(CredentialUid)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  CredentialUid is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.Credential t1, inserted t2
              where  t1.CredentialUid = t2.CredentialUid) != @numrows - @numnull
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.Credential". Cannot create child in "GCS.AccessPortalActivityEvent".'
             goto error
          end
    end
    /*  Parent "GCS.Person" must exist when inserting a child in "GCS.AccessPortalActivityEvent"  */
    if update(PersonUid)
    begin
       select @numnull = (select count(*)
                          from   inserted
                          where  PersonUid is null)
       if @numnull != @numrows
          if (select count(*)
              from   GCS.Person t1, inserted t2
              where  t1.PersonUid = t2.PersonUid) != @numrows - @numnull
          begin
             select @errno  = 50002,
                    @errmsg = 'Parent does not exist in "GCS.Person". Cannot create child in "GCS.AccessPortalActivityEvent".'
             goto error
          end
    end

    return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


create or alter trigger GCS.tu_accessportalactivityevent on GCS.AccessPortalActivityEvent for update as
begin
   declare
      @ins_AccessPortalActivityEventUid uniqueidentifier,
      @del_AccessPortalActivityEventUid uniqueidentifier,
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      /*  Parent "GCS.GalaxyActivityEventType" must exist when updating a child in "GCS.AccessPortalActivityEvent"  */
      if update(GalaxyActivityEventTypeUid)
      begin
         if (select count(*)
             from   GCS.GalaxyActivityEventType t1, inserted t2
             where  t1.GalaxyActivityEventTypeUid = t2.GalaxyActivityEventTypeUid) != @numrows
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.GalaxyActivityEventType" does not exist. Cannot modify child in "GCS.AccessPortalActivityEvent".'
               goto error
            end
      end
      /*  Parent "GCS.Credential" must exist when updating a child in "GCS.AccessPortalActivityEvent"  */
      if update(CredentialUid)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  CredentialUid is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.Credential t1, inserted t2
                where  t1.CredentialUid = t2.CredentialUid) != @numrows - @numnull
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.Credential" does not exist. Cannot modify child in "GCS.AccessPortalActivityEvent".'
               goto error
            end
      end
      /*  Parent "GCS.Person" must exist when updating a child in "GCS.AccessPortalActivityEvent"  */
      if update(PersonUid)
      begin
         select @numnull = (select count(*)
                            from   inserted
                            where  PersonUid is null)
         if @numnull != @numrows
            if (select count(*)
                from   GCS.Person t1, inserted t2
                where  t1.PersonUid = t2.PersonUid) != @numrows - @numnull
            begin
               select @errno  = 50003,
                      @errmsg = 'GCS.Person" does not exist. Cannot modify child in "GCS.AccessPortalActivityEvent".'
               goto error
            end
      end
      declare cIns cursor local for select 
              AccessPortalActivityEventUid
          from inserted
      declare cDel cursor local for select 
              AccessPortalActivityEventUid
          from deleted

      /*  Modify parent code of "GCS.AccessPortalActivityEvent" for all children in "GCS.PersonLastUsage"  */
      if update(AccessPortalActivityEventUid)
      begin
         if @@rowcount = 1
            update GCS.PersonLastUsage
               set   LastAccessPortalActivityEventUid = i1.AccessPortalActivityEventUid
            from   GCS.PersonLastUsage t2, inserted i1, deleted d1
               where  t2.LastAccessPortalActivityEventUid = d1.AccessPortalActivityEventUid
                and  (i1.AccessPortalActivityEventUid != d1.AccessPortalActivityEventUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_AccessPortalActivityEventUid
            fetch cDel into @del_AccessPortalActivityEventUid

            while (@@fetch_status = 0)
            begin
               update GCS.PersonLastUsage
                  set   LastAccessPortalActivityEventUid = @ins_AccessPortalActivityEventUid
               where  LastAccessPortalActivityEventUid = @del_AccessPortalActivityEventUid
               fetch cIns into @ins_AccessPortalActivityEventUid
               fetch cDel into @del_AccessPortalActivityEventUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.AccessPortalActivityEvent" for all children in "GCS.PersonLastUsage"  */
      if update(AccessPortalActivityEventUid)
      begin
         if @@rowcount = 1
            update GCS.PersonLastUsage
               set   LastAccessGrantedAccessPortalActivityEventUid = i1.AccessPortalActivityEventUid
            from   GCS.PersonLastUsage t2, inserted i1, deleted d1
               where  t2.LastAccessGrantedAccessPortalActivityEventUid = d1.AccessPortalActivityEventUid
                and  (i1.AccessPortalActivityEventUid != d1.AccessPortalActivityEventUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_AccessPortalActivityEventUid
            fetch cDel into @del_AccessPortalActivityEventUid

            while (@@fetch_status = 0)
            begin
               update GCS.PersonLastUsage
                  set   LastAccessGrantedAccessPortalActivityEventUid = @ins_AccessPortalActivityEventUid
               where  LastAccessGrantedAccessPortalActivityEventUid = @del_AccessPortalActivityEventUid
               fetch cIns into @ins_AccessPortalActivityEventUid
               fetch cDel into @del_AccessPortalActivityEventUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.AccessPortalActivityEvent" for all children in "GCS.AccessPortalLastUsage"  */
      if update(AccessPortalActivityEventUid)
      begin
         if @@rowcount = 1
            update GCS.AccessPortalLastUsage
               set   LastActivityEventUid = i1.AccessPortalActivityEventUid
            from   GCS.AccessPortalLastUsage t2, inserted i1, deleted d1
               where  t2.LastActivityEventUid = d1.AccessPortalActivityEventUid
                and  (i1.AccessPortalActivityEventUid != d1.AccessPortalActivityEventUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_AccessPortalActivityEventUid
            fetch cDel into @del_AccessPortalActivityEventUid

            while (@@fetch_status = 0)
            begin
               update GCS.AccessPortalLastUsage
                  set   LastActivityEventUid = @ins_AccessPortalActivityEventUid
               where  LastActivityEventUid = @del_AccessPortalActivityEventUid
               fetch cIns into @ins_AccessPortalActivityEventUid
               fetch cDel into @del_AccessPortalActivityEventUid
            end
            close cIns
            close cDel
         end
      end
      /*  Modify parent code of "GCS.AccessPortalActivityEvent" for all children in "GCS.AccessPortalLastUsage"  */
      if update(AccessPortalActivityEventUid)
      begin
         if @@rowcount = 1
            update GCS.AccessPortalLastUsage
               set   LastAccessGrantedActivityEventUid = i1.AccessPortalActivityEventUid
            from   GCS.AccessPortalLastUsage t2, inserted i1, deleted d1
               where  t2.LastAccessGrantedActivityEventUid = d1.AccessPortalActivityEventUid
                and  (i1.AccessPortalActivityEventUid != d1.AccessPortalActivityEventUid)
         else
         begin
            open cIns
            open cDel
            fetch cIns into @ins_AccessPortalActivityEventUid
            fetch cDel into @del_AccessPortalActivityEventUid

            while (@@fetch_status = 0)
            begin
               update GCS.AccessPortalLastUsage
                  set   LastAccessGrantedActivityEventUid = @ins_AccessPortalActivityEventUid
               where  LastAccessGrantedActivityEventUid = @del_AccessPortalActivityEventUid
               fetch cIns into @ins_AccessPortalActivityEventUid
               fetch cDel into @del_AccessPortalActivityEventUid
            end
            close cIns
            close cDel
         end
      end

      return

/*  Errors handling  */
error:
    raiserror(@errmsg, @errno, 1)
    rollback  transaction
end
go


/* All Stored Procedures for table: AccessPortalLastUsage */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.AccessPortalLastUsage table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalLastUsagePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalLastUsagePDSA_SelectAll]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessPortalLastUsagePDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalUid
,LastActivityEventUid
,LastAccessGrantedActivityEventUid
FROM GCS.AccessPortalLastUsage

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalLastUsagePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.AccessPortalLastUsage table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalLastUsagePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalLastUsagePDSA_SelectListBox]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessPortalLastUsagePDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalUid
,AccessPortalUid
FROM GCS.AccessPortalLastUsage

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalLastUsagePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortalLastUsage table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalLastUsagePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalLastUsagePDSA_SelectByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalLastUsagePDSA_SelectByPK]
@AccessPortalUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalUid
,LastActivityEventUid
,LastAccessGrantedActivityEventUid
FROM GCS.AccessPortalLastUsage
WHERE 
AccessPortalUid = @AccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalLastUsagePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.AccessPortalLastUsage table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalLastUsagePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalLastUsagePDSA_SelectSearch]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalLastUsagePDSA_SelectSearch]
@AccessPortalUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalUid
,LastActivityEventUid
,LastAccessGrantedActivityEventUid
FROM GCS.AccessPortalLastUsage
WHERE 
(@AccessPortalUid IS NULL OR AccessPortalUid = @AccessPortalUid )

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalLastUsagePDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.AccessPortalLastUsage table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalLastUsagePDSA_ByGalaxyPanelUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalLastUsagePDSA_ByGalaxyPanelUid]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalLastUsagePDSA_ByGalaxyPanelUid]
@AccessPortalUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalUid
,LastActivityEventUid
,LastAccessGrantedActivityEventUid
FROM GCS.AccessPortalLastUsage
WHERE 
AccessPortalUid = @AccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalLastUsagePDSA_ByGalaxyPanelUid] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.AccessPortalLastUsage table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalLastUsagePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalLastUsagePDSA_Insert]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalLastUsagePDSA_Insert]
@AccessPortalUid uniqueidentifier 
,@LastActivityEventUid uniqueidentifier  = null
,@LastAccessGrantedActivityEventUid uniqueidentifier  = null
AS

declare @ret int;
select @ret = 0;

if @LastActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @LastActivityEventUid = NULL
if @LastAccessGrantedActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @LastAccessGrantedActivityEventUid = NULL

INSERT INTO GCS.AccessPortalLastUsage
(
AccessPortalUid
,LastActivityEventUid
,LastAccessGrantedActivityEventUid
) 
VALUES 
(
@AccessPortalUid
,@LastActivityEventUid
,@LastAccessGrantedActivityEventUid
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalLastUsagePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.AccessPortalLastUsage table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalLastUsagePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalLastUsagePDSA_Update]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalLastUsagePDSA_Update]
@AccessPortalUid uniqueidentifier 
,@LastActivityEventUid uniqueidentifier
,@IsAccessGrantedEvent bit
AS

declare @ret int;
select @ret = 0;

if @LastActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @LastActivityEventUid = NULL

if not exists(select AccessPortalUid from GCS.AccessPortalLastUsage where AccessPortalUid = @AccessPortalUid)
begin
	if @IsAccessGrantedEvent = 0
	begin
		INSERT INTO GCS.AccessPortalLastUsage (AccessPortalUid, LastActivityEventUid)
		VALUES ( @AccessPortalUid, @LastActivityEventUid)
	end
	else
	begin
		INSERT INTO GCS.AccessPortalLastUsage (AccessPortalUid, LastActivityEventUid, LastAccessGrantedActivityEventUid)
		VALUES ( @AccessPortalUid, @LastActivityEventUid, @LastActivityEventUid)
	end
end
else
begin
	if @IsAccessGrantedEvent = 0
	begin
		UPDATE GCS.AccessPortalLastUsage
		SET LastActivityEventUid = @LastActivityEventUid
		WHERE AccessPortalUid = @AccessPortalUid
	end
	else
	begin
		UPDATE GCS.AccessPortalLastUsage
		SET LastActivityEventUid = @LastActivityEventUid, LastAccessGrantedActivityEventUid = @LastActivityEventUid
		WHERE AccessPortalUid = @AccessPortalUid
	end
end

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[AccessPortalLastUsagePDSA_Update] TO public
GO






/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.AccessPortalLastUsage table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalLastUsagePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalLastUsagePDSA_DeleteByPK]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalLastUsagePDSA_DeleteByPK]
@AccessPortalUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.AccessPortalLastUsage
WHERE
AccessPortalUid = @AccessPortalUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalLastUsagePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.AccessPortalLastUsage table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalLastUsagePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalLastUsagePDSA_RowCount]
GO
CREATE OR ALTER PROCEDURE GCS.[AccessPortalLastUsagePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.AccessPortalLastUsage

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalLastUsagePDSA_RowCount] TO public
GO


CREATE OR ALTER PROCEDURE GCS.AccessPortalUids_SelectForClusterUid
@ClusterUid uniqueidentifier
AS
BEGIN
	select apgha.AccessPortalUid from GCS.AccessPortalGalaxyHardwareAddress apgha 
	JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
	JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
	JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
	JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
	JOIN GCS.InterfaceBoardType apBoardType on apBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
	WHERE c.ClusterUid = @ClusterUid 
END
GO

GRANT EXECUTE ON GCS.AccessPortalUids_SelectForClusterUid TO public
GO


CREATE OR ALTER PROCEDURE GCS.TimeScheduleUids_SelectForClusterUid
@ClusterUid uniqueidentifier
AS
BEGIN
	select TimeScheduleUid from GCS.GalaxyClusterTimeScheduleMap 
	WHERE ClusterUid = @ClusterUid 
END
GO

GRANT EXECUTE ON GCS.TimeScheduleUids_SelectForClusterUid TO public
GO


CREATE OR ALTER PROCEDURE GCS.AccessGroupUids_SelectForClusterUid
@ClusterUid uniqueidentifier
AS
BEGIN
	select AccessGroupUid from GCS.AccessGroup 
	WHERE ClusterUid = @ClusterUid 
END
GO

GRANT EXECUTE ON GCS.AccessGroupUids_SelectForClusterUid TO public
GO


CREATE OR ALTER PROCEDURE GCS.GetGalaxyPanelUidForGalaxyInterfaceBoardSection 
@uid uniqueidentifier
AS
	select GalaxyPanelUid from GCS.GalaxyInterfaceBoardSection ibs
	join GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	where ibs.GalaxyInterfaceBoardSectionUid = @uid
GO

GRANT EXECUTE ON GCS.GetGalaxyPanelUidForGalaxyInterfaceBoardSection TO public
GO


CREATE OR ALTER PROCEDURE GCS.GetGalaxyPanelUidForAccessPortal
@uid uniqueidentifier
AS
	select ib.GalaxyPanelUid from GCS.AccessPortalGalaxyHardwareAddress aphwa
	join GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = aphwa.GalaxyInterfaceBoardSectionNodeUid
	join GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
	join GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
	join GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	where aphwa.AccessPortalUid = @uid
GO

GRANT EXECUTE ON GCS.GetGalaxyPanelUidForAccessPortal TO public
GO


CREATE OR ALTER PROCEDURE GCS.GetClusterUidForAccessPortal
@uid uniqueidentifier
AS
	select gp.ClusterUid from GCS.AccessPortalGalaxyHardwareAddress aphwa
	join GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = aphwa.GalaxyInterfaceBoardSectionNodeUid
	join GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
	join GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
	join GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ib.GalaxyPanelUid
	where aphwa.AccessPortalUid = @uid
GO

GRANT EXECUTE ON GCS.GetClusterUidForAccessPortal TO public
GO


CREATE OR ALTER PROCEDURE GCS.GetTimeScheduleUidsForCluster
@uid uniqueidentifier
AS

SELECT 
TimeScheduleUid
FROM GCS.TimeSchedule t
JOIN GCS.Cluster c on c.ClusterUid = @uid
WHERE 
( TimeScheduleUid in (SELECT TimeScheduleUid FROM GCS.GalaxyClusterTimeScheduleMap WHERE ClusterUid = @uid) 
--OR TimeScheduleUid in (SELECT TimeScheduleUid FROM GCS.TimeScheduleEntityMap WHERE EntityId = c.EntityId) 
) OR
t.EntityId = '00000000-0000-0000-0000-000000000001'
GO

GRANT EXECUTE ON GCS.GetTimeScheduleUidsForCluster TO public
GO

CREATE OR ALTER PROCEDURE GCS.GetAreaUidsForCluster
@uid uniqueidentifier
AS

SELECT 
AreaUid
FROM GCS.Area 
WHERE 
ClusterUid = @uid
GO

GRANT EXECUTE ON GCS.GetAreaUidsForCluster TO public
GO

CREATE OR ALTER PROCEDURE GCS.GetInputOutputGroupUidsForCluster
@uid uniqueidentifier
AS

SELECT 
InputOutputGroupUid
FROM GCS.InputOutputGroup 
WHERE 
ClusterUid = @uid
GO

GRANT EXECUTE ON GCS.GetInputOutputGroupUidsForCluster TO public
GO

CREATE OR ALTER PROCEDURE GCS.GetAccessGroupUidsForCluster
@uid uniqueidentifier
AS

SELECT 
AccessGroupUid
FROM GCS.AccessGroup 
WHERE 
ClusterUid = @uid
GO

GRANT EXECUTE ON GCS.GetAccessGroupUidsForCluster TO public
GO


CREATE OR ALTER PROCEDURE GCS.TimeSchedule_CanBeUnmappedFromCluster
@timeScheduleUid uniqueidentifier,
@clusterUid uniqueidentifier
AS

declare @accessGroupDefaultTimeScheduleCount int = 0
declare @accessGroupAccessPortalCount int = 0
declare @accessPortalAlertEventCount int = 0
declare @accessPortalAuxOutputCount int = 0
declare @accessPortalTimeScheduleCount int = 0
declare @inputDeviceTimeScheduleCount int = 0
declare @outputDeviceTimeScheduleCount int = 0
declare @galaxyPanelAlertEventTimeScheduleCount int = 0
declare @inputDeviceEventPropertiesTimeScheduleCount int = 0
declare @inputOutputGroupTimeScheduleCount int = 0
declare @personPersonalAccessGroupTimeScheduleCount int = 0
declare @assaDsrTimeScheduleCount int = 0
declare @otisFloorGroupTimeScheduleCount int = 0


select @accessGroupDefaultTimeScheduleCount = count(*) from GCS.AccessGroup where DefaultTimeScheduleUid = @timeScheduleUid AND ClusterUid = @clusterUid
if @accessGroupDefaultTimeScheduleCount > 0
BEGIN
	SELECT @accessGroupDefaultTimeScheduleCount AS [Count]
	RETURN
END

select @accessGroupAccessPortalCount = count(*) from GCS.AccessGroupAccessPortal t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
ghwa.AccessPortalUid = t.AccessPortalUid
JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
where t.TimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid
if @accessGroupAccessPortalCount > 0
BEGIN
	SELECT @accessGroupAccessPortalCount AS [Count]
	RETURN
END

select @accessPortalAlertEventCount = count(*) from GCS.AccessPortalAlertEvent t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
ghwa.AccessPortalUid = t.AccessPortalUid
JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
where t.AcknowledgeTimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid
if @accessPortalAlertEventCount > 0
BEGIN
	SELECT @accessPortalAlertEventCount AS [Count]
	RETURN
END

select @accessPortalAuxOutputCount = count(*) from GCS.AccessPortalAuxiliaryOutput t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
ghwa.AccessPortalUid = t.AccessPortalUid
JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
where t.TimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid
if @accessPortalAuxOutputCount > 0
BEGIN
	SELECT @accessPortalAuxOutputCount AS [Count]
	RETURN
END

select @accessPortalTimeScheduleCount = count(*) from GCS.AccessPortalTimeSchedule t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
ghwa.AccessPortalUid = t.AccessPortalUid
JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
where t.TimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid
if @accessPortalTimeScheduleCount > 0
BEGIN
	SELECT @accessPortalTimeScheduleCount AS [Count]
	RETURN
END

select @inputDeviceTimeScheduleCount = count(*) from GCS.GalaxyInputDeviceTimeSchedule t JOIN GCS.InputDeviceGalaxyHardwareAddress ghwa on 
ghwa.InputDeviceUid = t.InputDeviceUid
JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
where t.TimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid
if @inputDeviceTimeScheduleCount > 0
BEGIN
	SELECT @inputDeviceTimeScheduleCount AS [Count]
	RETURN
END

select @outputDeviceTimeScheduleCount = count(*) from GCS.GalaxyOutputDevice t JOIN GCS.OutputDeviceGalaxyHardwareAddress ghwa on 
ghwa.OutputDeviceUid = t.OutputDeviceUid
JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
where t.TimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid
if @outputDeviceTimeScheduleCount > 0
BEGIN
	SELECT @outputDeviceTimeScheduleCount AS [Count]
	RETURN
END

select @galaxyPanelAlertEventTimeScheduleCount = count(*) from GCS.GalaxyPanelAlertEvent t 
JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = t.GalaxyPanelUid
where t.AcknowledgeTimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid
if @galaxyPanelAlertEventTimeScheduleCount > 0
BEGIN
	SELECT @galaxyPanelAlertEventTimeScheduleCount AS [Count]
	RETURN
END

select @inputDeviceEventPropertiesTimeScheduleCount = count(*) from GCS.InputDeviceEventProperties t JOIN GCS.InputDeviceGalaxyHardwareAddress ghwa on 
ghwa.InputDeviceUid = t.InputDeviceUid
JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
where t.AcknowledgeTimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid
if @inputDeviceEventPropertiesTimeScheduleCount > 0
BEGIN
	SELECT @inputDeviceEventPropertiesTimeScheduleCount AS [Count]
	RETURN
END

select @inputOutputGroupTimeScheduleCount = count(*) from GCS.InputOutputGroup t
where t.TimeScheduleUid = @timeScheduleUid AND t.ClusterUid = @clusterUid
if @inputOutputGroupTimeScheduleCount > 0
BEGIN
	SELECT @inputOutputGroupTimeScheduleCount AS [Count]
	RETURN
END

select @personPersonalAccessGroupTimeScheduleCount = count(*) from GCS.PersonPersonalAccessGroup t 
where t.TimeScheduleUid = @timeScheduleUid AND t.ClusterUid = @clusterUid
if @personPersonalAccessGroupTimeScheduleCount > 0
BEGIN
	SELECT @personPersonalAccessGroupTimeScheduleCount AS [Count]
	RETURN
END
select 0 as [Count]
GO

GRANT EXECUTE ON GCS.TimeSchedule_CanBeUnmappedFromCluster TO public
GO

CREATE OR ALTER PROCEDURE GCS.TimeSchedule_GetTimeScheduleUsageCountsForCluster
@timeScheduleUid uniqueidentifier,
@clusterUid uniqueidentifier
AS

declare @AccessGroupDefaultTimeScheduleCount int = 0
declare @AccessGroupAccessPortalCount int = 0
declare @AccessPortalAlertEventCount int = 0
declare @AccessPortalAuxOutputCount int = 0
declare @AccessPortalTimeScheduleCount int = 0
declare @InputDeviceTimeScheduleCount int = 0
declare @OutputDeviceTimeScheduleCount int = 0
declare @GalaxyPanelAlertEventTimeScheduleCount int = 0
declare @InputDeviceEventPropertiesTimeScheduleCount int = 0
declare @InputOutputGroupTimeScheduleCount int = 0
declare @PersonPersonalAccessGroupTimeScheduleCount int = 0
declare @AssaDsrTimeScheduleCount int = 0
declare @OtisFloorGroupTimeScheduleCount int = 0
declare @timeScheduleName nvarchar(65)
declare @clusterName nvarchar(65)
	
select @timeScheduleName = Display from GCS.TimeSchedule where TimeScheduleUid = @timeScheduleUid

if @clusterUid is not null and @clusterUid <> '00000000-0000-0000-0000-000000000000' AND @timeScheduleName IS NOT NULL
BEGIN
	select @clusterName = ClusterName from GCS.Cluster where ClusterUid = @clusterUid

	select @AccessGroupDefaultTimeScheduleCount = count(*) from GCS.AccessGroup where DefaultTimeScheduleUid = @timeScheduleUid AND ClusterUid = @clusterUid

	select @AccessGroupAccessPortalCount = count(*) from GCS.AccessGroupAccessPortal t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
	ghwa.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	where t.TimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid

	select @AccessPortalAlertEventCount = count(*) from GCS.AccessPortalAlertEvent t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
	ghwa.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	where t.AcknowledgeTimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid

	select @AccessPortalAuxOutputCount = count(*) from GCS.AccessPortalAuxiliaryOutput t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
	ghwa.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	where t.TimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid

	select @AccessPortalTimeScheduleCount = count(*) from GCS.AccessPortalTimeSchedule t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
	ghwa.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	where t.TimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid

	select @InputDeviceTimeScheduleCount = count(*) from GCS.GalaxyInputDeviceTimeSchedule t JOIN GCS.InputDeviceGalaxyHardwareAddress ghwa on 
	ghwa.InputDeviceUid = t.InputDeviceUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	where t.TimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid

	select @OutputDeviceTimeScheduleCount = count(*) from GCS.GalaxyOutputDevice t JOIN GCS.OutputDeviceGalaxyHardwareAddress ghwa on 
	ghwa.OutputDeviceUid = t.OutputDeviceUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	where t.TimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid

	select @GalaxyPanelAlertEventTimeScheduleCount = count(*) from GCS.GalaxyPanelAlertEvent t 
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = t.GalaxyPanelUid
	where t.AcknowledgeTimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid

	select @InputDeviceEventPropertiesTimeScheduleCount = count(*) from GCS.InputDeviceEventProperties t JOIN GCS.InputDeviceGalaxyHardwareAddress ghwa on 
	ghwa.InputDeviceUid = t.InputDeviceUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	where t.AcknowledgeTimeScheduleUid = @timeScheduleUid AND gp.ClusterUid = @clusterUid

	select @InputOutputGroupTimeScheduleCount = count(*) from GCS.InputOutputGroup t
	where t.TimeScheduleUid = @timeScheduleUid AND t.ClusterUid = @clusterUid

	select @PersonPersonalAccessGroupTimeScheduleCount = count(*) from GCS.PersonPersonalAccessGroup t 
	where t.TimeScheduleUid = @timeScheduleUid AND t.ClusterUid = @clusterUid
END
ELSE IF @timeScheduleName IS NOT NULL
BEGIN
	select @AccessGroupDefaultTimeScheduleCount = count(*) from GCS.AccessGroup where DefaultTimeScheduleUid = @timeScheduleUid

	select @AccessGroupAccessPortalCount = count(*) from GCS.AccessGroupAccessPortal t 
	where t.TimeScheduleUid = @timeScheduleUid

	select @AccessPortalAlertEventCount = count(*) from GCS.AccessPortalAlertEvent t 
	where t.AcknowledgeTimeScheduleUid = @timeScheduleUid

	select @AccessPortalAuxOutputCount = count(*) from GCS.AccessPortalAuxiliaryOutput t 
	where t.TimeScheduleUid = @timeScheduleUid

	select @AccessPortalTimeScheduleCount = count(*) from GCS.AccessPortalTimeSchedule t 
	where t.TimeScheduleUid = @timeScheduleUid

	select @InputDeviceTimeScheduleCount = count(*) from GCS.GalaxyInputDeviceTimeSchedule t
	where t.TimeScheduleUid = @timeScheduleUid

	select @OutputDeviceTimeScheduleCount = count(*) from GCS.GalaxyOutputDevice t 
	where t.TimeScheduleUid = @timeScheduleUid

	select @GalaxyPanelAlertEventTimeScheduleCount = count(*) from GCS.GalaxyPanelAlertEvent t 
	where t.AcknowledgeTimeScheduleUid = @timeScheduleUid

	select @InputDeviceEventPropertiesTimeScheduleCount = count(*) from GCS.InputDeviceEventProperties t 
	where t.AcknowledgeTimeScheduleUid = @timeScheduleUid

	select @InputOutputGroupTimeScheduleCount = count(*) from GCS.InputOutputGroup t
	where t.TimeScheduleUid = @timeScheduleUid

	select @PersonPersonalAccessGroupTimeScheduleCount = count(*) from GCS.PersonPersonalAccessGroup t 
	where t.TimeScheduleUid = @timeScheduleUid
END

select @ClusterUid as ClusterUid, @TimeScheduleUid as TimeScheduleUid,
@clusterName as ClusterName,
@timeScheduleName as TimeScheduleName,
@AccessGroupDefaultTimeScheduleCount as AccessGroupDefaultTimeScheduleCount,
@AccessGroupAccessPortalCount as AccessGroupAccessPortalCount, 
@AccessPortalAlertEventCount as AccessPortalAlertEventCount, 
@AccessPortalAuxOutputCount as AccessPortalAuxOutputCount, 
@AccessPortalTimeScheduleCount as AccessPortalTimeScheduleCount, 
@InputDeviceTimeScheduleCount as InputDeviceTimeScheduleCount, 
@OutputDeviceTimeScheduleCount as OutputDeviceTimeScheduleCount, 
@GalaxyPanelAlertEventTimeScheduleCount as GalaxyPanelAlertEventTimeScheduleCount, 
@InputDeviceEventPropertiesTimeScheduleCount as InputDeviceEventPropertiesTimeScheduleCount, 
@InputOutputGroupTimeScheduleCount as InputOutputGroupTimeScheduleCount, 
@PersonPersonalAccessGroupTimeScheduleCount as PersonPersonalAccessGroupTimeScheduleCount, 
@AssaDsrTimeScheduleCount as AssaDsrTimeScheduleCount, 
@OtisFloorGroupTimeScheduleCount as OtisFloorGroupTimeScheduleCount,
@AccessGroupDefaultTimeScheduleCount + @AccessGroupAccessPortalCount + @AccessPortalAlertEventCount + @AccessPortalAuxOutputCount + @AccessPortalTimeScheduleCount + @InputDeviceTimeScheduleCount + @OutputDeviceTimeScheduleCount + @GalaxyPanelAlertEventTimeScheduleCount + @InputDeviceEventPropertiesTimeScheduleCount + @InputOutputGroupTimeScheduleCount + @PersonPersonalAccessGroupTimeScheduleCount + @AssaDsrTimeScheduleCount + @OtisFloorGroupTimeScheduleCount as TotalCount
GO

GRANT EXECUTE ON GCS.TimeSchedule_GetTimeScheduleUsageCountsForCluster TO public
GO


CREATE OR ALTER PROCEDURE GCS.TimeSchedule_CanBeDeleted
@timeScheduleUid uniqueidentifier
AS

declare @accessGroupDefaultTimeScheduleCount int = 0
declare @accessGroupAccessPortalCount int = 0
declare @accessPortalAlertEventCount int = 0
declare @accessPortalAuxOutputCount int = 0
declare @accessPortalTimeScheduleCount int = 0
declare @inputDeviceTimeScheduleCount int = 0
declare @outputDeviceTimeScheduleCount int = 0
declare @galaxyPanelAlertEventTimeScheduleCount int = 0
declare @inputDeviceEventPropertiesTimeScheduleCount int = 0
declare @inputOutputGroupTimeScheduleCount int = 0
declare @personPersonalAccessGroupTimeScheduleCount int = 0
declare @assaDsrTimeScheduleCount int = 0
declare @otisFloorGroupTimeScheduleCount int = 0


select @accessGroupDefaultTimeScheduleCount = count(*) from GCS.AccessGroup where DefaultTimeScheduleUid = @timeScheduleUid 
if @accessGroupDefaultTimeScheduleCount > 0
BEGIN
	SELECT @accessGroupDefaultTimeScheduleCount AS [Count]
	RETURN
END

select @accessGroupAccessPortalCount = count(*) from GCS.AccessGroupAccessPortal t 
where t.TimeScheduleUid = @timeScheduleUid
if @accessGroupAccessPortalCount > 0
BEGIN
	SELECT @accessGroupAccessPortalCount AS [Count]
	RETURN
END

select @accessPortalAlertEventCount = count(*) from GCS.AccessPortalAlertEvent t
where t.AcknowledgeTimeScheduleUid = @timeScheduleUid 
if @accessPortalAlertEventCount > 0
BEGIN
	SELECT @accessPortalAlertEventCount AS [Count]
	RETURN
END

select @accessPortalAuxOutputCount = count(*) from GCS.AccessPortalAuxiliaryOutput t
where t.TimeScheduleUid = @timeScheduleUid
if @accessPortalAuxOutputCount > 0
BEGIN
	SELECT @accessPortalAuxOutputCount AS [Count]
	RETURN
END

select @accessPortalTimeScheduleCount = count(*) from GCS.AccessPortalTimeSchedule t 
where t.TimeScheduleUid = @timeScheduleUid
if @accessPortalTimeScheduleCount > 0
BEGIN
	SELECT @accessPortalTimeScheduleCount AS [Count]
	RETURN
END

select @inputDeviceTimeScheduleCount = count(*) from GCS.GalaxyInputDeviceTimeSchedule t 
where t.TimeScheduleUid = @timeScheduleUid 
if @inputDeviceTimeScheduleCount > 0
BEGIN
	SELECT @inputDeviceTimeScheduleCount AS [Count]
	RETURN
END

select @outputDeviceTimeScheduleCount = count(*) from GCS.GalaxyOutputDevice t 
where t.TimeScheduleUid = @timeScheduleUid 
if @outputDeviceTimeScheduleCount > 0
BEGIN
	SELECT @outputDeviceTimeScheduleCount AS [Count]
	RETURN
END

select @galaxyPanelAlertEventTimeScheduleCount = count(*) from GCS.GalaxyPanelAlertEvent t 
where t.AcknowledgeTimeScheduleUid = @timeScheduleUid
if @galaxyPanelAlertEventTimeScheduleCount > 0
BEGIN
	SELECT @galaxyPanelAlertEventTimeScheduleCount AS [Count]
	RETURN
END

select @inputDeviceEventPropertiesTimeScheduleCount = count(*) from GCS.InputDeviceEventProperties t
where t.AcknowledgeTimeScheduleUid = @timeScheduleUid 
if @inputDeviceEventPropertiesTimeScheduleCount > 0
BEGIN
	SELECT @inputDeviceEventPropertiesTimeScheduleCount AS [Count]
	RETURN
END

select @inputOutputGroupTimeScheduleCount = count(*) from GCS.InputOutputGroup t
where t.TimeScheduleUid = @timeScheduleUid 
if @inputOutputGroupTimeScheduleCount > 0
BEGIN
	SELECT @inputOutputGroupTimeScheduleCount AS [Count]
	RETURN
END

select @personPersonalAccessGroupTimeScheduleCount = count(*) from GCS.PersonPersonalAccessGroup t 
where t.TimeScheduleUid = @timeScheduleUid 
if @personPersonalAccessGroupTimeScheduleCount > 0
BEGIN
	SELECT @personPersonalAccessGroupTimeScheduleCount AS [Count]
	RETURN
END
select 0 as [Count]
GO

GRANT EXECUTE ON GCS.TimeSchedule_CanBeDeleted TO public
GO





ALTER TABLE GCS.GalaxyTimePeriod
ALTER COLUMN [Description] [nvarchar](1000) NULL
GO

CREATE OR ALTER FUNCTION dbo.Split_On_Upper_Case
 (
     @String NVARCHAR(4000),
	 @splitWith NCHAR = ' ',
	 @skipFirst bit = 1
 )
RETURNS NVARCHAR(4000)
AS
BEGIN

DECLARE @Char NCHAR(1);
DECLARE @i    INT = 1;
DECLARE @OutString NVARCHAR(4000) = '';

WHILE (@i <= LEN(@String))
BEGIN

    SELECT @Char = SUBSTRING(@String, @i,1)

    IF (@Char = UPPER(@Char) Collate Latin1_General_CS_AI) 
    BEGIN
		IF @i = 1 AND @skipFirst = 1
			SET @OutString = @OutString + @Char;
		ELSE
			SET @OutString = @OutString + @splitWith + @Char;
	END
    ELSE 
       SET @OutString = @OutString +  @Char;

     SET @i += 1;
END

 SET @OutString =  LTRIM(@OutString);

 RETURN @OutString;

END 
GO

GRANT EXECUTE ON dbo.Split_On_Upper_Case TO public
GO

CREATE OR ALTER PROCEDURE GCS.TimeSchedule_GetTimeScheduleUsageDataForCluster
@timeScheduleUid uniqueidentifier,
@clusterUid uniqueidentifier
AS

if @clusterUid is not null and @clusterUid = '00000000-0000-0000-0000-000000000000'
	set @clusterUid = NULL

	select N'AccessGroup' as N'DataType', AccessGroupUid as N'Id', Display as N'Name', 
		NULL as N'DeviceUid', NULL as N'DeviceName', 'DEFAULT_TIME_SCHEDULE' as N'Type' 
		from GCS.AccessGroup where DefaultTimeScheduleUid = @timeScheduleUid AND (@clusterUid IS NULL OR ClusterUid = @clusterUid)
	UNION
	select N'AccessGroup' as N'DataType', t.AccessGroupUid as N'Id', Display as N'Name', 
	t.AccessPortalUid as N'DeviceUid', ap.PortalName as N'DeviceName', 'CHILD_ACCESS_PORTAL' as N'Type' 
	from GCS.AccessGroupAccessPortal t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
	ghwa.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.AccessGroup ag on ag.AccessGroupUid = t.AccessGroupUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	where t.TimeScheduleUid = @timeScheduleUid AND (@clusterUid IS NULL OR gp.ClusterUid = @clusterUid)
	UNION
	select N'AccessPortal', t.AccessPortalUid as N'Id', ap.PortalName as N'Name',
	NULL as N'DeviceUid', NULL as N'DeviceName', UPPER(dbo.Split_On_Upper_Case(aeType.Tag, '_', 1)) + N'_ALERT_EVENT_ACK_SCH' as N'Type'
	from GCS.AccessPortalAlertEvent t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
	ghwa.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	JOIN GCS.AccessPortalAlertEventType aeType on aeType.AccessPortalAlertEventTypeUid = t.AccessPortalAlertEventTypeUid
	where t.AcknowledgeTimeScheduleUid = @timeScheduleUid AND aeType.CanHaveSchedule = 1 AND (@clusterUid IS NULL OR gp.ClusterUid = @clusterUid)
	UNION
	select N'AccessPortal', t.AccessPortalUid as N'Id', ap.PortalName as N'Name',
	NULL as N'DeviceUid', NULL as N'DeviceName', UPPER(dbo.Split_On_Upper_Case(auxOutType.Tag, '_', 1)) +  N'_ACTIVE_SCHEDULE' as N'Type'
	from GCS.AccessPortalAuxiliaryOutput t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
	ghwa.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	JOIN GCS.AccessPortalAuxiliaryOutput auxOutType on auxOutType.AccessPortalAuxiliaryOutputUid = t.AccessPortalAuxiliaryOutputUid
	where t.TimeScheduleUid = @timeScheduleUid AND (@clusterUid IS NULL OR gp.ClusterUid = @clusterUid)
	UNION
	select N'AccessPortal', t.AccessPortalUid as N'Id', ap.PortalName as N'Name',
	NULL as N'DeviceUid', NULL as N'DeviceName', UPPER(dbo.Split_On_Upper_Case(schType.Tag, '_', 1)) + N'_SCHEDULE' as N'Type'
	from GCS.AccessPortalTimeSchedule t JOIN GCS.AccessPortalGalaxyHardwareAddress ghwa on 
	ghwa.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	JOIN GCS.AccessPortalScheduleType schType on schType.AccessPortalScheduleTypeUid = t.AccessPortalScheduleTypeUid
	where t.TimeScheduleUid = @timeScheduleUid AND (@clusterUid IS NULL OR gp.ClusterUid = @clusterUid)
	UNION
	select N'InputDevice', t.InputDeviceUid as N'Id', id.InputName as N'Name',
	NULL as N'DeviceUid', NULL as N'DeviceName', UPPER(dbo.Split_On_Upper_Case(t.Tag, '_', 1)) as N'Type'
	from GCS.GalaxyInputDeviceTimeSchedule t JOIN GCS.InputDeviceGalaxyHardwareAddress ghwa on 
	ghwa.InputDeviceUid = t.InputDeviceUid
	JOIN GCS.InputDevice id on id.InputDeviceUid = t.InputDeviceUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	where t.TimeScheduleUid = @timeScheduleUid AND (@clusterUid IS NULL OR gp.ClusterUid = @clusterUid)
	UNION
	select N'InputDevice', t.InputDeviceUid as N'Id', id.InputName as N'Name',
	NULL as N'DeviceUid', NULL as N'DeviceName', UPPER(dbo.Split_On_Upper_Case(aeType.Tag, '_', 1)) as N'Type'
	from GCS.InputDeviceEventProperties t JOIN GCS.InputDeviceGalaxyHardwareAddress ghwa on 
	ghwa.InputDeviceUid = t.InputDeviceUid
	JOIN GCS.InputDevice id on id.InputDeviceUid = t.InputDeviceUid	
	JOIN GCS.InputDeviceAlertEventType aeType on aeType.InputDeviceAlertEventTypeUid = t.InputDeviceAlertEventTypeUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	where t.AcknowledgeTimeScheduleUid = @timeScheduleUid AND aeType.CanHaveSchedule = 1 AND (@clusterUid IS NULL OR gp.ClusterUid = @clusterUid)
	UNION
	select N'OutputDevice', t.OutputDeviceUid as N'Id', od.OutputName as N'Name',
	NULL as N'DeviceUid', NULL as N'DeviceName', N'ACTIVE_SCHEDULE' as N'Type'
	from GCS.GalaxyOutputDevice t JOIN GCS.OutputDeviceGalaxyHardwareAddress ghwa on 
	ghwa.OutputDeviceUid = t.OutputDeviceUid
	JOIN GCS.OutputDevice od on od.OutputDeviceUid = t.OutputDeviceUid
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ghwa.GalaxyPanelUid
	where t.TimeScheduleUid = @timeScheduleUid AND (@clusterUid IS NULL OR gp.ClusterUid = @clusterUid)
	UNION
	select N'GalaxyPanel', t.GalaxyPanelUid as N'Id', gp.PanelName as N'Name',
	NULL as N'DeviceUid', NULL as N'DeviceName', UPPER(dbo.Split_On_Upper_Case(aeType.Tag, '_', 1)) + N'_ALERT_EVENT_ACK_SCH' as N'Type'
	from GCS.GalaxyPanelAlertEvent t 
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = t.GalaxyPanelUid
	JOIN GCS.GalaxyPanelAlertEventType aeType on aeType.GalaxyPanelAlertEventTypeUid = t.GalaxyPanelAlertEventTypeUid
	where t.AcknowledgeTimeScheduleUid = @timeScheduleUid AND aeType.CanHaveSchedule = 1 AND (@clusterUid IS NULL OR gp.ClusterUid = @clusterUid)
	UNION
	select N'InputOutputGroup', t.InputOutputGroupUid as N'Id', t.Display as N'Name',
	NULL as N'DeviceUid', NULL as N'DeviceName', N'ARMED_SCHEDULE' as N'Type'
	from GCS.InputOutputGroup t
	where t.TimeScheduleUid = @timeScheduleUid AND (@clusterUid IS NULL OR t.ClusterUid = @clusterUid)
	UNION
	select N'PersonalAccessGroup', p.PersonUid as N'Id', p.ActivityEventText as N'Name',
	pcp.ClusterUid as N'DeviceUid', c.ClusterName as N'DeviceName', N'PERSONAL_ACCESS_SCHEDULE' as N'Type'
	from GCS.PersonPersonalAccessGroup t 
	JOIN GCS.PersonClusterPermission pcp on pcp.PersonClusterPermissionUid = t.PersonClusterPermissionUid
	JOIN GCS.Person p ON p.PersonUid = pcp.PersonUid
	JOIN GCS.Cluster c on c.ClusterUid = pcp.ClusterUid
	where t.TimeScheduleUid = @timeScheduleUid AND (@clusterUid IS NULL OR t.ClusterUid = @clusterUid)
GO

GRANT EXECUTE ON GCS.TimeSchedule_GetTimeScheduleUsageDataForCluster TO public
GO


CREATE OR ALTER PROCEDURE GCS.GetTimeScheduleAndClusterNames
@timeScheduleUid uniqueidentifier,
@clusterUid uniqueidentifier
AS

	declare @tsName nvarchar(65)
	declare @clusterName nvarchar(65)
	select @tsName = Display from GCS.TimeSchedule where TimeScheduleUid = @timeScheduleUid
	select @clusterName = ClusterName from GCS.Cluster where ClusterUid = @clusterUid

	select @tsName as TimeScheduleName, @clusterName as ClusterName
GO

GRANT EXECUTE ON GCS.GetTimeScheduleAndClusterNames TO public
GO


CREATE OR ALTER PROCEDURE GCS.IsGalaxyPanelConnected
@galaxyPanelUid uniqueidentifier
AS
	SELECT count(*) as CountConnected FROM GCS.GalaxyCpu cpu JOIN GCS.GalaxyCpuConnection cpuConn on cpuConn.CpuUid = cpu.CpuUid
	WHERE cpu.GalaxyPanelUid = @galaxyPanelUid and IsConnected = 1

GRANT EXECUTE ON GCS.IsGalaxyPanelConnected TO public
GO

CREATE OR ALTER PROCEDURE GCS.IsGalaxyCpuConnected
@cpuUid uniqueidentifier
AS
	SELECT count(*) as IsConnected FROM GCS.GalaxyCpuConnection cpuConn 
	WHERE CpuUid = @cpuUid AND IsConnected = 1

GRANT EXECUTE ON GCS.IsGalaxyCpuConnected TO public
GO



CREATE OR ALTER FUNCTION [GCS].[fn_IsGalaxyPanelConnected] (@galaxyPanelUid uniqueidentifier)
RETURNS int
WITH EXECUTE AS CALLER
AS 
BEGIN
	DECLARE @ret int;

	set @ret = 0
	SELECT @ret = count(*) FROM GCS.GalaxyCpu cpu JOIN GCS.GalaxyCpuConnection cpuConn on cpuConn.CpuUid = cpu.CpuUid
	WHERE cpu.GalaxyPanelUid = @galaxyPanelUid and IsConnected = 1
	return (@ret);
END;
GO
ALTER AUTHORIZATION ON [GCS].[fn_IsGalaxyPanelConnected] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[fn_IsGalaxyPanelConnected] TO [public] 
GO

CREATE OR ALTER PROCEDURE [GCS].[AccessPortal_GetHardwareInformation]
	@AccessPortalUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
SELECT 
ap.AccessPortalUid
,ap.AccessPortalTypeUid
,ap.PortalName
,ap.EntityId
,r.RegionUid
,s.SiteName
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,apgha.DoorNumber
,c.ClusterTypeUid
,ct.TypeCode as 'ClusterTypeCode'
,p.GalaxyPanelModelUid
,gpm.TypeCode as 'GalaxyPanelTypeCode'
,ibt.InterfaceBoardTypeUid
,ibt.TypeCode as 'InterfaceBoardTypeCode'
,ibt.Model as 'InterfaceBoardModel'
,ibsm.InterfaceBoardSectionModeUid
,ibsm.ModeCode as 'InterfaceBoardSectionModeCode'
,ghmt.GalaxyHardwareModuleTypeUid
,ghmt.ModuleTypeCode
,c.ClusterUid
,p.GalaxyPanelUid
,gib.GalaxyInterfaceBoardUid
,gibs.GalaxyInterfaceBoardSectionUid
,m.GalaxyHardwareModuleUid
,n.GalaxyInterfaceBoardSectionNodeUid
,n.IsNodeActive
,ap.IsEnabled
,[GCS].[fn_IsGalaxyPanelConnected](p.GalaxyPanelUid) as 'PanelConnectedCount'
FROM GCS.AccessPortal ap
JOIN GCS.Site s on s.SiteUid = ap.SiteUid
JOIN GCS.Region r on r.RegionUid = s.RegionUid
LEFT OUTER JOIN GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = apgha.GalaxyInterfaceBoardSectionNodeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
LEFT OUTER JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
LEFT OUTER JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
LEFT OUTER JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
LEFT OUTER JOIN GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
LEFT OUTER JOIN GCS.GalaxyPanelModel gpm on gpm.GalaxyPanelModelUid = p.GalaxyPanelModelUid
LEFT OUTER JOIN GCS.InterfaceBoardType ibt on ibt.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
LEFT OUTER JOIN GCS.InterfaceBoardSectionMode ibsm on ibsm.InterfaceBoardSectionModeUid = gibs.InterfaceBoardSectionModeUid
LEFT OUTER JOIN GCS.GalaxyHardwareModuleType ghmt on ghmt.GalaxyHardwareModuleTypeUid = m.GalaxyHardwareModuleTypeUid
WHERE ap.AccessPortalUid = @AccessPortalUid
ORDER BY r.RegionName, s.SiteName, ap.PortalName
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortal_GetHardwareInformation] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortal_GetHardwareInformation] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[GalaxyCpu_GetCpuPanelClusterInformation]
	@ClusterNumber [int],
	@PanelNumber [int],
	@CpuNumber [smallint],
	@ClusterGroupId [int],
	@ClusterUid [uniqueidentifier],
	@GalaxyPanelUid [uniqueidentifier],
	@CpuUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
if @CpuUid is not null AND @CpuUid <> '00000000-0000-0000-0000-000000000000'
BEGIN	-- Get a specific CPU by CpuUid value
	SELECT gci.*, gcc.IsConnected from GCS.GalaxyCpuInformation gci 
		LEFT OUTER JOIN GCS.GalaxyCpuConnection gcc on gcc.CpuUid = gci.CpuUid 
		WHERE gci.CpuUid = @CpuUid-- AND IsConnected = 1
END
ELSE if @GalaxyPanelUid IS NOT NULL AND @GalaxyPanelUid <> '00000000-0000-0000-0000-000000000000'
BEGIN	-- Get all CPUs for a specific Panel by GalaxyPanelUid value
	SELECT gci.*, gcc.IsConnected from GCS.GalaxyCpuInformation gci 
		LEFT OUTER JOIN GCS.GalaxyCpuConnection gcc on gcc.CpuUid = gci.CpuUid 
		WHERE GalaxyPanelUid = @GalaxyPanelUid --AND IsConnected = 1
		ORDER BY CpuNumber
END
ELSE if @ClusterUid IS NOT NULL AND @ClusterUid <> '00000000-0000-0000-0000-000000000000'
BEGIN	-- Get all CPUs for a specific Cluster by ClusterUid value
	SELECT gci.*, gcc.IsConnected from GCS.GalaxyCpuInformation gci 
		LEFT OUTER JOIN GCS.GalaxyCpuConnection gcc on gcc.CpuUid = gci.CpuUid 
		WHERE ClusterUid = @ClusterUid --AND IsConnected = 1
		ORDER BY PanelNumber, CpuNumber
END
ELSE
BEGIN	-- If none of the uniqueid values are specified, THEN use the account, cluster, panel AND cpu number values
	IF @ClusterNumber IS NOT NULL AND @ClusterNumber <> 0 AND @PanelNumber IS NOT NULL AND @PanelNumber <> 0 AND @CpuNumber IS NOT NULL AND @CpuNumber <> 0 
		SELECT gci.*, gcc.IsConnected FROM GCS.GalaxyCpuInformation gci 
		LEFT OUTER JOIN GCS.GalaxyCpuConnection gcc on gcc.CpuUid = gci.CpuUid
		WHERE ClusterGroupId = @ClusterGroupId AND 
		ClusterNumber = @ClusterNumber AND 
		Panelnumber = @PanelNumber AND
		CpuNumber = @CpuNumber --AND IsConnected = 1	
	-- Account, Cluster & Panel but no CPU number
	ELSE IF @ClusterNumber IS NOT NULL AND @ClusterNumber <> 0 AND @PanelNumber IS NOT NULL AND @PanelNumber <> 0 AND ( @CpuNumber IS NULL OR @CpuNumber = 0)
		SELECT gci.*, gcc.IsConnected from GCS.GalaxyCpuInformation gci 
		LEFT OUTER JOIN GCS.GalaxyCpuConnection gcc on gcc.CpuUid = gci.CpuUid
		WHERE ClusterGroupId = @ClusterGroupId AND 
		ClusterNumber = @ClusterNumber AND 
		Panelnumber = @PanelNumber --AND IsConnected = 1
		ORDER BY CpuNumber
	-- Account, Cluster but no Panel AND CPU number
	ELSE IF @ClusterNumber IS NOT NULL AND @ClusterNumber <> 0 AND (@PanelNumber IS NULL OR @PanelNumber = 0 ) AND ( @CpuNumber IS NULL OR @CpuNumber = 0)
		SELECT gci.*, gcc.IsConnected from GCS.GalaxyCpuInformation gci 
		LEFT OUTER JOIN GCS.GalaxyCpuConnection gcc on gcc.CpuUid = gci.CpuUid
		WHERE ClusterGroupId = @ClusterGroupId AND 
		ClusterNumber = @ClusterNumber --AND IsConnected = 1
		ORDER BY PanelNumber, CpuNumber
END
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyCpu_GetCpuPanelClusterInformation] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyCpu_GetCpuPanelClusterInformation] TO [public] AS [dbo]
GO



/*==============================================================*/
/* View: GalaxyCpuInformation                        */
/*==============================================================*/
create or alter view [GCS].[GalaxyCpuInformation] as

SELECT 
c.ClusterUid
,p.GalaxyPanelUid
,cpu.CpuUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,cpu.CpuNumber
,ISNULL(cpu.SerialNumber, N'') AS SerialNumber
,ISNULL(cpu.IpAddress, N'') AS IpAddress
,cpu.DefaultEventLoggingOn
,cpu.PreventDataLoading
,cpu.PreventFlashLoading
,LastLogIndex
,c.ClusterName
,p.PanelName
,ct.TypeCode as ClusterTypeCode
,ct.IsActive as ClusterTypeIsActive
,credDataLength.DataLength as CredentialDataLength
,p.Location as PanelLocation
,panelModel.TypeCode as PanelModelTypeCode
,panelModel.IsActive as PanelModelIsActive
,cpu.IsActive as CpuIsActive
,c.SiteUid
,s.SiteName
,c.EntityId
,e.EntityName
,e.EntityType
,c.TimeZoneId
FROM GCS.GalaxyCpu cpu 
left outer join GCS.GalaxyCpuLoggingControl clc on clc.CpuUid = cpu.CpuUid
join GCS.GalaxyPanel p on p.GalaxyPanelUid = cpu.GalaxyPanelUid
join GCS.Cluster c on c.ClusterUid = p.ClusterUid
join GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
join GCS.CredentialDataLength credDataLength on credDataLength.CredentialDataLengthUid = c.CredentialDataLengthUid
join GCS.GalaxyPanelModel panelModel on panelModel.GalaxyPanelModelUid = p.GalaxyPanelModelUid
join GCS.Site s on s.SiteUid = c.SiteUid
join GCS.gcsEntity e on e.EntityId = c.EntityId
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyCpuInformation] TO  SCHEMA OWNER 
GO
/****** Object:  View [GCS].[GalaxyClusterPanelCpuInformation]    Script Date: 8/31/2020 2:21:55 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




/*==============================================================*/
/* View: GalaxyCpuInformationTest                        */
/*==============================================================*/
create or alter view [GCS].[GalaxyClusterPanelCpuInformation] as

SELECT 
c.ClusterUid
,p.GalaxyPanelUid
,cpu.CpuUid
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,cpu.CpuNumber
,ISNULL(cpu.SerialNumber, N'') AS SerialNumber
,ISNULL(cpu.IpAddress, N'') AS IpAddress
,cpu.DefaultEventLoggingOn
,cpu.PreventDataLoading
,cpu.PreventFlashLoading
,LastLogIndex
,c.ClusterName
,p.PanelName
,ct.TypeCode as ClusterTypeCode
,ct.IsActive as ClusterTypeIsActive
,credDataLength.DataLength as CredentialDataLength
,p.Location as PanelLocation
,panelModel.TypeCode as PanelModelTypeCode
,panelModel.IsActive as PanelModelIsActive
,cpu.IsActive as CpuIsActive
,c.SiteUid
,s.SiteName
,c.EntityId
,e.EntityName
,e.EntityType
,c.TimeZoneId
,gcc.IsConnected
FROM GCS.Cluster c
join GCS.ClusterType ct on ct.ClusterTypeUid = c.ClusterTypeUid
join GCS.CredentialDataLength credDataLength on credDataLength.CredentialDataLengthUid = c.CredentialDataLengthUid
left outer join GCS.GalaxyPanel p on p.ClusterUid = c.ClusterUid
left outer join GCS.GalaxyPanelModel panelModel on panelModel.GalaxyPanelModelUid = p.GalaxyPanelModelUid
left outer join GCS.GalaxyCpu cpu on cpu.GalaxyPanelUid = p.GalaxyPanelUid
left outer join GCS.GalaxyCpuLoggingControl clc on clc.CpuUid = cpu.CpuUid
left outer join GCS.GalaxyCpuConnection gcc on gcc.CpuUid = cpu.CpuUid
left outer join GCS.Site s on s.SiteUid = c.SiteUid
left outer join GCS.gcsEntity e on e.EntityId = c.EntityId
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyClusterPanelCpuInformation] TO  SCHEMA OWNER 
GO

--create or alter view [GCS].[GalaxyTimePeriod_PanelLoadData] as
--select gtp.GalaxyTimePeriodUid, gtp.Display as TimePeriodName, gtp.PanelTimePeriodNumber,
--tp.StartTime, tp.EndTime, e.EntityName, e.EntityId, c.ClusterUid, c.ClusterGroupId, c.ClusterNumber, c.ClusterName, tst.ScheduleTypeCode, tst.Display as ScheduleTypeDisplay
--from GCS.GalaxyTimePeriod gtp 
--join GCS.TimePeriod tp on tp.GalaxyTimePeriodUid = gtp.GalaxyTimePeriodUid
--join GCS.gcsEntity e on e.EntityId = gtp.EntityId
--join GCS.Cluster c on c.EntityId = e.EntityId
--join GCS.TimeScheduleType tst on tst.TimeScheduleTypeUid = c.TimeScheduleTypeUid
--where tst.ScheduleTypeCode = 1
----union
----select gtp.GalaxyTimePeriodUid, gtp.Display as TimePeriodName, gtp.PanelTimePeriodNumber,
----'00:00' AS StartTime, '23:59:59' AS EndTime, e.EntityName, e.EntityId, NULL AS ClusterUid, NULL AS ClusterGroupId, NULL AS ClusterNumber, NULL AS ClusterName, tst.ScheduleTypeCode, tst.Display as ScheduleTypeDisplay
----from GCS.GalaxyTimePeriod gtp 
----join GCS.gcsEntity e on e.EntityId = gtp.EntityId
----join GCS.TimeScheduleType tst on tst.TimeScheduleTypeUid = '00000000-0000-0000-0000-000000000001'
----where tst.ScheduleTypeCode = 1 AND PanelTimePeriodNumber = 255

--GO
--ALTER AUTHORIZATION ON [GCS].[GalaxyTimePeriod_PanelLoadData] TO  SCHEMA OWNER 
--GO


--CREATE OR ALTER PROCEDURE [GCS].[GalaxyTimePeriod_GetPanelLoadData]
--	@GalaxyTimePeriodUid [uniqueidentifier],
--	@ClusterUid [uniqueidentifier]
--WITH EXECUTE AS CALLER
--AS
--declare @ret int;
--select @ret = 0;

--if @GalaxyTimePeriodUid is NULL OR @GalaxyTimePeriodUid = '00000000-0000-0000-0000-000000000000'
--BEGIN -- No specific time period has been specified
--	IF @ClusterUid IS NULL OR @ClusterUid = '00000000-0000-0000-0000-000000000000'
--	BEGIN
--		select * from GCS.GalaxyTimePeriod_PanelLoadData
--		ORDER BY ClusterGroupId, ClusterNumber,PanelTimePeriodNumber, StartTime
--	END
--	ELSE
--	BEGIN	-- No specific schedule BUT a specific Cluster 
--		select * from GCS.GalaxyTimePeriod_PanelLoadData
--		WHERE ClusterUid = @ClusterUid-- OR ClusterUid IS NULL
--		ORDER BY ClusterGroupId, ClusterNumber, PanelTimePeriodNumber, StartTime
--	END
--END
--ELSE -- A specific time period has been specified
--BEGIN
--	IF @ClusterUid IS NULL OR @ClusterUid = '00000000-0000-0000-0000-000000000000'
--	BEGIN	-- No specific cluster has been specified
--		select * from GCS.GalaxyTimePeriod_PanelLoadData
--		WHERE GalaxyTimePeriodUid = @GalaxyTimePeriodUid
--		ORDER BY ClusterGroupId, ClusterNumber, PanelTimePeriodNumber, StartTime
--	END
--	ELSE
--	BEGIN	-- A specific cluster has been specified
--		select * from GCS.GalaxyTimePeriod_PanelLoadData
--		WHERE ClusterUid = @ClusterUid AND GalaxyTimePeriodUid = @GalaxyTimePeriodUid
--		ORDER BY ClusterGroupId, ClusterNumber, PanelTimePeriodNumber, StartTime
--	END
--END

--if @@ROWCOUNT = 0
--  SELECT @ret = -1;

--RETURN @ret;
--GO
--ALTER AUTHORIZATION ON [GCS].[GalaxyTimePeriod_GetPanelLoadData] TO  SCHEMA OWNER 
--GO
--GRANT EXECUTE ON [GCS].[GalaxyTimePeriod_GetPanelLoadData] TO [public] AS [dbo]
--GO
CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableAccessGroupNumber]
	@ClusterUid [uniqueidentifier],
	@Extended [bit]
WITH EXECUTE AS CALLER
AS
declare @minAccessGroupNumber int
	declare @maxAccessGroupNumber int
	set @maxAccessGroupNumber = 254
	set @minAccessGroupNumber = 1

	if @Extended <> 0
	begin
		set @minAccessGroupNumber = 256
		set @maxAccessGroupNumber = 2000
	end

declare @accessGroupNumbers table
( AccessGroupNumber int)

	insert into @accessGroupNumbers select AccessGroupNumber from GCS.AccessGroup where ClusterUid = @ClusterUid AND AccessGroupNumber >= @minAccessGroupNumber AND AccessGroupNumber <= @maxAccessGroupNumber ORDER BY AccessGroupNumber
	declare @count int
	select @count = count(*) from @accessGroupNumbers
	if @count = 0
	begin
		select @minAccessGroupNumber as AccessGroupNumber
	end
	else if @count = (@maxAccessGroupNumber - @minAccessGroupNumber)
	begin
		select 0 as AccessGroupNumber
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minAccessGroupNumber
		DECLARE agCursor CURSOR LOCAL FOR SELECT AccessGroupNumber from @accessGroupNumbers ORDER BY AccessGroupNumber
		OPEN agCursor
		FETCH NEXT FROM agCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			set @lastNumber = @currentNumber
			FETCH NEXT FROM agCursor INTO @currentNumber
	    END
		CLOSE agCursor;
		DEALLOCATE agCursor;
		select @lastNumber + 1 as AccessGroupNumber
	end
GO
ALTER AUTHORIZATION ON [GCS].[ChooseAvailableAccessGroupNumber] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[ChooseAvailableAccessGroupNumber] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableAccessGroupNumberWithOutput]
	@ClusterUid [uniqueidentifier],
	@Extended [bit],
	@AccessGroupNumber [int] OUTPUT
WITH EXECUTE AS CALLER
AS
declare @minAccessGroupNumber int
	declare @maxAccessGroupNumber int
	set @maxAccessGroupNumber = 254
	set @minAccessGroupNumber = 1

	if @Extended <> 0
	begin
		set @minAccessGroupNumber = 256
		set @maxAccessGroupNumber = 2000
	end

declare @accessGroupNumbers table
( AccessGroupNumber int)

	insert into @accessGroupNumbers select AccessGroupNumber from GCS.AccessGroup where ClusterUid = @ClusterUid AND AccessGroupNumber >= @minAccessGroupNumber AND AccessGroupNumber <= @maxAccessGroupNumber ORDER BY AccessGroupNumber
	declare @count int
	select @count = count(*) from @accessGroupNumbers
	if @count = 0
	begin
		set @AccessGroupNumber = @minAccessGroupNumber
	end
	else if @count = (@maxAccessGroupNumber - @minAccessGroupNumber)
	begin
		set @AccessGroupNumber = 0 
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minAccessGroupNumber
		DECLARE agCursor CURSOR LOCAL FOR SELECT AccessGroupNumber from @accessGroupNumbers ORDER BY AccessGroupNumber
		OPEN agCursor
		FETCH NEXT FROM agCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			set @lastNumber = @currentNumber
			FETCH NEXT FROM agCursor INTO @currentNumber
	    END
		CLOSE agCursor;
		DEALLOCATE agCursor;
		set @AccessGroupNumber = @lastNumber + 1
	end
GO
ALTER AUTHORIZATION ON [GCS].[ChooseAvailableAccessGroupNumberWithOutput] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[ChooseAvailableAccessGroupNumberWithOutput] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableAreaNumber]
	@ClusterUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @minNumber int
	declare @maxNumber int
	set @maxNumber = 255
	set @minNumber = 1

declare @areaNumbers table
( AreaNumber int)

	insert into @areaNumbers select AreaNumber from GCS.Area where ClusterUid = @ClusterUid AND AreaNumber >= @minNumber AND AreaNumber <= @maxNumber ORDER BY AreaNumber
	declare @count int
	select @count = count(*) from @areaNumbers
	if @count = 0
	begin
		select @minNumber as AreaNumber
	end
	else if @count = (@maxNumber - @minNumber)
	begin
		select 0 as AreaNumber
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minNumber
		DECLARE areaCursor CURSOR LOCAL FOR SELECT AreaNumber from @areaNumbers ORDER BY AreaNumber
		OPEN areaCursor
		FETCH NEXT FROM areaCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			set @lastNumber = @currentNumber
			FETCH NEXT FROM areaCursor INTO @currentNumber
	    END
		CLOSE areaCursor;
		DEALLOCATE areaCursor;
		select @lastNumber + 1 as AreaNumber
	end
GO
ALTER AUTHORIZATION ON [GCS].[ChooseAvailableAreaNumber] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[ChooseAvailableAreaNumber] TO [public] AS [dbo]
GO
/****** Object:  StoredProcedure [GCS].[ChooseAvailableAreaNumberWithOutput]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableAreaNumberWithOutput]
	@ClusterUid [uniqueidentifier],
	@AreaNumber [int] OUTPUT
WITH EXECUTE AS CALLER
AS
declare @minNumber int
	declare @maxNumber int
	set @maxNumber = 255
	set @minNumber = 1

declare @areaNumbers table
( AreaNumber int)

	insert into @areaNumbers select AreaNumber from GCS.Area where ClusterUid = @ClusterUid AND AreaNumber >= @minNumber AND AreaNumber <= @maxNumber ORDER BY AreaNumber
	declare @count int
	select @count = count(*) from @areaNumbers
	if @count = 0
	begin
		set @AreaNumber = @minNumber
	end
	else if @count = (@maxNumber - @minNumber)
	begin
		set @AreaNumber = 0 
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minNumber
		DECLARE areaCursor CURSOR LOCAL FOR SELECT AreaNumber from @areaNumbers ORDER BY AreaNumber
		OPEN areaCursor
		FETCH NEXT FROM areaCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			set @lastNumber = @currentNumber
			FETCH NEXT FROM areaCursor INTO @currentNumber
	    END
		CLOSE areaCursor;
		DEALLOCATE areaCursor;
		set @AreaNumber = @lastNumber + 1
	end
GO
ALTER AUTHORIZATION ON [GCS].[ChooseAvailableAreaNumberWithOutput] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[ChooseAvailableAreaNumberWithOutput] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableClusterNumber]
	@ClusterGroupId [int]
WITH EXECUTE AS CALLER
AS
declare @ClusterNumber int
	declare @minClusterNumber int
	declare @maxClusterNumber int
	set @minClusterNumber = 1
	set @maxClusterNumber = 65535


declare @clusterNumbers table
( ClusterNumber int)

	insert into @clusterNumbers select ClusterNumber from GCS.Cluster where ClusterGroupId = @ClusterGroupId ORDER BY ClusterNumber

	declare @count int
	select @count = count(*) from @clusterNumbers
	if @count = 0
	begin
		set @ClusterNumber = @minClusterNumber
	end
	else if @count = (@maxClusterNumber - @minClusterNumber)
	begin
		set @ClusterNumber = 0 
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minClusterNumber
		DECLARE clusterNumberCursor CURSOR LOCAL FOR SELECT ClusterNumber from @clusterNumbers ORDER BY ClusterNumber
		OPEN clusterNumberCursor
		FETCH NEXT FROM clusterNumberCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			set @lastNumber = @currentNumber

			FETCH NEXT FROM clusterNumberCursor INTO @currentNumber
	    END
		CLOSE clusterNumberCursor;
		DEALLOCATE clusterNumberCursor;
		set @ClusterNumber = @lastNumber + 1
	end
	select @ClusterNumber as ClusterNumber
GO
ALTER AUTHORIZATION ON [GCS].[ChooseAvailableClusterNumber] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[ChooseAvailableClusterNumber] TO [public] AS [dbo]
GO
/****** Object:  StoredProcedure [GCS].[ChooseAvailableClusterNumberWithOutput]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableClusterNumberWithOutput]
	@ClusterGroupId [int],
	@ClusterNumber [int] OUTPUT
WITH EXECUTE AS CALLER
AS
declare @minClusterNumber int
	declare @maxClusterNumber int
	set @minClusterNumber = 1
	set @maxClusterNumber = 65535


declare @clusterNumbers table
( ClusterNumber int)

	insert into @clusterNumbers select ClusterNumber from GCS.Cluster where ClusterGroupId = @ClusterGroupId ORDER BY ClusterNumber

	declare @count int
	select @count = count(*) from @clusterNumbers
	if @count = 0
	begin
		set @ClusterNumber = @minClusterNumber
	end
	else if @count = (@maxClusterNumber - @minClusterNumber)
	begin
		set @ClusterNumber = 0 
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minClusterNumber
		DECLARE clusterNumberCursor CURSOR LOCAL FOR SELECT ClusterNumber from @clusterNumbers ORDER BY ClusterNumber
		OPEN clusterNumberCursor
		FETCH NEXT FROM clusterNumberCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			FETCH NEXT FROM clusterNumberCursor INTO @currentNumber
	    END
		CLOSE clusterNumberCursor;
		DEALLOCATE clusterNumberCursor;
		set @ClusterNumber = @lastNumber + 1
	end
GO
ALTER AUTHORIZATION ON [GCS].[ChooseAvailableClusterNumberWithOutput] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[ChooseAvailableClusterNumberWithOutput] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableGalaxyTimePeriodNumber]
	@EntityId [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @minTimePeriodNumber int
	declare @maxTimePeriodNumber int
	set @maxTimePeriodNumber = 254
	set @minTimePeriodNumber = 1

declare @timePeriodNumbers table
( TimePeriodNumber int)

	insert into @timePeriodNumbers select PanelTimePeriodNumber from GCS.GalaxyTimePeriod where EntityId = @EntityId ORDER BY PanelTimePeriodNumber
	declare @count int
	select @count = count(*) from @timePeriodNumbers
	if @count = 0
	begin
		select @minTimePeriodNumber as PanelTimePeriodNumber
	end
	else if @count = (@maxTimePeriodNumber - @minTimePeriodNumber)
	begin
		select 0 as PanelTimePeriodNumber
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minTimePeriodNumber
		DECLARE tpCursor CURSOR LOCAL FOR SELECT TimePeriodNumber from @timePeriodNumbers ORDER BY TimePeriodNumber
		OPEN tpCursor
		FETCH NEXT FROM tpCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			set @lastNumber = @currentNumber
			FETCH NEXT FROM tpCursor INTO @currentNumber
	    END
		CLOSE tpCursor;
		DEALLOCATE tpCursor;
		select @lastNumber + 1 as PanelTimePeriodNumber
	end
GO
ALTER AUTHORIZATION ON [GCS].[ChooseAvailableGalaxyTimePeriodNumber] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[ChooseAvailableGalaxyTimePeriodNumber] TO [public] AS [dbo]
GO
/****** Object:  StoredProcedure [GCS].[ChooseAvailableGalaxyTimePeriodNumberWithOutput]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableGalaxyTimePeriodNumberWithOutput]
	@EntityId [uniqueidentifier],
	@PanelTimePeriodNumber [int] OUTPUT
WITH EXECUTE AS CALLER
AS
declare @minTimePeriodNumber int
	declare @maxTimePeriodNumber int
	set @maxTimePeriodNumber = 254
	set @minTimePeriodNumber = 1

declare @timePeriodNumbers table
( TimePeriodNumber int)

	insert into @timePeriodNumbers select PanelTimePeriodNumber from GCS.GalaxyTimePeriod where EntityId = @EntityId ORDER BY PanelTimePeriodNumber
	declare @count int
	select @count = count(*) from @timePeriodNumbers
	if @count = 0
	begin
		set @PanelTimePeriodNumber = @minTimePeriodNumber
	end
	else if @count = (@maxTimePeriodNumber - @minTimePeriodNumber)
	begin
		set @PanelTimePeriodNumber = 0
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minTimePeriodNumber
		DECLARE tpCursor CURSOR LOCAL FOR SELECT TimePeriodNumber from @timePeriodNumbers ORDER BY TimePeriodNumber
		OPEN tpCursor
		FETCH NEXT FROM tpCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			set @lastNumber = @currentNumber
			FETCH NEXT FROM tpCursor INTO @currentNumber
	    END
		CLOSE tpCursor;
		DEALLOCATE tpCursor;
		set @PanelTimePeriodNumber = @lastNumber + 1
	end
GO
ALTER AUTHORIZATION ON [GCS].[ChooseAvailableGalaxyTimePeriodNumberWithOutput] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[ChooseAvailableGalaxyTimePeriodNumberWithOutput] TO [public] AS [dbo]
GO
/****** Object:  StoredProcedure [GCS].[ChooseAvailableInputOutputGroupNumber]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableInputOutputGroupNumber]
	@ClusterUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @minNumber int
	declare @maxNumber int
	set @maxNumber = 255
	set @minNumber = 1

declare @ioGroupNumbers table
( IOGroupNumber int)

	insert into @ioGroupNumbers select IOGroupNumber from GCS.InputOutputGroup where ClusterUid = @ClusterUid AND IOGroupNumber >= @minNumber AND IOGroupNumber <= @maxNumber ORDER BY IOGroupNumber
	declare @count int
	select @count = count(*) from @ioGroupNumbers
	if @count = 0
	begin
		select @minNumber as IOGroupNumber
	end
	else if @count = (@maxNumber - @minNumber)
	begin
		select 0 as IOGroupNumber
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minNumber
		DECLARE iogCursor CURSOR LOCAL FOR SELECT IOGroupNumber from @ioGroupNumbers ORDER BY IOGroupNumber
		OPEN iogCursor
		FETCH NEXT FROM iogCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			set @lastNumber = @currentNumber
			FETCH NEXT FROM iogCursor INTO @currentNumber
	    END
		CLOSE iogCursor;
		DEALLOCATE iogCursor;
		select @lastNumber + 1 as IOGroupNumber
	end
GO
ALTER AUTHORIZATION ON [GCS].[ChooseAvailableInputOutputGroupNumber] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[ChooseAvailableInputOutputGroupNumber] TO [public] AS [dbo]
GO
/****** Object:  StoredProcedure [GCS].[ChooseAvailableInputOutputGroupNumberWithOutput]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[ChooseAvailableInputOutputGroupNumberWithOutput]
	@ClusterUid [uniqueidentifier],
	@IOGroupNumber [int] OUTPUT
WITH EXECUTE AS CALLER
AS
declare @minNumber int
	declare @maxNumber int
	set @maxNumber = 255
	set @minNumber = 1

declare @ioGroupNumbers table
( IOGroupNumber int)

	insert into @ioGroupNumbers select IOGroupNumber from GCS.InputOutputGroup where ClusterUid = @ClusterUid AND IOGroupNumber >= @minNumber AND IOGroupNumber <= @maxNumber ORDER BY IOGroupNumber
	declare @count int
	select @count = count(*) from @ioGroupNumbers
	if @count = 0
	begin
		set @IOGroupNumber = @minNumber
	end
	else if @count = (@maxNumber - @minNumber)
	begin
		set @IOGroupNumber = 0 
	end
	else
	begin
		declare @lastNumber int
		declare @currentNumber int
		set @lastNumber = @minNumber
		DECLARE iogCursor CURSOR LOCAL FOR SELECT IOGroupNumber from @ioGroupNumbers ORDER BY IOGroupNumber
		OPEN iogCursor
		FETCH NEXT FROM iogCursor INTO @currentNumber
		WHILE @@FETCH_STATUS = 0
		BEGIN
			if @currentNumber > @lastNumber + 1
				break
			set @lastNumber = @currentNumber
			FETCH NEXT FROM iogCursor INTO @currentNumber
	    END
		CLOSE iogCursor;
		DEALLOCATE iogCursor;
		set @IOGroupNumber = @lastNumber + 1
	end
GO
ALTER AUTHORIZATION ON [GCS].[ChooseAvailableInputOutputGroupNumberWithOutput] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[ChooseAvailableInputOutputGroupNumberWithOutput] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[CredentialToDeleteFromCpu_Create]
	@CpuUid [uniqueidentifier],
	@CardBinaryData [binary](32),
	@DeletedFromDatabaseDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

DECLARE @CredentialToDeleteFromCpuUid uniqueidentifier
SELECT @CredentialToDeleteFromCpuUid = CredentialToDeleteFromCpuUid FROM GCS.CredentialToDeleteFromCpu WHERE CpuUid = @CpuUid AND CardBinaryData = @CardBinaryData
IF @CredentialToDeleteFromCpuUid IS NULL
BEGIN
	SET @CredentialToDeleteFromCpuUid = newid()
	INSERT INTO GCS.CredentialToDeleteFromCpu (CredentialToDeleteFromCpuUid, CpuUid, CardBinaryData, DeletedFromDatabaseDate, DeletedFromCpuDate)
	VALUES(@CredentialToDeleteFromCpuUid, @CpuUid, @CardBinaryData, SYSDATETIMEOFFSET(), NULL)

END
ELSE
BEGIN
	UPDATE GCS.CredentialToDeleteFromCpu SET DeletedFromDatabaseDate = @DeletedFromDatabaseDate, DeletedFromCpuDate = NULL
	WHERE CredentialToDeleteFromCpuUid = @CredentialToDeleteFromCpuUid
END

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[CredentialToDeleteFromCpu_Create] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToDeleteFromCpu_Create] TO [public] AS [dbo]
GO

/****** Object:  StoredProcedure [GCS].[CredentialToDeleteFromCpuPDSA_Insert]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[CredentialToDeleteFromCpuPDSA_Insert]
	@CredentialToDeleteFromCpuUid [uniqueidentifier],
	@CpuUid [uniqueidentifier],
	@CardBinaryData [binary](32),
	@DeletedFromDatabaseDate [datetimeoffset],
	@DeletedFromCpuDate [datetimeoffset] = null
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @CredentialToDeleteFromCpuUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialToDeleteFromCpuUid = NULL

if @CredentialToDeleteFromCpuUid = '00000000-0000-0000-0000-000000000000' OR @CredentialToDeleteFromCpuUid IS NULL
	SET @CredentialToDeleteFromCpuUid = NewID()

INSERT INTO GCS.CredentialToDeleteFromCpu
(
CredentialToDeleteFromCpuUid
,CpuUid
,CardBinaryData
,DeletedFromDatabaseDate
,DeletedFromCpuDate
) 
VALUES 
(
@CredentialToDeleteFromCpuUid
,@CpuUid
,@CardBinaryData
,@DeletedFromDatabaseDate
,@DeletedFromCpuDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[CredentialToDeleteFromCpuPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToDeleteFromCpuPDSA_Insert] TO [public] AS [dbo]
GO

/****** Object:  StoredProcedure [GCS].[CredentialToDeleteFromCpuPDSA_Update]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[CredentialToDeleteFromCpuPDSA_Update]
	@CredentialToDeleteFromCpuUid [uniqueidentifier],
	@CpuUid [uniqueidentifier],
	@CardBinaryData [binary](32),
	@DeletedFromDatabaseDate [datetimeoffset],
	@DeletedFromCpuDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


UPDATE GCS.CredentialToDeleteFromCpu
SET 
CredentialToDeleteFromCpuUid = @CredentialToDeleteFromCpuUid
,CpuUid = @CpuUid
,CardBinaryData = @CardBinaryData
,DeletedFromDatabaseDate = @DeletedFromDatabaseDate
,DeletedFromCpuDate = @DeletedFromCpuDate
WHERE
CredentialToDeleteFromCpuUid = @CredentialToDeleteFromCpuUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[CredentialToDeleteFromCpuPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToDeleteFromCpuPDSA_Update] TO [public] AS [dbo]
GO




CREATE OR ALTER PROCEDURE [GCS].[CredentialToDeleteFromCpu_GenerateFromDeleteCredential]
	@CardBinaryData [binary](32),
	@PersonUid [uniqueidentifier],
	@DeletedFromDatabaseDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
DECLARE @cpuUid uniqueidentifier

	DECLARE CpuCursor CURSOR LOCAL FOR
		SELECT CpuUid FROM GCS.GalaxyCpu cpu 
		JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = cpu.GalaxyPanelUid 
		JOIN GCS.PersonClusterPermission pcp ON pcp.ClusterUid = gp.ClusterUid
		WHERE pcp.PersonUid = @PersonUid

    OPEN CpuCursor
    FETCH NEXT FROM CpuCursor INTO  @cpuUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		exec GCS.[CredentialToDeleteFromCpu_Create] @cpuUid, @CardBinaryData, @DeletedFromDatabaseDate
	FETCH NEXT FROM CpuCursor INTO @cpuUid
    END
    CLOSE CpuCursor;
    DEALLOCATE CpuCursor;

GO
ALTER AUTHORIZATION ON [GCS].[CredentialToDeleteFromCpu_GenerateFromDeleteCredential] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToDeleteFromCpu_GenerateFromDeleteCredential] TO [public] AS [dbo]
GO
/****** Object:  StoredProcedure [GCS].[CredentialToDeleteFromCpu_GenerateFromDeletePersonClusterPermission]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[CredentialToDeleteFromCpu_GenerateFromDeletePersonClusterPermission]
	@ClusterUid [uniqueidentifier],
	@PersonUid [uniqueidentifier],
	@DeletedFromDatabaseDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
DECLARE @cpuUid uniqueidentifier;
    DECLARE CpuCursor CURSOR LOCAL FOR 
		select CpuUid from GCS.GalaxyCpu cpu JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = cpu.GalaxyPanelUid where gp.ClusterUid = @ClusterUid

	DECLARE @cardBinaryData binary(32);
	DECLARE CardBinaryDataCursor CURSOR LOCAL FOR
		select CardBinaryData from GCS.Credential c join GCS.PersonCredential pc on pc.CredentialUid = c.CredentialUid where pc.PersonUid = @PersonUid

    OPEN CpuCursor
    FETCH NEXT FROM CpuCursor INTO @cpuUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		OPEN CardBinaryDataCursor
		FETCH NEXT FROM CardBinaryDataCursor INTO @cardBinaryData
		WHILE @@FETCH_STATUS = 0
		BEGIN
			exec GCS.[CredentialToDeleteFromCpu_Create] @CpuUid, @cardBinaryData, @DeletedFromDatabaseDate
		FETCH NEXT FROM CardBinaryDataCursor INTO @cardBinaryData
		END
		CLOSE CardBinaryDataCursor;

	FETCH NEXT FROM CpuCursor INTO @cpuUid
    END
    CLOSE CpuCursor;
    DEALLOCATE CpuCursor;
    DEALLOCATE CardBinaryDataCursor;

GO
ALTER AUTHORIZATION ON [GCS].[CredentialToDeleteFromCpu_GenerateFromDeletePersonClusterPermission] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToDeleteFromCpu_GenerateFromDeletePersonClusterPermission] TO [public] AS [dbo]
GO
/****** Object:  StoredProcedure [GCS].[CredentialToDeleteFromCpu_GenerateFromUpdateCredential]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[CredentialToDeleteFromCpu_GenerateFromUpdateCredential]
	@CredentialUid [uniqueidentifier],
	@CardBinaryData [binary](32),
	@DeletedFromDatabaseDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
DECLARE @cpuUid uniqueidentifier

	DECLARE CpuCursor CURSOR LOCAL FOR
		SELECT CpuUid FROM GCS.GalaxyCpu cpu 
		JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = cpu.GalaxyPanelUid 
		JOIN GCS.PersonClusterPermission pcp ON pcp.ClusterUid = gp.ClusterUid
		JOIN GCS.PersonCredential pc on pc.PersonUid = pcp.PersonUid
		WHERE pc.CredentialUid = @CredentialUid

    OPEN CpuCursor
    FETCH NEXT FROM CpuCursor INTO  @cpuUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		exec GCS.[CredentialToDeleteFromCpu_Create] @cpuUid, @CardBinaryData, @DeletedFromDatabaseDate
	FETCH NEXT FROM CpuCursor INTO @cpuUid
    END
    CLOSE CpuCursor;
    DEALLOCATE CpuCursor;

GO
ALTER AUTHORIZATION ON [GCS].[CredentialToDeleteFromCpu_GenerateFromUpdateCredential] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToDeleteFromCpu_GenerateFromUpdateCredential] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[CredentialToLoadToCpu_Create]
	@CpuUid [uniqueidentifier],
	@CredentialUid [uniqueidentifier],
	@InsertedIntoDatabaseDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

DECLARE @CredentialToLoadToCpuUid uniqueidentifier
SELECT @CredentialToLoadToCpuUid = CredentialToLoadToCpuUid FROM GCS.CredentialToLoadToCpu WHERE CpuUid = @CpuUid AND CredentialUid = @CredentialUid
IF @CredentialToLoadToCpuUid IS NULL
BEGIN
	SET @CredentialToLoadToCpuUid = newid()
	INSERT INTO GCS.CredentialToLoadToCpu (CredentialToLoadToCpuUid, CpuUid, CredentialUid, LastCredentialChangeDate, LastPersonalAccessGroupChangeDate)
	VALUES(@CredentialToLoadToCpuUid, @CpuUid, @CredentialUid, SYSDATETIMEOFFSET(), SYSDATETIMEOFFSET())

END
ELSE
BEGIN
	UPDATE GCS.CredentialToLoadToCpu SET LastCredentialChangeDate = @InsertedIntoDatabaseDate, LastPersonalAccessGroupChangeDate = @InsertedIntoDatabaseDate
	WHERE CredentialToLoadToCpuUid = @CredentialToLoadToCpuUid
END

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[CredentialToLoadToCpu_Create] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToLoadToCpu_Create] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[CredentialToLoadToCpu_SaveLastCredentialLoadedDate]
	@CpuUid [uniqueidentifier],
	@CredentialUid [uniqueidentifier],
	@LastCredentialLoadedDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

DECLARE @CredentialToLoadToCpuUid uniqueidentifier 

SELECT @CredentialToLoadToCpuUid = CredentialToLoadToCpuUid FROM GCS.CredentialToLoadToCpu WHERE CpuUid = @CpuUid AND CredentialUid = @CredentialUid
IF @CredentialToLoadToCpuUid IS NULL
BEGIN
	SET @CredentialToLoadToCpuUid = newid()
	INSERT INTO GCS.CredentialToLoadToCpu (CredentialToLoadToCpuUid, CpuUid, CredentialUid, LastCredentialChangeDate, LastPersonalAccessGroupChangeDate, LastCredentialLoadedDate)
	VALUES(@CredentialToLoadToCpuUid, @CpuUid, @CredentialUid, SYSDATETIMEOFFSET(), SYSDATETIMEOFFSET(), @LastCredentialLoadedDate)

END
ELSE
BEGIN
	UPDATE GCS.CredentialToLoadToCpu SET LastCredentialLoadedDate = @LastCredentialLoadedDate
	WHERE CredentialToLoadToCpuUid = @CredentialToLoadToCpuUid
END

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[CredentialToLoadToCpu_SaveLastCredentialLoadedDate] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToLoadToCpu_SaveLastCredentialLoadedDate] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[CredentialToLoadToCpu_GenerateFromInsertPersonClusterPermission]
	@ClusterUid [uniqueidentifier],
	@PersonUid [uniqueidentifier],
	@InsertedIntoDatabaseDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
DECLARE @cpuUid uniqueidentifier;
    DECLARE CpuCursor CURSOR LOCAL FOR 
		select CpuUid from GCS.GalaxyCpu cpu JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = cpu.GalaxyPanelUid where gp.ClusterUid = @ClusterUid

	DECLARE @credentialUid uniqueidentifier
	DECLARE CredentialUidCursor CURSOR LOCAL FOR
		select CredentialUid from GCS.PersonCredential where PersonUid = @PersonUid

    OPEN CpuCursor
    FETCH NEXT FROM CpuCursor INTO @cpuUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		OPEN CredentialUidCursor
		FETCH NEXT FROM CredentialUidCursor INTO @credentialUid
		WHILE @@FETCH_STATUS = 0
		BEGIN
			exec GCS.[CredentialToLoadToCpu_Create] @CpuUid, @credentialUid, @InsertedIntoDatabaseDate
		FETCH NEXT FROM CredentialUidCursor INTO @credentialUid
		END
		CLOSE CredentialUidCursor;

	FETCH NEXT FROM CpuCursor INTO @cpuUid
    END
    CLOSE CpuCursor;
    DEALLOCATE CpuCursor;
    DEALLOCATE CredentialUidCursor;

GO
ALTER AUTHORIZATION ON [GCS].[CredentialToLoadToCpu_GenerateFromInsertPersonClusterPermission] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToLoadToCpu_GenerateFromInsertPersonClusterPermission] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[CredentialToLoadToCpu_SetForceLoadForActivationAndExpirationValues]
	@currentTime datetimeoffset,
	@ClusterUid [uniqueidentifier],
	@PersonUid [uniqueidentifier],
	@InsertedIntoDatabaseDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
DECLARE @cpuUid uniqueidentifier;
    DECLARE CpuCursor CURSOR LOCAL FOR 
		select CpuUid from GCS.GalaxyCpu cpu JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = cpu.GalaxyPanelUid where gp.ClusterUid = @ClusterUid

	DECLARE @credentialUid uniqueidentifier
	DECLARE CredentialUidCursor CURSOR LOCAL FOR
		select CredentialUid from GCS.PersonCredential where PersonUid = @PersonUid

    OPEN CpuCursor
    FETCH NEXT FROM CpuCursor INTO @cpuUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		OPEN CredentialUidCursor
		FETCH NEXT FROM CredentialUidCursor INTO @credentialUid
		WHILE @@FETCH_STATUS = 0
		BEGIN
			exec GCS.[CredentialToLoadToCpu_Create] @CpuUid, @credentialUid, @InsertedIntoDatabaseDate
		FETCH NEXT FROM CredentialUidCursor INTO @credentialUid
		END
		CLOSE CredentialUidCursor;

	FETCH NEXT FROM CpuCursor INTO @cpuUid
    END
    CLOSE CpuCursor;
    DEALLOCATE CpuCursor;
    DEALLOCATE CredentialUidCursor;

GO
ALTER AUTHORIZATION ON [GCS].[CredentialToLoadToCpu_SetForceLoadForActivationAndExpirationValues] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToLoadToCpu_SetForceLoadForActivationAndExpirationValues] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[PersonUid_GetByCredentialFieldValues]
	@CredentialParts [nvarchar](100),
	@EntityId [uniqueidentifier] = null,
	@OrderBy [nvarchar](1000) = 'LastName asc, FirstName asc'
WITH EXECUTE AS CALLER
AS
DECLARE @pagingSqlClause nvarchar(200)
DECLARE @sql nvarchar(max)
DECLARE @credType nvarchar(100)
DECLARE @credPart1 nvarchar(100)
DECLARE @credPart2 nvarchar(100)
DECLARE @credPart3 nvarchar(100)
DECLARE @credPart4 nvarchar(100)
DECLARE @credPart5 nvarchar(100)
declare @partCounter int

	set @partCounter = 0

	BEGIN TRY
		if @OrderBy is null or len(@OrderBy) = 0
		begin
			set @OrderBy = 'LastName asc, FirstName asc'
		end

		DECLARE @part nvarchar(100)
		SELECT * INTO #CredentialParts FROM fnSPLIT_nVARCHAR( @CredentialParts, N':')	
		DECLARE CredentialPartsCursor CURSOR LOCAL FOR 
				SELECT NVARCHAR_DATA FROM #CredentialParts
		OPEN CredentialPartsCursor
		
		FETCH NEXT FROM CredentialPartsCursor INTO @part
		WHILE @@FETCH_STATUS = 0
		BEGIN
			PRINT @part
			if @partCounter = 0
				set @credType = @part
			else if @partCounter = 1
				set @credPart1 = @part
			else if @partCounter = 2
				set @credPart2 = @part
			else if @partCounter = 3
				set @credPart3 = @part
			else if @partCounter = 4
				set @credPart4 = @part
			else if @partCounter = 5
				set @credPart5 = @part

			set @partCounter = @partCounter + 1
			FETCH NEXT FROM CredentialPartsCursor INTO @part
		END
		CLOSE CredentialPartsCursor;
		DEALLOCATE CredentialPartsCursor;	
	
		declare @personUid uniqueidentifier
		declare @lastName nvarchar(65)
		declare @firstName nvarchar(65)
		declare @InsertDate datetimeoffset
		declare @UpdateDate datetimeoffset

		if @credType = 'Wiegand26Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.Credential26BitStandard cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.Credential26BitStandard cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end	
		else if @credType = 'HIDCorp1K35Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCorporate1K35Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.CompanyCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCorporate1K35Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.CompanyCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end	
		else if @credType = 'HIDCorp1K48Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCorporate1K48Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.CompanyCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCorporate1K48Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.CompanyCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end		
		else if @credType = 'PIV75Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialPIV75Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.AgencyCode = @credPart1 AND cd.SiteCode = @credPart2 AND cd.CredentialCode = @credPart3
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialPIV75Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.AgencyCode = @credPart1 AND cd.SiteCode = @credPart2 AND cd.CredentialCode = @credPart3 AND p.EntityId = @EntityId
		end		
		else if @credType = 'BQT36Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialBqt36Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2 AND cd.IssueCode = @credPart3
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialBqt36Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2 AND cd.IssueCode = @credPart3 AND p.EntityId = @EntityId
		end		
		else if @credType = 'XceedID40Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialXceedId40Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.SiteCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialXceedId40Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.SiteCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end		
		else if @credType = 'Cypress37Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCypress37Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialCypress37Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end	
		else if @credType = 'HIDH1030437Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialH1030437Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialH1030437Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.IdCode = @credPart2 AND p.EntityId = @EntityId
		end	
		else if @credType = 'HIDH1030237Bit'
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialH1030237Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.IdCode = @credPart1
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialH1030237Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.IdCode = @credPart1 AND p.EntityId = @EntityId
		end	
		else if @credType = 'SoftwareHouse37Bit '
		begin
			if @EntityId is null or @EntityId = '00000000-0000-0000-0000-000000000000'
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialSoftwareHouse37Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.SiteCode = @credPart2 AND cd.IdCode = @credPart3
			else
				select @personUid = p.PersonUid, @lastName = p.LastName, @firstName = p.FirstName, @insertDate = p.InsertDate, @updateDate = p.UpdateDate from GCS.Person p join GCS.PersonCredential pc on pc.PersonUid = p.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid join GCS.CredentialSoftwareHouse37Bit cd on cd.CredentialUid = c.CredentialUid
				where cd.FacilityCode = @credPart1 AND cd.SiteCode = @credPart2 AND cd.IdCode = @credPart3 AND p.EntityId = @EntityId
		end	


		if @personUid is not null
			select @personUid, @lastName, @firstName, @insertDate, @updateDate, 1 as TotalCount
		else
			select PersonUid, LastName, FirstName, @insertDate, @updateDate, 1 as TotalCount from GCS.Person where PersonUid is null
	
	END TRY
	BEGIN CATCH
		exec [usp_GetErrorInfo] 0,1
	END CATCH			

GO
ALTER AUTHORIZATION ON [GCS].[PersonUid_GetByCredentialFieldValues] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonUid_GetByCredentialFieldValues] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[PersonUid_GetListByPersonValues]
	@EntityId [uniqueidentifier],
	@SearchByColumnNamesCSV [nvarchar](max),
	@SearchData [nvarchar](max),
	@SearchDataDelimiter [nvarchar](10),
	@ExactMatch [smallint],
	@MaximumResults [int] = 0,
	@PageNumber [int] = 0,
	@PageSize [int] = 0,
	@DateComparisonType [nvarchar](20) = '='
WITH EXECUTE AS CALLER
AS
DECLARE @sql nvarchar(max)

DECLARE @Column nvarchar(255)
DECLARE @Value nvarchar(255)
DECLARE @OrderBy nvarchar(255)
DECLARE @searchByPersonCredentialColumn smallint 
DECLARE @whereAdded smallint
DECLARE @whereClause nvarchar(max)
DECLARE @pagingSqlClause nvarchar(200)

	BEGIN TRY
		
	SET @whereAdded = 0
	SET @whereClause = ''
	SET @OrderBy = ''
	
	if @PageSize is not null AND @PageSize > 0 AND ( @MaximumResults IS NULL OR @MaximumResults = 0 )
	BEGIN
		DECLARE @pagedOffset int
		select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
		set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
	END
	ELSE
		SET @pagingSqlClause = N''

    SET @sql = N'SELECT'
	IF @MaximumResults IS NOT NULL AND @MaximumResults > 0 AND @pagingSqlClause = ''
		SET @sql = @sql + N' TOP(' + CAST(@MaximumResults AS NVARCHAR) + ')' 

    SET @sql = @sql + N' PersonUid, COUNT(*) OVER() as TotalCardCount'
    SET @sql = @sql + N' FROM GCS.Person WHERE PersonUid IN '
	SET @sql = @sql + N' (SELECT DISTINCT(p.PersonUid) FROM GCS.Person p'

	IF @SearchByColumnNamesCSV IS NOT NULL AND LEN(@SearchByColumnNamesCSV) > 0
	BEGIN
		SELECT * INTO #WhereColumns FROM fnSPLIT_nVARCHAR( @SearchByColumnNamesCSV, N',')
		SELECT * INTO #WhereValues FROM fnSPLIT_nVARCHAR( @SearchData, @SearchDataDelimiter)
		
		--IF @EntityId IS NOT NULL
		--BEGIN
		--	INSERT INTO #WhereColumns (NVARCHAR_DATA) VALUES( 'GCS.Person.EntityId')
		--	INSERT INTO #WhereValues (NVARCHAR_DATA) VALUES( cast(@EntityId as nvarchar(40)))
		--END

		declare @prefixLen int
		declare @prefix nvarchar(100)

		-- REPLACE ALL GCS.PersonCredential column prefixes with pc
		set @prefix = 'GCS.PersonCredential'
		set @prefixLen = LEN(@prefix);
		UPDATE #WhereColumns SET NVARCHAR_DATA = 'pc' + RIGHT(NVARCHAR_DATA, len(NVARCHAR_DATA)-@prefixLen) WHERE NVARCHAR_DATA LIKE @prefix + '%'

		-- REPLACE ALL GCS.Person column prefixes with p
		set @prefix = 'GCS.Person'
		set @prefixLen = LEN(@prefix);
		UPDATE #WhereColumns SET NVARCHAR_DATA = 'p' + RIGHT(NVARCHAR_DATA, len(NVARCHAR_DATA)-@prefixLen) WHERE NVARCHAR_DATA LIKE @prefix + '%'

		SELECT @Column = NULL, @Value = NULL, @whereAdded = 0, @whereClause = '', @searchByPersonCredentialColumn = 0
		 
		SET @sql = @sql + N' LEFT OUTER JOIN GCS.PersonCredential pc ON pc.PersonUid = p.PersonUid '
		
		DECLARE ColumnCursor CURSOR LOCAL FOR 
				SELECT NVARCHAR_DATA FROM #WhereColumns

		DECLARE ValueCursor CURSOR LOCAL FOR 
				SELECT NVARCHAR_DATA FROM #WhereValues

		OPEN ColumnCursor
		OPEN ValueCursor
		
		FETCH NEXT FROM ColumnCursor INTO @Column
		WHILE @@FETCH_STATUS = 0
		BEGIN
			PRINT 'Column: ' + @Column		
			FETCH NEXT FROM ValueCursor INTO @Value
			IF @@FETCH_STATUS <> 0
				SET @Value = NULL
			PRINT 'Value: ' + @Value
			
			IF @Column IS NOT NULL
			BEGIN

				SELECT @whereAdded = 1
				IF LEN(@whereClause) > 0
					SET @whereClause = @whereClause + ' AND '
				ELSE
					SET @whereClause = @whereClause + ' WHERE ( '
				
				IF @Value IS NULL OR LEN(@Value) = 0 OR @Value = 'NULL'
				BEGIN
					SET @whereClause = @whereClause + N'(' + @Column
--					SET @whereClause = @whereClause + N' IS NULL OR ' + @Column + N' = '''')'
					SET @whereClause = @whereClause + N' IS NULL OR ' + @Column + N' LIKE ''%'')'
				END
				ELSE
				BEGIN
					--SET @whereClause = @whereClause + @Column
					IF @ExactMatch = 1
					BEGIN
						SET @whereClause = @whereClause + @Column
						SET @whereClause = @whereClause + N' = '''
						SET @whereClause = @whereClause + @Value
						SET @whereClause = @whereClause + N''''
					END
					ELSE
					BEGIN
						IF @Column IN ('p.DepartmentUid', 'p.PersonUid', 'p.EntityId', 'p.PersonRecordTypeUid', 'p.CountryOfBirthUid', 'p.PersonActiveStatusTypeUid', 'p.GenderUid' )
						BEGIN
							SET @whereClause = @whereClause + @Column
							SET @whereClause = @whereClause + N' = '''
							SET @whereClause = @whereClause + @Value
							SET @whereClause = @whereClause + N''''
						END
						ELSE IF @Column IN ('p.InsertDate', 'p.UpdateDate', 'p.DateOfBirth', 'p.EmploymentDate', 'p.TerminationDate', 'p.ActivationDateTime', 'p.ExpirationDateTime', 'pc.ActivationDateTime', 'pc.ExpirationDateTime', 'pc.BadgeLastPrinted', 'pc.DossierLastPrinted', 'pc.InsertDate', 'pc.UpdateDate')
						BEGIN
							SET @whereClause = @whereClause + N'CAST(CAST(' + @Column + N' AS DATE) AS NVARCHAR(255))'

							SET @whereClause = @whereClause + N' ' + @DateComparisonType
							SET @whereClause = @whereClause + N' '''
							SET @whereClause = @whereClause + @Value
							SET @whereClause = @whereClause + N''''
						END
						ELSE
						BEGIN
							SET @whereClause = @whereClause + @Column
							SET @whereClause = @whereClause + N' LIKE '''
							SET @whereClause = @whereClause + @Value
							SET @whereClause = @whereClause + N'%'''
						END
					END	
				END			
				DECLARE @cardPrefix nvarchar(20)
				SET @cardPrefix = 'pc.'
				IF  LEFT(@Column, LEN(@cardPrefix))= @cardPrefix 
				BEGIN
					PRINT 'Search column in PersonCredential table'
					SET @searchByPersonCredentialColumn = 1
				END	
			END
			FETCH NEXT FROM ColumnCursor INTO @Column
		END
		CLOSE ColumnCursor;
		DEALLOCATE ColumnCursor;		
	END
	
	IF @whereAdded = 1
		SET @whereClause = @whereClause + ' ) '
			 

	IF @whereAdded = 1
		SET @whereClause = @whereClause + ' AND '
	ELSE
		SET @whereClause = @whereClause + ' WHERE '

	SELECT @whereAdded = 1
	SET @whereClause = @whereClause + N' ( p.EntityId = '''
	set @whereClause = @whereClause + cast(@EntityId as nvarchar(40)) + N''')'

	IF @whereAdded = 1
	BEGIN
		SET @whereClause = @whereClause + ' ) '
		SET @sql = @sql + @whereClause
	END
	ELSE
		SET @sql = @sql +  ' ) '
		
    IF @OrderBy IS NULL OR LEN(@OrderBy) = 0
	BEGIN
		SET @OrderBy = 'LastName, FirstName'
	END   
	
    SET @sql = @sql + ' ORDER BY '
    
    SET @sql = @sql + @OrderBy
    
	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @sql = @sql + @pagingSqlClause
	END
	
    print @sql
    execute sp_executesql @sql 
	
	END TRY
	BEGIN CATCH
		exec [usp_GetErrorInfo] 0,1
	END CATCH			

	IF @SearchByColumnNamesCSV IS NOT NULL AND LEN(@SearchByColumnNamesCSV) > 0
	BEGIN
		DROP TABLE #WhereColumns
		DROP TABLE #WhereValues
	END

GO
ALTER AUTHORIZATION ON [GCS].[PersonUid_GetListByPersonValues] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonUid_GetListByPersonValues] TO [public] AS [dbo]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonUid_GetListByPersonValuesWithParams]
	@EntityId [uniqueidentifier],
	@SearchByColumnName1 [nvarchar](255),
	@SearchData1 [nvarchar](255),
	@SearchByColumnName2 [nvarchar](255),
	@SearchData2 [nvarchar](255),
	@SearchByColumnName3 [nvarchar](255),
	@SearchData3 [nvarchar](255),
	@SearchByColumnName4 [nvarchar](255),
	@SearchData4 [nvarchar](255),
	@SearchByColumnName5 [nvarchar](255),
	@SearchData5 [nvarchar](255),
	@SearchByColumnName6 [nvarchar](255),
	@SearchData6 [nvarchar](255),
	@SearchByColumnName7 [nvarchar](255),
	@SearchData7 [nvarchar](255),
	@SearchByColumnName8 [nvarchar](255),
	@SearchData8 [nvarchar](255),
	@ExactMatch [smallint] = 0,
	@AnywhereWithin [smallint] = 0,
	@OrNotAnd [smallint] = 0,
	@MaximumResults [int] = 0,
	@PageNumber [int] = 0,
	@PageSize [int] = 0,
	@DateComparisonType [nvarchar](20) = '=',
	@OrderBy nvarchar(255) = 'LastName asc, FirstName asc'
WITH EXECUTE AS CALLER
AS
DECLARE @sql nvarchar(max)

DECLARE @Column nvarchar(255)
DECLARE @Value nvarchar(255)
DECLARE @searchByPersonCredentialColumn smallint 
DECLARE @whereAdded smallint
DECLARE @whereClause nvarchar(max)
DECLARE @pagingSqlClause nvarchar(200)

	BEGIN TRY
	
	SET @whereAdded = 0
	SET @whereClause = ''
	
	if @PageSize is not null AND @PageSize > 0 AND ( @MaximumResults IS NULL OR @MaximumResults = 0 )
	BEGIN
		DECLARE @pagedOffset int
		select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
		set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
	END
	ELSE
		SET @pagingSqlClause = N''


	if @OrderBy is null or len(@OrderBy) = 0
	begin
		set @OrderBy = 'LastName asc, FirstName asc'
	end

    SET @sql = N'SELECT'
	IF @MaximumResults IS NOT NULL AND @MaximumResults > 0 AND @pagingSqlClause = ''
		SET @sql = @sql + N' TOP(' + CAST(@MaximumResults AS NVARCHAR) + ')' 

    SET @sql = @sql + N' PersonUid, LastName, FirstName, InsertDate, UpdateDate, COUNT(*) OVER() as TotalCardCount'
    SET @sql = @sql + N' FROM GCS.Person WHERE PersonUid IN '
	SET @sql = @sql + N' (SELECT DISTINCT(p.PersonUid) FROM GCS.Person p'

	CREATE TABLE #ColumnsValues
	( 
		ID INT IDENTITY(1, 1),
		ColumnName nvarchar(255),
		ColumnValue nvarchar(255)
	)

	if @SearchByColumnName1 is not null AND LEN(@SearchByColumnName1) > 0
	begin
		insert into #ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName1, @SearchData1)
	end

	if @SearchByColumnName2 is not null AND LEN(@SearchByColumnName2) > 0
	begin
		insert into #ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName2, @SearchData2)
	end

	if @SearchByColumnName3 is not null AND LEN(@SearchByColumnName3) > 0
	begin
		insert into #ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName3, @SearchData3)
	end

	if @SearchByColumnName4 is not null AND LEN(@SearchByColumnName4) > 0
	begin
		insert into #ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName4, @SearchData4)
	end

	if @SearchByColumnName5 is not null AND LEN(@SearchByColumnName5) > 0
	begin
		insert into #ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName5, @SearchData5)
	end

	if @SearchByColumnName6 is not null AND LEN(@SearchByColumnName6) > 0
	begin
		insert into #ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName6, @SearchData6)
	end

	if @SearchByColumnName7 is not null AND LEN(@SearchByColumnName7) > 0
	begin
		insert into #ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName7, @SearchData7)
	end

	if @SearchByColumnName8 is not null AND LEN(@SearchByColumnName8) > 0
	begin
		insert into #ColumnsValues (ColumnName, ColumnValue) Values (@SearchByColumnName8, @SearchData8)
	end

	declare @cnt int
	select @cnt = count(*) from #ColumnsValues
	IF @cnt > 0
	BEGIN
		
		declare @prefixLen int
		declare @prefix nvarchar(100)

		-- REPLACE ALL GCS.PersonCredential column prefixes with pc
		set @prefix = 'GCS.PersonCredential'
		set @prefixLen = LEN(@prefix);
		UPDATE #ColumnsValues SET ColumnName = 'pc' + RIGHT(ColumnName, len(ColumnName)-@prefixLen) WHERE ColumnName LIKE @prefix + '%'

		-- REPLACE ALL GCS.Person column prefixes with p
		set @prefix = 'GCS.Person'
		set @prefixLen = LEN(@prefix);
		UPDATE #ColumnsValues SET ColumnName = 'p' + RIGHT(ColumnName, len(ColumnName)-@prefixLen) WHERE ColumnName LIKE @prefix + '%'

		SELECT @Column = NULL, @Value = NULL, @whereAdded = 0, @whereClause = '', @searchByPersonCredentialColumn = 0
		 
		SET @sql = @sql + N' LEFT OUTER JOIN GCS.PersonCredential pc ON pc.PersonUid = p.PersonUid '
		
		DECLARE ColumnCursor CURSOR LOCAL FOR 
				SELECT ColumnName, ColumnValue FROM #ColumnsValues

		OPEN ColumnCursor
		
		FETCH NEXT FROM ColumnCursor INTO @Column, @Value
		WHILE @@FETCH_STATUS = 0
		BEGIN
			PRINT 'Column: ' + @Column		
			PRINT 'Value: ' + @Value
			
			IF @Column IS NOT NULL
			BEGIN
				SELECT @whereAdded = 1
				IF LEN(@whereClause) > 0
				BEGIN
					IF @OrNotAnd = 1
					BEGIN
						SET @whereClause = @whereClause + ' OR '
					END
					ELSE
					BEGIN
						SET @whereClause = @whereClause + ' AND '
					END
				END
				ELSE
					SET @whereClause = @whereClause + ' WHERE ( '
				
				IF @Value IS NULL OR LEN(@Value) = 0 OR @Value = 'NULL'
				BEGIN
					SET @whereClause = @whereClause + N'(' + @Column
--					SET @whereClause = @whereClause + N' IS NULL OR ' + @Column + N' = '''')'
					SET @whereClause = @whereClause + N' IS NULL OR ' + @Column + N' LIKE ''%'')'
				END
				ELSE
				BEGIN
					--SET @whereClause = @whereClause + @Column
					IF @ExactMatch = 1
					BEGIN
						SET @whereClause = @whereClause + @Column
						SET @whereClause = @whereClause + N' = '''
						SET @whereClause = @whereClause + @Value
						SET @whereClause = @whereClause + N''''
					END
					ELSE
					BEGIN
						IF @Column IN ('p.DepartmentUid', 'p.PersonUid', 'p.EntityId', 'p.PersonRecordTypeUid', 'p.CountryOfBirthUid', 'p.PersonActiveStatusTypeUid', 'p.GenderUid' )
						BEGIN
							SET @whereClause = @whereClause + @Column
							SET @whereClause = @whereClause + N' = '''
							SET @whereClause = @whereClause + @Value
							SET @whereClause = @whereClause + N''''
						END
						ELSE IF @Column IN ('p.InsertDate', 'p.UpdateDate', 'p.DateOfBirth', 'p.EmploymentDate', 'p.TerminationDate', 'p.ActivationDateTime', 'p.ExpirationDateTime', 'pc.ActivationDateTime', 'pc.ExpirationDateTime', 'pc.BadgeLastPrinted', 'pc.DossierLastPrinted', 'pc.InsertDate', 'pc.UpdateDate')
						BEGIN
							SET @whereClause = @whereClause + N'CAST(CAST(' + @Column + N' AS DATE) AS NVARCHAR(255))'

							SET @whereClause = @whereClause + N' ' + @DateComparisonType
							SET @whereClause = @whereClause + N' '''
							SET @whereClause = @whereClause + @Value
							SET @whereClause = @whereClause + N''''
						END
						ELSE
						BEGIN
							SET @whereClause = @whereClause + @Column
							SET @whereClause = @whereClause + N' LIKE '''
							if @AnywhereWithin = 1
							begin
								SET @whereClause = @whereClause + N'%'
							end
							SET @whereClause = @whereClause + @Value
							SET @whereClause = @whereClause + N'%'''
						END
					END	
				END			
				DECLARE @cardPrefix nvarchar(20)
				SET @cardPrefix = 'pc.'
				IF  LEFT(@Column, LEN(@cardPrefix))= @cardPrefix 
				BEGIN
					PRINT 'Search column in PersonCredential table'
					SET @searchByPersonCredentialColumn = 1
				END	
			END
		FETCH NEXT FROM ColumnCursor INTO @Column, @Value
		END
		CLOSE ColumnCursor;
		DEALLOCATE ColumnCursor;		
	END
	
	IF @whereAdded = 1
		SET @whereClause = @whereClause + ' ) '
			 

	IF @whereAdded = 1
		SET @whereClause = @whereClause + ' AND '
	ELSE
		SET @whereClause = @whereClause + ' WHERE '

	SELECT @whereAdded = 1
	SET @whereClause = @whereClause + N' ( p.EntityId = '''
	set @whereClause = @whereClause + cast(@EntityId as nvarchar(40)) + N''')'

	IF @whereAdded = 1
	BEGIN
		SET @whereClause = @whereClause + ' ) '
		SET @sql = @sql + @whereClause
	END
	ELSE
		SET @sql = @sql +  ' ) '
		
	
    SET @sql = @sql + ' ORDER BY '
    
    SET @sql = @sql + @OrderBy
    
	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @sql = @sql + @pagingSqlClause
	END
	
    print @sql
    execute sp_executesql @sql 
	
	END TRY
	BEGIN CATCH
		exec [usp_GetErrorInfo] 0,1
	END CATCH			

	DROP TABLE #ColumnsValues
GO
ALTER AUTHORIZATION ON [GCS].[PersonUid_GetListByPersonValuesWithParams] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonUid_GetListByPersonValuesWithParams] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[gcsSetting_Save]
	@EntityId [uniqueidentifier],
	@SettingGroup [nvarchar](65),
	@SettingSubGroup [nvarchar](65),
	@SettingKey [nvarchar](255),
	@Value [nvarchar](255),
	@UserName [nvarchar](100) = NULL
WITH EXECUTE AS CALLER
AS
IF @UserName IS NULL
		SET @UserName = CURRENT_USER
	
	if @EntityId IS NULL
		SET @EntityId = '00000000-0000-0000-0000-000000000001'
	
	declare @settingId uniqueidentifier
	select @settingId = SettingId FROM GCS.[gcsSetting] where SettingGroup = @SettingGroup AND SettingSubGroup = @SettingSubGroup AND SettingKey = @SettingKey AND EntityId = @EntityId
	if @settingId IS NOT NULL
	BEGIN
		UPDATE GCS.[gcsSetting] SET [Value] = @Value WHERE SettingId = @settingId
	END
	ELSE
	BEGIN
		INSERT INTO GCS.[gcsSetting] (SettingId, EntityId, SettingGroup, SettingSubGroup, SettingKey, [Value], InsertName, InsertDate)
		VALUES(NewId(), @EntityId, @SettingGroup, @SettingSubGroup, @SettingKey, @Value, @UserName, SYSDATETIMEOFFSET() )
	END
GO
ALTER AUTHORIZATION ON [GCS].[gcsSetting_Save] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsSetting_Save] TO [public] AS [dbo]
GO



CREATE OR ALTER PROCEDURE [GCS].[usp_ProcessAuditRecordDescription]
WITH EXECUTE AS CALLER
AS
set nocount on
	DECLARE @TableName nvarchar(128)
	DECLARE @PKField nvarchar(1000)
	DECLARE @PKValue nvarchar(1000)
	DECLARE @descValue nvarchar(255)
	DECLARE @TransactionID uniqueidentifier
	
    DECLARE AuditCursor CURSOR LOCAL FOR 
		SELECT TableName, PKField, PKValue, TransactionID FROM GCS.gcsAuditXml WHERE Description IS NULL AND Type <> 'D'

    OPEN AuditCursor
    FETCH NEXT FROM AuditCursor INTO @TableName, @PKField, @PKValue, @TransactionID 
    WHILE @@FETCH_STATUS = 0
    BEGIN
--		PRINT @TableName + ', ' + @PKField + ', ' + @PKValue
		DECLARE @descColumn nvarchar(max)
		SET @descColumn = NULL
	    exec GCS.[gcsSetting_GetValue] '00000000-0000-0000-0000-000000000001', 'GalaxySMSDB_Audit', 'Audit', @TableName, @descColumn output
		
		if @descColumn is null
		begin
			--print 'null'
			--exec GCS.[SaveSetting] N'GalaxySMSDB_Audit', @TableName, N'', N''
		    exec GCS.[gcsSetting_Save] '00000000-0000-0000-0000-000000000001', 'GalaxySMSDB_Audit', 'Audit',  @TableName,  N'', N''
		end
		
		IF @descColumn IS NOT NULL AND LEN(@descColumn) > 0
		BEGIN	
			--PRINT 'Audit Data: ' + @TableName + ', ' + @PKField + ', ' + @PKValue
			--PRINT 'Description Column: ' + @descColumn
			
			select * INTO #tmpPKFields from dbo.[fnSPLIT_nVARCHAR]( @PKField, '.')
			select * INTO #tmpPKValues from dbo.[fnSPLIT_nVARCHAR]( @PKValue, '.')
			DECLARE @sqlWhere nvarchar(max)
			DECLARE @sql nvarchar(max)
			
--			SET @sql = 'SELECT ' + @descColumn + ' FROM ' + @TableName + ' WHERE ( '
			SET @sql = 'SELECT @descValue = ' + @descColumn + ' FROM ' + @TableName + ' WHERE ( '
	
			DECLARE @FieldName nvarchar(128)
			DECLARE @FieldValue nvarchar(128)
			DECLARE @fieldCount int
	
			SET @fieldCount = 0
			
			DECLARE WhereFieldsCursor CURSOR LOCAL FOR 
				SELECT NVARCHAR_DATA FROM #tmpPKFields

			DECLARE WhereValuesCursor CURSOR LOCAL FOR 
				SELECT NVARCHAR_DATA FROM #tmpPKValues

			OPEN WhereFieldsCursor
			OPEN WhereValuesCursor
			
			FETCH NEXT FROM WhereValuesCursor INTO @FieldValue 
		    FETCH NEXT FROM WhereFieldsCursor INTO @FieldName 
			WHILE @@FETCH_STATUS = 0
			BEGIN
				DECLARE @sqlWhereTemp nvarchar(max)
								
				SET @sqlWhereTemp = @FieldName + ' = ''' + @FieldValue + ''''
				--print @sqlWhereTemp
				
				IF @fieldCount = 0
				BEGIN
					SET @sqlWhere = @sqlWhereTemp
				END
				ELSE
				BEGIN
					SET @sqlWhere = @sqlWhere + ' AND ' + @sqlWhereTemp				
				END
				
				SET @fieldCount = @fieldCount + 1
					
				FETCH NEXT FROM WhereValuesCursor INTO @FieldValue 
			    FETCH NEXT FROM WhereFieldsCursor INTO @FieldName 
			END
			CLOSE WhereFieldsCursor;
			CLOSE WhereValuesCursor;
			DEALLOCATE WhereFieldsCursor;
			DEALLOCATE WhereValuesCursor;
			
			SET @sql = @sql + @sqlWhere
			SET @sql = @sql + ')'
			--PRINT @sql

			BEGIN TRY
				EXEC sp_executesql 
					@query = @sql, 
					@params = N'@descValue nvarchar(1000) OUTPUT', 
					@descValue =@descValue OUTPUT 	
	        
				UPDATE GCS.gcsAuditXml SET Description = @descValue WHERE CURRENT OF AuditCursor
			END TRY
			BEGIN CATCH
				EXEC [usp_GetErrorInfo] 0,1
			END CATCH;

			DROP TABLE #tmpPKFields
			DROP TABLE #tmpPKValues
		END	
    FETCH NEXT FROM AuditCursor INTO @TableName, @PKField, @PKValue, @TransactionID 
    END
    CLOSE AuditCursor;
    DEALLOCATE AuditCursor;
GO
ALTER AUTHORIZATION ON [GCS].[usp_ProcessAuditRecordDescription] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[usp_ProcessAuditRecordDescription] TO [public] AS [dbo]
GO



create OR ALTER trigger [GCS].[td_Credential_UpdateCredentialToDeleteFromCpu] on [GCS].[Credential] for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    declare @cardBinaryData binary(32)
    declare @personUid uniqueidentifier
    declare @now datetimeoffset
    set @now = SYSDATETIMEOFFSET()    
	
	IF (SELECT CURSOR_STATUS('local','CredentialDeleteCursor')) >= -1
	BEGIN
		IF (SELECT CURSOR_STATUS('local','CredentialDeleteCursor')) > -1
		BEGIN
			CLOSE CredentialDeleteCursor
		END
		DEALLOCATE CredentialDeleteCursor
	END

	DECLARE CredentialDeleteCursor CURSOR LOCAL FOR 
		select d.CardBinaryData, pc.PersonUid FROM GCS.PersonCredential pc JOIN deleted as d on d.CredentialUid = pc.CredentialUid 
    OPEN CredentialDeleteCursor
    FETCH NEXT FROM CredentialDeleteCursor INTO @cardBinaryData, @personUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		EXEC GCS.[CredentialToDeleteFromCpu_GenerateFromDeleteCredential] @cardBinaryData, @personUid, @now
    FETCH NEXT FROM CredentialDeleteCursor INTO @cardBinaryData, @personUid
    END
    CLOSE CredentialDeleteCursor;
    DEALLOCATE CredentialDeleteCursor;

    return

/*  Errors handling  */
error:
    rollback  transaction
    RAISERROR(@errmsg, @errno, 1)
end
GO


create OR ALTER trigger [GCS].[tu_Credential_UpdateCredentialToDeleteFromCpu] on [GCS].[Credential] for update as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

	-- if the card binary data has changed, mark the old one as needing deleted from the panel(s)
	if update(CardBinaryData)
	begin
		declare @oldCardBinaryData binary(32)
		declare @newCardBinaryData binary(32)
		declare @credentialUid uniqueidentifier
		declare @now datetimeoffset
		set @now = SYSDATETIMEOFFSET()    
	
		IF (SELECT CURSOR_STATUS('local','CredentialUpdateCursor')) >= -1
		BEGIN
			IF (SELECT CURSOR_STATUS('local','CredentialUpdateCursor')) > -1
			BEGIN
				CLOSE CredentialUpdateCursor
			END
			DEALLOCATE CredentialUpdateCursor
		END

		DECLARE CredentialUpdateCursor CURSOR LOCAL FOR 
			select d.CardBinaryData, i.CardBinaryData, d.CredentialUid FROM deleted d JOIN inserted i on i.CredentialUid = d.CredentialUid 
		OPEN CredentialUpdateCursor
		FETCH NEXT FROM CredentialUpdateCursor INTO @oldCardBinaryData, @newCardBinaryData, @credentialUid
		WHILE @@FETCH_STATUS = 0
		BEGIN
			-- The binary data has changed, mark the original one as needing deleted from every CPU that the credential has been given access 
			-- To accomplish 
			IF @oldCardBinaryData <> @newCardBinaryData OR -- the old AND new credential bytes are different
			(@oldCardBinaryData is not null AND @newCardBinaryData is null ) OR	-- the old credential bytes were valid AND the new ones are null
			(@oldCardBinaryData is null AND @newCardBinaryData is not null) -- the old credential bytes were null AND the new ones are not null
			BEGIN
				IF (SELECT CURSOR_STATUS('local','CredentialCpuCursor')) >= -1
				BEGIN
					IF (SELECT CURSOR_STATUS('local','CredentialCpuCursor')) > -1
					BEGIN
						CLOSE CredentialCpuCursor
					END
					DEALLOCATE CredentialCpuCursor
				END
					
				if @oldCardBinaryData is not null
					EXEC GCS.[CredentialToDeleteFromCpu_GenerateFromUpdateCredential] @credentialUid, @oldCardBinaryData, @now
			END
		FETCH NEXT FROM CredentialUpdateCursor INTO @oldCardBinaryData, @newCardBinaryData, @credentialUid
		END
		CLOSE CredentialUpdateCursor;
		DEALLOCATE CredentialUpdateCursor;
	end

    return

/*  Errors handling  */
error:
    rollback  transaction
    RAISERROR(@errmsg, @errno, 1)
end
GO
ALTER TABLE [GCS].[Credential] ENABLE TRIGGER [tu_Credential_UpdateCredentialToDeleteFromCpu]
GO


create OR ALTER trigger [GCS].[td_PersonClusterPermission_UpdateCredentialToDeleteFromCpu] on [GCS].[PersonClusterPermission] for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

	IF (SELECT CURSOR_STATUS('local','PersonClusterPermissionDeleteCursor')) >= -1
	BEGIN
		IF (SELECT CURSOR_STATUS('local','PersonClusterPermissionDeleteCursor')) > -1
		BEGIN
			CLOSE PersonClusterPermissionDeleteCursor
		END
		DEALLOCATE PersonClusterPermissionDeleteCursor
	END

    declare @clusterUid uniqueidentifier
    declare @personUid uniqueidentifier
    declare @now datetimeoffset
	set @now = SYSDATETIMEOFFSET()    

	DECLARE PersonClusterPermissionDeleteCursor CURSOR LOCAL FOR 
		select ClusterUid, PersonUid from deleted d
    OPEN PersonClusterPermissionDeleteCursor
    FETCH NEXT FROM PersonClusterPermissionDeleteCursor INTO @clusterUid, @personUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		EXEC GCS.[CredentialToDeleteFromCpu_GenerateFromDeletePersonClusterPermission] @clusterUid, @personUid, @now
    FETCH NEXT FROM PersonClusterPermissionDeleteCursor INTO @clusterUid, @personUid
    END
    CLOSE PersonClusterPermissionDeleteCursor;
    DEALLOCATE PersonClusterPermissionDeleteCursor;

    return

/*  Errors handling  */
error:
    rollback  transaction
    RAISERROR(@errmsg, @errno, 1)
end
GO
ALTER TABLE [GCS].[PersonClusterPermission] ENABLE TRIGGER [td_PersonClusterPermission_UpdateCredentialToDeleteFromCpu]
GO


create OR ALTER trigger [GCS].[ti_PersonClusterPermission_InsertCredentialToLoadToCpu] on [GCS].[PersonClusterPermission] for insert as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

	IF (SELECT CURSOR_STATUS('local','PersonClusterPermissionInsertCursor')) >= -1
	BEGIN
		IF (SELECT CURSOR_STATUS('local','PersonClusterPermissionInsertCursor')) > -1
		BEGIN
			CLOSE PersonClusterPermissionInsertCursor
		END
		DEALLOCATE PersonClusterPermissionInsertCursor
	END

    declare @clusterUid uniqueidentifier
    declare @personUid uniqueidentifier
    declare @now datetimeoffset
	set @now = SYSDATETIMEOFFSET()    

	DECLARE PersonClusterPermissionInsertCursor CURSOR LOCAL FOR 
		select ClusterUid, PersonUid from inserted i
    OPEN PersonClusterPermissionInsertCursor
    FETCH NEXT FROM PersonClusterPermissionInsertCursor INTO @clusterUid, @personUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		EXEC GCS.[CredentialToLoadToCpu_GenerateFromInsertPersonClusterPermission] @clusterUid, @personUid, @now
    FETCH NEXT FROM PersonClusterPermissionInsertCursor INTO @clusterUid, @personUid
    END
    CLOSE PersonClusterPermissionInsertCursor;
    DEALLOCATE PersonClusterPermissionInsertCursor;

    return

/*  Errors handling  */
error:
    rollback  transaction
    RAISERROR(@errmsg, @errno, 1)
end
GO
ALTER TABLE [GCS].[PersonClusterPermission] ENABLE TRIGGER [ti_PersonClusterPermission_InsertCredentialToLoadToCpu]
GO


create OR ALTER trigger [GCS].[td_PersonCredential_UpdateCredentialToDeleteFromCpu] on [GCS].[PersonCredential] for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    declare @cardBinaryData binary(32)
    declare @personUid uniqueidentifier
    declare @now datetimeoffset
    set @now = SYSDATETIMEOFFSET()    

	IF (SELECT CURSOR_STATUS('local','PersonCredentialDeleteCursor')) >= -1
	BEGIN
		IF (SELECT CURSOR_STATUS('local','PersonCredentialDeleteCursor')) > -1
		BEGIN
			CLOSE PersonCredentialDeleteCursor
		END
		DEALLOCATE PersonCredentialDeleteCursor
	END

	DECLARE PersonCredentialDeleteCursor CURSOR LOCAL FOR 
	select c.CardBinaryData, d.PersonUid FROM GCS.Credential c JOIN deleted as d on d.CredentialUid = c.CredentialUid 
    OPEN PersonCredentialDeleteCursor
    FETCH NEXT FROM PersonCredentialDeleteCursor INTO @cardBinaryData, @personUid
    WHILE @@FETCH_STATUS = 0
    BEGIN
		EXEC GCS.[CredentialToDeleteFromCpu_GenerateFromDeleteCredential] @cardBinaryData, @personUid, @now
		delete from GCS.Credential where CardBinaryData = @cardBinaryData
    FETCH NEXT FROM PersonCredentialDeleteCursor INTO @cardBinaryData, @personUid
    END
    CLOSE PersonCredentialDeleteCursor;
    DEALLOCATE PersonCredentialDeleteCursor;

    return

/*  Errors handling  */
error:
    rollback  transaction
    RAISERROR(@errmsg, @errno, 1)
end
GO
ALTER TABLE [GCS].[PersonCredential] ENABLE TRIGGER [td_PersonCredential_UpdateCredentialToDeleteFromCpu]
GO


CREATE OR ALTER PROCEDURE GCS.[gcsEntityCountPDSA_GenerateAllCounts]
@EntityId uniqueidentifier 
AS

if @EntityId IS NULL OR @EntityId = '00000000-0000-0000-0000-000000000000'
begin
	DECLARE entCursor CURSOR LOCAL FOR SELECT EntityId from GCS.gcsEntity where EntityId <> '00000000-0000-0000-0000-000000000001' ORDER BY EntityId 
	OPEN entCursor
	FETCH NEXT FROM entCursor INTO @EntityId
	WHILE @@FETCH_STATUS = 0
	BEGIN
		EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertInputDeviceCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertOutputDeviceCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertPersonCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertPrimaryUserCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertEntityUserCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertTimeScheduleCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertSiteCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertClusterCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertPanelCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertInterfaceBoardCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalActivityEventCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertInputDeviceActivityEventCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertOutputDeviceActivityEventCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertGalaxyPanelActivityEventCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertAccessGroupCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertAccessProfileCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertInputOutputGroupCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalGroupCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertRegionCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertDayTypeCount] @EntityId
		EXEC gcs.[gcsEntityCountPDSA_InsertTimePeriodCount] @EntityId
	FETCH NEXT FROM entCursor INTO @EntityId
	END
	CLOSE entCursor;
	DEALLOCATE entCursor;
end
else
begin
	EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertInputDeviceCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertOutputDeviceCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertPersonCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertPrimaryUserCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertEntityUserCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertTimeScheduleCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertSiteCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertClusterCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertPanelCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertInterfaceBoardCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalActivityEventCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertInputDeviceActivityEventCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertOutputDeviceActivityEventCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertGalaxyPanelActivityEventCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertAccessGroupCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertAccessProfileCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertInputOutputGroupCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertAccessPortalGroupCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertRegionCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertDayTypeCount] @EntityId
	EXEC gcs.[gcsEntityCountPDSA_InsertTimePeriodCount] @EntityId
end
GO

GRANT EXECUTE ON GCS.[gcsEntityCountPDSA_GenerateAllCounts] TO public
GO

create or alter trigger [GCS].[AccessPortalGalaxyHardwareAddress_DeleteTrigger] on [GCS].[AccessPortalGalaxyHardwareAddress] for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Delete all children in "GCS.AccessPortalLoadToCpu"  */
    delete GCS.AccessPortalLoadToCpu
    from   GCS.AccessPortalLoadToCpu t2, deleted t1
    where  t2.AccessPortalGalaxyHardwareAddressUid = t1.AccessPortalGalaxyHardwareAddressUid

	-- Without this line, the access portal will remain in the database, but un-bound to hardware
    --delete GCS.AccessPortal from GCS.AccessPortal t2, deleted t1 where t2.AccessPortalUid = t1.AccessPortalUid

	-- Update the access portal name to be appended with date and time of deletion
	--update GCS.AccessPortal
 --              set PortalName = t2.PortalName + N' - not in use ' + convert(nvarchar(20), GETUTCDATE(), 120)
 --           from   GCS.AccessPortal t2, deleted d1
 --              where  t2.AccessPortalUid = d1.AccessPortalUid

    return

/*  Errors handling  */
error:
    rollback  transaction
    RAISERROR(@errmsg, @errno, 1)
end
GO
ALTER TABLE [GCS].[AccessPortalGalaxyHardwareAddress] ENABLE TRIGGER [AccessPortalGalaxyHardwareAddress_DeleteTrigger]
GO
/****** Object:  Trigger [GCS].[ti_accessportalgalaxyhardwareaddress]    Script Date: 8/31/2020 2:22:27 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE OR ALTER PROCEDURE [GCS].[GalaxyInterfaceBoardPDSA_SelectAll]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
GalaxyInterfaceBoardUid
,t.GalaxyPanelUid
,InterfaceBoardTypeUid
,BoardNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,c.ClusterName
,p.ClusterUid
,p.PanelName
FROM GCS.GalaxyInterfaceBoard t
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = t.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyInterfaceBoardPDSA_SelectAll] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyInterfaceBoardPDSA_SelectAll] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[GalaxyInterfaceBoardPDSA_SelectByPK]
	@GalaxyInterfaceBoardUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;
SELECT 
GalaxyInterfaceBoardUid
,t.GalaxyPanelUid
,InterfaceBoardTypeUid
,BoardNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,c.ClusterName
,p.ClusterUid
,p.PanelName
FROM GCS.GalaxyInterfaceBoard t
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = t.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
WHERE 
GalaxyInterfaceBoardUid = @GalaxyInterfaceBoardUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyInterfaceBoardPDSA_SelectByPK] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyInterfaceBoardPDSA_SelectByPK] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[GalaxyInterfaceBoardPDSA_SelectSearch]
	@InsertName [nvarchar](100)
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;
SELECT 
GalaxyInterfaceBoardUid
,t.GalaxyPanelUid
,InterfaceBoardTypeUid
,BoardNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,c.ClusterName
,p.ClusterUid
,p.PanelName
FROM GCS.GalaxyInterfaceBoard t
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = t.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
WHERE 
(@InsertName IS NULL OR t.InsertName LIKE @InsertName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyInterfaceBoardPDSA_SelectSearch] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyInterfaceBoardPDSA_SelectSearch] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[GalaxyInterfaceBoardPDSA_ByClusterUid]
	@ClusterUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;
SELECT 
GalaxyInterfaceBoardUid
,t.GalaxyPanelUid
,InterfaceBoardTypeUid
,BoardNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,c.ClusterName
,p.ClusterUid
,p.PanelName
FROM GCS.GalaxyInterfaceBoard t
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = t.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
WHERE 
t.GalaxyPanelUid IN (SELECT GalaxyPanelUid FROM GCS.GalaxyPanel WHERE ClusterUid = @ClusterUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyInterfaceBoardPDSA_ByClusterUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyInterfaceBoardPDSA_ByClusterUid] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[GalaxyInterfaceBoardPDSA_ByGalaxyPanelUid]
	@GalaxyPanelUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
GalaxyInterfaceBoardUid
,t.GalaxyPanelUid
,InterfaceBoardTypeUid
,BoardNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,c.ClusterName
,p.ClusterUid
,p.PanelName
FROM GCS.GalaxyInterfaceBoard t
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = t.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
WHERE 
t.GalaxyPanelUid = @GalaxyPanelUid
order by BoardNumber

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyInterfaceBoardPDSA_ByGalaxyPanelUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyInterfaceBoardPDSA_ByGalaxyPanelUid] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[GalaxyInterfaceBoardPDSA_ByPanelAddress]
	@ClusterGroupId [int],
	@ClusterNumber [int],
	@PanelNumber [int]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

SELECT 
GalaxyInterfaceBoardUid
,t.GalaxyPanelUid
,InterfaceBoardTypeUid
,BoardNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,c.ClusterNumber
,p.PanelNumber
,c.ClusterName
,p.ClusterUid
,p.PanelName
FROM GCS.GalaxyInterfaceBoard t
JOIN GCS.GalaxyPanel p ON p.GalaxyPanelUid = t.GalaxyPanelUid
JOIN GCS.Cluster c ON c.ClusterUid = p.ClusterUid
WHERE 
c.ClusterGroupId = @ClusterGroupId AND
c.ClusterNumber = @ClusterNumber AND
p.PanelNumber = @PanelNumber


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyInterfaceBoardPDSA_ByPanelAddress] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyInterfaceBoardPDSA_ByPanelAddress] TO [public] AS [dbo]
GO


exec dbo.[gcs_DeleteIndex] 'GCS', 'Person', 'idxPersonId'
go

/****** Object:  Index [idxPersonId]    Script Date: 8/31/2020 2:22:22 PM ******/
CREATE UNIQUE NONCLUSTERED INDEX [idxPersonId] ON [GCS].[Person]
(
	[EntityId] ASC,
	[PersonId] ASC
) WHERE (PersonId IS NOT NULL AND PersonId <> N'') WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO


create or alter trigger [GCS].[InputDeviceGalaxyHardwareAddress_DeleteTrigger] on [GCS].[InputDeviceGalaxyHardwareAddress] for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Delete all children in "GCS.InputDeviceLoadToCpu"  */
    delete GCS.InputDeviceLoadToCpu
    from   GCS.InputDeviceLoadToCpu t2, deleted t1
    where  t2.InputDeviceGalaxyHardwareAddressUid = t1.InputDeviceGalaxyHardwareAddressUid

    
    delete GCS.GalaxyInputDevice from GCS.GalaxyInputDevice t2, deleted t1 where t2.InputDeviceUid = t1.InputDeviceUid
	--update GCS.InputDevice
 --              set InputName = t2.InputName + N' - not in use ' + convert(nvarchar(20), GETUTCDATE(), 120)
 --           from   GCS.InputDevice t2, deleted d1
 --              where  t2.InputDeviceUid = d1.InputDeviceUid

    return

/*  Errors handling  */
error:
    rollback  transaction
    RAISERROR(@errmsg, @errno, 1)
end
GO
ALTER TABLE [GCS].[InputDeviceGalaxyHardwareAddress] ENABLE TRIGGER [InputDeviceGalaxyHardwareAddress_DeleteTrigger]
GO


create or alter trigger [GCS].[OutputDeviceGalaxyHardwareAddress_DeleteTrigger] on [GCS].[OutputDeviceGalaxyHardwareAddress] for delete as
begin
    declare
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)
	   
    select  @numrows = @@rowcount
    if @numrows = 0
       return

    /*  Delete all children in "GCS.OutputDeviceLoadToCpu"  */
    delete GCS.OutputDeviceLoadToCpu
    from   GCS.OutputDeviceLoadToCpu t2, deleted t1
    where  t2.OutputDeviceGalaxyHardwareAddressUid = t1.OutputDeviceGalaxyHardwareAddressUid


    delete GCS.OutputDeviceLoadToCpu
    from   GCS.OutputDeviceLoadToCpu t2, deleted t1
    where  t2.OutputDeviceGalaxyHardwareAddressUid = t1.OutputDeviceGalaxyHardwareAddressUid


    delete GCS.GalaxyOutputDevice from GCS.OutputDevice t2, deleted t1 where t2.OutputDeviceUid = t1.OutputDeviceUid
	
	--update GCS.OutputDevice
 --              set OutputName = t2.OutputName + N' - not in use ' + convert(nvarchar(20), GETUTCDATE(), 120)
 --           from   GCS.OutputDevice t2, deleted d1
 --              where  t2.OutputDeviceUid = d1.OutputDeviceUid

    return

/*  Errors handling  */
error:
    rollback  transaction
    RAISERROR(@errmsg, @errno, 1)
end
GO
ALTER TABLE [GCS].[OutputDeviceGalaxyHardwareAddress] ENABLE TRIGGER [OutputDeviceGalaxyHardwareAddress_DeleteTrigger]
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDevicePDSA_ListBySiteUidAndName]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDevicePDSA_ListBySiteUidAndName]
GO
CREATE PROCEDURE GCS.[InputDevicePDSA_ListBySiteUidAndName]
@InputName nvarchar(65) 
,@SiteUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.InputDevice

SELECT 
id.EntityId
,id.InputDeviceUid
,id.InputName
,id.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.InputDevice id
JOIN GCS.InputDeviceGalaxyHardwareAddress idgha on idgha.InputDeviceUid = id.InputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = idgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE (@InputName IS NULL OR id.InputName LIKE '%' + @InputName + '%')
 And (id.SiteUid = @SiteUid)
ORDER BY (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 0 THEN InputName end) asc,
         (CASE WHEN @SortColumn = 'InputName' AND @DescendingOrder = 1 THEN InputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN id.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN id.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN id.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN id.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.InputDevicePDSA_ListBySiteUidAndName TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[OutputDevicePDSA_ListBySiteUidAndName]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[OutputDevicePDSA_ListBySiteUidAndName]
GO
CREATE PROCEDURE GCS.[OutputDevicePDSA_ListBySiteUidAndName]
@OutputName nvarchar(65),
@SiteUid uniqueidentifier,
@PageNumber int,
@PageSize int,
@SortColumn nvarchar(255) = 'InsertDate',
@DescendingOrder bit = 1
AS

declare @ret int;
select @ret = 0;

if @PageNumber = 0
	set @PageNumber = 1

if @PageSize = 0
	select @PageSize = count(*) from GCS.OutputDevice

SELECT 
od.EntityId
,od.OutputDeviceUid
,od.OutputName
,od.IsActive
,c.ClusterGroupId
,c.ClusterNumber
,p.PanelNumber
,gib.BoardNumber
,gibs.SectionNumber
,m.ModuleNumber
,n.NodeNumber
,n.IsNodeActive
,IsBoundToHardware
,idBoardType.TypeCode as InterfaceBoardTypeCode
,COUNT(*) OVER() TotalRowCount
FROM GCS.OutputDevice od
JOIN GCS.OutputDeviceGalaxyHardwareAddress odgha on odgha.OutputDeviceUid = od.OutputDeviceUid
JOIN GCS.GalaxyInterfaceBoardSectionNode n on n.GalaxyInterfaceBoardSectionNodeUid = odgha.GalaxyInterfaceBoardSectionNodeUid
JOIN GCS.GalaxyHardwareModule m on m.GalaxyHardwareModuleUid = n.GalaxyHardwareModuleUid
JOIN GCS.GalaxyInterfaceBoardSection gibs on gibs.GalaxyInterfaceBoardSectionUid = m.GalaxyInterfaceBoardSectionUid
JOIN GCS.GalaxyInterfaceBoard gib on gib.GalaxyInterfaceBoardUid = gibs.GalaxyInterfaceBoardUid
JOIN GCS.GalaxyPanel p on p.GalaxyPanelUid = gib.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = p.ClusterUid
JOIN GCS.InterfaceBoardType idBoardType on idBoardType.InterfaceBoardTypeUid = gib.InterfaceBoardTypeUid
WHERE (@OutputName IS NULL OR od.OutputName LIKE '%' + @OutputName + '%')
and od.SiteUid = @SiteUid
ORDER BY (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 0 THEN OutputName end) asc,
         (CASE WHEN @SortColumn = 'OutputName' AND @DescendingOrder = 1 THEN OutputName end) desc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 0 THEN od.InsertDate end) asc,
         (CASE WHEN @SortColumn = 'InsertDate' AND @DescendingOrder = 1 THEN od.InsertDate end) desc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 0 THEN od.UpdateDate end) asc,
         (CASE WHEN @SortColumn = 'UpdateDate' AND @DescendingOrder = 1 THEN od.UpdateDate end) desc
    OFFSET (@PageNumber - 1) * @PageSize ROWS
    FETCH NEXT @PageSize ROWS ONLY;


if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_ListBySiteUidAndName] TO public
GO

CREATE OR ALTER PROCEDURE GCS.[OutputDevicePDSA_GetNamesForSiteUid]
@OutputName nvarchar(65),
@SiteUid uniqueidentifier
AS

SELECT OutputName 
FROM GCS.OutputDevice od
WHERE (@OutputName IS NULL OR od.OutputName LIKE '%' + @OutputName + '%')
and od.SiteUid = @SiteUid
GO

GRANT EXECUTE ON GCS.[OutputDevicePDSA_GetNamesForSiteUid] TO public
GO



/****** Object:  StoredProcedure [GCS].[OutputDeviceGalaxyHardwareAddressPDSA_Insert]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[OutputDeviceGalaxyHardwareAddressPDSA_Insert]
	@OutputDeviceGalaxyHardwareAddressUid [uniqueidentifier],
	@OutputDeviceUid [uniqueidentifier],
	@GalaxyInterfaceBoardSectionNodeUid [uniqueidentifier],
	@GalaxyPanelUid [uniqueidentifier],
	@InsertName [nvarchar](100),
	@InsertDate [datetimeoffset],
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;
DECLARE @gpuid uniqueidentifier

if @OutputDeviceGalaxyHardwareAddressUid = '00000000-0000-0000-0000-000000000000'
	SET @OutputDeviceGalaxyHardwareAddressUid = NULL

if @OutputDeviceGalaxyHardwareAddressUid = '00000000-0000-0000-0000-000000000000' OR @OutputDeviceGalaxyHardwareAddressUid IS NULL
	SET @OutputDeviceGalaxyHardwareAddressUid = NewID()

--SET @GalaxyPanelUid = [GCS].[GalaxyPanelUid_GetByGalaxyInterfaceBoardSectionNodeUid] (@GalaxyInterfaceBoardSectionNodeUid)


INSERT INTO GCS.OutputDeviceGalaxyHardwareAddress
(
OutputDeviceGalaxyHardwareAddressUid
,OutputDeviceUid
,GalaxyInterfaceBoardSectionNodeUid
,GalaxyPanelUid
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@OutputDeviceGalaxyHardwareAddressUid
,@OutputDeviceUid
,@GalaxyInterfaceBoardSectionNodeUid
,@GalaxyPanelUid
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[OutputDeviceGalaxyHardwareAddressPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[OutputDeviceGalaxyHardwareAddressPDSA_Insert] TO [public] AS [dbo]
GO

--CREATE UNIQUE NONCLUSTERED INDEX [idxOutputDeviceUid] ON [GCS].[OutputDeviceGalaxyHardwareAddress]
--(
--	[OutputDeviceUid] ASC
--)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
--GO

CREATE OR ALTER PROCEDURE [GCS].[IsAccessPortalUnique]
	@AccessPortalUid [uniqueidentifier],
	@SiteUid [uniqueidentifier],
	@PortalName [nvarchar](65),
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
select @Result = count(*) from GCS.AccessPortal where AccessPortalUid <> @AccessPortalUid AND ( SiteUid = @SiteUid AND PortalName = @PortalName )
	select @Result as Result
GO
ALTER AUTHORIZATION ON [GCS].[IsAccessPortalUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsAccessPortalUnique] TO [public] AS [dbo]
GO

update GCS.gcsResourceString set DefaultValue = N'Send an enable command to a monitored device. The monitored device will return to normal operation.' where
DefaultValue = N'Send a enable command to a monitored device. The monitored device will return to normal operation.'
go

update GCS.gcsResourceString set DefaultValue = N'Send an enable command to an access portal. This command will return the access portal to normal operation.' where
DefaultValue = N'Send a enable command to a access portal. This command will return the access portal to normal operation.'
go

update GCS.gcsResourceString set DefaultValue = N'Send an enable command to a group of access portals. This command will return the access portals to normal operation.' where
DefaultValue = N'Send a enable command to a group of access portals. This command will return the access portals to normal operation.'
go

update GCS.gcsResourceString set DefaultValue = N'Send an enable command to an output device. The output control (relay) line will return to normal operation.' where
DefaultValue = N'Send a enable command to a output device. The output control (relay) line will return to normal operation.'
go

update GCS.gcsResourceString set DefaultValue = N'Send a command to an access portal to change the current state of the LED control signal.' where
DefaultValue = N'Send a command to a access portal to change the current state of the LED control signal.'
go

update GCS.gcsResourceString set DefaultValue = N'Send a command to an access portal to de-activate (turn off) the auxiliary relay.' where
DefaultValue = N'Send a command to a access portal to de-activate (turn off) the auxiliary relay.'
go

update GCS.gcsResourceString set DefaultValue = N'Send a command to request the current status/state of the output control (relay) line.' where
DefaultValue = N'Send a command to be sent to request the current status/state of the output control (relay) line.'
go

update GCS.gcsResourceString set DefaultValue = N'Send an off or de-activate command to an output device.' where
DefaultValue = N'Send a off or de-activate command to a output device. '
go

update GCS.gcsResourceString set DefaultValue = N'Send an off or deactivate command to an output device. The output control relay/line will be turned off or deactivated.' where
DefaultValue = N'Send a off or deactivate command to a output device. The output control relay/line will be turned off or deactivated.'
go

update GCS.gcsResourceString set DefaultValue = N'Send an on or activate command to an output device.' where
DefaultValue = N'Send a on or activate command to a output device.'
go

update GCS.gcsResourceString set DefaultValue = N'Send an on or activate command to an output device. The output control relay/line will be turned on or activated.' where
DefaultValue = N'Send a on or activate command to a output device. The output control relay/line will be turned on or activated.'
go

update GCS.gcsResourceString set DefaultValue = N'Send an unlock command to an access portal. The lock will be activated, cancelling any previous lock command or state.' where
DefaultValue = N'Send a unlock command to a access portal. The lock will be activated, cancelling any previous lock command or state.'
go

update GCS.gcsResourceString set DefaultValue = N'Send an unlock command to a group of access portals.' where
DefaultValue = N'Send a unlock command to a group of access portals.'
go

update GCS.gcsResourceString set DefaultValue = N'Send an unlock momentarily (pulse) command to an access portal. The lock will release/unlock for a period of time in accordance with the configured unlock duration time.' where
DefaultValue = N'Send a unlock momentarily (pulse) command to a access portal. The lock will release/unlock for a period of time in accordance with the configured unlock duration time.'
go

update GCS.gcsResourceString set DefaultValue = N'Send an un-shunt command to an input output group. The monitored devices will return to normal operation.' where
DefaultValue = N'Send a un-shunt command to a input output group. The monitored devices will return to normal operation.'
go

update GCS.gcsResourceString set DefaultValue = N'Send an un-shunt command to a monitored device. ' where
DefaultValue = N'Send a un-shunt command to a monitored device. '
go

update GCS.gcsResourceString set DefaultValue = N'Send an un-shunt command to a monitored device. The monitored device will return to normal operation.' where
DefaultValue = N'Send a un-shunt command to a monitored device. The monitored device will return to normal operation.'
go

--update GCS.gcsResourceString set DefaultValue = N'' where
--DefaultValue = N''
--go

--update GCS.gcsResourceString set DefaultValue = N'' where
--DefaultValue = N''
--go

--update GCS.gcsResourceString set DefaultValue = N'' where
--DefaultValue = N''
--go

--update GCS.gcsResourceString set DefaultValue = N'' where
--DefaultValue = N''
--go

--update GCS.gcsResourceString set DefaultValue = N'' where
--DefaultValue = N''
--go

--update GCS.gcsResourceString set DefaultValue = N'' where
--DefaultValue = N''
--go

/****** Object:  StoredProcedure [GCS].[insert_GalaxyPanelActivityEvent]    Script Date: 8/31/2020 2:22:24 PM ******/
CREATE OR ALTER PROCEDURE [GCS].[insert_GalaxyPanelActivityEvent]
	@GalaxyPanelActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@GalaxyPanelUid [uniqueidentifier],
	@CredentialUid [uniqueidentifier] = null,
	@PersonUid [uniqueidentifier] = null,
	@InputOutputGroupUid [uniqueidentifier] = null,
	@GalaxyInterfaceBoardUid [uniqueidentifier] = null,
	@GalaxyInterfaceBoardSectionUid [uniqueidentifier] = null,
	@GalaxyHardwareModuleUid [uniqueidentifier] = null,
	@GalaxyInterfaceBoardSectionNodeUid [uniqueidentifier] = null,
	@ActivityDateTime [datetimeoffset],
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@BufferIndex [int],
	@InputOutputGroupNumber [int] = null,
	@BoardNumber [int] = null,
	@SectionNumber [int] = null,
	@ModuleNumber [int] = null,
	@NodeNumber [int] = null,
	@InsertDate [datetimeoffset],
	@eventType [varchar](50),
	@IsAlarmEvent [bit],
	@AlarmPriority [int],
	@ResponseRequired bit,
	@NoteUid [uniqueidentifier],
	@BinaryResourceUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @GalaxyPanelActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyPanelActivityEventUid = NULL
if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL
if @PersonUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonUid = NULL
if @InputOutputGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @InputOutputGroupUid = NULL
if @GalaxyInterfaceBoardUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyInterfaceBoardUid = NULL
if @GalaxyInterfaceBoardSectionUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyInterfaceBoardSectionUid = NULL
if @GalaxyHardwareModuleUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyHardwareModuleUid = NULL
if @GalaxyInterfaceBoardSectionNodeUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyInterfaceBoardSectionNodeUid = NULL

if @GalaxyPanelActivityEventUid = '00000000-0000-0000-0000-000000000000' OR @GalaxyPanelActivityEventUid IS NULL
	SET @GalaxyPanelActivityEventUid = NewID()
	
if @eventType IS NOT NULL AND ( @GalaxyActivityEventTypeUid IS NULL OR @GalaxyActivityEventTypeUid = '00000000-0000-0000-0000-000000000000')
	SELECT @GalaxyActivityEventTypeUid = GalaxyActivityEventTypeUid FROM [GCS].[GalaxyActivityEventType] WHERE EventType = @eventType

if @InputOutputGroupNumber IS NOT NULL AND @InputOutputGroupNumber < 1
	set @InputOutputGroupNumber = NULL

if @BoardNumber IS NOT NULL AND @BoardNumber < 1
	set @BoardNumber = NULL

if @SectionNumber IS NOT NULL AND @SectionNumber < 1
	set @SectionNumber = NULL

if @ModuleNumber IS NOT NULL AND @ModuleNumber < 1
	set @ModuleNumber = NULL

if @NodeNumber IS NOT NULL AND @NodeNumber < 1
	set @NodeNumber = NULL

INSERT INTO GCS.GalaxyPanelActivityEvent
(
GalaxyPanelActivityEventUid
,GalaxyActivityEventTypeUid
,GalaxyPanelUid
,CredentialUid
,PersonUid
,InputOutputGroupUid
,GalaxyInterfaceBoardUid
,GalaxyInterfaceBoardSectionUid
,GalaxyHardwareModuleUid
,GalaxyInterfaceBoardSectionNodeUid
,ActivityDateTime
,CpuUid
,CpuNumber
,BufferIndex
,InputOutputGroupNumber
,BoardNumber
,SectionNumber
,ModuleNumber
,NodeNumber
,InsertDate
) 
VALUES 
(
@GalaxyPanelActivityEventUid
,@GalaxyActivityEventTypeUid
,@GalaxyPanelUid
,@CredentialUid
,@PersonUid
,@InputOutputGroupUid
,@GalaxyInterfaceBoardUid
,@GalaxyInterfaceBoardSectionUid
,@GalaxyHardwareModuleUid
,@GalaxyInterfaceBoardSectionNodeUid
,@ActivityDateTime
,@CpuUid
,@CpuNumber
,@BufferIndex
,@InputOutputGroupNumber
,@BoardNumber
,@SectionNumber
,@ModuleNumber
,@NodeNumber
,@InsertDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;



if @IsAlarmEvent is not null AND @IsAlarmEvent <> 0 AND @ret = 0
BEGIN
	if @NoteUid = '00000000-0000-0000-0000-000000000000'
		SET @NoteUid = NULL

	if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
		SET @BinaryResourceUid = NULL

	INSERT INTO GCS.GalaxyPanelActivityAlarmEvent (GalaxyPanelActivityEventUid, NoteUid, BinaryResourceUid, AlarmPriority,ResponseRequired)
	VALUES (@GalaxyPanelActivityEventUid, @NoteUid, @BinaryResourceUid, @AlarmPriority,@ResponseRequired)
END

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[insert_GalaxyPanelActivityEvent] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[insert_GalaxyPanelActivityEvent] TO [public] AS [dbo]
GO



CREATE OR ALTER PROCEDURE [GCS].[GalaxyPanelActivityEventPDSA_Insert]
	@GalaxyPanelActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@GalaxyPanelUid [uniqueidentifier],
	@CredentialUid [uniqueidentifier] = null,
	@PersonUid [uniqueidentifier] = null,
	@InputOutputGroupUid [uniqueidentifier] = null,
	@GalaxyInterfaceBoardUid [uniqueidentifier] = null,
	@GalaxyInterfaceBoardSectionUid [uniqueidentifier] = null,
	@GalaxyHardwareModuleUid [uniqueidentifier] = null,
	@GalaxyInterfaceBoardSectionNodeUid [uniqueidentifier] = null,
	@ActivityDateTime [datetimeoffset],
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@BufferIndex [int],
	@InputOutputGroupNumber [int] = null,
	@BoardNumber [int] = null,
	@SectionNumber [int] = null,
	@ModuleNumber [int] = null,
	@NodeNumber [int] = null,
	@InsertDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @GalaxyPanelActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyPanelActivityEventUid = NULL
if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL
if @PersonUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonUid = NULL
if @InputOutputGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @InputOutputGroupUid = NULL
if @GalaxyInterfaceBoardUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyInterfaceBoardUid = NULL
if @GalaxyInterfaceBoardSectionUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyInterfaceBoardSectionUid = NULL
if @GalaxyHardwareModuleUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyHardwareModuleUid = NULL
if @GalaxyInterfaceBoardSectionNodeUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyInterfaceBoardSectionNodeUid = NULL

if @GalaxyPanelActivityEventUid = '00000000-0000-0000-0000-000000000000' OR @GalaxyPanelActivityEventUid IS NULL
	SET @GalaxyPanelActivityEventUid = NewID()

INSERT INTO GCS.GalaxyPanelActivityEvent
(
GalaxyPanelActivityEventUid
,GalaxyActivityEventTypeUid
,GalaxyPanelUid
,CredentialUid
,PersonUid
,InputOutputGroupUid
,GalaxyInterfaceBoardUid
,GalaxyInterfaceBoardSectionUid
,GalaxyHardwareModuleUid
,GalaxyInterfaceBoardSectionNodeUid
,ActivityDateTime
,CpuUid
,CpuNumber
,BufferIndex
,InputOutputGroupNumber
,BoardNumber
,SectionNumber
,ModuleNumber
,NodeNumber
,InsertDate
) 
VALUES 
(
@GalaxyPanelActivityEventUid
,@GalaxyActivityEventTypeUid
,@GalaxyPanelUid
,@CredentialUid
,@PersonUid
,@InputOutputGroupUid
,@GalaxyInterfaceBoardUid
,@GalaxyInterfaceBoardSectionUid
,@GalaxyHardwareModuleUid
,@GalaxyInterfaceBoardSectionNodeUid
,@ActivityDateTime
,@CpuUid
,@CpuNumber
,@BufferIndex
,@InputOutputGroupNumber
,@BoardNumber
,@SectionNumber
,@ModuleNumber
,@NodeNumber
,@InsertDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyPanelActivityEventPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyPanelActivityEventPDSA_Insert] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[GalaxyPanelActivityEventPDSA_Update]
	@GalaxyPanelActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@GalaxyPanelUid [uniqueidentifier],
	@CredentialUid [uniqueidentifier],
	@PersonUid [uniqueidentifier],
	@InputOutputGroupUid [uniqueidentifier],
	@GalaxyInterfaceBoardUid [uniqueidentifier],
	@GalaxyInterfaceBoardSectionUid [uniqueidentifier],
	@GalaxyHardwareModuleUid [uniqueidentifier],
	@GalaxyInterfaceBoardSectionNodeUid [uniqueidentifier],
	@ActivityDateTime [datetimeoffset],
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@BufferIndex [int],
	@InputOutputGroupNumber [int],
	@BoardNumber [int],
	@SectionNumber [int],
	@ModuleNumber [int],
	@NodeNumber [int]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL
if @PersonUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonUid = NULL
if @InputOutputGroupUid = '00000000-0000-0000-0000-000000000000'
	SET @InputOutputGroupUid = NULL
if @GalaxyInterfaceBoardUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyInterfaceBoardUid = NULL
if @GalaxyInterfaceBoardSectionUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyInterfaceBoardSectionUid = NULL
if @GalaxyHardwareModuleUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyHardwareModuleUid = NULL
if @GalaxyInterfaceBoardSectionNodeUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyInterfaceBoardSectionNodeUid = NULL

UPDATE GCS.GalaxyPanelActivityEvent
SET 
GalaxyPanelActivityEventUid = @GalaxyPanelActivityEventUid
,GalaxyActivityEventTypeUid = @GalaxyActivityEventTypeUid
,GalaxyPanelUid = @GalaxyPanelUid
,CredentialUid = @CredentialUid
,PersonUid = @PersonUid
,InputOutputGroupUid = @InputOutputGroupUid
,GalaxyInterfaceBoardUid = @GalaxyInterfaceBoardUid 
,GalaxyInterfaceBoardSectionUid  = @GalaxyInterfaceBoardSectionUid 
,GalaxyHardwareModuleUid = @GalaxyHardwareModuleUid 
,GalaxyInterfaceBoardSectionNodeUid = @GalaxyInterfaceBoardSectionNodeUid 
,ActivityDateTime = @ActivityDateTime
,CpuUid = @CpuUid
,CpuNumber = @CpuNumber
,BufferIndex = @BufferIndex
,InputOutputGroupNumber = @InputOutputGroupNumber
,BoardNumber = @BoardNumber
,SectionNumber = @SectionNumber
,ModuleNumber = @ModuleNumber
,NodeNumber = @NodeNumber
WHERE
GalaxyPanelActivityEventUid = @GalaxyPanelActivityEventUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyPanelActivityEventPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyPanelActivityEventPDSA_Update] TO [public] AS [dbo]
GO


/****** Object:  StoredProcedure [GCS].[insert_InputDeviceActivityEvent]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[insert_InputDeviceActivityEvent]
	@InputDeviceActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@InputDeviceUid [uniqueidentifier],
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int],
	@InsertDate [datetimeoffset],
	@eventType [varchar](50),
	@IsAlarmEvent [bit],
	@AlarmPriority [int],
	@ResponseRequired bit,
	@NoteUid [uniqueidentifier],
	@BinaryResourceUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @InputDeviceActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @InputDeviceActivityEventUid = NULL

if @InputDeviceActivityEventUid = '00000000-0000-0000-0000-000000000000' OR @InputDeviceActivityEventUid IS NULL
	SET @InputDeviceActivityEventUid = NewID()
	
if @eventType IS NOT NULL AND ( @GalaxyActivityEventTypeUid IS NULL OR @GalaxyActivityEventTypeUid = '00000000-0000-0000-0000-000000000000')
	SELECT @GalaxyActivityEventTypeUid = GalaxyActivityEventTypeUid FROM [GCS].[GalaxyActivityEventType] WHERE EventType = @eventType


INSERT INTO GCS.InputDeviceActivityEvent
(
InputDeviceActivityEventUid
,GalaxyActivityEventTypeUid
,InputDeviceUid
,CpuUid
,CpuNumber
,ActivityDateTime
,BufferIndex
,InsertDate
) 
VALUES 
(
@InputDeviceActivityEventUid
,@GalaxyActivityEventTypeUid
,@InputDeviceUid
,@CpuUid
,@CpuNumber
,@ActivityDateTime
,@BufferIndex
,@InsertDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
if @IsAlarmEvent is not null AND @IsAlarmEvent <> 0 AND @ret = 0
BEGIN
	if @NoteUid = '00000000-0000-0000-0000-000000000000'
		SET @NoteUid = NULL

	if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
		SET @BinaryResourceUid = NULL

	INSERT INTO GCS.InputDeviceActivityAlarmEvent (InputDeviceActivityEventUid, NoteUid, BinaryResourceUid, AlarmPriority,ResponseRequired)
	VALUES (@InputDeviceActivityEventUid, @NoteUid, @BinaryResourceUid, @AlarmPriority,@ResponseRequired)
END

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[insert_InputDeviceActivityEvent] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[insert_InputDeviceActivityEvent] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[InputDeviceActivityEventPDSA_Insert]
	@InputDeviceActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@InputDeviceUid [uniqueidentifier],
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int],
	@InsertDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @InputDeviceActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @InputDeviceActivityEventUid = NULL

if @InputDeviceActivityEventUid = '00000000-0000-0000-0000-000000000000' OR @InputDeviceActivityEventUid IS NULL
	SET @InputDeviceActivityEventUid = NewID()

INSERT INTO GCS.InputDeviceActivityEvent
(
InputDeviceActivityEventUid
,GalaxyActivityEventTypeUid
,InputDeviceUid
,CpuUid
,CpuNumber
,ActivityDateTime
,BufferIndex
,InsertDate
) 
VALUES 
(
@InputDeviceActivityEventUid
,@GalaxyActivityEventTypeUid
,@InputDeviceUid
,@CpuUid
,@CpuNumber
,@ActivityDateTime
,@BufferIndex
,@InsertDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[InputDeviceActivityEventPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputDeviceActivityEventPDSA_Insert] TO [public] AS [dbo]
GO

/****** Object:  StoredProcedure [GCS].[InputDeviceActivityEventPDSA_Update]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[InputDeviceActivityEventPDSA_Update]
	@InputDeviceActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@InputDeviceUid [uniqueidentifier],
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

UPDATE GCS.InputDeviceActivityEvent
SET 
InputDeviceActivityEventUid = @InputDeviceActivityEventUid
,GalaxyActivityEventTypeUid = @GalaxyActivityEventTypeUid
,InputDeviceUid = @InputDeviceUid
,CpuUid = @CpuUid
,CpuNumber = @CpuNumber
,ActivityDateTime = @ActivityDateTime
,BufferIndex = @BufferIndex
WHERE
InputDeviceActivityEventUid = @InputDeviceActivityEventUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[InputDeviceActivityEventPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputDeviceActivityEventPDSA_Update] TO [public] AS [dbo]
GO

/****** Object:  View [GCS].[AcknowledgedAlarms]    Script Date: 8/31/2020 2:21:57 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create or alter view [GCS].[AcknowledgedAlarms] as
	select e.AccessPortalActivityEventUid as ActivityEventUid,
	cluster.ClusterGroupId, cluster.ClusterNumber,
	gp.PanelNumber, e.CpuNumber as CpuId,
	0 as BoardNumber, 0 as SectionNumber, 0 as ModuleNumber, 0 as NodeNumber, 0 as CpuModel,
	e.ActivityDateTime as 'DateTime', e.BufferIndex, et.EventType as PanelActivityType,
	0 as InputOutputGroupNumber, 0 as MultiFactorMode,
	ap.PortalName as 'DeviceDescription', et.Display as 'EventDescription', 
	ap.EntityId as DeviceEntityId, e.AccessPortalUid as 'DeviceUid',  	
	e.CpuUid, cluster.ClusterName, 1 as IsAlarmEvent,
	ae.AlarmPriority,
	ae.ResponseRequired,
	n.NoteText as Instructions,
	ae.NoteUid as InstructionsNoteUid,
	ae.BinaryResourceUid as AudioBinaryResourceUid,
	null as RawData,
	et.ForeColor as Color,
	et.ForeColorHex as ColorHex,
	e.PersonUid, e.CredentialUid,
	p.ActivityEventText as PersonDescription, pc.CredentialDescription,
	p.Trace
	from GCS.AccessPortalActivityEvent e 
	join GCS.AccessPortal ap on ap.AccessPortalUid = e.AccessPortalUid
	join GCS.AccessPortalGalaxyHardwareAddress gha on gha.AccessPortalUid = e.AccessPortalUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = gha.GalaxyPanelUid
	join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	join GCS.GalaxyActivityEventType et on et.GalaxyActivityEventTypeUid = e.GalaxyActivityEventTypeUid
	join GCS.AccessPortalActivityAlarmEvent ae on ae.AccessPortalActivityEventUid = e.AccessPortalActivityEventUid
	left outer join GCS.Person p on p.PersonUid = e.PersonUid
	left outer join GCS.PersonCredential pc on pc.CredentialUid = e.CredentialUid
	left outer join GCS.Note n on n.NoteUid = ae.NoteUid
	where e.AccessPortalActivityEventUid in (select distinct(AccessPortalActivityEventUid) from GCS.AccessPortalAlarmEventAcknowledgment)
	union
		select e.GalaxyPanelActivityEventUid as ActivityEventUid,
	cluster.ClusterGroupId, cluster.ClusterNumber,
	gp.PanelNumber, e.CpuNumber as CpuId,
	0 as BoardNumber, 0 as SectionNumber, 0 as ModuleNumber, 0 as NodeNumber, 0 as CpuModel,
	e.ActivityDateTime as 'DateTime', e.BufferIndex, et.EventType as PanelActivityType,
	0 as InputOutputGroupNumber, 0 as MultiFactorMode,
	gp.PanelName as 'DeviceDescription', et.Display as 'EventDescription', 
	cluster.EntityId as DeviceEntityId, e.GalaxyPanelUid as 'DeviceUid',  	
	e.CpuUid, cluster.ClusterName, 1 as IsAlarmEvent,
	ae.AlarmPriority,
	ae.ResponseRequired,
	n.NoteText as Instructions,
	ae.NoteUid as InstructionsNoteUid,
	ae.BinaryResourceUid as AudioBinaryResourceUid,
	null as RawData,
	et.ForeColor as Color,
	et.ForeColorHex as ColorHex,
	e.PersonUid, e.CredentialUid,
	p.ActivityEventText as PersonDescription, pc.CredentialDescription,
	p.Trace
	from GCS.GalaxyPanelActivityEvent e 
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = e.GalaxyPanelUid
	join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	join GCS.GalaxyActivityEventType et on et.GalaxyActivityEventTypeUid = e.GalaxyActivityEventTypeUid
	join GCS.GalaxyPanelActivityAlarmEvent ae on ae.GalaxyPanelActivityEventUid = e.GalaxyPanelActivityEventUid
	left outer join GCS.Person p on p.PersonUid = e.PersonUid
	left outer join GCS.PersonCredential pc on pc.CredentialUid = e.CredentialUid
	left outer join GCS.Note n on n.NoteUid = ae.NoteUid
	where e.GalaxyPanelActivityEventUid in (select distinct(GalaxyPanelActivityEventUid) from GCS.GalaxyPanelAlarmEventAcknowledgment)
union
	select e.InputDeviceActivityEventUid as ActivityEventUid,
	cluster.ClusterGroupId, cluster.ClusterNumber,
	gp.PanelNumber, e.CpuNumber as CpuId,
	0 as BoardNumber, 0 as SectionNumber, 0 as ModuleNumber, 0 as NodeNumber, 0 as CpuModel,
	e.ActivityDateTime as 'DateTime', e.BufferIndex, et.EventType as PanelActivityType,
	0 as InputOutputGroupNumber, 0 as MultiFactorMode,
	id.InputName as 'DeviceDescription', et.Display as 'EventDescription', 
	id.EntityId as DeviceEntityId, e.InputDeviceUid as 'DeviceUid',  	
	e.CpuUid, cluster.ClusterName, 1 as IsAlarmEvent,
	ae.AlarmPriority,
	ae.ResponseRequired,
	n.NoteText as Instructions,
	ae.NoteUid as InstructionsNoteUid,
	ae.BinaryResourceUid as AudioBinaryResourceUid,
	null as RawData,
	et.ForeColor as Color,
	et.ForeColorHex as ColorHex,
	NULL AS PersonUid, NULL AS CredentialUid,
	NULL as PersonDescription, NULL AS CredentialDescription,
	0 AS Trace
	from GCS.InputDeviceActivityEvent e 
	join GCS.InputDevice id on id.InputDeviceUid = e.InputDeviceUid
	join GCS.InputDeviceGalaxyHardwareAddress gha on gha.InputDeviceUid = e.InputDeviceUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode node on node.GalaxyInterfaceBoardSectionNodeUid = gha.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule module on module.GalaxyHardwareModuleUid = node.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = module.GalaxyInterfaceBoardSectionUid
	JOIN GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ib.GalaxyPanelUid
	join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	join GCS.GalaxyActivityEventType et on et.GalaxyActivityEventTypeUid = e.GalaxyActivityEventTypeUid
	join GCS.InputDeviceActivityAlarmEvent ae on ae.InputDeviceActivityEventUid = e.InputDeviceActivityEventUid
	left outer join GCS.Note n on n.NoteUid = ae.NoteUid
	where e.InputDeviceActivityEventUid in (select distinct(InputDeviceActivityEventUid) from GCS.InputDeviceAlarmEventAcknowledgment)

GO
ALTER AUTHORIZATION ON [GCS].[AcknowledgedAlarms] TO  SCHEMA OWNER 
GO

/****** Object:  View [GCS].[UnacknowledgedAlarms]    Script Date: 8/31/2020 2:21:57 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create or alter view [GCS].[UnacknowledgedAlarms] as
	select e.AccessPortalActivityEventUid as ActivityEventUid,
	cluster.ClusterGroupId, cluster.ClusterNumber,
	gp.PanelNumber, e.CpuNumber as CpuId,
	0 as BoardNumber, 0 as SectionNumber, 0 as ModuleNumber, 0 as NodeNumber, 0 as CpuModel,
	e.ActivityDateTime as 'DateTime', e.BufferIndex, et.EventType as PanelActivityType,
	0 as InputOutputGroupNumber, 0 as MultiFactorMode,
	ap.PortalName as 'DeviceDescription', et.Display as 'EventDescription', 
	ap.EntityId as DeviceEntityId, e.AccessPortalUid as 'DeviceUid',  	
	e.CpuUid, cluster.ClusterName, 1 as IsAlarmEvent,
	ae.AlarmPriority,
	ae.ResponseRequired,
	n.NoteText as Instructions,
	ae.NoteUid as InstructionsNoteUid,
	ae.BinaryResourceUid as AudioBinaryResourceUid,
	null as RawData,
	et.ForeColor as Color,
	et.ForeColorHex as ColorHex,
	e.PersonUid, e.CredentialUid,
	p.ActivityEventText as PersonDescription, pc.CredentialDescription,
	p.Trace
	from GCS.AccessPortalActivityEvent e 
	join GCS.AccessPortal ap on ap.AccessPortalUid = e.AccessPortalUid
	join GCS.AccessPortalGalaxyHardwareAddress gha on gha.AccessPortalUid = e.AccessPortalUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = gha.GalaxyPanelUid
	join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	join GCS.GalaxyActivityEventType et on et.GalaxyActivityEventTypeUid = e.GalaxyActivityEventTypeUid
	join GCS.AccessPortalActivityAlarmEvent ae on ae.AccessPortalActivityEventUid = e.AccessPortalActivityEventUid
	left outer join GCS.Person p on p.PersonUid = e.PersonUid
	left outer join GCS.PersonCredential pc on pc.CredentialUid = e.CredentialUid
	left outer join GCS.Note n on n.NoteUid = ae.NoteUid
	where e.AccessPortalActivityEventUid not in (select distinct(AccessPortalActivityEventUid) from GCS.AccessPortalAlarmEventAcknowledgment)
union
	select e.GalaxyPanelActivityEventUid as ActivityEventUid,
	cluster.ClusterGroupId, cluster.ClusterNumber,
	gp.PanelNumber, e.CpuNumber as CpuId,
	0 as BoardNumber, 0 as SectionNumber, 0 as ModuleNumber, 0 as NodeNumber, 0 as CpuModel,
	e.ActivityDateTime as 'DateTime', e.BufferIndex, et.EventType as PanelActivityType,
	0 as InputOutputGroupNumber, 0 as MultiFactorMode,
	gp.PanelName as 'DeviceDescription', et.Display as 'EventDescription', 
	cluster.EntityId as DeviceEntityId, e.GalaxyPanelUid as 'DeviceUid',  	
	e.CpuUid, cluster.ClusterName, 1 as IsAlarmEvent,
	ae.AlarmPriority,
	ae.ResponseRequired,
	n.NoteText as Instructions,
	ae.NoteUid as InstructionsNoteUid,
	ae.BinaryResourceUid as AudioBinaryResourceUid,
	null as RawData,
	et.ForeColor as Color,
	et.ForeColorHex as ColorHex,
	e.PersonUid, e.CredentialUid,
	p.ActivityEventText as PersonDescription, pc.CredentialDescription,
	p.Trace
	from GCS.GalaxyPanelActivityEvent e 
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = e.GalaxyPanelUid
	join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	join GCS.GalaxyActivityEventType et on et.GalaxyActivityEventTypeUid = e.GalaxyActivityEventTypeUid
	join GCS.GalaxyPanelActivityAlarmEvent ae on ae.GalaxyPanelActivityEventUid = e.GalaxyPanelActivityEventUid
	left outer join GCS.Person p on p.PersonUid = e.PersonUid
	left outer join GCS.PersonCredential pc on pc.CredentialUid = e.CredentialUid
	left outer join GCS.Note n on n.NoteUid = ae.NoteUid
	where e.GalaxyPanelActivityEventUid not in (select distinct(GalaxyPanelActivityEventUid) from GCS.GalaxyPanelAlarmEventAcknowledgment)
union
	select e.InputDeviceActivityEventUid as ActivityEventUid,
	cluster.ClusterGroupId, cluster.ClusterNumber,
	gp.PanelNumber, e.CpuNumber as CpuId,
	0 as BoardNumber, 0 as SectionNumber, 0 as ModuleNumber, 0 as NodeNumber, 0 as CpuModel,
	e.ActivityDateTime as 'DateTime', e.BufferIndex, et.EventType as PanelActivityType,
	0 as InputOutputGroupNumber, 0 as MultiFactorMode,
	id.InputName as 'DeviceDescription', et.Display as 'EventDescription', 
	id.EntityId as DeviceEntityId, e.InputDeviceUid as 'DeviceUid',  	
	e.CpuUid, cluster.ClusterName, 1 as IsAlarmEvent,
	ae.AlarmPriority,
	ae.ResponseRequired,
	n.NoteText as Instructions,
	ae.NoteUid as InstructionsNoteUid,
	ae.BinaryResourceUid as AudioBinaryResourceUid,
	null as RawData,
	et.ForeColor as Color,
	et.ForeColorHex as ColorHex,
	NULL AS PersonUid, NULL AS CredentialUid,
	NULL AS PersonDescription, NULL AS CredentialDescription,
	0 AS Trace
	from GCS.InputDeviceActivityEvent e 
	join GCS.InputDevice id on id.InputDeviceUid = e.InputDeviceUid
	join GCS.InputDeviceGalaxyHardwareAddress gha on gha.InputDeviceUid = e.InputDeviceUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode node on node.GalaxyInterfaceBoardSectionNodeUid = gha.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule module on module.GalaxyHardwareModuleUid = node.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = module.GalaxyInterfaceBoardSectionUid
	JOIN GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ib.GalaxyPanelUid
	join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	join GCS.GalaxyActivityEventType et on et.GalaxyActivityEventTypeUid = e.GalaxyActivityEventTypeUid
	join GCS.InputDeviceActivityAlarmEvent ae on ae.InputDeviceActivityEventUid = e.InputDeviceActivityEventUid
	left outer join GCS.Note n on n.NoteUid = ae.NoteUid
	where e.InputDeviceActivityEventUid not in (select distinct(InputDeviceActivityEventUid) from GCS.InputDeviceAlarmEventAcknowledgment)
GO
ALTER AUTHORIZATION ON [GCS].[UnacknowledgedAlarms] TO  SCHEMA OWNER 
GO

/****** Object:  View [GCS].[AcknowledgedAlarmsWithResponses]    Script Date: 8/31/2020 2:21:57 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

create or alter view [GCS].[AcknowledgedAlarmsWithResponses] as
	select e.AccessPortalActivityEventUid as ActivityEventUid,
	cluster.ClusterGroupId, cluster.ClusterNumber,
	gp.PanelNumber, e.CpuNumber as CpuId,
	0 as BoardNumber, 0 as SectionNumber, 0 as ModuleNumber, 0 as NodeNumber, 0 as CpuModel,
	e.ActivityDateTime as 'DateTime', e.BufferIndex, et.EventType as PanelActivityType,
	0 as InputOutputGroupNumber, 0 as MultiFactorMode,
	ap.PortalName as 'DeviceDescription', et.Display as 'EventDescription', 
	ap.EntityId as DeviceEntityId, e.AccessPortalUid as 'DeviceUid',  	
	e.CpuUid, cluster.ClusterName, 1 as IsAlarmEvent,
	ae.AlarmPriority,
	ae.ResponseRequired,
	n.NoteText as Instructions,
	ae.NoteUid as InstructionsNoteUid,
	ae.BinaryResourceUid as AudioBinaryResourceUid,
	null as RawData,
	et.ForeColor as Color,
	et.ForeColorHex as ColorHex,
	e.PersonUid, e.CredentialUid,
	p.ActivityEventText as PersonDescription, pc.CredentialDescription,
	p.Trace,
	aea.AccessPortalAlarmEventAcknowledgmentUid,
	aea.Response,
	aea.UserId as AckedByUserId,
	u.DisplayName as AckedByUserDisplayName,
	aea.InsertDate as AckedDateTime,
	aea.UpdateDate as AckedUpdatedDateTime
	from GCS.AccessPortalActivityEvent e 
	join GCS.AccessPortal ap on ap.AccessPortalUid = e.AccessPortalUid
	join GCS.AccessPortalGalaxyHardwareAddress gha on gha.AccessPortalUid = e.AccessPortalUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = gha.GalaxyPanelUid
	join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	join GCS.GalaxyActivityEventType et on et.GalaxyActivityEventTypeUid = e.GalaxyActivityEventTypeUid
	join GCS.AccessPortalActivityAlarmEvent ae on ae.AccessPortalActivityEventUid = e.AccessPortalActivityEventUid
	join GCS.AccessPortalAlarmEventAcknowledgment aea on aea.AccessPortalActivityEventUid = ae.AccessPortalActivityEventUid
	join GCS.gcsUser u on u.UserId = aea.UserId
	left outer join GCS.Person p on p.PersonUid = e.PersonUid
	left outer join GCS.PersonCredential pc on pc.CredentialUid = e.CredentialUid
	left outer join GCS.Note n on n.NoteUid = ae.NoteUid
	union
		select e.GalaxyPanelActivityEventUid as ActivityEventUid,
	cluster.ClusterGroupId, cluster.ClusterNumber,
	gp.PanelNumber, e.CpuNumber as CpuId,
	0 as BoardNumber, 0 as SectionNumber, 0 as ModuleNumber, 0 as NodeNumber, 0 as CpuModel,
	e.ActivityDateTime as 'DateTime', e.BufferIndex, et.EventType as PanelActivityType,
	0 as InputOutputGroupNumber, 0 as MultiFactorMode,
	gp.PanelName as 'DeviceDescription', et.Display as 'EventDescription', 
	cluster.EntityId as DeviceEntityId, e.GalaxyPanelUid as 'DeviceUid',  	
	e.CpuUid, cluster.ClusterName, 1 as IsAlarmEvent,
	ae.AlarmPriority,
	ae.ResponseRequired,
	n.NoteText as Instructions,
	ae.NoteUid as InstructionsNoteUid,
	ae.BinaryResourceUid as AudioBinaryResourceUid,
	null as RawData,
	et.ForeColor as Color,
	et.ForeColorHex as ColorHex,
	e.PersonUid, e.CredentialUid,
	p.ActivityEventText as PersonDescription, pc.CredentialDescription,
	p.Trace,
	aea.GalaxyPanelAlarmEventAcknowledgmentUid,
	aea.Response,
	aea.UserId as AckedByUserId,
	u.DisplayName as AckedByUserDisplayName,
	aea.InsertDate as AckedDateTime,
	aea.UpdateDate as AckedUpdatedDateTime
	from GCS.GalaxyPanelActivityEvent e 
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = e.GalaxyPanelUid
	join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	join GCS.GalaxyActivityEventType et on et.GalaxyActivityEventTypeUid = e.GalaxyActivityEventTypeUid
	join GCS.GalaxyPanelActivityAlarmEvent ae on ae.GalaxyPanelActivityEventUid = e.GalaxyPanelActivityEventUid
	join GCS.GalaxyPanelAlarmEventAcknowledgment aea on aea.GalaxyPanelActivityEventUid = ae.GalaxyPanelActivityEventUid
	join GCS.gcsUser u on u.UserId = aea.UserId
	left outer join GCS.Person p on p.PersonUid = e.PersonUid
	left outer join GCS.PersonCredential pc on pc.CredentialUid = e.CredentialUid
	left outer join GCS.Note n on n.NoteUid = ae.NoteUid
	union
		select e.InputDeviceActivityEventUid as ActivityEventUid,
	cluster.ClusterGroupId, cluster.ClusterNumber,
	gp.PanelNumber, e.CpuNumber as CpuId,
	0 as BoardNumber, 0 as SectionNumber, 0 as ModuleNumber, 0 as NodeNumber, 0 as CpuModel,
	e.ActivityDateTime as 'DateTime', e.BufferIndex, et.EventType as PanelActivityType,
	0 as InputOutputGroupNumber, 0 as MultiFactorMode,
	id.InputName as 'DeviceDescription', et.Display as 'EventDescription', 
	id.EntityId as DeviceEntityId, e.InputDeviceUid as 'DeviceUid',  	
	e.CpuUid, cluster.ClusterName, 1 as IsAlarmEvent,
	ae.AlarmPriority,
	ae.ResponseRequired,
	n.NoteText as Instructions,
	ae.NoteUid as InstructionsNoteUid,
	ae.BinaryResourceUid as AudioBinaryResourceUid,
	null as RawData,
	et.ForeColor as Color,
	et.ForeColorHex as ColorHex,
	NULL AS PersonUid, NULL AS CredentialUid,
	NULL AS PersonDescription, NULL AS CredentialDescription,
	0 AS Trace,
	aea.InputDeviceAlarmEventAcknowledgmentUid,
	aea.Response,
	aea.UserId as AckedByUserId,
	u.DisplayName as AckedByUserDisplayName,
	aea.InsertDate as AckedDateTime,
	aea.UpdateDate as AckedUpdatedDateTime
	from GCS.InputDeviceActivityEvent e 
	join GCS.InputDevice id on id.InputDeviceUid = e.InputDeviceUid
	join GCS.InputDeviceGalaxyHardwareAddress gha on gha.InputDeviceUid = e.InputDeviceUid
	JOIN GCS.GalaxyInterfaceBoardSectionNode node on node.GalaxyInterfaceBoardSectionNodeUid = gha.GalaxyInterfaceBoardSectionNodeUid
	JOIN GCS.GalaxyHardwareModule module on module.GalaxyHardwareModuleUid = node.GalaxyHardwareModuleUid
	JOIN GCS.GalaxyInterfaceBoardSection ibs on ibs.GalaxyInterfaceBoardSectionUid = module.GalaxyInterfaceBoardSectionUid
	JOIN GCS.GalaxyInterfaceBoard ib on ib.GalaxyInterfaceBoardUid = ibs.GalaxyInterfaceBoardUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = ib.GalaxyPanelUid
	join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
	join GCS.GalaxyActivityEventType et on et.GalaxyActivityEventTypeUid = e.GalaxyActivityEventTypeUid
	join GCS.InputDeviceActivityAlarmEvent ae on ae.InputDeviceActivityEventUid = e.InputDeviceActivityEventUid
	join GCS.InputDeviceAlarmEventAcknowledgment aea on aea.InputDeviceActivityEventUid = ae.InputDeviceActivityEventUid
	join GCS.gcsUser u on u.UserId = aea.UserId
	left outer join GCS.Note n on n.NoteUid = ae.NoteUid
GO
ALTER AUTHORIZATION ON [GCS].[AcknowledgedAlarmsWithResponses] TO  SCHEMA OWNER 
GO

CREATE OR ALTER PROCEDURE [GCS].[GetDeviceInformation]
	@Uid [uniqueidentifier],
	@DeviceType [nvarchar](65)
WITH EXECUTE AS CALLER
AS
	if @DeviceType = 'AccessPortal'
		select AccessPortalUid as Id, PortalName as 'Name', @DeviceType as 'DeviceType' from GCS.AccessPortal where AccessPortalUid = @Uid
	else if @DeviceType = 'InputDevice'
		select InputDeviceUid as Id, InputName as 'Name', @DeviceType as 'DeviceType' from GCS.InputDevice where InputDeviceUid = @Uid
	else if @DeviceType = 'OutputDevice'
		select OutputDeviceUid as Id, OutputName as 'Name', @DeviceType as 'DeviceType' from GCS.OutputDevice where OutputDeviceUid = @Uid
	else if @DeviceType = 'GalaxyPanel'
		select GalaxyPanelUid as Id, PanelName as 'Name', @DeviceType as 'DeviceType' from GCS.GalaxyPanel where GalaxyPanelUid = @Uid
	else
		select @Uid as Id, '' as 'Name', @DeviceType as 'DeviceType'
GO
ALTER AUTHORIZATION ON [GCS].[GetDeviceInformation] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GetDeviceInformation] TO [public] AS [dbo]
GO


CREATE OR ALTER FUNCTION [GCS].[CountAccessGroupAccessPortalPacketsForAccessPortalUid] (@AccessPortalUid uniqueidentifier) 
RETURNS int
as
BEGIN
DECLARE @count int
set @count = 0

		-- To accurately count the # of access portal access group packets that will be sent, we must count them up separately for each door
		-- Each packet can send up to 100 access groups/schedules for a door. Each packet represents a range from N to N+100
		declare @currentAgNumber int = 1
		declare @maxAgNumber int = 2000
		declare @tempCount int = 0

		select @maxAgNumber = max(AccessGroupNumber) from GCS.AccessGroupAccessPortal_PanelLoadData where AccessPortalUid = @AccessPortalUid and IsNodeActive = 1 and PanelScheduleNumber > 0
		if @maxAgNumber > 2000
			set @maxAgNumber = 2000
		while @currentAgNumber < @maxAgNumber 
		begin
			select @tempCount = count(*) from GCS.AccessGroupAccessPortal_PanelLoadData where AccessPortalUid = @AccessPortalUid and IsNodeActive = 1 and PanelScheduleNumber > 0 and 
			AccessGroupNumber >= @currentAgNumber and AccessGroupNumber < @currentAgNumber + 100
			set @currentAgNumber += 100

			if @tempCount > 0
				set @count += 1
		end

	return @count
END
GO

GRANT EXECUTE ON GCS.[CountAccessGroupAccessPortalPacketsForAccessPortalUid] TO public
GO




CREATE OR ALTER PROCEDURE [GCS].[GetLoadDataCountsForGalaxyPanelUid]
	@galaxyPanelUid [uniqueidentifier],
	@includeBoardSectionCount bit = 1,
	@includeAccessPortalCount bit = 1,
	@includeInputDeviceCount bit = 1,
	@includeOutputDeviceCount bit = 1,
	@includeIoGroupCount bit = 1,
	@includeCredentialCount bit = 1,
	@includePersonalAccessGroupCount bit = 1,
	@includeAccessRuleCount bit = 1,
	@includeTimeScheduleCount bit = 1
WITH EXECUTE AS CALLER
AS
declare @clusterUid uniqueidentifier
declare @entityId uniqueidentifier
select @clusterUid = ClusterUid from GCS.GalaxyPanel where GalaxyPanelUid = @galaxyPanelUid
select @entityId = EntityId from GCS.Cluster where ClusterUid = @clusterUid

declare @ioGroupCount int = 0
declare @boardSectionCount int = 0
declare @accessPortalCount int = 0
declare @accessPortalAccessGroupCount int = 0
declare @inputDeviceCount int = 0
declare @outputDeviceCount int = 0
declare @credentialCount int = 0
declare @personalAccessGroupCount int = 0
declare @accessGroupCount int = 0
declare @timePeriodCount int = 0
declare @dayTypeCount int = 0
declare @timeScheduleCount int = 0
declare @fifteenMinuteSchedulesCount int = 0
declare @totalTimeSchedulesPackets int = 0

declare @agCount int = 0
declare @apagCount int = 0
declare @apagMessageCount int = 0 -- represents the # of access portal access group packets that will be sent

	if ( @includeAccessPortalCount IS NOT NULL AND @includeAccessPortalCount = 1) OR (@includeAccessRuleCount is not null and @includeAccessRuleCount = 1) 
	begin
		select @agCount = count(*) from GCS.[AccessGroup] where ClusterUid = @clusterUid and AccessGroupNumber between 1 and 2000
		select @apagCount = count(*) from GCS.AccessGroupAccessPortal_PanelLoadData where GalaxyPanelUid = @galaxyPanelUid and IsNodeActive = 1 and PanelScheduleNumber > 0
		declare @apUid uniqueidentifier

		DECLARE apCur CURSOR LOCAL FAST_FORWARD FOR
			SELECT DISTINCT(AccessPortalUid) FROM GCS.AccessGroupAccessPortal_PanelLoadData where GalaxyPanelUid = @galaxyPanelUid and IsNodeActive = 1 and PanelScheduleNumber > 0
		OPEN apCur
		FETCH NEXT FROM apCur INTO @apUid
		WHILE @@FETCH_STATUS = 0
		BEGIN
			set @apagMessageCount += [GCS].[CountAccessGroupAccessPortalPacketsForAccessPortalUid] (@apUid)
			FETCH NEXT FROM apCur INTO @apUid
		END
		CLOSE apCur
		DEALLOCATE apCur
	end
	
	if @includeIoGroupCount is not null and @includeIoGroupCount = 1
		select @ioGroupCount = count(*) from GCS.InputOutputGroup_PanelLoadData where ClusterUid = @clusterUid and IOGroupNumber > 0

	if @includeBoardSectionCount is not null and @includeBoardSectionCount = 1
		select @boardSectionCount = count(*) from GCS.GalaxyInterfaceBoardSection_PanelLoadData where GalaxyPanelUid = @galaxyPanelUid 
		and (( BoardSectionMode > 0 and BoardTypeTypeCode NOT IN (16)) OR BoardTypeTypeCode IN (16))

	if @includeAccessPortalCount is not null and @includeAccessPortalCount = 1
	begin
		select @accessPortalCount = count(*) from GCS.AccessPortal_PanelLoadData where GalaxyPanelUid = @galaxyPanelUid
		-- The # of group records depends on how many doors exist * # of groups. 
		-- For each door, the servers sends a clear all access groups command, then loads groups, 100 groups per message,  
		set @accessPortalAccessGroupCount = @accessPortalCount + @apagMessageCount
	end

	if @includeInputDeviceCount is not null and @includeInputDeviceCount = 1
		select @inputDeviceCount = count(*) from GCS.InputDevice_PanelLoadData where GalaxyPanelUid = @galaxyPanelUid

	if @includeOutputDeviceCount is not null and @includeOutputDeviceCount = 1
		select @outputDeviceCount = count(*) from GCS.OutputDevice_PanelLoadData where GalaxyPanelUid = @galaxyPanelUid

	if @includeCredentialCount is not null and @includeCredentialCount = 1
		select @credentialCount = count(*) from GCS.PersonCredential pc join GCS.PersonClusterPermission pcp on pcp.PersonUid = pc.PersonUid 
		join GCS.Credential c on c.CredentialUid = pc.CredentialUid 
		where ClusterUid = @clusterUid and c.CardBinaryData <> 0x0000000000000000000000000000000000000000000000000000000000000000 

	-- This is accurate as long as no person has more than 100 doors via personal access group
	if @includePersonalAccessGroupCount is not null and @includePersonalAccessGroupCount = 1
		select @personalAccessGroupCount = count(distinct(PersonalAccessGroupNumber)) from GCS.PersonalAccessGroup_PanelLoadData where GalaxyPanelUid = @galaxyPanelUid

	-- Access Rules = 1 SetCrisisMode for each access group and at least 1 message with schedule data
	if @includeAccessRuleCount is not null and @includeAccessRuleCount = 1 and @apagCount > 0
	begin
	-- There is a set crisis mode command for each access group, then Unlimited Access
	-- May need to change in the future if server logic changes to load access group data to every door
		set @accessGroupCount = @agCount
		set @accessGroupCount += @agCount * @accessPortalCount
	end

	if @includeTimeScheduleCount is not null and @includeTimeScheduleCount = 1
	begin
		-- determine if the panel uses 15 minute or 1 minute schedules
		declare @uses1Minute bit = 1
		set @timePeriodCount = 1
		set @timeScheduleCount = 1
		set @dayTypeCount = 1		
		declare @schType uniqueidentifier
		select @schType = TimeScheduleTypeUid from GCS.Cluster where ClusterUid = @clusterUid
		if @schType is not null
		begin
			select @timeScheduleCount = count(*) from GCS.GalaxyClusterTimeScheduleMap where ClusterUid = @clusterUid and PanelScheduleNumber > 0 and PanelScheduleNumber < 255 and TimeScheduleUid not in ('00000000-0000-0000-0000-000000000001', 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF')
			-- 1 minute format
			if @schType = '00000000-0000-0000-0000-000000000001'
			begin
				set @uses1Minute = 1
				set @dayTypeCount = 1	-- always 1 year in a message
				--select @timePeriodCount = count(*) from GCS.GalaxyTimePeriod where EntityId = @entityId and PanelTimePeriodNumber > 0
				select @timePeriodCount = count(distinct(GalaxyTimePeriodUid)) from GCS.TimePeriod where EntityId = @entityId and GalaxyTimePeriodUid IS NOT NULL
				set @totalTimeSchedulesPackets = @dayTypeCount + @timePeriodCount + @timeScheduleCount
			end
			else if @schType = '00000000-0000-0000-0000-00000000000f'
			begin
				set @uses1Minute = 0
				set @dayTypeCount = 12	-- always 1 month in a message, loads 12 months / 1 year
				set @fifteenMinuteSchedulesCount = @timeScheduleCount * 2
				set @totalTimeSchedulesPackets = @dayTypeCount + @fifteenMinuteSchedulesCount
			end
		end
		

	end

	select 
	@boardSectionCount + @accessPortalCount + @inputDeviceCount + @outputDeviceCount as AccessPortalsInputsOutputsCount,
	@credentialCount + @personalAccessGroupCount as AllCardDataCount,
	@boardSectionCount as InterfaceBoardSectionCount, 
	@accessPortalCount as AccessPortalCount, 
	@inputDeviceCount as InputDeviceCount,
	@outputDeviceCount as OutputDeviceCount,
	@ioGroupCount as InputOutputGroupCount,
	@credentialCount as CredentialCount,
	@personalAccessGroupCount as PersonalAccessGroupCount,
	@accessGroupCount as AccessRulesCount,
	@accessPortalAccessGroupCount as AccessPortalAccessRulesCount,
--	@timeScheduleCount as TimeSchedulesCount,
	@dayTypeCount as DayTypeCount,
	@timePeriodCount as TimePeriodCount,
	@timeScheduleCount as TimePeriodDayTypeMapCount,
	@totalTimeSchedulesPackets as TimeSchedulesCount
GO
ALTER AUTHORIZATION ON [GCS].[GetLoadDataCountsForGalaxyPanelUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GetLoadDataCountsForGalaxyPanelUid] TO [public] AS [dbo]
GO


if dbo.[fn_GCSDoesIndexExist]('AccessPortalActivityEvent', 'idxAccessPortalActivityEventDateTime') = 0
BEGIN
	create nonclustered index idxAccessPortalActivityEventDateTime on GCS.AccessPortalActivityEvent (ActivityDateTime ASC)
END
GO

if dbo.[fn_GCSDoesIndexExist]('GalaxyPanelActivityEvent', 'idxGalaxyPanelActivityEventDateTime') = 0
BEGIN
	create nonclustered index idxGalaxyPanelActivityEventDateTime on GCS.GalaxyPanelActivityEvent (ActivityDateTime ASC)
END
GO

if dbo.[fn_GCSDoesIndexExist]('InputDeviceActivityEvent', 'idxInputDeviceActivityEventDateTime') = 0
BEGIN
	create nonclustered index idxInputDeviceActivityEventDateTime on GCS.InputDeviceActivityEvent (ActivityDateTime ASC)
END
GO

if dbo.[fn_GCSDoesIndexExist]('OutputDeviceActivityEvent', 'idxOutputDeviceActivityEventDateTime') = 0
BEGIN
	create nonclustered index idxOutputDeviceActivityEventDateTime on GCS.OutputDeviceActivityEvent (ActivityDateTime ASC)
END
GO

exec dbo.gcs_DeleteDefaultConstraint 'GCS','GalaxyRawActivityEvent', 'InsertDate'
go


if dbo.gcs_GetColumnDataType( 'GCS', 'GalaxyRawActivityEvent', 'InsertDate') <> 'datetimeoffset'
begin
	alter table GCS.GalaxyRawActivityEvent 
	alter column InsertDate datetimeoffset(7) not null
end
go

alter table GCS.GalaxyRawActivityEvent 
ADD CONSTRAINT DF_GalaxyRawActivityEvent_InsertDate DEFAULT SYSDATETIMEOFFSET() FOR InsertDate
go

if dbo.fn_GCSDoesColumnExist('GalaxyRawActivityEvent', 'UniqueEventId') = 1
BEGIN
	ALTER TABLE GCS.GalaxyRawActivityEvent
	DROP COLUMN UniqueEventId
END
GO


if dbo.gcs_GetColumnDataType( 'GCS', 'GalaxyRawActivityEvent', 'EventDateTime') <> 'datetimeoffset'
begin
	alter table GCS.GalaxyRawActivityEvent 
	alter column EventDateTime datetimeoffset(7) not null
end
go

if dbo.fn_GCSDoesColumnExist('GalaxyRawActivityEvent', 'UniqueEventId') = 0
BEGIN
	ALTER TABLE GCS.GalaxyRawActivityEvent
	ADD [UniqueEventId]  AS ((((((((((((((((((((CONVERT([varchar](5),[ClusterGroupId])+':')+CONVERT([varchar](5),[ClusterNumber]))+':')+CONVERT([varchar](5),[PanelNumber]))+':')+CONVERT([char](1),[CpuNumber]))+':')+CONVERT([varchar](10),[BufferIndex]))+':')+CONVERT([varchar](4),datepart(year,[EventDateTime])))+'-')+CONVERT([varchar](2),datepart(month,[EventDateTime])))+'-')+CONVERT([varchar](2),datepart(day,[EventDateTime])))+'T')+CONVERT([varchar](2),datepart(hour,[EventDateTime])))+':')+CONVERT([varchar](2),datepart(minute,[EventDateTime])))+':')+CONVERT([varchar](2),datepart(second,[EventDateTime]))) PERSISTED NOT NULL
END
GO

	
if dbo.gcs_GetColumnDataType( 'GCS', 'GalaxyRawActivityEvent', 'WhenProcessed') <> 'datetimeoffset'
begin
	alter table GCS.GalaxyRawActivityEvent 
	alter column WhenProcessed datetimeoffset(7) null
end
go




CREATE OR ALTER PROCEDURE [GCS].[insert_GalaxyRawActivityEvent]
	@GalaxyRawActivityEventUid [uniqueidentifier],
	@CpuUid [uniqueidentifier],
	@InsertDate [datetimeoffset],
	@ClusterGroupId [int],
	@ClusterNumber [int],
	@PanelNumber [int],
	@CpuNumber [smallint],
	@EventDateTime [datetimeoffset],
	@EventType [varchar](50),
	@BufferIndex [int],
	@CredentialBytes [varbinary](32),
	@Pin [int],
	@BitCount [smallint],
	@InputOutputGroupNumber [smallint],
	@BoardNumber [smallint],
	@SectionNumber [smallint],
	@ModuleNumber [smallint],
	@NodeNumber [smallint],
	@RawData [varbinary](1024)
WITH EXECUTE AS CALLER
AS
begin

   if @GalaxyRawActivityEventUid is null or @GalaxyRawActivityEventUid = '00000000-0000-0000-0000-000000000000' 
        set @GalaxyRawActivityEventUid = NEWID()

    insert into GCS.GalaxyRawActivityEvent (GalaxyRawActivityEventUid,CpuUid,InsertDate,ClusterGroupId,ClusterNumber,PanelNumber,CpuNumber,EventDateTime,EventType,BufferIndex,CredentialBytes,Pin,BitCount,InputOutputGroupNumber,BoardNumber,SectionNumber,ModuleNumber,NodeNumber,RawData)
    values(@GalaxyRawActivityEventUid,@CpuUid,@InsertDate,@ClusterGroupId,@ClusterNumber,@PanelNumber,@CpuNumber,@EventDateTime,@EventType,@BufferIndex,@CredentialBytes,@Pin,@BitCount,@InputOutputGroupNumber,@BoardNumber,@SectionNumber,@ModuleNumber,@NodeNumber,@RawData)

	exec GCS.[GalaxyCpuLoggingControl_Save] @CpuUid, @BufferIndex, @InsertDate
end
GO
ALTER AUTHORIZATION ON [GCS].[insert_GalaxyRawActivityEvent] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[insert_GalaxyRawActivityEvent] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[update_GalaxyRawActivityEventWhenProcessed]
	@GalaxyRawActivityEventUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
begin

   if @GalaxyRawActivityEventUid is null or @GalaxyRawActivityEventUid = '00000000-0000-0000-0000-000000000000' 
        return;

    update GCS.GalaxyRawActivityEvent set WhenProcessed = SYSDATETIMEOFFSET() where GalaxyRawActivityEventUid = GalaxyRawActivityEventUid
end

GRANT EXECUTE ON GCS.update_GalaxyRawActivityEventWhenProcessed TO public
GO
ALTER AUTHORIZATION ON [GCS].[update_GalaxyRawActivityEventWhenProcessed] TO  SCHEMA OWNER 
GO


exec dbo.gcs_DeleteDefaultConstraint 'GCS','AccessPortalActivityEvent', 'InsertDate'
go

if dbo.gcs_GetColumnDataType( 'GCS', 'AccessPortalActivityEvent', 'InsertDate') <> 'datetimeoffset'
begin
	alter table GCS.AccessPortalActivityEvent 
	alter column InsertDate datetimeoffset(7) not null
end
go

alter table GCS.AccessPortalActivityEvent 
ADD CONSTRAINT DF_AccessPortalActivityEvent_InsertDate DEFAULT SYSDATETIMEOFFSET() FOR InsertDate
go


exec dbo.gcs_DeleteDefaultConstraint 'GCS','GalaxyPanelActivityEvent', 'InsertDate'
go

if dbo.gcs_GetColumnDataType( 'GCS', 'GalaxyPanelActivityEvent', 'InsertDate') <> 'datetimeoffset'
begin
	alter table GCS.GalaxyPanelActivityEvent 
	alter column InsertDate datetimeoffset(7) not null
end
go

alter table GCS.GalaxyPanelActivityEvent 
ADD CONSTRAINT DF_GalaxyPanelActivityEvent_InsertDate DEFAULT SYSDATETIMEOFFSET() FOR InsertDate
go


exec dbo.gcs_DeleteDefaultConstraint 'GCS','InputDeviceActivityEvent', 'InsertDate'
go

if dbo.gcs_GetColumnDataType( 'GCS', 'InputDeviceActivityEvent', 'InsertDate') <> 'datetimeoffset'
begin
	alter table GCS.InputDeviceActivityEvent 
	alter column InsertDate datetimeoffset(7) not null
end
go

alter table GCS.InputDeviceActivityEvent 
ADD CONSTRAINT DF_InputDeviceActivityEvent_InsertDate DEFAULT SYSDATETIMEOFFSET() FOR InsertDate
go


exec dbo.gcs_DeleteDefaultConstraint 'GCS','OutputDeviceActivityEvent', 'InsertDate'
go

if dbo.gcs_GetColumnDataType( 'GCS', 'OutputDeviceActivityEvent', 'InsertDate') <> 'datetimeoffset'
begin
	alter table GCS.OutputDeviceActivityEvent 
	alter column InsertDate datetimeoffset(7) not null
end
go

alter table GCS.OutputDeviceActivityEvent 
ADD CONSTRAINT DF_OutputDeviceActivityEvent_InsertDate DEFAULT SYSDATETIMEOFFSET() FOR InsertDate
go

CREATE OR ALTER PROCEDURE [GCS].[AccessPortalActivityEventPDSA_Insert]
	@AccessPortalActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@AccessPortalUid [uniqueidentifier],
	@CredentialUid [uniqueidentifier] = null,
	@PersonUid [uniqueidentifier] = null,
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int],
	@CredentialBytes [varbinary](32),
	@InsertDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @AccessPortalActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalActivityEventUid = NULL
if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL
if @PersonUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonUid = NULL

if @AccessPortalActivityEventUid = '00000000-0000-0000-0000-000000000000' OR @AccessPortalActivityEventUid IS NULL
	SET @AccessPortalActivityEventUid = NewID()

INSERT INTO GCS.AccessPortalActivityEvent
(
AccessPortalActivityEventUid
,GalaxyActivityEventTypeUid
,AccessPortalUid
,CredentialUid
,PersonUid
,CpuUid
,CpuNumber
,ActivityDateTime
,BufferIndex
,CredentialBytes
,InsertDate
) 
VALUES 
(
@AccessPortalActivityEventUid
,@GalaxyActivityEventTypeUid
,@AccessPortalUid
,@CredentialUid
,@PersonUid
,@CpuUid
,@CpuNumber
,@ActivityDateTime
,@BufferIndex
,@CredentialBytes
,@InsertDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalActivityEventPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalActivityEventPDSA_Insert] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[AccessPortalActivityEventPDSA_Update]
	@AccessPortalActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@AccessPortalUid [uniqueidentifier],
	@CredentialUid [uniqueidentifier],
	@PersonUid [uniqueidentifier],
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@CredentialBytes [varbinary](32),
	@BufferIndex [int]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL
if @PersonUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonUid = NULL

UPDATE GCS.AccessPortalActivityEvent
SET 
AccessPortalActivityEventUid = @AccessPortalActivityEventUid
,GalaxyActivityEventTypeUid = @GalaxyActivityEventTypeUid
,AccessPortalUid = @AccessPortalUid
,CredentialUid = @CredentialUid
,PersonUid = @PersonUid
,CpuUid = @CpuUid
,CpuNumber = @CpuNumber
,ActivityDateTime = @ActivityDateTime
,CredentialBytes = @CredentialBytes
,BufferIndex = @BufferIndex
WHERE
AccessPortalActivityEventUid = @AccessPortalActivityEventUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalActivityEventPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalActivityEventPDSA_Update] TO [public] AS [dbo]
GO



CREATE OR ALTER PROCEDURE [GCS].[insert_AccessPortalActivityEvent]
	@AccessPortalActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@AccessPortalUid [uniqueidentifier],
	@CredentialUid [uniqueidentifier] = null,
	@PersonUid [uniqueidentifier] = null,
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int],
	@InsertDate [datetimeoffset],
	@eventType [varchar](50),
	@CredentialBytes [varbinary](32),
	@IsAlarmEvent [bit],
	@AlarmPriority [int],
	@ResponseRequired bit,
	@NoteUid [uniqueidentifier],
	@BinaryResourceUid [uniqueidentifier],
	@IsAccessGrantedEvent [bit]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @AccessPortalActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalActivityEventUid = NULL
if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL
if @PersonUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonUid = NULL

if @AccessPortalActivityEventUid = '00000000-0000-0000-0000-000000000000' OR @AccessPortalActivityEventUid IS NULL
	SET @AccessPortalActivityEventUid = NewID()

if @eventType IS NOT NULL AND ( @GalaxyActivityEventTypeUid IS NULL OR @GalaxyActivityEventTypeUid = '00000000-0000-0000-0000-000000000000')
	SELECT @GalaxyActivityEventTypeUid = GalaxyActivityEventTypeUid FROM [GCS].[GalaxyActivityEventType] WHERE EventType = @eventType

INSERT INTO GCS.AccessPortalActivityEvent
(
AccessPortalActivityEventUid
,GalaxyActivityEventTypeUid
,AccessPortalUid
,CredentialUid
,PersonUid
,CpuUid
,CpuNumber
,ActivityDateTime
,BufferIndex
,CredentialBytes
,InsertDate
) 
VALUES 
(
@AccessPortalActivityEventUid
,@GalaxyActivityEventTypeUid
,@AccessPortalUid
,@CredentialUid
,@PersonUid
,@CpuUid
,@CpuNumber
,@ActivityDateTime
,@BufferIndex
,@CredentialBytes
,@InsertDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

if @IsAlarmEvent is not null AND @IsAlarmEvent <> 0 AND @ret = 0
BEGIN
	if @NoteUid = '00000000-0000-0000-0000-000000000000'
		SET @NoteUid = NULL

	if @BinaryResourceUid = '00000000-0000-0000-0000-000000000000'
		SET @BinaryResourceUid = NULL

	INSERT INTO GCS.AccessPortalActivityAlarmEvent (AccessPortalActivityEventUid, NoteUid, BinaryResourceUid, AlarmPriority,ResponseRequired)
	VALUES (@AccessPortalActivityEventUid, @NoteUid, @BinaryResourceUid, @AlarmPriority,@ResponseRequired)
END
--ELSE
--BEGIN
	if @PersonUid is not null
	begin
		exec GCS.[PersonLastUsagePDSA_Update] @PersonUid, @AccessPortalActivityEventUid, @IsAccessGrantedEvent
	end
--END

exec GCS.[AccessPortalLastUsagePDSA_Update] @AccessPortalUid, @AccessPortalActivityEventUid, @IsAccessGrantedEvent

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[insert_AccessPortalActivityEvent] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[insert_AccessPortalActivityEvent] TO [public] AS [dbo]
GO



CREATE OR ALTER PROCEDURE [GCS].[insert_OutputDeviceActivityEvent]
	@OutputDeviceActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@OutputDeviceUid [uniqueidentifier],
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int],
	@InsertDate [datetimeoffset],
	@eventType [varchar](50)
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @OutputDeviceActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @OutputDeviceActivityEventUid = NULL

if @OutputDeviceActivityEventUid = '00000000-0000-0000-0000-000000000000' OR @OutputDeviceActivityEventUid IS NULL
	SET @OutputDeviceActivityEventUid = NewID()

if @eventType IS NOT NULL AND ( @GalaxyActivityEventTypeUid IS NULL OR @GalaxyActivityEventTypeUid = '00000000-0000-0000-0000-000000000000')
	SELECT @GalaxyActivityEventTypeUid = GalaxyActivityEventTypeUid FROM [GCS].[GalaxyActivityEventType] WHERE EventType = @eventType

INSERT INTO GCS.OutputDeviceActivityEvent
(
OutputDeviceActivityEventUid
,GalaxyActivityEventTypeUid
,OutputDeviceUid
,CpuUid
,CpuNumber
,ActivityDateTime
,BufferIndex
,InsertDate
) 
VALUES 
(
@OutputDeviceActivityEventUid
,@GalaxyActivityEventTypeUid
,@OutputDeviceUid
,@CpuUid
,@CpuNumber
,@ActivityDateTime
,@BufferIndex
,@InsertDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[insert_OutputDeviceActivityEvent] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[insert_OutputDeviceActivityEvent] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[IsAccessPortalActivityEventUnique]
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
IF EXISTS( SELECT AccessPortalActivityEventUid from GCS.AccessPortalActivityEvent where CpuNumber <> @CpuNumber AND ActivityDateTime = @ActivityDateTime AND BufferIndex = @BufferIndex)
		SELECT @Result = 1
	ELSE
		SELECT @Result = 1
	select @Result as Result

GO
ALTER AUTHORIZATION ON [GCS].[IsAccessPortalActivityEventUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsAccessPortalActivityEventUnique] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[IsGalaxyPanelActivityEventUnique]
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
IF EXISTS( SELECT GalaxyPanelActivityEventUid from GCS.GalaxyPanelActivityEvent where CpuNumber <> @CpuNumber AND ActivityDateTime = @ActivityDateTime AND BufferIndex = @BufferIndex)
		SELECT @Result = 1
	ELSE
		SELECT @Result = 1
	select @Result as Result

GO
ALTER AUTHORIZATION ON [GCS].[IsGalaxyPanelActivityEventUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsGalaxyPanelActivityEventUnique] TO [public] AS [dbo]
GO



CREATE OR ALTER PROCEDURE [GCS].[IsInputDeviceActivityEventUnique]
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
IF EXISTS( SELECT InputDeviceActivityEventUid from GCS.InputDeviceActivityEvent where CpuNumber <> @CpuNumber AND ActivityDateTime = @ActivityDateTime AND BufferIndex = @BufferIndex)
		SELECT @Result = 1
	ELSE
		SELECT @Result = 1
	select @Result as Result

GO
ALTER AUTHORIZATION ON [GCS].[IsInputDeviceActivityEventUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsInputDeviceActivityEventUnique] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[IsOutputDeviceActivityEventUnique]
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int],
	@Result [int] OUTPUT
WITH EXECUTE AS CALLER
AS
IF EXISTS( SELECT OutputDeviceActivityEventUid from GCS.OutputDeviceActivityEvent where CpuNumber <> @CpuNumber AND ActivityDateTime = @ActivityDateTime AND BufferIndex = @BufferIndex)
		SELECT @Result = 1
	ELSE
		SELECT @Result = 1
	select @Result as Result

GO
ALTER AUTHORIZATION ON [GCS].[IsOutputDeviceActivityEventUnique] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[IsOutputDeviceActivityEventUnique] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[OutputDeviceActivityEventPDSA_Insert]
	@OutputDeviceActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@OutputDeviceUid [uniqueidentifier],
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int],
	@InsertDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @OutputDeviceActivityEventUid = '00000000-0000-0000-0000-000000000000'
	SET @OutputDeviceActivityEventUid = NULL

if @OutputDeviceActivityEventUid = '00000000-0000-0000-0000-000000000000' OR @OutputDeviceActivityEventUid IS NULL
	SET @OutputDeviceActivityEventUid = NewID()

INSERT INTO GCS.OutputDeviceActivityEvent
(
OutputDeviceActivityEventUid
,GalaxyActivityEventTypeUid
,OutputDeviceUid
,CpuUid
,CpuNumber
,ActivityDateTime
,BufferIndex
,InsertDate
) 
VALUES 
(
@OutputDeviceActivityEventUid
,@GalaxyActivityEventTypeUid
,@OutputDeviceUid
,@CpuUid
,@CpuNumber
,@ActivityDateTime
,@BufferIndex
,@InsertDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[OutputDeviceActivityEventPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[OutputDeviceActivityEventPDSA_Insert] TO [public] AS [dbo]
GO





CREATE OR ALTER PROCEDURE [GCS].[OutputDeviceActivityEventPDSA_Update]
	@OutputDeviceActivityEventUid [uniqueidentifier],
	@GalaxyActivityEventTypeUid [uniqueidentifier],
	@OutputDeviceUid [uniqueidentifier],
	@CpuUid [uniqueidentifier],
	@CpuNumber [smallint],
	@ActivityDateTime [datetimeoffset],
	@BufferIndex [int]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

UPDATE GCS.OutputDeviceActivityEvent
SET 
OutputDeviceActivityEventUid = @OutputDeviceActivityEventUid
,GalaxyActivityEventTypeUid = @GalaxyActivityEventTypeUid
,OutputDeviceUid = @OutputDeviceUid
,CpuUid = @CpuUid
,CpuNumber = @CpuNumber
,ActivityDateTime = @ActivityDateTime
,BufferIndex = @BufferIndex
WHERE
OutputDeviceActivityEventUid = @OutputDeviceActivityEventUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[OutputDeviceActivityEventPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[OutputDeviceActivityEventPDSA_Update] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[TimeSchedule_IsScheduleActive]
	@TimeScheduleUid [uniqueidentifier],
	@ScheduleTypeCode [smallint],
	@ClusterUid [uniqueidentifier],
	@dt [datetimeoffset],
	@result [bit] OUTPUT
WITH EXECUTE AS CALLER
AS
DECLARE @date nvarchar(10)
DECLARE @day_of_week int
DECLARE @dayTypeCode smallint
DECLARE @tod time
DECLARE @entityId uniqueidentifier
DECLARE @usesHolidays bit

SELECT @result = 0
SET NOCOUNT ON

	IF @TimeScheduleUid = '00000000-0000-0000-0000-000000000001'
		goto myRet

	IF @TimeScheduleUid = 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF'
	BEGIN
		SELECT @result = 1
		goto myRet
	END
	
	IF NOT EXISTS(SELECT TimeScheduleUid from GCS.TimeSchedule WHERE TimeScheduleUid = @TimeScheduleUid)
		goto myRet

	IF @dt IS NULL
		SELECT @dt = sysdatetimeoffset()

	SET @date = CONVERT(varchar(10),@dt, 101)
	SET @day_of_week = DATEPART(weekday, @dt)		

	SET @tod = CONVERT(TIME, @dt)

	PRINT 'Day of week: ' + CAST(@day_of_week as nvarchar)
	PRINT 'Hour: ' + cast(@tod as nvarchar)
	
	SELECT @entityId = EntityId, @usesHolidays = gctsm.FifteenMinuteFormatUsesHolidays from GCS.Cluster c join GCS.GalaxyClusterTimeScheduleMap gctsm on gctsm.ClusterUid = c.ClusterUid where c.ClusterUid = @ClusterUid

	SELECT @dayTypeCode = DayTypeCode from GCS.DateType dateType join GCS.DayType dayType ON dayType.DayTypeUid = dateType.DayTypeUid WHERE Date = @date AND dateType.EntityId = @entityId
	IF @ScheduleTypeCode = 0	-- 15 Minute Schedules
	BEGIN
		PRINT 'Uses 15 minute based schedules'
		IF @usesHolidays <> 0 
		BEGIN	-- HOLDAYS ARE USED
			PRINT 'Holidays are used'
			if @dayTypeCode IS NULL
			BEGIN
				SET @dayTypeCode = @day_of_week + 90
			END
		END
		ELSE	-- HOLIDAYS ARE NOT USED WITH THIS SCHEDULE, force the day type to be based on the day of week
		BEGIN
			PRINT 'Holidays are not used'
			SET @dayTypeCode = @day_of_week + 90
		END

		IF EXISTS (select ts.Display, dt.Name, dt.DayTypeCode, tp.StartTime, tp.EndTime from GCS.TimeSchedule ts
			join GCS.TimeScheduleDayTypeTimePeriod tsdttp on tsdttp.TimeScheduleUid = ts.TimeScheduleUid
			join GCS.DayType dt on dt.DayTypeUid = tsdttp.DayTypeUid
			join GCS.TimePeriod tp on tp.TimePeriodUid = tsdttp.TimePeriodUid
			where ts.TimeScheduleUid = @timeScheduleUid AND dt.DayTypeCode = @dayTypeCode
			and tp.StartTime <= @tod AND tp.EndTime > @tod)
			set @result = 1

	END	-- END OF MINUTE BASED SCHEDULES
	ELSE	-- Uses 1 minute based schedules
	BEGIN
		PRINT 'Uses 1 minute based schedules'
		-- @dayTypeCode will be NULL if the date is not assigned to a specific day type. In this case, the default for the day of the week must be used
		if @dayTypeCode IS NULL
		BEGIN
			IF @day_of_week = 1 -- Sunday
				SELECT @dayTypeCode = SundayDayCode FROM GCS.DateTypeDefaultBehavior_PanelLoadData where EntityId = @EntityId
			ELSE IF @day_of_week = 2 -- Monday
				SELECT @dayTypeCode = MondayDayCode FROM GCS.DateTypeDefaultBehavior_PanelLoadData where EntityId = @EntityId
			ELSE IF @day_of_week = 3 -- Tuesday
				SELECT @dayTypeCode = TuesdayDayCode FROM GCS.DateTypeDefaultBehavior_PanelLoadData where EntityId = @EntityId
			ELSE IF @day_of_week = 4 -- Wednesday
				SELECT @dayTypeCode = WednesdayDayCode FROM GCS.DateTypeDefaultBehavior_PanelLoadData where EntityId = @EntityId
			ELSE IF @day_of_week = 5 -- Thursday
				SELECT @dayTypeCode = ThursdayDayCode FROM GCS.DateTypeDefaultBehavior_PanelLoadData where EntityId = @EntityId
			ELSE IF @day_of_week = 6 -- Friday
				SELECT @dayTypeCode = FridayDayCode FROM GCS.DateTypeDefaultBehavior_PanelLoadData where EntityId = @EntityId
			ELSE IF @day_of_week = 7 -- Saturday
				SELECT @dayTypeCode = SaturdayDayCode FROM GCS.DateTypeDefaultBehavior_PanelLoadData where EntityId = @EntityId
		END
		
		IF EXISTS(select ts.Display, dt.Name, dt.DayTypeCode, tp.StartTime, tp.EndTime from GCS.TimeSchedule ts 
				join GCS.TimeScheduleDayTypeGalaxyTimePeriod tsdtgtp on tsdtgtp.TimeScheduleUid = ts.TimeScheduleUid
				join GCS.DayType dt on dt.DayTypeUid = tsdtgtp.DayTypeUid
				join GCS.TimePeriod tp on tp.GalaxyTimePeriodUid = tsdtgtp.GalaxyTimePeriodUid
				where ts.TimeScheduleUid = @timeScheduleUid AND dt.DayTypeCode = @dayTypeCode 
				and tp.StartTime <= @tod AND tp.EndTime > @tod)
			set @result = 1

	END

myRet:
	select @result as IsActive
GO
ALTER AUTHORIZATION ON [GCS].[TimeSchedule_IsScheduleActive] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[TimeSchedule_IsScheduleActive] TO [public] AS [dbo]
GO

update gcs.gcsEntity set entityType = 'dealer' where EntityType = 'partner'
go

alter table GCS.Department
alter column Description nvarchar(1000) null
go

CREATE OR ALTER PROCEDURE [GCS].[AccessPortalLoadToCpu_SaveLastLoadedDate]
	@CpuUid [uniqueidentifier],
	@AccessPortalUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

DECLARE @AccessPortalLoadToCpuUid uniqueidentifier 
DECLARE @AccessPortalGalaxyHardwareAddressUid uniqueidentifier
DECLARE @CurrentTimeForCluster datetimeoffset
DECLARE @ClusterUid uniqueidentifier
DECLARE @GalaxyPanelUid uniqueidentifier

SELECT @AccessPortalGalaxyHardwareAddressUid = AccessPortalGalaxyHardwareAddressUid, @CurrentTimeForCluster = c.CurrentTimeForCluster, @ClusterUid = c.ClusterUid
FROM GCS.AccessPortalGalaxyHardwareAddress apghwa
JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = apghwa.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
where apghwa.AccessPortalUid = @AccessPortalUid 

IF @AccessPortalGalaxyHardwareAddressUid IS NOT NULL
BEGIN
	SELECT @AccessPortalLoadToCpuUid = AccessPortalLoadToCpuUid FROM GCS.AccessPortalLoadToCpu WHERE AccessPortalGalaxyHardwareAddressUid = @AccessPortalGalaxyHardwareAddressUid AND CpuUid = @CpuUid
	IF @AccessPortalLoadToCpuUid IS NULL
	BEGIN
		SET @AccessPortalLoadToCpuUid = newid()
		INSERT INTO GCS.AccessPortalLoadToCpu (AccessPortalLoadToCpuUid, AccessPortalGalaxyHardwareAddressUid, CpuUid, LastLoadedDate)
		VALUES(@AccessPortalLoadToCpuUid, @AccessPortalGalaxyHardwareAddressUid, @CpuUid, @CurrentTimeForCluster)
	END
	ELSE
	BEGIN
		UPDATE GCS.AccessPortalLoadToCpu SET LastLoadedDate = @CurrentTimeForCluster
		WHERE AccessPortalLoadToCpuUid = @AccessPortalLoadToCpuUid
	END

	-- Mark the reader as Enabled=1. This is default behavior when a galaxy port is loaded
	UPDATE GCS.AccessPortal SET IsEnabled = 1, IsEnabledLastUpdated = SYSDATETIMEOFFSET() where AccessPortalUid = @AccessPortalUid and IsEnabled <> 1
END

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalLoadToCpu_SaveLastLoadedDate] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalLoadToCpu_SaveLastLoadedDate] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[AccessPortal_SetIsEnabled]
	@AccessPortalUid [uniqueidentifier],
	@IsEnabled bit
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

IF @AccessPortalUid IS NOT NULL and @AccessPortalUid <> '00000000-0000-0000-0000-000000000000'
BEGIN
	-- Mark the reader as Enabled=@IsEnabled.
	UPDATE GCS.AccessPortal SET IsEnabled = @IsEnabled, IsEnabledLastUpdated = SYSDATETIMEOFFSET() where AccessPortalUid = @AccessPortalUid and IsEnabled <> @IsEnabled
END

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortal_SetIsEnabled] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortal_SetIsEnabled] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[PersonInputOutputGroupPDSA_ByPersonUidAndClusterUid]
	@PersonUid [uniqueidentifier],
	@ClusterUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;
SELECT 
PersonInputOutputGroupUid
,PersonClusterPermissionUid
,t.InputOutputGroupUid
,OrderNumber
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,IOGroupNumber as InputOutputGroupNumber
,Display as InputOutputGroupName
FROM GCS.PersonInputOutputGroup t join GCS.InputOutputGroup iog on iog.InputOutputGroupUid = t.InputOutputGroupUid
WHERE 
PersonClusterPermissionUid IN (SELECT PersonClusterPermissionUid FROM PersonClusterPermission WHERE PersonUid = @PersonUid AND ClusterUid = @ClusterUid)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[PersonInputOutputGroupPDSA_ByPersonUidAndClusterUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonInputOutputGroupPDSA_ByPersonUidAndClusterUid] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[gcsEntity_GetEntityWithChildren]
	@EntityId [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
WITH EntityHierarchy(ParentEntityId, EntityId, EntityName, EntityDescription, EntityKey, IsDefault, IsActive, InsertName, InsertDate, UpdateName, UpdateDate, ConcurrencyValue, BinaryResourceUid, License, PublicKey, EntityType, AutoMapTimeSchedules ) AS
(
    SELECT ParentEntityId, EntityId, EntityName, EntityDescription, EntityKey, IsDefault, IsActive, InsertName, InsertDate, UpdateName, UpdateDate, ConcurrencyValue, BinaryResourceUid, License, PublicKey, EntityType, AutoMapTimeSchedules
    FROM GCS.gcsEntity
    WHERE EntityId = @EntityId
    UNION ALL
    SELECT e.ParentEntityId, e.EntityId, e.EntityName, e.EntityDescription, e.EntityKey, e.IsDefault, e.IsActive, e.InsertName, e.InsertDate, e.UpdateName, e.UpdateDate, e.ConcurrencyValue, e.BinaryResourceUid, e.License, e.PublicKey, e.EntityType, e.AutoMapTimeSchedules
    FROM GCS.gcsEntity AS e
        INNER JOIN EntityHierarchy AS d
        ON e.ParentEntityId = d.EntityId
)
SELECT ParentEntityId, EntityId, EntityName, EntityDescription, EntityKey, IsDefault, IsActive, InsertName, InsertDate, UpdateName, UpdateDate, ConcurrencyValue, BinaryResourceUid, License, PublicKey, EntityType, AutoMapTimeSchedules
FROM EntityHierarchy
ORDER BY ParentEntityId;
GO
ALTER AUTHORIZATION ON [GCS].[gcsEntity_GetEntityWithChildren] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsEntity_GetEntityWithChildren] TO [public] AS [dbo]
GO

-- Clean up previous schedule bug
BEGIN
set nocount on
DECLARE @TimeScheduleDayTypeGalaxyTimePeriodUid uniqueidentifier
DECLARE @DayTypeUid uniqueidentifier
DECLARE @DayTypeCode smallint
DECLARE @GalaxyTimePeriodUid uniqueidentifier
DECLARE @TimeScheduleUid uniqueidentifier
DECLARE @Count int
DECLARE @DeletedCount int = 0

	DECLARE timeSchDayTypeTimePeriodCursor CURSOR LOCAL FOR 
	select t.TimeScheduleDayTypeGalaxyTimePeriodUid, t.DayTypeUid, dt.DayTypeCode, t.GalaxyTimePeriodUid, t.TimeScheduleUid from GCS.TimeScheduleDayTypeGalaxyTimePeriod t 
	join GCS.DayType dt on dt.DayTypeUid = t.DayTypeUid
	order by t.TimeScheduleUid, dt.DayTypeCode, t.GalaxyTimePeriodUid

	OPEN timeSchDayTypeTimePeriodCursor
	FETCH NEXT FROM timeSchDayTypeTimePeriodCursor INTO @TimeScheduleDayTypeGalaxyTimePeriodUid, @DayTypeUid, @DayTypeCode, @GalaxyTimePeriodUid, @TimeScheduleUid
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SELECT @Count = count(*) from GCS.TimeScheduleDayTypeGalaxyTimePeriod WHERE TimeScheduleUid = @TimeScheduleUid AND DayTypeUid = @DayTypeUid
		if @Count > 1
		BEGIN 
			PRINT 'Deleting duplicate TimeScheduleDayTypeGalaxyTimePeriod TimeScheduleUid:'  + cast( @TimeScheduleUid as nvarchar(50)) + ', DayTypeCode: ' + cast(@DayTypeCode as nvarchar)
			set @DeletedCount = @DeletedCount + 1
			DELETE FROM GCS.TimeScheduleDayTypeGalaxyTimePeriod where CURRENT OF timeSchDayTypeTimePeriodCursor
		END

		FETCH NEXT FROM timeSchDayTypeTimePeriodCursor INTO @TimeScheduleDayTypeGalaxyTimePeriodUid, @DayTypeUid, @DayTypeCode, @GalaxyTimePeriodUid, @TimeScheduleUid
	END
	CLOSE timeSchDayTypeTimePeriodCursor;
	DEALLOCATE timeSchDayTypeTimePeriodCursor;
	print cast(@DeletedCount as nvarchar) + 'Duplicate TimeScheduleDayTypeGalaxyTimePeriod records were deleted'
END
GO

if dbo.[fn_GCSDoesIndexExist]('TimeScheduleDayTypeGalaxyTimePeriod', 'idxTimeScheduleDayTypeGalaxyTimePeriod') = 1
BEGIN
	/****** Object:  Index [idxAccessPortalActivityEvent]    Script Date: 2/17/2023 8:20:08 AM ******/
	DROP INDEX [idxTimeScheduleDayTypeGalaxyTimePeriod] ON [GCS].[TimeScheduleDayTypeGalaxyTimePeriod]
END
GO

CREATE UNIQUE NONCLUSTERED INDEX [idxTimeScheduleDayTypeGalaxyTimePeriod] ON [GCS].[TimeScheduleDayTypeGalaxyTimePeriod]
(
	[DayTypeUid] ASC,
	--[GalaxyTimePeriodUid] ASC,
	[TimeScheduleUid] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO


-- Ensure that each entity has a role with IsDefault=true
BEGIN
set nocount on
DECLARE @EntityId uniqueidentifier
DECLARE @EntityName nvarchar(65)
DECLARE @Count int
DECLARE @userName nvarchar(100) = user_name()
DECLARE @dt datetimeoffset = SYSDATETIMEOFFSET()

	DECLARE entityCursor CURSOR LOCAL FOR 
	select e.EntityId, e.EntityName from GCS.gcsEntity e

	OPEN entityCursor
	FETCH NEXT FROM entityCursor INTO @EntityId, @EntityName
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SELECT @Count = count(*) from GCS.gcsRole WHERE EntityId = @EntityId AND (IsDefault = 1 OR RoleName = 'Default, Non-Administrator Role')
		if @Count = 0
		BEGIN 
			DECLARE @roleId uniqueidentifier = NewID()
			PRINT 'Inserting default role for Entity: '  + @EntityName
			exec GCS.gcsRolePDSA_Insert @roleId, @EntityId, N'Default, Non-Administrator Role', N'Role that allows default permissions to the system', 1, 1, @userName, @dt, @userName, @dt, 0, 0
			insert into GCS.gcsRolePermission (RolePermissionId, RoleId, PermissionId, InsertName, InsertDate, UpdateName, UpdateDate, ConcurrencyValue)
			select NEWID(), @roleId, PermissionId, @userName, @dt, @userName, @dt, 0 from GCS.gcsPermission
		END

		FETCH NEXT FROM entityCursor INTO @EntityId, @EntityName
	END
	CLOSE entityCursor;
	DEALLOCATE entityCursor;
END
GO


CREATE OR ALTER PROCEDURE [GCS].[AccessPortalAlarmEventAcknowledgmentPDSA_Insert]
	@AccessPortalAlarmEventAcknowledgmentUid [uniqueidentifier],
	@AccessPortalActivityEventUid [uniqueidentifier],
	@UserId [uniqueidentifier],
	@Response [nvarchar](1000) = null,
	@InsertName [nvarchar](100),
	@InsertDate [datetimeoffset],
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @AccessPortalAlarmEventAcknowledgmentUid = '00000000-0000-0000-0000-000000000000'
	SET @AccessPortalAlarmEventAcknowledgmentUid = NULL

if @AccessPortalAlarmEventAcknowledgmentUid = '00000000-0000-0000-0000-000000000000' OR @AccessPortalAlarmEventAcknowledgmentUid IS NULL
	SET @AccessPortalAlarmEventAcknowledgmentUid = NewID()

INSERT INTO GCS.AccessPortalAlarmEventAcknowledgment
(
AccessPortalAlarmEventAcknowledgmentUid
,AccessPortalActivityEventUid
,UserId
,Response
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@AccessPortalAlarmEventAcknowledgmentUid
,@AccessPortalActivityEventUid
,@UserId
,@Response
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
ELSE
BEGIN

	DECLARE @DeviceEntityId uniqueidentifier 
	DECLARE @DeviceUid uniqueidentifier 
	SELECT @DeviceUid = apae.AccessPortalUid, @DeviceEntityId = ap.EntityId from GCS.AccessPortalActivityEvent apae
	JOIN GCS.AccessPortal ap on ap.AccessPortalUid = apae.AccessPortalUid 
	where AccessPortalActivityEventUid = @AccessPortalActivityEventUid

	exec GCS.[insert_ActivityEventAcknowledgement] 
		@AccessPortalAlarmEventAcknowledgmentUid
		,@AccessPortalActivityEventUid
		,@DeviceEntityId
		,@DeviceUid
		,'Door'
		,@Response
		,@UserId
		,@InsertDate
		,@UpdateDate
END

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalAlarmEventAcknowledgmentPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalAlarmEventAcknowledgmentPDSA_Insert] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[AccessPortalAlarmEventAcknowledgmentPDSA_Update]
	@AccessPortalAlarmEventAcknowledgmentUid [uniqueidentifier],
	@AccessPortalActivityEventUid [uniqueidentifier],
	@UserId [uniqueidentifier],
	@Response [nvarchar](1000),
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

UPDATE GCS.AccessPortalAlarmEventAcknowledgment
SET 
AccessPortalAlarmEventAcknowledgmentUid = @AccessPortalAlarmEventAcknowledgmentUid
,AccessPortalActivityEventUid = @AccessPortalActivityEventUid
,UserId = @UserId
,Response = @Response
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
AccessPortalAlarmEventAcknowledgmentUid = @AccessPortalAlarmEventAcknowledgmentUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;
ELSE
BEGIN
	exec GCS.[update_ActivityEventAcknowledgement] 
		@AccessPortalAlarmEventAcknowledgmentUid
		,@Response
		,@UserId
		,@UpdateDate
END

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalAlarmEventAcknowledgmentPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalAlarmEventAcknowledgmentPDSA_Update] TO [public] AS [dbo]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AccessPortalAlarmEventAcknowledgmentPDSA_DeleteByPK]
	@AccessPortalAlarmEventAcknowledgmentUid [uniqueidentifier],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

DELETE FROM GCS.AccessPortalAlarmEventAcknowledgment
WHERE
AccessPortalAlarmEventAcknowledgmentUid = @AccessPortalAlarmEventAcknowledgmentUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
ELSE
BEGIN
	DELETE FROM GCS.ActivityEventAcknowledgement
	WHERE ActivityEventAcknowledgementUid = @AccessPortalAlarmEventAcknowledgmentUid
END

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortalAlarmEventAcknowledgmentPDSA_DeleteByPK] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortalAlarmEventAcknowledgmentPDSA_DeleteByPK] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[GalaxyPanelAlarmEventAcknowledgmentPDSA_Insert]
	@GalaxyPanelAlarmEventAcknowledgmentUid [uniqueidentifier],
	@GalaxyPanelActivityEventUid [uniqueidentifier],
	@UserId [uniqueidentifier],
	@Response [nvarchar](1000) = null,
	@InsertName [nvarchar](100),
	@InsertDate [datetimeoffset],
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @GalaxyPanelAlarmEventAcknowledgmentUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyPanelAlarmEventAcknowledgmentUid = NULL

if @GalaxyPanelAlarmEventAcknowledgmentUid = '00000000-0000-0000-0000-000000000000' OR @GalaxyPanelAlarmEventAcknowledgmentUid IS NULL
	SET @GalaxyPanelAlarmEventAcknowledgmentUid = NewID()

INSERT INTO GCS.GalaxyPanelAlarmEventAcknowledgment
(
GalaxyPanelAlarmEventAcknowledgmentUid
,GalaxyPanelActivityEventUid
,UserId
,Response
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@GalaxyPanelAlarmEventAcknowledgmentUid
,@GalaxyPanelActivityEventUid
,@UserId
,@Response
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
ELSE
BEGIN

	DECLARE @DeviceEntityId uniqueidentifier 
	DECLARE @DeviceUid uniqueidentifier 
	SELECT @DeviceUid = gpae.GalaxyPanelUid, @DeviceEntityId = c.EntityId from GCS.GalaxyPanelActivityEvent gpae
	JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = gpae.GalaxyPanelUid 
	JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
	where GalaxyPanelActivityEventUid = @GalaxyPanelActivityEventUid

	exec GCS.[insert_ActivityEventAcknowledgement] 
		@GalaxyPanelAlarmEventAcknowledgmentUid
		,@GalaxyPanelActivityEventUid
		,@DeviceEntityId
		,@DeviceUid
		,'Panel'
		,@Response
		,@UserId
		,@InsertDate
		,@UpdateDate
END

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyPanelAlarmEventAcknowledgmentPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyPanelAlarmEventAcknowledgmentPDSA_Insert] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[GalaxyPanelAlarmEventAcknowledgmentPDSA_Update]
	@GalaxyPanelAlarmEventAcknowledgmentUid [uniqueidentifier],
	@GalaxyPanelActivityEventUid [uniqueidentifier],
	@UserId [uniqueidentifier],
	@Response [nvarchar](1000),
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @GalaxyPanelAlarmEventAcknowledgmentUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyPanelAlarmEventAcknowledgmentUid = NULL

UPDATE GCS.GalaxyPanelAlarmEventAcknowledgment
SET 
GalaxyPanelAlarmEventAcknowledgmentUid = @GalaxyPanelAlarmEventAcknowledgmentUid
,GalaxyPanelActivityEventUid = @GalaxyPanelActivityEventUid
,UserId = @UserId
,Response = @Response
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
GalaxyPanelAlarmEventAcknowledgmentUid = @GalaxyPanelAlarmEventAcknowledgmentUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;
ELSE
BEGIN

	exec GCS.[update_ActivityEventAcknowledgement] 
		@GalaxyPanelAlarmEventAcknowledgmentUid
		,@Response
		,@UserId
		,@UpdateDate
END

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyPanelAlarmEventAcknowledgmentPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyPanelAlarmEventAcknowledgmentPDSA_Update] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[GalaxyPanelAlarmEventAcknowledgmentPDSA_DeleteByPK]
	@GalaxyPanelAlarmEventAcknowledgmentUid [uniqueidentifier],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

DELETE FROM GCS.GalaxyPanelAlarmEventAcknowledgment
WHERE
GalaxyPanelAlarmEventAcknowledgmentUid = @GalaxyPanelAlarmEventAcknowledgmentUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
ELSE
BEGIN
	DELETE FROM GCS.ActivityEventAcknowledgement
	WHERE ActivityEventAcknowledgementUid = @GalaxyPanelAlarmEventAcknowledgmentUid
END  
RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyPanelAlarmEventAcknowledgmentPDSA_DeleteByPK] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyPanelAlarmEventAcknowledgmentPDSA_DeleteByPK] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[InputDeviceAlarmEventAcknowledgmentPDSA_Insert]
	@InputDeviceAlarmEventAcknowledgmentUid [uniqueidentifier],
	@InputDeviceActivityEventUid [uniqueidentifier],
	@UserId [uniqueidentifier],
	@Response [nvarchar](1000) = null,
	@InsertName [nvarchar](100),
	@InsertDate [datetimeoffset],
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;


if @InputDeviceAlarmEventAcknowledgmentUid = '00000000-0000-0000-0000-000000000000'
	SET @InputDeviceAlarmEventAcknowledgmentUid = NULL

if @InputDeviceAlarmEventAcknowledgmentUid = '00000000-0000-0000-0000-000000000000' OR @InputDeviceAlarmEventAcknowledgmentUid IS NULL
	SET @InputDeviceAlarmEventAcknowledgmentUid = NewID()

INSERT INTO GCS.InputDeviceAlarmEventAcknowledgment
(
InputDeviceAlarmEventAcknowledgmentUid
,InputDeviceActivityEventUid
,UserId
,Response
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@InputDeviceAlarmEventAcknowledgmentUid
,@InputDeviceActivityEventUid
,@UserId
,@Response
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
ELSE
BEGIN

	DECLARE @DeviceEntityId uniqueidentifier 
	DECLARE @DeviceUid uniqueidentifier 
	SELECT @DeviceUid = id.InputDeviceUid, @DeviceEntityId = id.EntityId from GCS.InputDeviceActivityEvent idae
	JOIN GCS.InputDevice id on id.InputDeviceUid = idae.InputDeviceUid 
	where InputDeviceActivityEventUid = @InputDeviceActivityEventUid

	exec GCS.[insert_ActivityEventAcknowledgement] 
		@InputDeviceAlarmEventAcknowledgmentUid
		,@InputDeviceActivityEventUid
		,@DeviceEntityId
		,@DeviceUid
		,'Input'
		,@Response
		,@UserId
		,@InsertDate
		,@UpdateDate
END

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[InputDeviceAlarmEventAcknowledgmentPDSA_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputDeviceAlarmEventAcknowledgmentPDSA_Insert] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[InputDeviceAlarmEventAcknowledgmentPDSA_Update]
	@InputDeviceAlarmEventAcknowledgmentUid [uniqueidentifier],
	@InputDeviceActivityEventUid [uniqueidentifier],
	@UserId [uniqueidentifier],
	@Response [nvarchar](1000),
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

UPDATE GCS.InputDeviceAlarmEventAcknowledgment
SET 
InputDeviceAlarmEventAcknowledgmentUid = @InputDeviceAlarmEventAcknowledgmentUid
,InputDeviceActivityEventUid = @InputDeviceActivityEventUid
,UserId = @UserId
,Response = @Response
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
InputDeviceAlarmEventAcknowledgmentUid = @InputDeviceAlarmEventAcknowledgmentUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;
ELSE
BEGIN
	exec GCS.[update_ActivityEventAcknowledgement] 
		@InputDeviceAlarmEventAcknowledgmentUid
		,@Response
		,@UserId
		,@UpdateDate
END
RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[InputDeviceAlarmEventAcknowledgmentPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputDeviceAlarmEventAcknowledgmentPDSA_Update] TO [public] AS [dbo]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[InputDeviceAlarmEventAcknowledgmentPDSA_DeleteByPK]
	@InputDeviceAlarmEventAcknowledgmentUid [uniqueidentifier],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

DELETE FROM GCS.InputDeviceAlarmEventAcknowledgment
WHERE
InputDeviceAlarmEventAcknowledgmentUid = @InputDeviceAlarmEventAcknowledgmentUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
ELSE
BEGIN
	DELETE FROM GCS.ActivityEventAcknowledgement
	WHERE
	ActivityEventAcknowledgementUid = @InputDeviceAlarmEventAcknowledgmentUid
END

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[InputDeviceAlarmEventAcknowledgmentPDSA_DeleteByPK] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputDeviceAlarmEventAcknowledgmentPDSA_DeleteByPK] TO [public] AS [dbo]
GO

update GCS.gcsUser set UserActivationDate = null where UserActivationDate <= '1753-01-01 00:00:00.000'
GO

update GCS.gcsUser set UserExpirationDate = null where UserExpirationDate <= '1753-01-01 00:00:00.000'
GO

update GCS.gcsUser set LastPasswordResetDate = null where LastPasswordResetDate <= '1753-01-01 00:00:00.000'
GO

update GCS.gcsUser set IsLockedOutClearedDate = null where IsLockedOutClearedDate <= '1753-01-01 00:00:00.000'
GO

update GCS.gcsUser set LockoutEnd = null where LockoutEnd <= '1753-01-01 00:00:00.000'
GO

update GCS.gcsUser set LastLoginDate = null where LastLoginDate <= '1753-01-01 00:00:00.000'
GO

update GCS.AccessGroup set ActivationDate = null where ActivationDate <= '1753-01-01 00:00:00.000'
GO

update GCS.AccessGroup set ExpirationDate = null where ExpirationDate >= '9999-12-31 23:59:59.000'
GO

update GCS.Person set DateOfBirth = null where DateOfBirth = '1753-1-1'
GO

update GCS.Person set EmploymentDate = null where EmploymentDate = '1753-1-1'
GO

update GCS.Person set TerminationDate = null where TerminationDate = '1753-1-1'
GO

update GCS.Person set ActivationDateTime = null where ActivationDateTime <= '1753-1-1'
GO

update GCS.Person set ExpirationDateTime = null where ExpirationDateTime <= '1753-1-1'
GO

update GCS.PersonCredential set ActivationDateTime = null where ActivationDateTime <= '1753-1-1'
GO

update GCS.PersonCredential set ExpirationDateTime = null where ExpirationDateTime <= '1753-1-1'
GO

update GCS.PersonCredential set BadgeLastPrinted = null where BadgeLastPrinted <= '1753-1-1'
GO

update GCS.PersonCredential set DossierLastPrinted = null where DossierLastPrinted <= '1753-1-1'
GO

CREATE OR ALTER PROCEDURE [GCS].[Cluster_GetCurrentTime]
	@ClusterUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

DECLARE @time datetimeoffset
SELECT @time = CurrentTimeForCluster FROM GCS.Cluster WHERE ClusterUid = @ClusterUid

IF @time is null
	select @time = SYSDATETIMEOFFSET()

select @time as CurrentTimeForCluster


RETURN @ret;
GO

ALTER AUTHORIZATION ON [GCS].[Cluster_GetCurrentTime] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[Cluster_GetCurrentTime] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[CredentialToLoadToCpu_SaveLastCredentialLoadedDateByCredentialData]
	@CpuUid [uniqueidentifier],
	@CredentialData [binary](32),
	@LastCredentialLoadedDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

DECLARE @CredentialToLoadToCpuUid uniqueidentifier 
DECLARE @CredentialUid uniqueidentifier

SELECT TOP(1) @CredentialUid = CredentialUid FROM GCS.Credential WHERE CardBinaryData = @CredentialData
IF @CredentialUid IS NULL
BEGIN
	SELECT @ret = -1;
	RETURN @@ERROR;
END

SELECT @CredentialToLoadToCpuUid = CredentialToLoadToCpuUid FROM GCS.CredentialToLoadToCpu WHERE CpuUid = @CpuUid AND CredentialUid = @CredentialUid
IF @CredentialToLoadToCpuUid IS NULL
BEGIN
	SET @CredentialToLoadToCpuUid = newid()
	INSERT INTO GCS.CredentialToLoadToCpu (CredentialToLoadToCpuUid, CpuUid, CredentialUid, LastCredentialChangeDate, LastPersonalAccessGroupChangeDate, LastCredentialLoadedDate)
	VALUES(@CredentialToLoadToCpuUid, @CpuUid, @CredentialUid, SYSDATETIMEOFFSET(), SYSDATETIMEOFFSET(), @LastCredentialLoadedDate)

END
ELSE
BEGIN
	UPDATE GCS.CredentialToLoadToCpu SET LastCredentialLoadedDate = @LastCredentialLoadedDate
	WHERE CredentialToLoadToCpuUid = @CredentialToLoadToCpuUid
END

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[CredentialToLoadToCpu_SaveLastCredentialLoadedDateByCredentialData] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToLoadToCpu_SaveLastCredentialLoadedDateByCredentialData] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[CredentialToLoadToCpu_SaveLastPersonalAccessGroupLoadedDate]
	@CpuUid [uniqueidentifier],
	@CredentialUid [uniqueidentifier],
	@LastPersonalAccessGroupLoadedDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

DECLARE @CredentialToLoadToCpuUid uniqueidentifier 

SELECT @CredentialToLoadToCpuUid = CredentialToLoadToCpuUid FROM GCS.CredentialToLoadToCpu WHERE CpuUid = @CpuUid AND CredentialUid = @CredentialUid
IF @CredentialToLoadToCpuUid IS NULL
BEGIN
	SET @CredentialToLoadToCpuUid = newid()
	INSERT INTO GCS.CredentialToLoadToCpu (CredentialToLoadToCpuUid, CpuUid, CredentialUid, LastCredentialChangeDate, LastPersonalAccessGroupChangeDate, LastPersonalAccessGroupLoadedDate)
	VALUES(@CredentialToLoadToCpuUid, @CpuUid, @CredentialUid, SYSDATETIMEOFFSET(), SYSDATETIMEOFFSET(), @LastPersonalAccessGroupLoadedDate)

END
ELSE
BEGIN
	UPDATE GCS.CredentialToLoadToCpu SET LastPersonalAccessGroupLoadedDate = @LastPersonalAccessGroupLoadedDate
	WHERE CredentialToLoadToCpuUid = @CredentialToLoadToCpuUid
END

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[CredentialToLoadToCpu_SaveLastPersonalAccessGroupLoadedDate] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToLoadToCpu_SaveLastPersonalAccessGroupLoadedDate] TO [public] AS [dbo]
GO

/****** Object:  StoredProcedure [GCS].[gcsUser_UpdateLastLoginDate]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[gcsUser_UpdateLastLoginDate]
	@UserId [uniqueidentifier],
	@LastLoginDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

UPDATE GCS.gcsUser
SET 
LastLoginDate = @LastLoginDate 
WHERE
UserId = @UserId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[gcsUser_UpdateLastLoginDate] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsUser_UpdateLastLoginDate] TO [public] AS [dbo]
GO

/****** Object:  StoredProcedure [GCS].[PersonCredentialCommandScriptPDSA_Update]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonCredentialCommandScriptPDSA_Update]
	@PersonCredentialCommandScriptUid [uniqueidentifier],
	@PersonCredentialUid [uniqueidentifier],
	@CommandScriptUid [uniqueidentifier],
	@DelayedCommandScriptUid [uniqueidentifier],
	@DelayTime [datetimeoffset](7),
	@UpdateName [nvarchar](100),
	@UpdateDate [datetimeoffset],
	@ConcurrencyValue [smallint]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

if @DelayedCommandScriptUid = '00000000-0000-0000-0000-000000000000'
	SET @DelayedCommandScriptUid = NULL

UPDATE GCS.PersonCredentialCommandScript
SET 
PersonCredentialUid = @PersonCredentialUid
,CommandScriptUid = @CommandScriptUid
,DelayedCommandScriptUid = @DelayedCommandScriptUid
,DelayTime = @DelayTime
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
PersonCredentialCommandScriptUid = @PersonCredentialCommandScriptUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[PersonCredentialCommandScriptPDSA_Update] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonCredentialCommandScriptPDSA_Update] TO [public] AS [dbo]
GO

/****** Object:  StoredProcedure [GCS].[CredentialToDeleteFromCpu_SaveDeletedFromCpuDate]    Script Date: 8/31/2020 2:22:23 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[CredentialToDeleteFromCpu_SaveDeletedFromCpuDate]
	@CpuUid [uniqueidentifier],
	@CardBinaryData [binary](32),
	@DeletedFromCpuDate [datetimeoffset]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

DECLARE @CredentialToDeleteFromCpuUid uniqueidentifier 

SELECT @CredentialToDeleteFromCpuUid = CredentialToDeleteFromCpuUid FROM GCS.CredentialToDeleteFromCpu WHERE CpuUid = @CpuUid AND CardBinaryData = @CardBinaryData
IF @CredentialToDeleteFromCpuUid IS NOT NULL
BEGIN
	UPDATE GCS.CredentialToDeleteFromCpu SET DeletedFromCpuDate = @DeletedFromCpuDate
	WHERE CredentialToDeleteFromCpuUid = @CredentialToDeleteFromCpuUid
END

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO
ALTER AUTHORIZATION ON [GCS].[CredentialToDeleteFromCpu_SaveDeletedFromCpuDate] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[CredentialToDeleteFromCpu_SaveDeletedFromCpuDate] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[Credential_GetPanelLoadDataChangesByCpuUid]
	@CpuUid [uniqueidentifier],
	@ServerAddress [nvarchar](255),
	@IsConnected [bit]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

	if @CpuUid is not null AND @CpuUid <> '00000000-0000-0000-0000-000000000000'
	begin
		if @ServerAddress is null or LEN(@ServerAddress) = 0
			SELECT * FROM GCS.Credential_PanelLoadDataChangesForCpu WHERE CpuUid = @CpuUid and CardBinaryData <> 0x0000000000000000000000000000000000000000000000000000000000000000
		else
			SELECT * FROM GCS.Credential_PanelLoadDataChangesForCpu WHERE CpuUid = @CpuUid AND ServerAddress = @ServerAddress AND IsConnected = @IsConnected and CardBinaryData <> 0x0000000000000000000000000000000000000000000000000000000000000000
	end
	ELSE
	begin
		if @ServerAddress is null or LEN(@ServerAddress) = 0
			SELECT * FROM GCS.Credential_PanelLoadDataChangesForCpu WHERE CardBinaryData <> 0x0000000000000000000000000000000000000000000000000000000000000000 ORDER BY ClusterGroupId, ClusterNumber, PanelNumber, CpuNumber
		else
			SELECT * FROM GCS.Credential_PanelLoadDataChangesForCpu where ServerAddress = @ServerAddress AND IsConnected = @IsConnected and CardBinaryData <> 0x0000000000000000000000000000000000000000000000000000000000000000 ORDER BY ClusterGroupId, ClusterNumber, PanelNumber, CpuNumber
	end
if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[Credential_GetPanelLoadDataChangesByCpuUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[Credential_GetPanelLoadDataChangesByCpuUid] TO [public] AS [dbo]
GO

use [GalaxySMS-AuditActivity]
go

if dbo.fn_GCSDoesColumnExist('PanelDataPacketLog', 'ClusterGroupId') = 0
BEGIN
	ALTER TABLE GCS.PanelDataPacketLog
	ADD ClusterGroupId int not NULL default 0;
END
GO

use GalaxySMS
go

/****** Object:  StoredProcedure [GCS].[PanelDataPacketLog_Insert]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PanelDataPacketLog_Insert]
	@Id [uniqueidentifier],
	@InsertDate [datetimeoffset],
	@UpdateDate [datetimeoffset],
	@Length [smallint],
	@Distribute [smallint],
	@ClusterGroupId [int],
	@ClusterId [int],
	@PanelId [int],
	@CpuId [smallint],
	@BoardNumber [int],
	@SectionNumber [smallint],
	@SecondsFromWeekStart [int],
	@Sequence [int],
	@RawData [varbinary](max),
	@Direction [bit]
WITH EXECUTE AS CALLER
AS
begin

   if @Id is null or @Id = '00000000-0000-0000-0000-000000000000' 
        set @Id = NEWID()

    insert into [GalaxySMS-AuditActivity].[GCS].PanelDataPacketLog (PanelDataPacketLog.Id,PanelDataPacketLog.InsertDate,PanelDataPacketLog.UpdateDate,PanelDataPacketLog.Length,PanelDataPacketLog.Distribute,PanelDataPacketLog.ClusterGroupId,PanelDataPacketLog.ClusterId,PanelDataPacketLog.PanelId,PanelDataPacketLog.CpuId,PanelDataPacketLog.BoardNumber,PanelDataPacketLog.SectionNumber,PanelDataPacketLog.SecondsFromWeekStart,PanelDataPacketLog.Sequence,PanelDataPacketLog.RawData, PanelDataPacketLog.Direction)
    values(@Id,@InsertDate,@UpdateDate,@Length,@Distribute,@ClusterGroupId,@ClusterId,@PanelId,@CpuId,@BoardNumber,@SectionNumber,@SecondsFromWeekStart,@Sequence,@RawData, @Direction)
end
GO
ALTER AUTHORIZATION ON [GCS].[PanelDataPacketLog_Insert] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PanelDataPacketLog_Insert] TO [public] AS [dbo]
GO


/* All Stored Procedures for table: GalaxyActivityEventType */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.GalaxyActivityEventType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyActivityEventTypePDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyActivityEventTypePDSA_SelectAll]
GO

CREATE PROCEDURE GCS.[GalaxyActivityEventTypePDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyActivityEventTypeUid
,DisplayResourceKey
,DescriptionResourceKey
,Display
,Description
,EventType
,DeviceType
,ForeColor
,ForeColorHex
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyActivityEventType
order by DeviceType, Display

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyActivityEventTypePDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.GalaxyActivityEventType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyActivityEventTypePDSA_AllForCulture]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyActivityEventTypePDSA_AllForCulture] 
GO

CREATE PROCEDURE GCS.[GalaxyActivityEventTypePDSA_AllForCulture] 
@CultureName nvarchar(20) = NULL 
AS

declare @ret int;
select @ret = 0;

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
t.GalaxyActivityEventTypeUid
,t.DisplayResourceKey
,t.DescriptionResourceKey
,t.EventType
,t.DeviceType
,t.ForeColor
,t.ForeColorHex
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
FROM GCS.GalaxyActivityEventType t
order by DeviceType, Display

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyActivityEventTypePDSA_AllForCulture] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyActivityEventType table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyActivityEventTypePDSA_SelectByEventType]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyActivityEventTypePDSA_SelectByEventType]
GO
CREATE PROCEDURE GCS.[GalaxyActivityEventTypePDSA_SelectByEventType]
@EventType varchar(50),
@CultureName nvarchar(20) = NULL
AS

declare @ret int;
select @ret = 0;

IF @CultureName IS NULL SET @CultureName = 'en-US'

declare @languageId uniqueidentifier
select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

SELECT 
t.GalaxyActivityEventTypeUid
,t.DisplayResourceKey
,t.DescriptionResourceKey
,t.EventType
,t.DeviceType
,t.ForeColor
,t.ForeColorHex
,CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DisplayResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DisplayResourceKey)
	ELSE t.Display
	END AS Display,
CASE 
	WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId) IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = t.DescriptionResourceKey and LanguageId = @languageId)
	WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = t.DescriptionResourceKey)
	ELSE t.Description
	END AS Description
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
FROM GCS.GalaxyActivityEventType t
WHERE 
EventType= @EventType

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyActivityEventTypePDSA_SelectByEventType] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.GalaxyActivityEventType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyActivityEventTypePDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyActivityEventTypePDSA_SelectListBox]
GO

CREATE PROCEDURE GCS.[GalaxyActivityEventTypePDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyActivityEventTypeUid
,Display
FROM GCS.GalaxyActivityEventType

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyActivityEventTypePDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyActivityEventType table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyActivityEventTypePDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyActivityEventTypePDSA_SelectByPK]
GO
CREATE PROCEDURE GCS.[GalaxyActivityEventTypePDSA_SelectByPK]
@GalaxyActivityEventTypeUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyActivityEventTypeUid
,DisplayResourceKey
,DescriptionResourceKey
,Display
,Description
,EventType
,DeviceType
,ForeColor
,ForeColorHex
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyActivityEventType
WHERE 
GalaxyActivityEventTypeUid = @GalaxyActivityEventTypeUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyActivityEventTypePDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.GalaxyActivityEventType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyActivityEventTypePDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyActivityEventTypePDSA_SelectSearch]
GO
CREATE PROCEDURE GCS.[GalaxyActivityEventTypePDSA_SelectSearch]
@Display nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
GalaxyActivityEventTypeUid
,DisplayResourceKey
,DescriptionResourceKey
,Display
,Description
,EventType
,DeviceType
,ForeColor
,ForeColorHex
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.GalaxyActivityEventType
WHERE 
(@Display IS NULL OR Display LIKE @Display + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyActivityEventTypePDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.GalaxyActivityEventType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyActivityEventTypePDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyActivityEventTypePDSA_Insert]
GO
CREATE PROCEDURE GCS.[GalaxyActivityEventTypePDSA_Insert]
@GalaxyActivityEventTypeUid uniqueidentifier 
,@DisplayResourceKey uniqueidentifier  = null
,@DescriptionResourceKey uniqueidentifier  = null
,@Display nvarchar(65) 
,@Description nvarchar(1000) 
,@EventType varchar(50) 
,@DeviceType varchar(50) 
,@ForeColor int 
,@InsertName nvarchar(50) 
,@InsertDate datetime 
,@UpdateName nvarchar(50) 
,@UpdateDate datetime 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;


if @GalaxyActivityEventTypeUid = '00000000-0000-0000-0000-000000000000'
	SET @GalaxyActivityEventTypeUid = NULL
if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL


if @GalaxyActivityEventTypeUid = '00000000-0000-0000-0000-000000000000' OR @GalaxyActivityEventTypeUid IS NULL
	SET @GalaxyActivityEventTypeUid = NewID()

INSERT INTO GCS.GalaxyActivityEventType
(
GalaxyActivityEventTypeUid
,DisplayResourceKey
,DescriptionResourceKey
,Display
,Description
,EventType
,DeviceType
,ForeColor
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@GalaxyActivityEventTypeUid
,@DisplayResourceKey
,@DescriptionResourceKey
,@Display
,@Description
,@EventType
,@DeviceType
,@ForeColor
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyActivityEventTypePDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.GalaxyActivityEventType table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyActivityEventTypePDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyActivityEventTypePDSA_Update]
GO
CREATE PROCEDURE GCS.[GalaxyActivityEventTypePDSA_Update]
@GalaxyActivityEventTypeUid uniqueidentifier 
,@DisplayResourceKey uniqueidentifier
,@DescriptionResourceKey uniqueidentifier
,@Display nvarchar(65)
,@Description nvarchar(1000)
,@EventType varchar(50)
,@DeviceType varchar(50) 
,@ForeColor int
,@UpdateName nvarchar(50)
,@UpdateDate datetime
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

if @DisplayResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DisplayResourceKey = NULL
if @DescriptionResourceKey = '00000000-0000-0000-0000-000000000000'
	SET @DescriptionResourceKey = NULL

UPDATE GCS.GalaxyActivityEventType
SET 
GalaxyActivityEventTypeUid = @GalaxyActivityEventTypeUid
,DisplayResourceKey = @DisplayResourceKey
,DescriptionResourceKey = @DescriptionResourceKey
,Display = @Display
,Description = @Description
,EventType = @EventType
,DeviceType = @DeviceType
,ForeColor = @ForeColor
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
GalaxyActivityEventTypeUid = @GalaxyActivityEventTypeUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyActivityEventTypePDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.GalaxyActivityEventType table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyActivityEventTypePDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyActivityEventTypePDSA_UpdateConcurrency]
GO
CREATE PROCEDURE GCS.[GalaxyActivityEventTypePDSA_UpdateConcurrency]
@GalaxyActivityEventTypeUid uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.GalaxyActivityEventType
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
GalaxyActivityEventTypeUid = @GalaxyActivityEventTypeUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[GalaxyActivityEventTypePDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.GalaxyActivityEventType table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyActivityEventTypePDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyActivityEventTypePDSA_DeleteByPK]
GO
CREATE PROCEDURE GCS.[GalaxyActivityEventTypePDSA_DeleteByPK]
@GalaxyActivityEventTypeUid uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.GalaxyActivityEventType
WHERE
GalaxyActivityEventTypeUid = @GalaxyActivityEventTypeUid
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyActivityEventTypePDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.GalaxyActivityEventType table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyActivityEventTypePDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyActivityEventTypePDSA_RowCount]
GO
CREATE PROCEDURE GCS.[GalaxyActivityEventTypePDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.GalaxyActivityEventType

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyActivityEventTypePDSA_RowCount] TO public
GO



if dbo.fn_GCSDoesColumnExist('InputDeviceAlertEventType', 'Flag') = 0
BEGIN
	ALTER TABLE GCS.InputDeviceAlertEventType
	ADD Flag as (case Tag when 'StateChange' then 1 
	else 0
	end
	);
END
GO


if dbo.fn_GCSDoesColumnExist('GalaxyPanelAlertEventType', 'Flag') = 0
BEGIN
	ALTER TABLE GCS.GalaxyPanelAlertEventType
	ADD Flag as (case Tag when 'LowBattery' then 1 
	when'ACFailure' then 2
	when 'Tamper' then 4
	when 'EmergencyUnlock' then 8
	else 0
	end
	);
END
GO

--select * from GCS.GalaxyPanelAlertEventType


if dbo.fn_GCSDoesColumnExist('AccessPortalAlertEventType', 'Flag') = 0
BEGIN
	ALTER TABLE GCS.AccessPortalAlertEventType
	ADD Flag as (case Tag when 'ForcedOpen' then 1 
	when'OpenTooLong' then 2
	when 'InvalidAccessAttempt' then 4
	when 'PassbackViolation' then 8
	when 'Duress' then 16
	when 'ReaderHeartbeat' then 32
	when 'AccessGranted' then 64
	when 'AccessGrantedDisarmInputOutputGroup1' then 128
	when 'AccessGrantedDisarmInputOutputGroup2' then 256
	when 'AccessGrantedDisarmInputOutputGroup3' then 512
	when 'AccessGrantedDisarmInputOutputGroup4' then 1024
	when 'DoorGroup' then 2048
	when 'UnlockedBy' then 4096
	when 'LockedBy' then 8192
	else 0
	end
	);
END
GO

if dbo.fn_GCSDoesColumnExist('AccessPortal', 'AlertEventsFlag') = 1
BEGIN
	ALTER TABLE GCS.AccessPortal
	DROP COLUMN AlertEventsFlag
END
GO



CREATE OR ALTER FUNCTION [GCS].[AccessPortalAlertEventsFlag] (@accessPortalUid uniqueidentifier) 
RETURNS int
as
begin

declare @flags int = 0

	SELECT @flags = SUM(Flag) from GCS.AccessPortalAlertEvent et join
	GCS.AccessPortalAlertEventType aet on aet.AccessPortalAlertEventTypeUid = et.AccessPortalAlertEventTypeUid
	WHERE AccessPortalUid = @accessPortalUid AND AcknowledgeTimeScheduleUid <> '00000000-0000-0000-0000-000000000001' AND IsActive = 1
	return ISNULL(@flags, 0)
	end
go

GRANT EXECUTE ON GCS.[AccessPortalAlertEventsFlag] TO public
GO

if dbo.fn_GCSDoesColumnExist('AccessPortal', 'AlertEventsFlag') = 0
BEGIN
	ALTER TABLE GCS.AccessPortal
	ADD AlertEventsFlag as (GCS.[AccessPortalAlertEventsFlag](AccessPortalUid));
END
GO


if dbo.fn_GCSDoesColumnExist('GalaxyPanel', 'AlertEventsFlag') = 1
BEGIN
	ALTER TABLE GCS.GalaxyPanel
	DROP COLUMN AlertEventsFlag
END
GO

CREATE OR ALTER FUNCTION [GCS].[GalaxyPanelAlertEventsFlag] (@galaxyPanelUid uniqueidentifier) 
RETURNS int
as
begin

declare @flags int = 0

	SELECT @flags = SUM(Flag) from GCS.GalaxyPanelAlertEvent et join
	GCS.GalaxyPanelAlertEventType aet on aet.GalaxyPanelAlertEventTypeUid = et.GalaxyPanelAlertEventTypeUid
	WHERE GalaxyPanelUid = @galaxyPanelUid AND AcknowledgeTimeScheduleUid <> '00000000-0000-0000-0000-000000000001' AND IsActive = 1
	return ISNULL(@flags, 0)
	end
go

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventsFlag] TO public
GO

--drop view GCS.DeviceAlertEventSettingsView

--alter table GCS.GalaxyPanel
--drop column AlertEventsFlag

if dbo.fn_GCSDoesColumnExist('GalaxyPanel', 'AlertEventsFlag') = 0
BEGIN
	ALTER TABLE GCS.GalaxyPanel
	ADD AlertEventsFlag as (GCS.[GalaxyPanelAlertEventsFlag](GalaxyPanelUid));
END
GO

if dbo.fn_GCSDoesColumnExist('InputDevice', 'AlertEventsFlag') = 1
BEGIN
	ALTER TABLE GCS.InputDevice
	DROP COLUMN AlertEventsFlag
END
GO

CREATE OR ALTER FUNCTION [GCS].[InputDeviceAlertEventsFlag] (@inputDeviceUid uniqueidentifier) 
RETURNS int
as
begin

declare @flags int = 0

	SELECT @flags = SUM(Flag) from GCS.InputDeviceEventProperties et join
	GCS.InputDeviceAlertEventType aet on aet.InputDeviceAlertEventTypeUid = et.InputDeviceAlertEventTypeUid
	WHERE InputDeviceUid = @inputDeviceUid AND AcknowledgeTimeScheduleUid <> '00000000-0000-0000-0000-000000000001' AND IsActive = 1
	return ISNULL(@flags, 0)
	end
go

GRANT EXECUTE ON GCS.[InputDeviceAlertEventsFlag] TO public
GO

if dbo.fn_GCSDoesColumnExist('InputDevice', 'AlertEventsFlag') = 0
BEGIN
	ALTER TABLE GCS.InputDevice
	ADD AlertEventsFlag as (GCS.[InputDeviceAlertEventsFlag](InputDeviceUid));
END
GO


CREATE OR ALTER VIEW [GCS].[DeviceAlertEventSettingsView] WITH SCHEMABINDING 
as
	select apae.AccessPortalAlertEventUid as Pk, ap.EntityId, ent.EntityName, ap.AccessPortalUid as DeviceId, ap.PortalName as 'DeviceName', aet.Display as 'EventType', 'AccessPortal' as DeviceType, c.ClusterName, ts.Display as 'TimeSchedule',
	apae.AccessPortalAlertEventTypeUid as AlertEventTypeUid, c.ClusterUid, apae.AcknowledgeTimeScheduleUid,
	apae.IsActive, aet.Flag, ap.AlertEventsFlag
	from GCS.AccessPortalAlertEvent apae
	join GCS.AccessPortal ap on ap.AccessPortalUid = apae.AccessPortalUid
	join GCS.AccessPortalAlertEventType aet on aet.AccessPortalAlertEventTypeUid = apae.AccessPortalAlertEventTypeUid
	join GCS.TimeSchedule ts on ts.TimeScheduleUid = apae.AcknowledgeTimeScheduleUid
	join GCS.AccessPortalGalaxyHardwareAddress hwa on hwa.AccessPortalUid = apae.AccessPortalUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = hwa.GalaxyPanelUid
	join GCS.Cluster c on c.ClusterUid = gp.ClusterUid
	join GCS.gcsEntity ent on ent.EntityId = ap.EntityId
	where aet.CanAcknowledge = 1 and apae.AcknowledgeTimeScheduleUid <> '00000000-0000-0000-0000-000000000001'
union
	select gpae.GalaxyPanelAlertEventUid as Pk, c.EntityId, ent.EntityName, gp.GalaxyPanelUid as DeviceId, gp.PanelName as 'DeviceName', aet.Display as 'EventType', 'GalaxyPanel' as DeviceType, c.ClusterName, ts.Display as 'TimeSchedule',
	gpae.GalaxyPanelAlertEventTypeUid as AlertEventTypeUid, c.ClusterUid, gpae.AcknowledgeTimeScheduleUid,
	gpae.IsActive, aet.Flag, gp.AlertEventsFlag
	from GCS.GalaxyPanelAlertEvent gpae
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = gpae.GalaxyPanelUid
	join GCS.GalaxyPanelAlertEventType aet on aet.GalaxyPanelAlertEventTypeUid = gpae.GalaxyPanelAlertEventTypeUid
	join GCS.TimeSchedule ts on ts.TimeScheduleUid = gpae.AcknowledgeTimeScheduleUid
	join GCS.Cluster c on c.ClusterUid = gp.ClusterUid
	join GCS.gcsEntity ent on ent.EntityId = c.EntityId
	where aet.CanAcknowledge = 1 and gpae.AcknowledgeTimeScheduleUid <> '00000000-0000-0000-0000-000000000001'
union
	select idae.InputDeviceEventPropertiesUid as Pk, id.EntityId, ent.EntityName, id.InputDeviceUid as DeviceId, id.InputName as 'DeviceName', aet.Display as 'EventType', 'InputDevice' as DeviceType, c.ClusterName, ts.Display as 'TimeSchedule',
	idae.InputDeviceAlertEventTypeUid as AlertEventTypeUid, c.ClusterUid, idae.AcknowledgeTimeScheduleUid,
	idae.IsActive, aet.Flag, id.AlertEventsFlag
	from GCS.InputDeviceEventProperties idae
	join GCS.InputDevice id on id.InputDeviceUid = idae.InputDeviceUid
	join GCS.InputDeviceAlertEventType aet on aet.InputDeviceAlertEventTypeUid = idae.InputDeviceAlertEventTypeUid
	join GCS.TimeSchedule ts on ts.TimeScheduleUid = idae.AcknowledgeTimeScheduleUid
	join GCS.InputDeviceGalaxyHardwareAddress hwa on hwa.InputDeviceUid = idae.InputDeviceUid
	join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = hwa.GalaxyPanelUid
	join GCS.Cluster c on c.ClusterUid = gp.ClusterUid
	join GCS.gcsEntity ent on ent.EntityId = id.EntityId
	where aet.CanAcknowledge = 1 and idae.AcknowledgeTimeScheduleUid <> '00000000-0000-0000-0000-000000000001'
go


CREATE OR ALTER PROCEDURE [GCS].[DeviceAlertEventSettings_ByEntityId]
	@EntityId [uniqueidentifier],
	@IsActive bit = 1
WITH EXECUTE AS CALLER
AS
	IF @IsActive is not null
	begin
		SELECT * FROM GCS.DeviceAlertEventSettingsView
		where EntityId = @EntityId AND IsActive = @IsActive
		order by ClusterUid, DeviceType, AcknowledgeTimeScheduleUid, AlertEventsFlag
	end
	else
	begin
		SELECT * FROM GCS.DeviceAlertEventSettingsView
		where EntityId = @EntityId
		order by ClusterUid, DeviceType, AcknowledgeTimeScheduleUid, AlertEventsFlag
	end
GO
ALTER AUTHORIZATION ON [GCS].[DeviceAlertEventSettings_ByEntityId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[DeviceAlertEventSettings_ByEntityId] TO [public] AS [dbo]
GO


--exec  [GCS].[DeviceAlertEventSettings_ByEntityId] '00000000-0000-0000-0000-000000000002'

-- Ensure that all entities have a default person record type defined in the gcsSettings table
begin
	DECLARE @prtEntityId uniqueidentifier;
	DECLARE @personRecordTypeUid uniqueidentifier
	
    DECLARE SettingsCursor CURSOR LOCAL FOR 
		SELECT EntityId FROM GCS.gcsEntity where EntityId <> '00000000-0000-0000-0000-000000000001';

    OPEN SettingsCursor
    FETCH NEXT FROM SettingsCursor INTO @prtEntityId
    WHILE @@FETCH_STATUS = 0
    BEGIN
		IF NOT EXISTS (select [Value] from GCS.gcsSetting where SettingGroup = 'gcsEntity' and SettingSubGroup = 'Person' and SettingKey = 'DefaultPersonRecordTypeUid' AND EntityId = @prtEntityId)
		BEGIN
			Select @personRecordTypeUid = PersonRecordTypeUid from GCS.PersonRecordType where EntityId = @prtEntityId and Display = 'Employee'
			if @personRecordTypeUid IS NOT NULL
			BEGIN
				INSERT INTO GCS.gcsSetting (SettingId, EntityId, SettingGroup, SettingSubGroup, SettingKey, Value, InsertName, InsertDate, UpdateName, UpdateDate, ConcurrencyValue)
				values (NewID(), @prtEntityId, 'gcsEntity', 'Person', 'DefaultPersonRecordTypeUid', @personRecordTypeUid, USER_NAME(), SYSDATETIMEOFFSET(), USER_NAME(), SYSDATETIMEOFFSET(), 0)
			END
		END

    FETCH NEXT FROM SettingsCursor INTO @prtEntityId
    END
    CLOSE SettingsCursor;
    DEALLOCATE SettingsCursor;
end


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[AcknowledgedAlarmBasicData_ByActivityEventUid]
	@ActivityEventUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

	SELECT * FROM GCS.AcknowledgedAlarmBasicData WHERE ActivityEventUid = @ActivityEventUid

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[AcknowledgedAlarmBasicData_ByActivityEventUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AcknowledgedAlarmBasicData_ByActivityEventUid] TO [public] AS [dbo]
GO

CREATE OR ALTER VIEW [GCS].[CredentialToDelete_PanelLoadDataChangesForCpu] AS
SELECT 
CredentialToDeleteFromCpuUid
,t.CpuUid
,CardBinaryData
,DeletedFromDatabaseDate
,DeletedFromCpuDate
,cluster.ClusterNumber
,gp.PanelNumber
,cpu.CpuNumber
,cluster.ClusterGroupId
,gcc.ServerAddress
,gcc.IsConnected
,cdl.DataLength
,t.IsExtended
FROM GCS.CredentialToDeleteFromCpu t
join GCS.GalaxyCpu cpu on cpu.CpuUid = t.CpuUid
LEFT OUTER JOIN GCS.GalaxyCpuConnection gcc on gcc.CpuUid = cpu.CpuUid
join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = cpu.GalaxyPanelUid
join GCS.Cluster cluster on cluster.ClusterUid = gp.ClusterUid
join GCS.CredentialDataLength cdl on cdl.CredentialDataLengthUid = cluster.CredentialDataLengthUid
where (DeletedFromCpuDate IS NULL or DeletedFromCpuDate < DeletedFromDatabaseDate)
AND (IsExtended = 0 OR (IsExtended = 1 AND DataLength > 6))
GO
ALTER AUTHORIZATION ON [GCS].[CredentialToDelete_PanelLoadDataChangesForCpu] TO  SCHEMA OWNER 
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[AccessPortalAlertEventPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByEntityId]
GO

CREATE OR ALTER PROCEDURE GCS.[AccessPortalAlertEventPDSA_ByEntityId]
@EntityId uniqueidentifier
AS

declare @ret int;
select @ret = 0;

SELECT 
AccessPortalAlertEventUid
,t.AccessPortalUid
,InputOutputGroupUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,t.AccessPortalAlertEventTypeUid
,InputOutputGroupAssignmentUid
,AcknowledgePriority
,ResponseRequired
,t.IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,ap.EntityId
FROM GCS.AccessPortalAlertEvent t
JOIN GCS.AccessPortal ap on ap.AccessPortalUid = t.AccessPortalUid
JOIN GCS.AccessPortalAlertEventType aet on aet.AccessPortalAlertEventTypeUid = T.AccessPortalAlertEventTypeUid
where ap.EntityId = @EntityId AND aet.CanAcknowledge = 1

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[AccessPortalAlertEventPDSA_ByEntityId] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.GalaxyPanelAlertEvent table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[GalaxyPanelAlertEventPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[GalaxyPanelAlertEventPDSA_ByEntityId]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
t.GalaxyPanelAlertEventUid
,t.GalaxyPanelUid
,t.GalaxyPanelAlertEventTypeUid
,AcknowledgeTimeScheduleUid
,AudioBinaryResourceUid
,UserInstructionsNoteUid
,t.InputOutputGroupAssignmentUid
,t.InputOutputGroupUid
,AcknowledgePriority
,ResponseRequired
,t.IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
,OffsetIndex
FROM GCS.GalaxyPanelAlertEvent t
LEFT OUTER JOIN GCS.InputOutputGroupAssignment ass on ass.InputOutputGroupAssignmentUid = t.InputOutputGroupAssignmentUid
JOIN GCS.GalaxyPanel gp on gp.GalaxyPanelUid = t.GalaxyPanelUid
JOIN GCS.Cluster c on c.ClusterUid = gp.ClusterUid
JOIN GCS.GalaxyPanelAlertEventType aet on aet.GalaxyPanelAlertEventTypeUid = t.GalaxyPanelAlertEventTypeUid
WHERE 
c.EntityId = @EntityId AND aet.CanAcknowledge = 1

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[GalaxyPanelAlertEventPDSA_ByEntityId] TO public
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[InputDeviceEventPropertiesPDSA_ByEntityId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_ByEntityId]
GO
CREATE OR ALTER PROCEDURE GCS.[InputDeviceEventPropertiesPDSA_ByEntityId]
@EntityId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
InputDeviceEventPropertiesUid
,t.InputDeviceUid
,AudioBinaryResourceUid
,ResponseInstructionsUid
,AcknowledgeTimeScheduleUid
,t.InputDeviceAlertEventTypeUid
,AcknowledgePriority
,ResponseRequired
,t.Tag
,t.IsActive
,t.InsertName
,t.InsertDate
,t.UpdateName
,t.UpdateDate
,t.ConcurrencyValue
FROM GCS.InputDeviceEventProperties t
JOIN GCS.InputDevice id on id.InputDeviceUid = t.InputDeviceUid
JOIN GCS.InputDeviceAlertEventType aet on aet.InputDeviceAlertEventTypeUid = t.InputDeviceAlertEventTypeUid
WHERE 
id.EntityId = @EntityId AND aet.CanAcknowledge = 1

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[InputDeviceEventPropertiesPDSA_ByEntityId] TO public
GO

CREATE OR ALTER PROCEDURE [GCS].[AccessPortal_GetAllUidsForEntityId]
	@EntityId [uniqueidentifier]
AS
	select t.AccessPortalUid as Uid from GCS.AccessPortal t 
	where t.EntityId = @EntityId
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortal_GetAllUidsForEntityId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortal_GetAllUidsForEntityId] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[GalaxyPanel_GetAllUidsForEntityId]
	@EntityId [uniqueidentifier]
AS
	select t.GalaxyPanelUid as Uid from GCS.GalaxyPanel t 
	join GCS.Cluster c on c.ClusterUid = t.ClusterUid
	where c.EntityId = @EntityId
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyPanel_GetAllUidsForEntityId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyPanel_GetAllUidsForEntityId] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[InputDevice_GetAllUidsForEntityId]
	@EntityId [uniqueidentifier]
AS
	select t.InputDeviceUid as Uid  from GCS.InputDevice t 
	where t.EntityId = @EntityId
GO
ALTER AUTHORIZATION ON [GCS].[InputDevice_GetAllUidsForEntityId] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputDevice_GetAllUidsForEntityId] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[AccessPortal_GetAllUidsForClusterUid]
	@ClusterUid [uniqueidentifier]
AS
	select t.AccessPortalUid as Uid from GCS.AccessPortalGalaxyHardwareAddressView t 
	where t.ClusterUid = @ClusterUid
GO
ALTER AUTHORIZATION ON [GCS].[AccessPortal_GetAllUidsForClusterUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[AccessPortal_GetAllUidsForClusterUid] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[GalaxyPanel_GetAllUidsForClusterUid]
	@ClusterUid [uniqueidentifier]
AS
	select t.GalaxyPanelUid as Uid from GCS.GalaxyPanel t 
	where t.ClusterUid = @ClusterUid
GO
ALTER AUTHORIZATION ON [GCS].[GalaxyPanel_GetAllUidsForClusterUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[GalaxyPanel_GetAllUidsForClusterUid] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[InputDevice_GetAllUidsForClusterUid]
	@ClusterUid [uniqueidentifier]
AS
	select t.InputDeviceUid as Uid  from GCS.InputDeviceGalaxyHardwareAddressView t 
	where t.ClusterUid = @ClusterUid
GO
ALTER AUTHORIZATION ON [GCS].[InputDevice_GetAllUidsForClusterUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[InputDevice_GetAllUidsForClusterUid] TO [public] AS [dbo]
GO


CREATE OR ALTER PROCEDURE [GCS].[gcsUser_UpdatePasswordChangeToken]
	@UserId [uniqueidentifier],
	@PasswordResetToken nvarchar(128),
	@PasswordResetTokenExpiration datetimeoffset,
	@TempPassword nvarchar(1024),
	@UserName nvarchar(100),
	@UpdateDate datetimeoffset
AS
	update GCS.gcsUser set PasswordResetToken = @PasswordResetToken, PasswordResetTokenExpiration = @PasswordResetTokenExpiration, UpdateName = @UserName,
	 UpdateDate = @UpdateDate, UserPassword = @TempPassword where UserId = @UserId

GO
ALTER AUTHORIZATION ON [GCS].[gcsUser_UpdatePasswordChangeToken] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsUser_UpdatePasswordChangeToken] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[gcsUser_UpdatePassword]
	@UserId [uniqueidentifier],
	@Password nvarchar(1024),
	@PasswordHash nvarchar(max),
	@UserName nvarchar(100),
	@UpdateDate datetimeoffset
AS
	update GCS.gcsUser set UserPassword = @Password, PasswordHash = @PasswordHash, PasswordResetToken = NULL, PasswordResetTokenExpiration = NULL, ResetPasswordFlag = 0, LastPasswordResetDate = SYSDATETIMEOFFSET(), UpdateName = @UserName,
	 UpdateDate = @UpdateDate where UserId = @UserId and UserPassword <> @Password and PasswordResetTokenExpiration > SYSDATETIMEOFFSET() and PasswordResetToken IS NOT NULL
GO
ALTER AUTHORIZATION ON [GCS].[gcsUser_UpdatePassword] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsUser_UpdatePassword] TO [public] AS [dbo]
GO

CREATE OR ALTER PROCEDURE [GCS].[gcsUser_GetPasswordResetInfo]
	@UserId [uniqueidentifier],
	@UserName nvarchar(100),
	@Email nvarchar(255)

AS
	if @UserId is not null and @UserId <> '00000000-0000-0000-0000-000000000000'
		select UserId, PrimaryEntityId, UserName, Email, ResetPasswordFlag, LastPasswordResetDate, PasswordResetToken, PasswordResetTokenExpiration FROM GCS.gcsUser where UserId = @UserId
	ELSE IF @UserName is not null
		select UserId, PrimaryEntityId, UserName, Email, ResetPasswordFlag, LastPasswordResetDate, PasswordResetToken, PasswordResetTokenExpiration FROM GCS.gcsUser where UserName = @UserName
	ELSE IF @Email is not null
		select UserId, PrimaryEntityId, UserName, Email, ResetPasswordFlag, LastPasswordResetDate, PasswordResetToken, PasswordResetTokenExpiration FROM GCS.gcsUser where Email = @Email
	ELSE
		select UserId, PrimaryEntityId, UserName, Email, ResetPasswordFlag, LastPasswordResetDate, PasswordResetToken, PasswordResetTokenExpiration FROM GCS.gcsUser where UserId IS NULL

GO
ALTER AUTHORIZATION ON [GCS].[gcsUser_GetPasswordResetInfo] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[gcsUser_GetPasswordResetInfo] TO [public] AS [dbo]
GO

/* All Stored Procedures for table: gcsPermission */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_SelectAll]
GO

CREATE PROCEDURE GCS.[gcsPermissionPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionId
,PermissionCategoryId
,PermissionName
,PermissionDescription
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,PermissionTypeId
,Code
FROM GCS.gcsPermission

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsPermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_ByApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_ByApplicationId]
GO
CREATE PROCEDURE GCS.[gcsPermissionPDSA_ByApplicationId]
@ApplicationId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionId
,PermissionCategoryId
,PermissionName
,PermissionDescription
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,PermissionTypeId
,Code
FROM GCS.gcsPermission
WHERE 
PermissionCategoryId = (SELECT PermissionCategoryId from GCS.gcsPermissionCategory WHERE ApplicationId = @ApplicationId)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_ByApplicationId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsPermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_ByPermissionCategoryId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_ByPermissionCategoryId]
GO
CREATE PROCEDURE GCS.[gcsPermissionPDSA_ByPermissionCategoryId]
@PermissionCategoryId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionId
,PermissionCategoryId
,PermissionName
,PermissionDescription
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,PermissionTypeId
,Code
FROM GCS.gcsPermission
WHERE 
PermissionCategoryId = @PermissionCategoryId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_ByPermissionCategoryId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsPermission table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_ByRoleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_ByRoleId]
GO
CREATE PROCEDURE GCS.[gcsPermissionPDSA_ByRoleId]
@RoleId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionId
,PermissionCategoryId
,PermissionName
,PermissionDescription
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,PermissionTypeId
,Code
FROM GCS.gcsPermission
WHERE 
PermissionId IN (SELECT PermissionId FROM GCS.gcsRolePermission WHERE RoleId = @RoleId)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_ByRoleId] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.gcsPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_SelectListBox]
GO

CREATE PROCEDURE GCS.[gcsPermissionPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionId
,PermissionName
,Code
FROM GCS.gcsPermission

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsPermission table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_SelectByPK]
GO
CREATE PROCEDURE GCS.[gcsPermissionPDSA_SelectByPK]
@PermissionId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionId
,PermissionCategoryId
,PermissionName
,PermissionDescription
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,PermissionTypeId
,Code
FROM GCS.gcsPermission
WHERE 
PermissionId = @PermissionId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_SelectSearch]
GO
CREATE PROCEDURE GCS.[gcsPermissionPDSA_SelectSearch]
@PermissionName nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionId
,PermissionCategoryId
,PermissionName
,PermissionDescription
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,PermissionTypeId
,Code
FROM GCS.gcsPermission
WHERE 
(@PermissionName IS NULL OR PermissionName LIKE @PermissionName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.gcsPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_Insert]
GO
CREATE PROCEDURE GCS.[gcsPermissionPDSA_Insert]
@PermissionId uniqueidentifier 
,@PermissionCategoryId uniqueidentifier 
,@PermissionName nvarchar(65) 
,@PermissionDescription nvarchar(255) 
,@IsActive bit 
,@InsertName nvarchar(50) 
,@InsertDate datetime 
,@UpdateName nvarchar(50) 
,@UpdateDate datetime 
,@ConcurrencyValue smallint 
,@PermissionTypeId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;


if @PermissionId = '00000000-0000-0000-0000-000000000000'
	SET @PermissionId = NULL

if @PermissionId = '00000000-0000-0000-0000-000000000000' OR @PermissionId IS NULL
	SET @PermissionId = NewID()

INSERT INTO GCS.gcsPermission
(
PermissionId
,PermissionCategoryId
,PermissionName
,PermissionDescription
,IsActive
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
,PermissionTypeId
) 
VALUES 
(
@PermissionId
,@PermissionCategoryId
,@PermissionName
,@PermissionDescription
,@IsActive
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
,@PermissionTypeId
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsPermission table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_Update]
GO
CREATE PROCEDURE GCS.[gcsPermissionPDSA_Update]
@PermissionId uniqueidentifier 
,@PermissionCategoryId uniqueidentifier
,@PermissionName nvarchar(65)
,@PermissionDescription nvarchar(255)
,@IsActive bit
,@UpdateName nvarchar(50)
,@UpdateDate datetime
,@PermissionTypeId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsPermission
SET 
PermissionCategoryId = @PermissionCategoryId
,PermissionName = @PermissionName
,PermissionDescription = @PermissionDescription
,IsActive = @IsActive
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,PermissionTypeId = @PermissionTypeId
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
PermissionId = @PermissionId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsPermission table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_UpdateConcurrency]
GO
CREATE PROCEDURE GCS.[gcsPermissionPDSA_UpdateConcurrency]
@PermissionId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsPermission
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
PermissionId = @PermissionId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsPermission table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_DeleteByPK]
GO
CREATE PROCEDURE GCS.[gcsPermissionPDSA_DeleteByPK]
@PermissionId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsPermission
WHERE
PermissionId = @PermissionId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsPermission table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionPDSA_RowCount]
GO
CREATE PROCEDURE GCS.[gcsPermissionPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsPermission

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionPDSA_RowCount] TO public
GO

/* All Stored Procedures for table: gcsPermissionCategory */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.gcsPermissionCategory table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionCategoryPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionCategoryPDSA_SelectAll]
GO

CREATE PROCEDURE GCS.[gcsPermissionCategoryPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionCategoryId
,ApplicationId
,CategoryName
,PermissionCategoryDescription
,IsSystemCategory
,IsEntityCategory
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsPermissionCategory

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionCategoryPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.gcsPermissionCategory table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionCategoryPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionCategoryPDSA_SelectListBox]
GO

CREATE PROCEDURE GCS.[gcsPermissionCategoryPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionCategoryId
,CategoryName
FROM GCS.gcsPermissionCategory

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionCategoryPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsPermissionCategory table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionCategoryPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionCategoryPDSA_SelectByPK]
GO
CREATE PROCEDURE GCS.[gcsPermissionCategoryPDSA_SelectByPK]
@PermissionCategoryId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionCategoryId
,ApplicationId
,CategoryName
,PermissionCategoryDescription
,IsSystemCategory
,IsEntityCategory
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsPermissionCategory
WHERE 
PermissionCategoryId = @PermissionCategoryId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionCategoryPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.gcsPermissionCategory table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionCategoryPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionCategoryPDSA_SelectSearch]
GO
CREATE PROCEDURE GCS.[gcsPermissionCategoryPDSA_SelectSearch]
@CategoryName nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionCategoryId
,ApplicationId
,CategoryName
,PermissionCategoryDescription
,IsSystemCategory
,IsEntityCategory
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsPermissionCategory
WHERE 
(@CategoryName IS NULL OR CategoryName LIKE @CategoryName + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionCategoryPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.gcsPermissionCategory table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionCategoryPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionCategoryPDSA_Insert]
GO
CREATE PROCEDURE GCS.[gcsPermissionCategoryPDSA_Insert]
@PermissionCategoryId uniqueidentifier 
,@ApplicationId uniqueidentifier 
,@CategoryName nvarchar(65) 
,@PermissionCategoryDescription nvarchar(255) 
,@IsSystemCategory bit 
,@IsEntityCategory bit 
,@InsertName nvarchar(50) 
,@InsertDate datetime 
,@UpdateName nvarchar(50) 
,@UpdateDate datetime 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

if @PermissionCategoryId = '00000000-0000-0000-0000-000000000000'
	SET @PermissionCategoryId = NULL

if @PermissionCategoryId = '00000000-0000-0000-0000-000000000000' OR @PermissionCategoryId IS NULL
	SET @PermissionCategoryId = NewID()

INSERT INTO GCS.gcsPermissionCategory
(
PermissionCategoryId
,ApplicationId
,CategoryName
,PermissionCategoryDescription
,IsSystemCategory
,IsEntityCategory
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
) 
VALUES 
(
@PermissionCategoryId
,@ApplicationId
,@CategoryName
,@PermissionCategoryDescription
,@IsSystemCategory
,@IsEntityCategory
,@InsertName
,@InsertDate
,@UpdateName
,@UpdateDate
,@ConcurrencyValue
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionCategoryPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.gcsPermissionCategory table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionCategoryPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionCategoryPDSA_Update]
GO
CREATE PROCEDURE GCS.[gcsPermissionCategoryPDSA_Update]
@PermissionCategoryId uniqueidentifier 
,@ApplicationId uniqueidentifier
,@CategoryName nvarchar(65)
,@PermissionCategoryDescription nvarchar(255)
,@IsSystemCategory bit
,@IsEntityCategory bit
,@UpdateName nvarchar(50)
,@UpdateDate datetime
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsPermissionCategory
SET 
PermissionCategoryId = @PermissionCategoryId
,ApplicationId = @ApplicationId
,CategoryName = @CategoryName
,PermissionCategoryDescription = @PermissionCategoryDescription
,IsSystemCategory = @IsSystemCategory
,IsEntityCategory = @IsEntityCategory
,UpdateName = @UpdateName
,UpdateDate = @UpdateDate
,ConcurrencyValue = ConcurrencyValue + 1
WHERE
PermissionCategoryId = @PermissionCategoryId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsPermissionCategoryPDSA_Update] TO public
GO
/************************************************************
'* This stored procedure is used to UPDATE the Concurrency Column in
'* GCS.gcsPermissionCategory table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionCategoryPDSA_UpdateConcurrency]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionCategoryPDSA_UpdateConcurrency]
GO
CREATE PROCEDURE GCS.[gcsPermissionCategoryPDSA_UpdateConcurrency]
@PermissionCategoryId uniqueidentifier 
,@ConcurrencyValue smallint 
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.gcsPermissionCategory
SET 
ConcurrencyValue = @ConcurrencyValue
WHERE
PermissionCategoryId = @PermissionCategoryId

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[gcsPermissionCategoryPDSA_UpdateConcurrency] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.gcsPermissionCategory table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionCategoryPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionCategoryPDSA_DeleteByPK]
GO
CREATE PROCEDURE GCS.[gcsPermissionCategoryPDSA_DeleteByPK]
@PermissionCategoryId uniqueidentifier
,@ConcurrencyValue smallint
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.gcsPermissionCategory
WHERE
PermissionCategoryId = @PermissionCategoryId
 And (ConcurrencyValue = @ConcurrencyValue OR ConcurrencyValue is null)

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionCategoryPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.gcsPermissionCategory table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionCategoryPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionCategoryPDSA_RowCount]
GO
CREATE PROCEDURE GCS.[gcsPermissionCategoryPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.gcsPermissionCategory

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionCategoryPDSA_RowCount] TO public
GO

/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.gcsPermissionCategory table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[gcsPermissionCategoryPDSA_ByApplicationId]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[gcsPermissionCategoryPDSA_ByApplicationId]
GO
CREATE PROCEDURE GCS.[gcsPermissionCategoryPDSA_ByApplicationId]
@ApplicationId uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
PermissionCategoryId
,ApplicationId
,CategoryName
,PermissionCategoryDescription
,IsSystemCategory
,IsEntityCategory
,InsertName
,InsertDate
,UpdateName
,UpdateDate
,ConcurrencyValue
FROM GCS.gcsPermissionCategory
WHERE 
ApplicationId = @ApplicationId

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[gcsPermissionCategoryPDSA_ByApplicationId] TO public
GO

create or alter view [GCS].[PersonalAccessGroup_PanelLoadData] as
select pcp.PersonUid, c.ClusterUid, gp.GalaxyPanelUid, ppag.PersonalAccessGroupNumber, c.ClusterNumber, c.ClusterGroupId, gctsm.PanelScheduleNumber, apgha.DoorNumber, gp.PanelNumber, '' as AccessGroupDisplay, gctsm.TimeScheduleUid, gctsm.TimeScheduleUid as DefaultTimeScheduleUid
from GCS.PersonClusterPermission pcp
join GCS.PersonPersonalAccessGroup ppag on ppag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid
join GCS.Cluster c on c.ClusterUid = pcp.ClusterUid
join  GCS.GalaxyClusterTimeScheduleMap gctsm on gctsm.TimeScheduleUid = ppag.TimeScheduleUid AND gctsm.ClusterUid = c.ClusterUid
join GCS.PersonalAccessGroupAccessPortal pagap on pagap.PersonClusterPermissionUid = ppag.PersonClusterPermissionUid
join  GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = pagap.AccessPortalUid
join  GCS.GalaxyPanel gp on gp.GalaxyPanelUid = apgha.GalaxyPanelUid
GO
ALTER AUTHORIZATION ON [GCS].[PersonalAccessGroup_PanelLoadData] TO  SCHEMA OWNER 
GO


create or alter view [GCS].[PersonalAccessGroupDynamicAccessGroup_PanelLoadData] as
select pcp.PersonUid, c.ClusterUid, gp.GalaxyPanelUid, ppag.PersonalAccessGroupNumber, c.ClusterNumber, c.ClusterGroupId, gctsm.PanelScheduleNumber, apgha.DoorNumber, gp.PanelNumber, ag.Display as AccessGroupDisplay, agap.TimeScheduleUid, ag.DefaultTimeScheduleUid
from GCS.PersonClusterPermission pcp
join GCS.PersonPersonalAccessGroup ppag on ppag.PersonClusterPermissionUid = pcp.PersonClusterPermissionUid
join GCS.Cluster c on c.ClusterUid = pcp.ClusterUid
join GCS.GalaxyClusterTimeScheduleMap gctsm on gctsm.TimeScheduleUid = ppag.TimeScheduleUid AND gctsm.ClusterUid = c.ClusterUid
join GCS.PersonalAccessGroupDynamicAccessGroup pagdag on pagdag.PersonClusterPermissionUid = ppag.PersonClusterPermissionUid
join GCS.AccessGroup ag on ag.AccessGroupUid = pagdag.AccessGroupUid
join GCS.AccessGroupAccessPortal agap on agap.AccessGroupUid = pagdag.AccessGroupUid
join GCS.AccessPortal ap on ap.AccessPortalUid = agap.AccessPortalUid
join GCS.AccessPortalGalaxyHardwareAddress apgha on apgha.AccessPortalUid = ap.AccessPortalUid
join GCS.GalaxyPanel gp on gp.GalaxyPanelUid = apgha.GalaxyPanelUid
GO
ALTER AUTHORIZATION ON [GCS].[PersonalAccessGroupDynamicAccessGroup_PanelLoadData] TO  SCHEMA OWNER 
GO


CREATE OR ALTER PROCEDURE [GCS].[PersonalAccessGroup_PanelLoadDataByClusterUid]
	@ClusterUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

	select * from GCS.PersonalAccessGroup_PanelLoadData
	where ClusterUid = @ClusterUid AND PanelScheduleNumber <> 0 AND PersonalAccessGroupNumber > 0
	union
	select * from GCS.PersonalAccessGroupDynamicAccessGroup_PanelLoadData
	where ClusterUid = @ClusterUid AND PanelScheduleNumber <> 0 AND PersonalAccessGroupNumber > 0
	ORDER BY PersonUid, PanelNumber, DoorNumber
if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[PersonalAccessGroup_PanelLoadDataByClusterUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonalAccessGroup_PanelLoadDataByClusterUid] TO [public] AS [dbo]
GO
/****** Object:  StoredProcedure [GCS].[PersonalAccessGroup_PanelLoadDataByPersonUid]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonalAccessGroup_PanelLoadDataByPersonUid]
	@PersonUid [uniqueidentifier]
WITH EXECUTE AS CALLER
AS
declare @ret int;
select @ret = 0;

	select * from GCS.PersonalAccessGroup_PanelLoadData
	where PersonUid = @PersonUid AND PanelScheduleNumber <> 0 AND PersonalAccessGroupNumber > 0
	union
	select * from GCS.PersonalAccessGroupDynamicAccessGroup_PanelLoadData
	where PersonUid = @PersonUid AND PanelScheduleNumber <> 0 AND PersonalAccessGroupNumber > 0
	--AND ( (TimeScheduleUid IS NULL AND DefaultTimeScheduleUid <> '00000000-0000-0000-0000-000000000001') OR (TimeScheduleUid <> '00000000-0000-0000-0000-000000000001'))
	ORDER BY ClusterUid, PanelNumber, DoorNumber
if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO
ALTER AUTHORIZATION ON [GCS].[PersonalAccessGroup_PanelLoadDataByPersonUid] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonalAccessGroup_PanelLoadDataByPersonUid] TO [public] AS [dbo]
GO



if dbo.fn_GCSDoesTableExist('ActivityEvent') = 0
begin
	/*==============================================================*/
	/* Table: ActivityEvent                                         */
	/*==============================================================*/
	create table GCS.ActivityEvent (
	   ActivityEventUid     uniqueidentifier     not null,
	   ActivityDateTime     datetimeoffset       not null,
	   ActivityDateTimeUTC  AS (ActivityDateTime AT TIME ZONE 'UTC'),
	   EventTypeMessage     nvarchar(65)         not null,
	   ForeColor            int                  not null,
	   ForeColorHex         AS ([GCS].[Int2Rgba](ForeColor)),
	   DeviceName           nvarchar(65)         not null,
	   SiteName             nvarchar(65)         null,
	   EntityId             uniqueidentifier     not null,
	   DeviceUid            uniqueidentifier     not null,
	   EventTypeUid         uniqueidentifier     not null,
	   DeviceType           nvarchar(65)         not null,
	   LastName             nvarchar(65)         null,
	   FirstName            nvarchar(65)         null,
	   IsTraced             bit                  not null,
	   CredentialDescription nvarchar(65)         null,
	   PersonUid            uniqueidentifier     null,
	   CredentialUid        uniqueidentifier     null,
	   ClusterUid           uniqueidentifier     null,
	   ClusterNumber        int                  null,
	   ClusterName          nvarchar(65)         null,
	   ClusterGroupId       int                  null,
	   PanelNumber          int                  null,
	   InputOutputGroupName nvarchar(65)         null,
	   InputOutputGroupNumber int                  null,
	   CpuNumber            smallint             null,
	   BoardNumber          smallint             null,
	   SectionNumber        smallint             null,
	   ModuleNumber         smallint             null,
	   NodeNumber           smallint             null,
	   AlarmPriority        int                  null,
	   ResponseRequired     bit                  null,
	 --  IsAcknowledgeable    bit                  null,
	   EntityName           nvarchar(65)         not null,
	   EntityType           nvarchar(65)         not null,
	   BufferIndex          int                  not null,
	   CredentialBytes      varbinary(32)        null,
	   InsertDate			datetimeoffset		 not null default SYSDATETIMEOFFSET()
	   constraint PK_ACTIVITYEVENT primary key (ActivityEventUid)
	)
end
go

/*==============================================================*/
/* Index: idxActivityEventActivityDateTime                      */
/*==============================================================*/
if dbo.[fn_GCSDoesIndexExist]('ActivityEvent', 'idxActivityEventActivityDateTime') = 0
BEGIN
	create nonclustered index idxActivityEventActivityDateTime on GCS.ActivityEvent (ActivityDateTime ASC)
end
go

/*==============================================================*/
/* Index: idxActivityEventEntityId                              */
/*==============================================================*/
if dbo.[fn_GCSDoesIndexExist]('ActivityEvent', 'idxActivityEventEntityId') = 0
BEGIN
	create nonclustered index idxActivityEventEntityId on GCS.ActivityEvent (EntityId ASC)
END
go

/*==============================================================*/
/* Index: idxActivityEventDeviceUid                             */
/*==============================================================*/
if dbo.[fn_GCSDoesIndexExist]('ActivityEvent', 'idxActivityEventDeviceUid') = 0
BEGIN
	create nonclustered index idxActivityEventDeviceUid on GCS.ActivityEvent (DeviceUid ASC)
END
go

/*==============================================================*/
/* Index: idxActivityEventPersonUid                             */
/*==============================================================*/
if dbo.[fn_GCSDoesIndexExist]('ActivityEvent', 'idxActivityEventPersonUid') = 0
BEGIN
	create nonclustered index idxActivityEventPersonUid on GCS.ActivityEvent (PersonUid ASC)
END
go


if dbo.fn_GCSDoesTableExist('ActivityEventAcknowledgement') = 0
begin
	/*==============================================================*/
	/* Table: ActivityEventAcknowledgement                          */
	/*==============================================================*/
	create table GCS.ActivityEventAcknowledgement (
	   ActivityEventAcknowledgementUid uniqueidentifier             not null,
	   ActivityEventUid     uniqueidentifier     not null,
	   DeviceEntityId       uniqueidentifier     not null,
	   DeviceUid            uniqueidentifier     not null,
	   ActivityEventCategory nvarchar(65)         not null,
	   Response             nvarchar(1000)       null,
	   AckedByUserId        uniqueidentifier     not null,
	   AckedByUserDisplayName nvarchar(100)        not null,
	   AckedDateTime        datetimeoffset       not null,
	   AckedUpdatedDateTime datetimeoffset       null,
	   constraint PK_ACTIVITYEVENTACKNOWLEDGEMEN primary key (ActivityEventAcknowledgementUid)
	)

	alter table GCS.ActivityEventAcknowledgement
	   add constraint FK_ActivityEventAcknowledgementActivityEvent foreign key (ActivityEventUid)
		  references GCS.ActivityEvent (ActivityEventUid)
			 on update cascade on delete cascade
end
go


/*==============================================================*/
/* Index: idxActivityEventAcknowledgementDeviceUid                                          */
/*==============================================================*/
if dbo.[fn_GCSDoesIndexExist]('ActivityEventAcknowledgement', 'idxActivityEventAcknowledgementDeviceUid') = 0
BEGIN
	create nonclustered index idxActivityEventAcknowledgementDeviceUid on GCS.ActivityEventAcknowledgement (DeviceUid ASC)
END
go

/*==============================================================*/
/* Index: idxActivityEventAcknowledgementActivityEventUid                                   */
/*==============================================================*/
if dbo.[fn_GCSDoesIndexExist]('ActivityEventAcknowledgement', 'idxActivityEventAcknowledgementActivityEventUid') = 0
BEGIN
	create nonclustered index idxActivityEventAcknowledgementActivityEventUid on GCS.ActivityEventAcknowledgement (ActivityEventUid ASC)
END
go


CREATE OR ALTER FUNCTION [GCS].[IsActivityEventAcknowledged] (@activityEventUid uniqueidentifier) 
RETURNS bit
as
begin
	
	if exists (select ActivityEventUid from GCS.ActivityEventAcknowledgement where ActivityEventUid = @activityEventUid)
		return 1
	return 0
end
go

GRANT EXECUTE ON GCS.[IsActivityEventAcknowledged] TO public
GO


CREATE OR ALTER FUNCTION [GCS].[GetActivityEventAcknowledgementCount] (@activityEventUid uniqueidentifier) 
RETURNS int
as
begin
	declare @count int = 0

	select @count = count(*) from GCS.ActivityEventAcknowledgement where ActivityEventUid = @activityEventUid
	return @count
end
go

GRANT EXECUTE ON GCS.[GetActivityEventAcknowledgementCount] TO public
GO
 
if ( select count(*) from GCS.ActivityEvent ) = 0
begin
	-- print populating GCS.ActivityEvent
	INSERT INTO [GCS].[ActivityEvent]
           ([ActivityEventUid]
           ,[ActivityDateTime]
           ,[EventTypeMessage]
           ,[ForeColor]
           ,[DeviceName]
           ,[SiteName]
           ,[EntityId]
           ,[DeviceUid]
           ,[EventTypeUid]
           ,[DeviceType]
           ,[LastName]
           ,[FirstName]
           ,[IsTraced]
           ,[CredentialDescription]
           ,[PersonUid]
           ,[CredentialUid]
           ,[ClusterUid]
           ,[ClusterNumber]
           ,[ClusterName]
           ,[ClusterGroupId]
           ,[PanelNumber]
           ,[InputOutputGroupName]
           ,[InputOutputGroupNumber]
           ,[CpuNumber]
           ,[BoardNumber]
           ,[SectionNumber]
           ,[ModuleNumber]
           ,[NodeNumber]
           ,[AlarmPriority]
           ,[ResponseRequired]
   --        ,[IsAcknowledgeable]
           ,[EntityName]
           ,[EntityType]
		   ,BufferIndex)
		select PK 
			,[ActivityDateTime]
           ,[EventTypeMessage]
           ,[ForeColor]
           ,[DeviceName]
           ,[SiteName]
           ,[EntityId]
           ,[DeviceUid]
           ,[EventTypeUid]
           ,[DeviceType]
           ,[LastName]
           ,[FirstName]
           ,[IsTraced]
           ,[CredentialDescription]
           ,[PersonUid]
           ,[CredentialUid]
           ,[ClusterUid]
           ,[ClusterNumber]
           ,[ClusterName]
           ,[ClusterGroupId]
           ,[PanelNumber]
           ,[InputOutputGroupName]
           ,[InputOutputGroupNumber]
           ,[CpuNumber]
           ,[BoardNumber]
           ,[SectionNumber]
           ,[ModuleNumber]
           ,[NodeNumber]
           ,[AlarmPriority]
           ,[ResponseRequired]
  --         ,[IsAcknowledgeable]
           ,[EntityName]
           ,[EntityType],
		   0 from GCS.ActivityHistoryView order by ActivityDateTime

end
go

--select * from GCS.ActivityEvent
--select * from GCS.ActivityEventAcknowledgement

if ( select count(*) from GCS.ActivityEventAcknowledgement ) = 0
begin
	-- print populating GCS.ActivityEventAcknowledgement
INSERT INTO [GCS].[ActivityEventAcknowledgement]
           ([ActivityEventAcknowledgementUid]
           ,[ActivityEventUid]
           ,[DeviceEntityId]
           ,[DeviceUid]
           ,[ActivityEventCategory]
           ,[Response]
           ,[AckedByUserId]
           ,[AckedByUserDisplayName]
           ,[AckedDateTime]
           ,[AckedUpdatedDateTime])
     SELECT AccessPortalAlarmEventAcknowledgmentUid
           ,[ActivityEventUid]
           ,[DeviceEntityId]
           ,[DeviceUid]
           ,'Door'
           ,[Response]
           ,[AckedByUserId]
           ,[AckedByUserDisplayName]
           ,[AckedDateTime]
           ,[AckedUpdatedDateTime] 
		   FROM GCS.AcknowledgedAlarmBasicData where AccessPortalAlarmEventAcknowledgmentUid is not null
	UNION
	     SELECT GalaxyPanelAlarmEventAcknowledgmentUid
           ,[ActivityEventUid]
           ,[DeviceEntityId]
           ,[DeviceUid]
           ,'Panel'
           ,[Response]
           ,[AckedByUserId]
           ,[AckedByUserDisplayName]
           ,[AckedDateTime]
           ,[AckedUpdatedDateTime] 
		   FROM GCS.AcknowledgedAlarmBasicData where GalaxyPanelAlarmEventAcknowledgmentUid is not null
	UNION
	     SELECT InputDeviceAlarmEventAcknowledgmentUid
           ,[ActivityEventUid]
           ,[DeviceEntityId]
           ,[DeviceUid]
           ,'Input'
           ,[Response]
           ,[AckedByUserId]
           ,[AckedByUserDisplayName]
           ,[AckedDateTime]
           ,[AckedUpdatedDateTime] 
		   FROM GCS.AcknowledgedAlarmBasicData where InputDeviceAlarmEventAcknowledgmentUid is not null
end
go


create or alter view GCS.ActivityEventView WITH SCHEMABINDING 
as
	select ActivityDateTime, 
	ActivityDateTimeUTC,
	EventTypeMessage,
	ForeColor,
	ForeColorHex,
	DeviceName, 
	SiteName, 
	EntityId, 
	ae.DeviceUid, 
	EventTypeUid,
	DeviceType, 
	LastName, FirstName, IsTraced,
	CredentialDescription,
	PersonUid, CredentialUid,
	ClusterUid,
	ClusterNumber,
	ClusterName,
	ClusterGroupId,
	PanelNumber,
	InputOutputGroupName,
	InputOutputGroupNumber,
	CpuNumber,
	BoardNumber,
	SectionNumber,
	ModuleNumber,
	NodeNumber,
	ae.ActivityEventUid,	
	AlarmPriority,
	ResponseRequired,
	AckData.AcknowledgedTime,
	AckData.AcknowledgeComment,
	AckData.IsAcknowledgeable,
	IIF( (select count(*) from GCS.ActivityEventAcknowledgement aea where aea.ActivityEventUid = ae.ActivityEventUid) = 0, 0, 1) as IsAcknowledged,
	AckData.AcknowledgedByUser,
	EntityName, EntityType,
	(select count(*) from GCS.ActivityEventAcknowledgement aea where aea.ActivityEventUid =  ae.ActivityEventUid) as AckCount,
	COUNT(*) OVER() as TotalRecordCount,0 as PageNumber,0 as PageSize from GCS.ActivityEvent ae
	--left outer join GCS.ActivityEventAcknowledgement aea on aea.ActivityEventUid = ae.ActivityEventUid
	--left outer join GCS.AccessPortalAlarmEventAcknowledgment apaea on apaea.AccessPortalActivityEventUid = apae.AccessPortalActivityEventUid
	--left outer join GCS.gcsUser u on u.UserId = apaea.UserId
	OUTER APPLY (SELECT TOP 1 aea.AckedDateTime AS AcknowledgedTime, Response as AcknowledgeComment, 
	CASE WHEN AlarmPriority IS NOT NULL THEN 1 ELSE 0 END AS IsAcknowledgeable,
	CASE WHEN aea.AckedDateTime IS NOT NULL THEN 1 ELSE 0 END AS IsAcknowledged,
	AckedByUserDisplayName as AcknowledgedByUser
	FROM GCS.ActivityEventAcknowledgement aea
	WHERE aea.ActivityEventUid = ae.ActivityEventUid) AckData
go	


CREATE OR ALTER PROCEDURE GCS.[select_ActivityEvents]
@EntityId uniqueidentifier,
@UserId uniqueidentifier = null,
@StartDateTime datetimeoffset = null,
@EndDateTime datetimeoffset = null,
@DeviceUid uniqueidentifier = null,
@PersonUid uniqueidentifier = null,
@CredentialUid uniqueidentifier = null,
@ClusterUid uniqueidentifier = null,
@EventTypeUids nvarchar(2000) = null,
@IsAcknowledgeable bit = null,
@IsActionRequired bit = null,
@IsTraced bit = null,
@StartPriority int = null,
@EndPriority int = null,
@Priorities nvarchar(1000) = null,
@JustNumber bit = 0,
@PageNumber int = 0,
@PageSize int = 0,
@SortColumn nvarchar(255) = 'ActivityDateTime',
@DescendingOrder bit = 1,
@CultureName nvarchar(20) = null,
@IncludeLoggingOnOffEvents bit = 0
AS

IF @StartDateTime is null OR @StartDateTime < '1900-01-01'--min(ActivityDateTime) from GCS.AccessPortalActivityEvent
	SELECT @StartDateTime = '1900-01-01' --dateadd(d, -1, SYSDATETIMEOFFSET())
if @EndDateTime is null OR @EndDateTime < @StartDateTime
	select @EndDateTime = dateadd(d, 1, SYSDATETIMEOFFSET())-- @StartDateTime)

--print convert(nvarchar, @StartDateTime, 0)
--print convert(nvarchar, @StartDateTime, 1)
--print convert(nvarchar, @EndDateTime, 0)
--print convert(nvarchar, @EndDateTime, 1)

declare @languageId uniqueidentifier
declare @dynSql nvarchar(max) = N''
declare @pagingSqlClause nvarchar(200) = N''
DECLARE @totalPages int = 0

if @SortColumn is not null and len(@SortColumn) > 0
begin
	set @SortColumn = TRIM(@SortColumn)
end

if @SortColumn is null or len(@SortColumn) = 0
	set @SortColumn = 'ActivityDateTime'


--IF @CultureName IS NULL OR LEN(LTRIM(@CultureName)) = 0 SET @CultureName = 'en-US'

--select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

if @PageNumber is null
	set @PageNumber = 0

if @PageSize is null
	set @PageSize = 0

if @PageSize > 0 AND @PageNumber > 0 
BEGIN
	DECLARE @pagedOffset int
	select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
	set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
END

--set @dynSql = N'select COUNT(*) OVER() TotalItemCount, * from GCS.ActivityHistoryView WHERE ActivityDateTime >= ''' + cast(@StartDateTime as nvarchar) + N''''
if @JustNumber is null or @JustNumber <> 1
begin
set @dynSql = N'select COUNT(*) OVER() TotalItemCount, ActivityEventUid as PK, ActivityDateTime, ActivityDateTimeUTC, AcknowledgeComment, AcknowledgedTime, EventTypeUid, EventTypeMessage, ForeColorHex, AlarmPriority, DeviceType, DeviceUid, DeviceName, PersonUid, LastName, FirstName, IsTraced, CredentialDescription, ClusterUid, ClusterName, InputOutputGroupName, IsAcknowledgeable, AckCount, IsAcknowledged, AcknowledgedByUser, EntityId, EntityName, EntityType from GCS.ActivityEventView WHERE ActivityDateTime >= ''' + convert(nvarchar, @StartDateTime, 0) + N''''
end
else
begin
set @pagingSqlClause = N''
set @dynSql = N'select COUNT(*) as TotalItemCount, null as PK, null as ActivityDateTime, null as ActivityDateTimeUTC, null as AcknowledgeComment, null as AcknowledgedTime, null as EventTypeUid, null as EventTypeMessage, null as ForeColorHex, null as AlarmPriority, null as DeviceType, null as DeviceUid, null as DeviceName, null as PersonUid, null as LastName, null as FirstName, null as IsTraced, null as CredentialDescription, null as ClusterUid, null as ClusterName, null as InputOutputGroupName, IsAcknowledgeable, AckCount, IsAcknowledged, AcknowledgedByUser, EntityId, EntityName, EntityType from GCS.ActivityEventView WHERE ActivityDateTime >= ''' + convert(nvarchar, @StartDateTime, 0) + N''''
end

if @EndDateTime is not null 
begin
	if @EndDateTime < @StartDateTime
		set @EndDateTime = DATEADD( d, 1, @StartDateTime)
	set @dynSql = @dynSql + N' AND ActivityDateTime <= ''' + convert(nvarchar, @EndDateTime, 0) + ''''
end

if @EntityId is not null AND @EntityId <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND EntityId = ''' + cast(@EntityId as nvarchar(100)) + ''''
end

if @UserId is not null AND @UserId <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND EntityId in (select EntityId from GCS.gcsUserEntity where UserId = ''' + cast(@UserId as nvarchar(40)) + ''')'
end

if @DeviceUid is not null AND @DeviceUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND DeviceUid = ''' + cast(@DeviceUid as nvarchar(100)) + ''''
end

if @PersonUid is not null AND @PersonUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND PersonUid = ''' + cast(@PersonUid as nvarchar(100)) + ''''
end

if @IsTraced is not null AND @IsTraced = 1
begin
	set @dynSql = @dynSql + N' AND IsTraced = 1'
end

if @CredentialUid is not null AND @CredentialUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND CredentialUid = ''' + cast(@CredentialUid as nvarchar(100)) + ''''
end

if @ClusterUid is not null AND @ClusterUid <> '00000000-0000-0000-0000-000000000000'
begin
	set @dynSql = @dynSql + N' AND ClusterUid = ''' + cast(@ClusterUid as nvarchar(100)) + ''''
end

if @IsAcknowledgeable is not null AND @IsAcknowledgeable = 1
begin
	--set @dynSql = @dynSql + N' AND AlarmPriority IS NOT NULL'
	set @dynSql = @dynSql + N' AND IsAcknowledgeable = 1'
end

if @IsActionRequired is not null AND @IsActionRequired = 1
begin
	set @dynSql = @dynSql + N' AND ResponseRequired = 1'
end

if @StartPriority is not null and @StartPriority > 0
begin
	set @dynSql = @dynSql + N' AND AlarmPriority IS NOT NULL AND AlarmPriority >= ' + cast(@StartPriority AS NVARCHAR)
end

if @EndPriority is not null and @EndPriority > 0
begin
	set @dynSql = @dynSql + N' AND (AlarmPriority IS NULL OR AlarmPriority <= ' + cast(@EndPriority AS NVARCHAR) + ')'
end

if @Priorities is not null and LEN(TRIM(@Priorities)) > 0 
begin
-- split @Priorities into lust of numbers
	set @dynSql = @dynSql + N' AND AlarmPriority IS NOT NULL AND AlarmPriority in (' + @Priorities + ')'
	--SELECT * INTO #Priorities FROM fnSPLIT_int( @Priorities, N',')	
end

if @EventTypeUids is not null and LEN(TRIM(@EventTypeUids)) > 0 
begin
-- split @Priorities into lust of numbers
	set @dynSql = @dynSql + N' AND EventTypeUid in (' + @EventTypeUids + ')'
	--SELECT * INTO #Priorities FROM fnSPLIT_int( @Priorities, N',')	
end

if @IncludeLoggingOnOffEvents IS NOT NULL AND @IncludeLoggingOnOffEvents = 0
BEGIN
	set @dynSql = @dynSql + N' AND EventTypeUid NOT IN (''00000000-0000-0000-0001-000000009760'', ''00000000-0000-0000-0001-000000009761'')'
END

if @JustNumber is null or @JustNumber <> 1
begin
	set @dynSql = @dynSql + N' ORDER BY ' + @SortColumn 
	if @DescendingOrder = 1
		set @dynSql = @dynSql + N' desc'

	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @dynSql = @dynSql + @pagingSqlClause
	END
end

print @dynSql
exec sp_executesql @dynSql
GO

GRANT EXECUTE ON GCS.[select_ActivityEvents] TO public
GO


exec GCS.[select_ActivityHistory] '00000000-0000-0000-0000-000000000002'
exec GCS.[select_ActivityEvents] '00000000-0000-0000-0000-000000000002'
--select * from GCS.ActivityEventAcknowledgement

/* All Stored Procedures for table: ActivityEvent */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.ActivityEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventPDSA_SelectAll]
GO

CREATE PROCEDURE GCS.[ActivityEventPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
ActivityEventUid
,ActivityDateTime
,ActivityDateTimeUTC
,EventTypeMessage
,ForeColor
,ForeColorHex
,DeviceName
,SiteName
,EntityId
,DeviceUid
,EventTypeUid
,DeviceType
,LastName
,FirstName
,IsTraced
,CredentialDescription
,PersonUid
,CredentialUid
,ClusterUid
,ClusterNumber
,ClusterName
,ClusterGroupId
,PanelNumber
,InputOutputGroupName
,InputOutputGroupNumber
,CpuNumber
,BoardNumber
,SectionNumber
,ModuleNumber
,NodeNumber
,AlarmPriority
,ResponseRequired
,EntityName
,EntityType
,BufferIndex
,CredentialBytes
,InsertDate
FROM GCS.ActivityEvent

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.ActivityEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventPDSA_SelectListBox]
GO

CREATE PROCEDURE GCS.[ActivityEventPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
ActivityEventUid
,ActivityDateTime
FROM GCS.ActivityEvent

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.ActivityEvent table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventPDSA_SelectByPK]
GO
CREATE PROCEDURE GCS.[ActivityEventPDSA_SelectByPK]
@ActivityEventUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
ActivityEventUid
,ActivityDateTime
,ActivityDateTimeUTC
,EventTypeMessage
,ForeColor
,ForeColorHex
,DeviceName
,SiteName
,EntityId
,DeviceUid
,EventTypeUid
,DeviceType
,LastName
,FirstName
,IsTraced
,CredentialDescription
,PersonUid
,CredentialUid
,ClusterUid
,ClusterNumber
,ClusterName
,ClusterGroupId
,PanelNumber
,InputOutputGroupName
,InputOutputGroupNumber
,CpuNumber
,BoardNumber
,SectionNumber
,ModuleNumber
,NodeNumber
,AlarmPriority
,ResponseRequired
,EntityName
,EntityType
,BufferIndex
,CredentialBytes
,InsertDate
FROM GCS.ActivityEvent
WHERE 
ActivityEventUid = @ActivityEventUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.ActivityEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventPDSA_SelectSearch]
GO
CREATE PROCEDURE GCS.[ActivityEventPDSA_SelectSearch]
@ActivityDateTime datetimeoffset 
AS

declare @ret int;
select @ret = 0;

SELECT 
ActivityEventUid
,ActivityDateTime
,ActivityDateTimeUTC
,EventTypeMessage
,ForeColor
,ForeColorHex
,DeviceName
,SiteName
,EntityId
,DeviceUid
,EventTypeUid
,DeviceType
,LastName
,FirstName
,IsTraced
,CredentialDescription
,PersonUid
,CredentialUid
,ClusterUid
,ClusterNumber
,ClusterName
,ClusterGroupId
,PanelNumber
,InputOutputGroupName
,InputOutputGroupNumber
,CpuNumber
,BoardNumber
,SectionNumber
,ModuleNumber
,NodeNumber
,AlarmPriority
,ResponseRequired
,EntityName
,EntityType
,BufferIndex
,CredentialBytes
,InsertDate
FROM GCS.ActivityEvent
WHERE 
(@ActivityDateTime IS NULL OR ActivityDateTime = @ActivityDateTime )

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventPDSA_SelectSearch] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.ActivityEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventPDSA_Insert]
GO
CREATE PROCEDURE GCS.[ActivityEventPDSA_Insert]
@ActivityEventUid uniqueidentifier 
,@ActivityDateTime datetimeoffset 
,@EventTypeMessage nvarchar(65) 
,@ForeColor int 
,@DeviceName nvarchar(65) 
,@SiteName nvarchar(65)  = null
,@EntityId uniqueidentifier 
,@DeviceUid uniqueidentifier 
,@EventTypeUid uniqueidentifier 
,@DeviceType nvarchar(65) 
,@LastName nvarchar(65)  = null
,@FirstName nvarchar(65)  = null
,@IsTraced bit 
,@CredentialDescription nvarchar(65)  = null
,@PersonUid uniqueidentifier  = null
,@CredentialUid uniqueidentifier  = null
,@ClusterUid uniqueidentifier  = null
,@ClusterNumber int  = null
,@ClusterName nvarchar(65)  = null
,@ClusterGroupId int  = null
,@PanelNumber int  = null
,@InputOutputGroupName nvarchar(65)  = null
,@InputOutputGroupNumber int  = null
,@CpuNumber smallint  = null
,@BoardNumber smallint  = null
,@SectionNumber smallint  = null
,@ModuleNumber smallint  = null
,@NodeNumber smallint  = null
,@AlarmPriority int  = null
,@ResponseRequired bit  = null
,@EntityName nvarchar(65) 
,@EntityType nvarchar(65) 
,@BufferIndex int
,@CredentialBytes varbinary(32)
,@InsertDate datetimeoffset
AS

declare @ret int;
select @ret = 0;

if @PersonUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonUid = NULL
if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL
if @ClusterUid = '00000000-0000-0000-0000-000000000000'
	SET @ClusterUid = NULL

if @InsertDate is null
	set @InsertDate = SYSDATETIMEOFFSET()

INSERT INTO GCS.ActivityEvent
(
ActivityEventUid
,ActivityDateTime
,EventTypeMessage
,ForeColor
,DeviceName
,SiteName
,EntityId
,DeviceUid
,EventTypeUid
,DeviceType
,LastName
,FirstName
,IsTraced
,CredentialDescription
,PersonUid
,CredentialUid
,ClusterUid
,ClusterNumber
,ClusterName
,ClusterGroupId
,PanelNumber
,InputOutputGroupName
,InputOutputGroupNumber
,CpuNumber
,BoardNumber
,SectionNumber
,ModuleNumber
,NodeNumber
,AlarmPriority
,ResponseRequired
,EntityName
,EntityType
,BufferIndex
,CredentialBytes
,InsertDate
) 
VALUES 
(
@ActivityEventUid
,@ActivityDateTime
,@EventTypeMessage
,@ForeColor
,@DeviceName
,@SiteName
,@EntityId
,@DeviceUid
,@EventTypeUid
,@DeviceType
,@LastName
,@FirstName
,@IsTraced
,@CredentialDescription
,@PersonUid
,@CredentialUid
,@ClusterUid
,@ClusterNumber
,@ClusterName
,@ClusterGroupId
,@PanelNumber
,@InputOutputGroupName
,@InputOutputGroupNumber
,@CpuNumber
,@BoardNumber
,@SectionNumber
,@ModuleNumber
,@NodeNumber
,@AlarmPriority
,@ResponseRequired
,@EntityName
,@EntityType
,@BufferIndex
,@CredentialBytes
,@InsertDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventPDSA_Insert] TO public
GO


/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.ActivityEvent table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventPDSA_Update]
GO
CREATE PROCEDURE GCS.[ActivityEventPDSA_Update]
@ActivityEventUid uniqueidentifier 
,@ActivityDateTime datetimeoffset
,@EventTypeMessage nvarchar(65)
,@ForeColor int
,@DeviceName nvarchar(65)
,@SiteName nvarchar(65)
,@EntityId uniqueidentifier
,@DeviceUid uniqueidentifier
,@EventTypeUid uniqueidentifier
,@DeviceType nvarchar(65)
,@LastName nvarchar(65)
,@FirstName nvarchar(65)
,@IsTraced bit
,@CredentialDescription nvarchar(65)
,@PersonUid uniqueidentifier
,@CredentialUid uniqueidentifier
,@ClusterUid uniqueidentifier
,@ClusterNumber int
,@ClusterName nvarchar(65)
,@ClusterGroupId int
,@PanelNumber int
,@InputOutputGroupName nvarchar(65)
,@InputOutputGroupNumber int
,@CpuNumber smallint
,@BoardNumber smallint
,@SectionNumber smallint
,@ModuleNumber smallint
,@NodeNumber smallint
,@AlarmPriority int
,@ResponseRequired bit
,@EntityName nvarchar(65)
,@EntityType nvarchar(65)
,@BufferIndex int
,@CredentialBytes varbinary(32)
AS

declare @ret int;
select @ret = 0;

if @PersonUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonUid = NULL
if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL
if @ClusterUid = '00000000-0000-0000-0000-000000000000'
	SET @ClusterUid = NULL

UPDATE GCS.ActivityEvent
SET 
ActivityEventUid = @ActivityEventUid
,ActivityDateTime = @ActivityDateTime
,EventTypeMessage = @EventTypeMessage
,ForeColor = @ForeColor
,DeviceName = @DeviceName
,SiteName = @SiteName
,EntityId = @EntityId
,DeviceUid = @DeviceUid
,EventTypeUid = @EventTypeUid
,DeviceType = @DeviceType
,LastName = @LastName
,FirstName = @FirstName
,IsTraced = @IsTraced
,CredentialDescription = @CredentialDescription
,PersonUid = @PersonUid
,CredentialUid = @CredentialUid
,ClusterUid = @ClusterUid
,ClusterNumber = @ClusterNumber
,ClusterName = @ClusterName
,ClusterGroupId = @ClusterGroupId
,PanelNumber = @PanelNumber
,InputOutputGroupName = @InputOutputGroupName
,InputOutputGroupNumber = @InputOutputGroupNumber
,CpuNumber = @CpuNumber
,BoardNumber = @BoardNumber
,SectionNumber = @SectionNumber
,ModuleNumber = @ModuleNumber
,NodeNumber = @NodeNumber
,AlarmPriority = @AlarmPriority
,ResponseRequired = @ResponseRequired
,EntityName = @EntityName
,EntityType = @EntityType
,BufferIndex = @BufferIndex
,CredentialBytes = @CredentialBytes
WHERE
ActivityEventUid = @ActivityEventUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[ActivityEventPDSA_Update] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.ActivityEvent table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventPDSA_DeleteByPK]
GO
CREATE PROCEDURE GCS.[ActivityEventPDSA_DeleteByPK]
@ActivityEventUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.ActivityEvent
WHERE
ActivityEventUid = @ActivityEventUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.ActivityEvent table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventPDSA_RowCount]
GO
CREATE PROCEDURE GCS.[ActivityEventPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.ActivityEvent

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventPDSA_RowCount] TO public
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[insert_ActivityEvent]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[insert_ActivityEvent]
GO
CREATE PROCEDURE GCS.[insert_ActivityEvent]
@ActivityEventUid uniqueidentifier 
,@ActivityDateTime datetimeoffset 
,@EventTypeMessage nvarchar(65) 
,@ForeColor int 
,@DeviceName nvarchar(65) 
,@SiteName nvarchar(65)  = null
,@EntityId uniqueidentifier 
,@DeviceUid uniqueidentifier 
,@EventTypeUid uniqueidentifier 
,@DeviceType nvarchar(65) 
,@LastName nvarchar(65)  = null
,@FirstName nvarchar(65)  = null
,@IsTraced bit 
,@CredentialDescription nvarchar(65)  = null
,@PersonUid uniqueidentifier  = null
,@CredentialUid uniqueidentifier  = null
,@ClusterUid uniqueidentifier  = null
,@ClusterNumber int  = null
,@ClusterName nvarchar(65)  = null
,@ClusterGroupId int  = null
,@PanelNumber int  = null
,@InputOutputGroupName nvarchar(65)  = null
,@InputOutputGroupNumber int  = null
,@CpuNumber smallint  = null
,@BoardNumber smallint  = null
,@SectionNumber smallint  = null
,@ModuleNumber smallint  = null
,@NodeNumber smallint  = null
,@AlarmPriority int  = null
,@ResponseRequired bit  = null
,@EntityName nvarchar(65) 
,@EntityType nvarchar(65) 
,@BufferIndex int
,@CredentialBytes varbinary(32)
,@InsertDate datetimeoffset
,@IsAlarmEvent bit
,@IsAccessGrantedEvent bit
AS

declare @ret int;
select @ret = 0;

if @PersonUid = '00000000-0000-0000-0000-000000000000'
	SET @PersonUid = NULL
if @CredentialUid = '00000000-0000-0000-0000-000000000000'
	SET @CredentialUid = NULL
if @ClusterUid = '00000000-0000-0000-0000-000000000000'
	SET @ClusterUid = NULL

if @InsertDate is null
	set @InsertDate = SYSDATETIMEOFFSET()

INSERT INTO GCS.ActivityEvent
(
ActivityEventUid
,ActivityDateTime
,EventTypeMessage
,ForeColor
,DeviceName
,SiteName
,EntityId
,DeviceUid
,EventTypeUid
,DeviceType
,LastName
,FirstName
,IsTraced
,CredentialDescription
,PersonUid
,CredentialUid
,ClusterUid
,ClusterNumber
,ClusterName
,ClusterGroupId
,PanelNumber
,InputOutputGroupName
,InputOutputGroupNumber
,CpuNumber
,BoardNumber
,SectionNumber
,ModuleNumber
,NodeNumber
,AlarmPriority
,ResponseRequired
,EntityName
,EntityType
,BufferIndex
,CredentialBytes
,InsertDate
) 
VALUES 
(
@ActivityEventUid
,@ActivityDateTime
,@EventTypeMessage
,@ForeColor
,@DeviceName
,@SiteName
,@EntityId
,@DeviceUid
,@EventTypeUid
,@DeviceType
,@LastName
,@FirstName
,@IsTraced
,@CredentialDescription
,@PersonUid
,@CredentialUid
,@ClusterUid
,@ClusterNumber
,@ClusterName
,@ClusterGroupId
,@PanelNumber
,@InputOutputGroupName
,@InputOutputGroupNumber
,@CpuNumber
,@BoardNumber
,@SectionNumber
,@ModuleNumber
,@NodeNumber
,@AlarmPriority
,@ResponseRequired
,@EntityName
,@EntityType
,@BufferIndex
,@CredentialBytes
,@InsertDate
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[insert_ActivityEvent] TO public
GO






/* All Stored Procedures for table: ActivityEventAcknowledgement */

/************************************************************
'* This stored procedure is used to retrieve all rows & columns from the
'* GCS.ActivityEventAcknowledgement table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventAcknowledgementPDSA_SelectAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_SelectAll]
GO

CREATE PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_SelectAll]
AS

declare @ret int;
select @ret = 0;

SELECT 
ActivityEventAcknowledgementUid
,ActivityEventUid
,DeviceEntityId
,DeviceUid
,ActivityEventCategory
,Response
,AckedByUserId
,AckedByUserDisplayName
,AckedDateTime
,AckedUpdatedDateTime
FROM GCS.ActivityEventAcknowledgement

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventAcknowledgementPDSA_SelectAll] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all rows and the primary key column and the 'description' column
'* in the GCS.ActivityEventAcknowledgement table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventAcknowledgementPDSA_SelectListBox]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_SelectListBox]
GO

CREATE PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_SelectListBox]
AS

declare @ret int;
select @ret = 0;

SELECT 
ActivityEventAcknowledgementUid
,ActivityEventCategory
FROM GCS.ActivityEventAcknowledgement

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventAcknowledgementPDSA_SelectListBox] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.ActivityEventAcknowledgement table 
'* for a single row of data based on the primary key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventAcknowledgementPDSA_SelectByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_SelectByPK]
GO
CREATE PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_SelectByPK]
@ActivityEventAcknowledgementUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
ActivityEventAcknowledgementUid
,ActivityEventUid
,DeviceEntityId
,DeviceUid
,ActivityEventCategory
,Response
,AckedByUserId
,AckedByUserDisplayName
,AckedDateTime
,AckedUpdatedDateTime
FROM GCS.ActivityEventAcknowledgement
WHERE 
ActivityEventAcknowledgementUid = @ActivityEventAcknowledgementUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventAcknowledgementPDSA_SelectByPK] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns and
'* the rows that match the search fields passed in
'* for the GCS.ActivityEventAcknowledgement table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventAcknowledgementPDSA_SelectSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_SelectSearch]
GO
CREATE PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_SelectSearch]
@ActivityEventCategory nvarchar(65) 
AS

declare @ret int;
select @ret = 0;

SELECT 
ActivityEventAcknowledgementUid
,ActivityEventUid
,DeviceEntityId
,DeviceUid
,ActivityEventCategory
,Response
,AckedByUserId
,AckedByUserDisplayName
,AckedDateTime
,AckedUpdatedDateTime
FROM GCS.ActivityEventAcknowledgement
WHERE 
(@ActivityEventCategory IS NULL OR ActivityEventCategory LIKE @ActivityEventCategory + '%')

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventAcknowledgementPDSA_SelectSearch] TO public
GO
/************************************************************
'* This stored procedure is used to retrieve all columns from
'* the GCS.ActivityEventAcknowledgement table 
'* for a single row of data based on a foreign key passed in
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventAcknowledgementPDSA_ByActivityEventUid]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_ByActivityEventUid]
GO
CREATE PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_ByActivityEventUid]
@ActivityEventUid uniqueidentifier 
AS

declare @ret int;
select @ret = 0;

SELECT 
ActivityEventAcknowledgementUid
,ActivityEventUid
,DeviceEntityId
,DeviceUid
,ActivityEventCategory
,Response
,AckedByUserId
,AckedByUserDisplayName
,AckedDateTime
,AckedUpdatedDateTime
FROM GCS.ActivityEventAcknowledgement
WHERE 
ActivityEventUid = @ActivityEventUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventAcknowledgementPDSA_ByActivityEventUid] TO public
GO

/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.ActivityEventAcknowledgement table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventAcknowledgementPDSA_Insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_Insert]
GO
CREATE PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_Insert]
@ActivityEventAcknowledgementUid uniqueidentifier 
,@ActivityEventUid uniqueidentifier 
,@DeviceEntityId uniqueidentifier 
,@DeviceUid uniqueidentifier 
,@ActivityEventCategory nvarchar(65) 
,@Response nvarchar(1000)  = null
,@AckedByUserId uniqueidentifier 
,@AckedByUserDisplayName nvarchar(100) 
,@AckedDateTime datetimeoffset 
,@AckedUpdatedDateTime datetimeoffset  = null
AS

declare @ret int;
select @ret = 0;


INSERT INTO GCS.ActivityEventAcknowledgement
(
ActivityEventAcknowledgementUid
,ActivityEventUid
,DeviceEntityId
,DeviceUid
,ActivityEventCategory
,Response
,AckedByUserId
,AckedByUserDisplayName
,AckedDateTime
,AckedUpdatedDateTime
) 
VALUES 
(
@ActivityEventAcknowledgementUid
,@ActivityEventUid
,@DeviceEntityId
,@DeviceUid
,@ActivityEventCategory
,@Response
,@AckedByUserId
,@AckedByUserDisplayName
,@AckedDateTime
,@AckedUpdatedDateTime
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventAcknowledgementPDSA_Insert] TO public
GO

/************************************************************
'* This stored procedure is used to UPDATE all columns in the
'* GCS.ActivityEventAcknowledgement table for a single row of data based on a primary key.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventAcknowledgementPDSA_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_Update]
GO
CREATE PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_Update]
@ActivityEventAcknowledgementUid uniqueidentifier 
,@ActivityEventUid uniqueidentifier
,@DeviceEntityId uniqueidentifier
,@DeviceUid uniqueidentifier
,@ActivityEventCategory nvarchar(65)
,@Response nvarchar(1000)
,@AckedByUserId uniqueidentifier
,@AckedByUserDisplayName nvarchar(100)
,@AckedDateTime datetimeoffset
,@AckedUpdatedDateTime datetimeoffset
AS

declare @ret int;
select @ret = 0;

UPDATE GCS.ActivityEventAcknowledgement
SET 
ActivityEventAcknowledgementUid = @ActivityEventAcknowledgementUid
,ActivityEventUid = @ActivityEventUid
,DeviceEntityId = @DeviceEntityId
,DeviceUid = @DeviceUid
,ActivityEventCategory = @ActivityEventCategory
,Response = @Response
,AckedByUserId = @AckedByUserId
,AckedByUserDisplayName = @AckedByUserDisplayName
,AckedDateTime = @AckedDateTime
,AckedUpdatedDateTime = @AckedUpdatedDateTime
WHERE
ActivityEventAcknowledgementUid = @ActivityEventAcknowledgementUid

IF @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @@ERROR;
GO

GRANT EXECUTE ON GCS.[ActivityEventAcknowledgementPDSA_Update] TO public
GO

/***************************************************************
'* This stored procedure is used to DELETE a single row from the 
'* GCS.ActivityEventAcknowledgement table based on the primary key value passed in.
'***************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventAcknowledgementPDSA_DeleteByPK]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_DeleteByPK]
GO
CREATE PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_DeleteByPK]
@ActivityEventAcknowledgementUid uniqueidentifier
AS

declare @ret int;
select @ret = 0;

DELETE FROM GCS.ActivityEventAcknowledgement
WHERE
ActivityEventAcknowledgementUid = @ActivityEventAcknowledgementUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;
  
RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventAcknowledgementPDSA_DeleteByPK] TO public
GO

/************************************************************
'* This stored procedure is used to count all rows in the 
'* GCS.ActivityEventAcknowledgement table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[ActivityEventAcknowledgementPDSA_RowCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_RowCount]
GO
CREATE PROCEDURE GCS.[ActivityEventAcknowledgementPDSA_RowCount]
AS

declare @ret int;
select @ret = 0;

SELECT Count(*) As NumRecs FROM GCS.ActivityEventAcknowledgement

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[ActivityEventAcknowledgementPDSA_RowCount] TO public
GO


/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.ActivityEventAcknowledgement table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[insert_ActivityEventAcknowledgement]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[insert_ActivityEventAcknowledgement]
GO
CREATE PROCEDURE GCS.[insert_ActivityEventAcknowledgement]
@ActivityEventAcknowledgementUid uniqueidentifier 
,@ActivityEventUid uniqueidentifier 
,@DeviceEntityId uniqueidentifier 
,@DeviceUid uniqueidentifier 
,@ActivityEventCategory nvarchar(65) 
,@Response nvarchar(1000)  = null
,@AckedByUserId uniqueidentifier 
,@AckedDateTime datetimeoffset 
,@AckedUpdatedDateTime datetimeoffset  = null
AS

declare @ret int;
select @ret = 0;

DECLARE @AckedByUserDisplayName nvarchar(100) 
SELECT @AckedByUserDisplayName = DisplayName from GCS.gcsUser where UserId = @AckedByUserId

INSERT INTO GCS.ActivityEventAcknowledgement
(
ActivityEventAcknowledgementUid
,ActivityEventUid
,DeviceEntityId
,DeviceUid
,ActivityEventCategory
,Response
,AckedByUserId
,AckedByUserDisplayName
,AckedDateTime
,AckedUpdatedDateTime
) 
VALUES 
(
@ActivityEventAcknowledgementUid
,@ActivityEventUid
,@DeviceEntityId
,@DeviceUid
,@ActivityEventCategory
,@Response
,@AckedByUserId
,@AckedByUserDisplayName
,@AckedDateTime
,@AckedUpdatedDateTime
)

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[insert_ActivityEventAcknowledgement] TO public
GO


/************************************************************
'* This stored procedure is used to INSERT all columns into the 
'* GCS.ActivityEventAcknowledgement table.
'************************************************************/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[update_ActivityEventAcknowledgement]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[update_ActivityEventAcknowledgement]
GO
CREATE PROCEDURE GCS.[update_ActivityEventAcknowledgement]
@ActivityEventAcknowledgementUid uniqueidentifier 
,@Response nvarchar(1000)
,@AckedByUserId uniqueidentifier 
,@AckedUpdatedDateTime datetimeoffset
AS

declare @ret int;
select @ret = 0;

DECLARE @AckedByUserDisplayName nvarchar(100) 
SELECT @AckedByUserDisplayName = DisplayName from GCS.gcsUser where UserId = @AckedByUserId

UPDATE GCS.ActivityEventAcknowledgement
SET AckedByUserId = @AckedByUserId, AckedByUserDisplayName = @AckedByUserDisplayName, Response = @Response, AckedUpdatedDateTime = @AckedUpdatedDateTime
where ActivityEventAcknowledgementUid = @ActivityEventAcknowledgementUid

if @@ROWCOUNT = 0
  SELECT @ret = -1;

RETURN @ret;
GO

GRANT EXECUTE ON GCS.[update_ActivityEventAcknowledgement] TO public
GO


if dbo.fn_GCSDoesColumnExist('Credential26BitStandard', 'Parts') = 0
BEGIN
	ALTER TABLE GCS.Credential26BitStandard
	ADD Parts as (cast(FacilityCode as nvarchar) + ':' + cast(IdCode as nvarchar));
END
GO

if dbo.fn_GCSDoesColumnExist('CredentialBqt36Bit', 'Parts') = 0
BEGIN
	ALTER TABLE GCS.CredentialBqt36Bit
	ADD Parts as (cast(FacilityCode as nvarchar) + ':' + cast(IdCode as nvarchar) + ':' + cast(IssueCode as nvarchar) );
END
GO

if dbo.fn_GCSDoesColumnExist('CredentialCorporate1K35Bit', 'Parts') = 0
BEGIN
	ALTER TABLE GCS.CredentialCorporate1K35Bit
	ADD Parts as (cast(CompanyCode as nvarchar) + ':' + cast(IdCode as nvarchar));
END
GO


if dbo.fn_GCSDoesColumnExist('CredentialCorporate1K48Bit', 'Parts') = 0
BEGIN
	ALTER TABLE GCS.CredentialCorporate1K48Bit
	ADD Parts as (cast(CompanyCode as nvarchar) + ':' + cast(IdCode as nvarchar));
END
GO


if dbo.fn_GCSDoesColumnExist('CredentialCypress37Bit', 'Parts') = 0
BEGIN
	ALTER TABLE GCS.CredentialCypress37Bit
	ADD Parts as (cast(FacilityCode as nvarchar) + ':' + cast(IdCode as nvarchar));
END
GO


if dbo.fn_GCSDoesColumnExist('CredentialH1030237Bit', 'Parts') = 0
BEGIN
	ALTER TABLE GCS.CredentialH1030237Bit
	ADD Parts as (cast(IdCode as nvarchar));
END
GO


if dbo.fn_GCSDoesColumnExist('CredentialH1030437Bit', 'Parts') = 0
BEGIN
	ALTER TABLE GCS.CredentialH1030437Bit
	ADD Parts as (cast(FacilityCode as nvarchar) + ':' + cast(IdCode as nvarchar));
END
GO


if dbo.fn_GCSDoesColumnExist('CredentialPIV75Bit', 'Parts') = 0
BEGIN
	ALTER TABLE GCS.CredentialPIV75Bit
	ADD Parts as (cast(AgencyCode as nvarchar) + ':' + cast(SiteCode as nvarchar) + ':' + cast(CredentialCode as nvarchar));
END
GO

if dbo.fn_GCSDoesColumnExist('CredentialSoftwareHouse37Bit', 'Parts') = 0
BEGIN
	ALTER TABLE GCS.CredentialSoftwareHouse37Bit
	ADD Parts as (cast(FacilityCode as nvarchar) + ':' + cast(SiteCode as nvarchar) + ':' + cast(IdCode as nvarchar));
END
GO


if dbo.fn_GCSDoesColumnExist('CredentialXceedId40Bit', 'Parts') = 0
BEGIN
	ALTER TABLE GCS.CredentialXceedId40Bit
	ADD Parts as (cast(SiteCode as nvarchar) + ':' + cast(IdCode as nvarchar));
END
GO

if dbo.fn_GCSDoesColumnExist('Credential', 'Parts') = 1
BEGIN
	ALTER TABLE GCS.Credential
	DROP COLUMN Parts
END
GO


CREATE OR ALTER FUNCTION GCS.GetCredentialParts (@CredentialUid uniqueidentifier)
RETURNS nvarchar(100) WITH EXECUTE AS CALLER
AS
BEGIN
	DECLARE @parts nvarchar(100)
	DECLARE @credentialFormatCode smallint = 0
	
	select @credentialFormatCode = cf.CredentialFormatCode, @parts = c.CardNumber from GCS.Credential c join GCS.CredentialFormat cf on cf.CredentialFormatUid = c.CredentialFormatUid
	where c.CredentialUid = @CredentialUid

	IF @credentialFormatCode = 3	-- 26 Bit Wiegand
	BEGIN
		select @parts = Parts FROM GCS.Credential26BitStandard WHERE CredentialUid = @CredentialUid
	END
	ELSE IF @credentialFormatCode = 6	-- Corporate 1000 35 Bit
	BEGIN
		select @parts = Parts FROM GCS.CredentialCorporate1K35Bit WHERE CredentialUid = @CredentialUid
	END
	ELSE IF @credentialFormatCode = 8	-- BQT 36 Bit
	BEGIN
		select @parts = Parts FROM GCS.CredentialBqt36Bit WHERE CredentialUid = @CredentialUid
	END
	ELSE IF @credentialFormatCode = 9	-- XCeed 40 Bit
	BEGIN
		select @parts = Parts FROM GCS.CredentialXceedId40Bit WHERE CredentialUid = @CredentialUid
	END
	--ELSE IF @credentialFormatCode = 10	-- U.S. Government 200 Bit
	--BEGIN
	--	select @parts = CardNumber FROM GCS.Credential WHERE CredentialUid = @CredentialUid
	--END
	ELSE IF @credentialFormatCode = 11	-- Corporate 1000 48 Bit
	BEGIN
		select @parts = Parts FROM GCS.CredentialCorporate1K48Bit WHERE CredentialUid = @CredentialUid
	END
	ELSE IF @credentialFormatCode = 12	-- Cypress 37 Bit
	BEGIN
		select @parts = Parts FROM GCS.CredentialCypress37Bit WHERE CredentialUid = @CredentialUid
	END
	ELSE IF @credentialFormatCode = 13	-- H10304 37 Bit
	BEGIN
		select @parts = Parts FROM GCS.CredentialH1030437Bit WHERE CredentialUid = @CredentialUid
	END
	ELSE IF @credentialFormatCode = 14	-- H10302 37 Bit
	BEGIN
		select @parts = Parts FROM GCS.CredentialH1030237Bit WHERE CredentialUid = @CredentialUid
	END
	ELSE IF @credentialFormatCode = 15	-- Sofware House 37 Bit
	BEGIN
		select @parts = Parts FROM GCS.CredentialSoftwareHouse37Bit WHERE CredentialUid = @CredentialUid
	END

	return @parts
END;
GO



if dbo.fn_GCSDoesColumnExist('Credential', 'Parts') = 0
BEGIN
	ALTER TABLE GCS.Credential
	ADD Parts as ([GCS].[GetCredentialParts](CredentialUid))
END
GO

CREATE OR ALTER FUNCTION dbo.IsEmailAddress (@Email NVARCHAR(MAX))
RETURNS BIT WITH EXECUTE AS CALLER
AS
BEGIN
    DECLARE @IsValid BIT = 0;
    
    -- Check if the string contains exactly one "@" character
    IF LEN(@Email) - LEN(REPLACE(@Email, '@', '')) = 1
    BEGIN
        -- Split the email address into local part and domain part
        DECLARE @LocalPart NVARCHAR(MAX);
        DECLARE @DomainPart NVARCHAR(MAX);
        
        SET @LocalPart = LEFT(@Email, CHARINDEX('@', @Email) - 1);
        SET @DomainPart = RIGHT(@Email, LEN(@Email) - CHARINDEX('@', @Email));
        
        -- Check if the local and domain parts are not empty and do not contain invalid characters
        IF LEN(@LocalPart) > 0
            AND LEN(@DomainPart) > 0
            AND CHARINDEX(' ', @LocalPart) = 0
            AND CHARINDEX(' ', @DomainPart) = 0
            AND CHARINDEX('..', @Email) = 0
            AND CHARINDEX('.', @DomainPart) > 1
            AND RIGHT(@DomainPart, 1) != '.'
        BEGIN
            SET @IsValid = 1;
        END
    END
    
    RETURN @IsValid;
END
GO


CREATE OR ALTER FUNCTION dbo.IsPhoneNumber (@Phone NVARCHAR(MAX))
RETURNS BIT WITH EXECUTE AS CALLER
AS
BEGIN
    DECLARE @IsValid BIT = 0;
	DECLARE @pos int = 0
	SELECT @pos = PATINDEX('%[^+()0123456789[-]]%', @Phone); 
	if @pos = 0
		set @IsValid = 1  
    RETURN @IsValid;
END
GO

if dbo.[fn_GCSDoesIndexExist]('Person', 'idxPersonEntity') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonEntity                                       */
	/*==============================================================*/
	create nonclustered index idxPersonEntity on GCS.Person (EntityId ASC)
END
go

if dbo.[fn_GCSDoesIndexExist]('Person', 'idxPersonDepartment') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonDepartment                                   */
	/*==============================================================*/
	create nonclustered index idxPersonDepartment on GCS.Person (DepartmentUid ASC)
END
GO

if dbo.[fn_GCSDoesIndexExist]('Person', 'idxPersonRecordType') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonRecordType                                   */
	/*==============================================================*/
	create nonclustered index idxPersonRecordType on GCS.Person (PersonRecordTypeUid ASC)
END
GO

if dbo.[fn_GCSDoesIndexExist]('Person', 'idxPersonLastName') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonLastName                                     */
	/*==============================================================*/
	create nonclustered index idxPersonLastName on GCS.Person (LastName ASC)
END
GO

if dbo.[fn_GCSDoesIndexExist]('Person', 'idxPersonGender') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonGender                                       */
	/*==============================================================*/
	create nonclustered index idxPersonGender on GCS.Person (GenderUid ASC)
END
GO

if dbo.[fn_GCSDoesIndexExist]('Person', 'idxPersonFirstName') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonFirstName                                    */
	/*==============================================================*/
	create nonclustered index idxPersonFirstName on GCS.Person (FirstName ASC)
END
GO

if dbo.[fn_GCSDoesIndexExist]('Person', 'idxPersonDob') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonDob                                          */
	/*==============================================================*/
	create nonclustered index idxPersonDob on GCS.Person (DateOfBirth ASC)
END
GO

if dbo.[fn_GCSDoesIndexExist]('Person', 'idxPersonActivationDate') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonActivationDate                               */
	/*==============================================================*/
	create nonclustered index idxPersonActivationDate on GCS.Person (ActivationDateTime ASC)
END
GO

if dbo.[fn_GCSDoesIndexExist]('Person', 'idxPersonExpirationDate') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonExpirationDate                               */
	/*==============================================================*/
	create nonclustered index idxPersonExpirationDate on GCS.Person (ExpirationDateTime ASC)
END
GO


if dbo.[fn_GCSDoesIndexExist]('PersonAccessControlProperties', 'idxPersonAccessProfile') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonAccessProfile                                */
	/*==============================================================*/
	create nonclustered index idxPersonAccessProfile on GCS.PersonAccessControlProperties (AccessProfileUid ASC)
END
go


if dbo.[fn_GCSDoesIndexExist]('PersonAccessControlProperties', 'idxPersonCanToggleLock') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonCanToggleLock                                */
	/*==============================================================*/
	create nonclustered index idxPersonCanToggleLock on GCS.PersonAccessControlProperties (CanToggleLockState ASC)
END
go

if dbo.[fn_GCSDoesIndexExist]('PersonClusterPermission', 'idxPersonCluster') = 0
BEGIN
	/*==============================================================*/
	/* Index: idxPersonCluster                                      */
	/*==============================================================*/
	create nonclustered index idxPersonCluster on GCS.PersonClusterPermission (ClusterUid ASC)
END
go

CREATE OR ALTER PROCEDURE [GCS].[PersonUid_GetListByPersonValuesWithParamsEx]
	@EntityId [uniqueidentifier],
	@QueryText nvarchar(255) = null,
	@DepartmentUids nvarchar(1000) = null,
	@AccessProfileUids nvarchar(1000) = null,
	@ClusterUids nvarchar(1000) = null,
	@PersonRecordTypeUids nvarchar(1000) = null,
	@PersonIds nvarchar(1000) = null,
	@Gender nvarchar(100) = null,
	@DateOfBirth date = null,
	@IsActive bit = null,
	@ActivationStart datetimeoffset = null,
	@ActivationEnd datetimeoffset = null,
	@ExpirationStart datetimeoffset = null,
	@ExpirationEnd datetimeoffset = null,
	@WithCredentials bit = null,
	@CanToggleLock bit = null,
	@CredentialNumbers nvarchar(100) = null,
	--@ExactMatch [smallint] = 0,
	--@AnywhereWithin [smallint] = 0,
	--@OrNotAnd [smallint] = 0,
	@MaximumResults [int] = 0,
	@PageNumber [int] = 0,
	@PageSize [int] = 0,
	@DateComparisonType [nvarchar](20) = '=',
	@OrderBy nvarchar(255) = 'LastName asc, FirstName asc'
WITH EXECUTE AS CALLER
AS
DECLARE @sql nvarchar(max)
DECLARE @tempSql nvarchar(max)
DECLARE @Column nvarchar(255)
DECLARE @Value nvarchar(255)
DECLARE @searchByPersonCredentialColumn smallint 
DECLARE @whereAdded smallint
DECLARE @whereClause nvarchar(max)
DECLARE @pagingSqlClause nvarchar(200)

	BEGIN TRY
	
	create table #personUids
	(
		PersonUid uniqueidentifier
	)

	SET @whereAdded = 0
	SET @whereClause = ''
	
	if @PageSize is not null AND @PageSize > 0 AND ( @MaximumResults IS NULL OR @MaximumResults = 0 )
	BEGIN
		DECLARE @pagedOffset int
		select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
		set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY'
	END
	ELSE
		SET @pagingSqlClause = N''


	if @OrderBy is null or len(@OrderBy) = 0
	begin
		set @OrderBy = 'LastName asc, FirstName asc'
	end

    SET @sql = N'SELECT'
	IF @MaximumResults IS NOT NULL AND @MaximumResults > 0 AND @pagingSqlClause = ''
		SET @sql = @sql + N' TOP(' + CAST(@MaximumResults AS NVARCHAR) + ')' 

    SET @sql = @sql + N' PersonUid, LastName, FirstName, InsertDate, UpdateDate, COUNT(*) OVER() as TotalCardCount'
    SET @sql = @sql + N' FROM GCS.Person p WHERE p.EntityId = ''' + cast(@EntityId as nvarchar(50)) + ''''
	--SET @sql = @sql + N' (SELECT DISTINCT(p.PersonUid) FROM GCS.Person p'
	SET @sql = @sql + N' AND PersonUid IN (SELECT DISTINCT(PersonUid) FROM #personUids )'

	-- @QueryText processing
	if @QueryText IS NOT NULL AND LEN(@QueryText) > 0
	BEGIN
		create table #queryTextPersonUids
		(
			PersonUid uniqueidentifier
		)
		--declare @queryTextPersonUids table
		--(
		--	PersonUid uniqueidentifier
		--)

		-- Start with selecting PersonUids based on QueryText parameter
		declare @qValues table
		( 
			v nvarchar(255),
			t nvarchar(10)
		)

		insert into @qValues (v, t) select NVARCHAR_DATA, '' from dbo.fnSPLIT_nVARCHAR (@QueryText, ' ')

		update @qValues set t = 'name'
		update @qValues set t = 'phone' where v like '%+%'
		--update @qValues set t = 'email' where v like '%@%.%'
	
		declare @lnamewhere nvarchar(max) = ''
		declare @fnamewhere nvarchar(max) = ''
		declare @emailwhere nvarchar(max) = ''
		declare @phonewhere nvarchar(max) = ''

		declare @v nvarchar(255)
		declare @t nvarchar(10)
		declare @count int = 0
		declare @emailCount int = 0
		declare @phoneCount int = 0


		declare valueCursor CURSOR LOCAL FOR 
				SELECT v, t FROM @qValues

		OPEN valueCursor
		FETCH NEXT FROM valueCursor INTO @v, @t
		WHILE @@FETCH_STATUS = 0
		BEGIN
		
			if dbo.IsEmailAddress(@v) = 1
			begin
				set @t = 'email'
			end
			else if dbo.IsPhoneNumber(@v) = 1
			begin
				set @t = 'phone'
			end

			if @count > 0
			begin
				SET @lnamewhere = @lnamewhere + ' OR '
				SET @fnamewhere = @fnamewhere + ' OR '
			end

			if @emailCount > 0 and @t = 'email'
			BEGIN
				SET @emailwhere = @emailwhere + ' OR '
			END

			if @phoneCount > 0 and @t = 'phone'
			BEGIN
				SET @phonewhere = @phonewhere + ' OR '
			END

			SET @lnamewhere = @lnamewhere + N'LastName LIKE ''%' + @v + '%'''
			SET @fnamewhere = @fnamewhere + N'FirstName LIKE ''%' + @v + '%'''


			if @t = 'email'
			begin
				SET @emailwhere = @emailwhere + N'EmailAddress LIKE ''%' + @v + '%'''
				set @emailCount = @emailCount + 1
			end

			if @t = 'phone'
			begin
				SET @phonewhere = @phonewhere + N'PhoneNumber LIKE ''%' + @v + '%'''
				set @phoneCount = @phoneCount + 1
			end
		
			set @count = @count + 1

			FETCH NEXT FROM valueCursor INTO @v, @t
		END
		CLOSE valueCursor;
		DEALLOCATE valueCursor;

		set @tempSql = N'insert into #queryTextPersonUids (PersonUid) select distinct(p.PersonUid) from GCS.Person p '
		IF @emailCount > 0
		BEGIN
			set @tempSql = @tempSql + ' LEFT OUTER JOIN GCS.PersonEmailAddress pem on pem.PersonUid = p.PersonUid'
		END
		IF @phoneCount > 0
		BEGIN
			set @tempSql = @tempSql + ' LEFT OUTER JOIN GCS.PersonPhoneNumber ppn on ppn.PersonUid = p.PersonUid'
		END

		set @tempSql = @tempSql + N' where p.EntityId = ''' + cast(@entityId as nvarchar(40)) + ''' AND  ((' + @lnamewhere + ') OR (' + @fnamewhere + ')'
		IF @emailCount > 0
		BEGIN
			set @tempSql = @tempSql + ' OR (' + @emailwhere + ')'
		END

		IF @phoneCount > 0
		BEGIN
			set @tempSql = @tempSql + ' OR (' + @phonewhere+ ')'
		END
		
		set @tempSql = @tempSql + N')'

		print @tempSql
		-- Insert PersonUid values into table variable @@queryTextPersonUids
		--insert into @queryTextPersonUids exec sp_sqlexec @tempSql
		exec sp_sqlexec @tempSql
	
		-- Add into the main @personUids variable
		if ( select count(*) from #queryTextPersonUids) > 0 
		begin
			insert into #personUids (PersonUid) 
			SELECT PersonUid from #queryTextPersonUids
		end
	END
	ELSE
	BEGIN
		set @QueryText = N'*'
		insert into #personUids (PersonUid) 
		SELECT PersonUid from GCS.Person where EntityId = @EntityId
	END


	if @DepartmentUids is not null and LEN(@DepartmentUids) > 0
	BEGIN
		declare @departmentPersonUids table
		(
			PersonUid uniqueidentifier
		)

		declare @deptUids table
		( 
			uniqueid uniqueidentifier
		)

		insert into @deptUids (uniqueid) (select UID_DATA from dbo.fnSPLIT_UNIQUEIDENTIFIER (@DepartmentUids, ','))

		insert into @departmentPersonUids (PersonUid) (select distinct(PersonUid) from GCS.Person where DepartmentUid in (select uniqueid from @deptUids) and EntityId = @EntityId)

		-- Add into the main @personUids variable
		if (select count(*) from @departmentPersonUids) > 0 
		begin
			if @QueryText IS NOT NULL AND LEN(@QueryText) > 0
			BEGIN -- delete all personUids from #personUids that do not match the department. This will treat the departments and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @departmentPersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match departments
				insert into #personUids (PersonUid) 
				SELECT PersonUid from @departmentPersonUids where PersonUid not in (select PersonUid from #personUids)
			END
		end
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @departmentPersonUids)
		end
	END

	
	if @AccessProfileUids is not null and LEN(@AccessProfileUids) > 0
	BEGIN
		declare @accessProfilePersonUids table
		(
			PersonUid uniqueidentifier
		)

		declare @apUids table
		( 
			uniqueid uniqueidentifier
		)

		insert into @apUids (uniqueid) (select UID_DATA from dbo.fnSPLIT_UNIQUEIDENTIFIER (@AccessProfileUids, ','))

		insert into @accessProfilePersonUids (PersonUid) (select distinct(t.PersonUid) from GCS.PersonAccessControlProperties t join GCS.Person p on p.PersonUid = t.PersonUid where AccessProfileUid in (select uniqueid from @apUids) and p.EntityId = @EntityId)
		
		-- Add into the main @personUids variable
		if (select count(*) from @accessProfilePersonUids) > 0 
		begin
			if ((@QueryText IS NOT NULL AND LEN(@QueryText) > 0) OR (SELECT COUNT(*) FROM #personUids) > 0)
			BEGIN -- delete all personUids from #personUids that do not match the access profile. This will treat the access profiles and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @accessProfilePersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match access profiles
				insert into #personUids (PersonUid) 
				SELECT PersonUid from @accessProfilePersonUids where PersonUid not in (select PersonUid from #personUids)
			END
		end
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @accessProfilePersonUids)
		end
	END
		
	if @ClusterUids is not null and LEN(@ClusterUids) > 0
	BEGIN
		declare @clusterPersonUids table
		(
			PersonUid uniqueidentifier
		)

		declare @clustUids table
		( 
			uniqueid uniqueidentifier
		)

		insert into @clustUids (uniqueid) (select UID_DATA from dbo.fnSPLIT_UNIQUEIDENTIFIER (@ClusterUids, ','))

		insert into @clusterPersonUids (PersonUid) (select distinct(t.PersonUid) from GCS.PersonClusterPermission t join GCS.Person p on p.PersonUid = t.PersonUid where ClusterUid in (select uniqueid from @clustUids) and p.EntityId = @EntityId)
		
		-- Add into the main @personUids variable
		if (select count(*) from @clusterPersonUids) > 0 
		begin
			if ((@QueryText IS NOT NULL AND LEN(@QueryText) > 0) OR (SELECT COUNT(*) FROM #personUids) > 0)
			BEGIN -- delete all personUids from #personUids that do not match the cluster. This will treat the clusters and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @clusterPersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match clusters
				insert into #personUids (PersonUid) 
				SELECT PersonUid from @clusterPersonUids where PersonUid not in (select PersonUid from #personUids)
			END
		end	
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @clusterPersonUids)
		end
	END
		
	if @PersonRecordTypeUids is not null and LEN(@PersonRecordTypeUids) > 0
	BEGIN
		declare @recordTypePersonUids table
		(
			PersonUid uniqueidentifier
		)

		declare @typeUids table
		( 
			uniqueid uniqueidentifier
		)

		insert into @typeUids (uniqueid) (select UID_DATA from dbo.fnSPLIT_UNIQUEIDENTIFIER (@PersonRecordTypeUids, ','))

		insert into @recordTypePersonUids (PersonUid) (select distinct(PersonUid) from GCS.Person p where PersonRecordTypeUid in (select uniqueid from @typeUids) and EntityId = @EntityId)
		
		-- Add into the main @personUids variable
		if (select count(*) from @recordTypePersonUids) > 0 
		begin
			if ((@QueryText IS NOT NULL AND LEN(@QueryText) > 0) OR (SELECT COUNT(*) FROM #personUids) > 0)
			BEGIN -- delete all personUids from #personUids that do not match the record type. This will treat the record type and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @recordTypePersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match record type
				insert into #personUids (PersonUid) 
				SELECT PersonUid from @recordTypePersonUids where PersonUid not in (select PersonUid from #personUids)
			END
		end
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @recordTypePersonUids)
		end
	END
		
	if @PersonIds is not null and LEN(@PersonIds) > 0
	BEGIN
		declare @pidPersonUids table
		(
			PersonUid uniqueidentifier
		)

		declare @personId table
		( 
			uniqueid nvarchar(65)
		)

		insert into @typeUids (uniqueid) (select NVARCHAR_DATA from dbo.fnSPLIT_nVARCHAR (@PersonRecordTypeUids, ','))

		insert into @pidPersonUids (PersonUid) (select distinct(PersonUid) from GCS.Person p where PersonId in (select uniqueid from @typeUids) and EntityId = @EntityId)
		
		-- Add into the main #personUids variable
		if (select count(*) from @pidPersonUids) > 0 
		begin
			if ((@QueryText IS NOT NULL AND LEN(@QueryText) > 0) OR (SELECT COUNT(*) FROM #personUids) > 0)
			BEGIN -- delete all personUids from #personUids that do not match the personId. This will treat the personId and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @pidPersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match record type
				insert into #personUids (PersonUid) 
				SELECT PersonUid from @pidPersonUids where PersonUid not in (select PersonUid from #personUids)
			END
		end
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @pidPersonUids)
		end
	END

	if @IsActive is not null
	BEGIN
		declare @isActivePersonUids table
		(
			PersonUid uniqueidentifier
		)

		if @IsActive = 1
			insert into @isActivePersonUids (PersonUid) (select distinct(PersonUid) from GCS.Person p where ActiveStatusCode = 1 and EntityId = @EntityId)
		else
			insert into @isActivePersonUids (PersonUid) (select distinct(PersonUid) from GCS.Person p where ActiveStatusCode <> 1 and EntityId = @EntityId)
		
		-- Add into the main #personUids variable
		if (select count(*) from @isActivePersonUids) > 0 
		begin
			if ((@QueryText IS NOT NULL AND LEN(@QueryText) > 0) OR (SELECT COUNT(*) FROM #personUids) > 0)
			BEGIN -- delete all personUids from #personUids that do not match the is active. This will treat the is active and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @isActivePersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match is active
				insert into #personUids (PersonUid) 
				SELECT PersonUid from @isActivePersonUids where PersonUid not in (select PersonUid from #personUids)
			END
		end
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @isActivePersonUids)
		end
	END

	if @DateOfBirth is not null
	BEGIN
		declare @dobPersonUids table
		(
			PersonUid uniqueidentifier
		)

		insert into @dobPersonUids (PersonUid) (select distinct(PersonUid) from GCS.Person p where DateOfBirth = @DateOfBirth and EntityId = @EntityId)
		
		-- Add into the main #personUids variable
		if (select count(*) from @dobPersonUids) > 0 
		begin
			if ((@QueryText IS NOT NULL AND LEN(@QueryText) > 0) OR (SELECT COUNT(*) FROM #personUids) > 0)
			BEGIN -- delete all personUids from #personUids that do not match the dob. This will treat the is active and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @dobPersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match dob
				insert into #personUids (PersonUid) 
				SELECT PersonUid from @dobPersonUids where PersonUid not in (select PersonUid from #personUids)
			END
		end
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @dobPersonUids)
		end
	END

	if @Gender is not null
	BEGIN
		declare @genderPersonUids table
		(
			PersonUid uniqueidentifier
		)

		insert into @genderPersonUids (PersonUid) (select distinct(PersonUid) from GCS.Person p join GCS.Gender g on g.GenderUid = p.GenderUid where GenderCode like @Gender + '%' and p.EntityId = @EntityId)
		
		-- Add into the main #personUids variable
		if (select count(*) from @genderPersonUids) > 0 
		begin
			if ((@QueryText IS NOT NULL AND LEN(@QueryText) > 0) OR (SELECT COUNT(*) FROM #personUids) > 0)
			BEGIN -- delete all personUids from #personUids that do not match the dob. This will treat the gender and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @genderPersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match gender
				insert into #personUids (PersonUid) 
				SELECT PersonUid from @genderPersonUids where PersonUid not in (select PersonUid from #personUids)
			END
		end
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @genderPersonUids)
		end
	END

	if @WithCredentials is not null
	BEGIN
		declare @withCredentialsPersonUids table
		(
			PersonUid uniqueidentifier
		)

		if @WithCredentials = 1
			insert into @withCredentialsPersonUids (PersonUid) (select distinct(p.PersonUid) from GCS.PersonCredential pc join GCS.Person p on p.PersonUid = pc.PersonUid where p.EntityId = @EntityId)
		else
			insert into @withCredentialsPersonUids (PersonUid) (select distinct(p.PersonUid) from GCS.Person p where p.EntityId = @EntityId and p.PersonUid not in (select distinct(pc.PersonUid) from GCS.PersonCredential pc join GCS.Person p on p.PersonUid = pc.PersonUid where p.EntityId = @EntityId))

		-- Add into the main #personUids variable
		if (select count(*) from @withCredentialsPersonUids) > 0 
		begin
			if ((@QueryText IS NOT NULL AND LEN(@QueryText) > 0) OR (SELECT COUNT(*) FROM #personUids) > 0)
			BEGIN -- delete all personUids from #personUids that do not match the dob. This will treat the with credentials and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @withCredentialsPersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match with credentials
				insert into #personUids (PersonUid) 
				SELECT PersonUid from @withCredentialsPersonUids where PersonUid not in (select PersonUid from #personUids)
			END
		end
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @withCredentialsPersonUids)
		end
	END
			
	if @CanToggleLock is not null
	BEGIN
		declare @canToggleLockPersonUids table
		(
			PersonUid uniqueidentifier
		)

		insert into @canToggleLockPersonUids (PersonUid) (select distinct(pacp.PersonUid) from GCS.PersonAccessControlProperties pacp join GCS.Person p on p.PersonUid = pacp.PersonUid where pacp.CanToggleLockState = @CanToggleLock AND p.EntityId = @EntityId)
		
		-- Add into the main #personUids variable
		if (select count(*) from @canToggleLockPersonUids) > 0 
		begin
			if ((@QueryText IS NOT NULL AND LEN(@QueryText) > 0) OR (SELECT COUNT(*) FROM #personUids) > 0)
			BEGIN -- delete all personUids from #personUids that do not match the dob. This will treat the can toggle and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @canToggleLockPersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match can toggle
				insert into #personUids (PersonUid) 
				SELECT PersonUid from @canToggleLockPersonUids where PersonUid not in (select PersonUid from #personUids)
			END
		end
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @canToggleLockPersonUids)
		end
	END

	IF @ActivationStart IS NOT NULL OR @ActivationEnd IS NOT NULL OR @ExpirationStart IS NOT NULL OR @ExpirationEnd IS NOT NULL
	BEGIN
		DECLARE @whereSql nvarchar(1000) = ''
		SET @tempSql = N'SELECT DISTINCT(PersonUid) FROM GCS.Person WHERE EntityId = ''' + cast(@EntityId as nvarchar(40)) + ' AND '
		IF @ActivationStart IS NOT NULL
		BEGIN
			SET @whereSql = N'ActivationDateTime >= ''' + cast(@ActivationStart as nvarchar) + ''
		END

		IF @ActivationEnd IS NOT NULL
		BEGIN
			IF LEN(@whereSql) > 0
				SET @whereSql = @whereSql + N' AND '
			SET @whereSql = @whereSql + N'ActivationDateTime <= ''' + cast(@ActivationEnd as nvarchar) + ''
		END

		IF @ExpirationStart IS NOT NULL
		BEGIN
			SET @whereSql = N'ExpirationStart >= ''' + cast(@ExpirationStart as nvarchar) + ''
		END

		IF @ExpirationEnd IS NOT NULL
		BEGIN
			IF LEN(@whereSql) > 0
				SET @whereSql = @whereSql + N' AND '
			SET @whereSql = @whereSql + N'ExpirationEnd <= ''' + cast(@ExpirationEnd as nvarchar) + ''
		END

		SET @tempSql = CONCAT(@tempSql, @whereSql)
	
		print @tempSql

		declare @activationExpirationPersonUids table
		(
			PersonUid uniqueidentifier
		)
		
		-- Insert PersonUid values into table variable @actExpPersonUids
		insert into @activationExpirationPersonUids exec sp_sqlexec @tempSql
		
		-- Add into the main #personUids variable
		if (select count(*) from @activationExpirationPersonUids) > 0 
		begin
			if ((@QueryText IS NOT NULL AND LEN(@QueryText) > 0) OR (SELECT COUNT(*) FROM #personUids) > 0)
			BEGIN -- delete all personUids from #personUids that do not match the dob. This will treat the act/exp and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @activationExpirationPersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match act/exp
				insert into #personUids (PersonUid) SELECT PersonUid from @activationExpirationPersonUids
			END
		end
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @activationExpirationPersonUids)
		end
	END

	IF @CredentialNumbers IS NOT NULL AND LEN(@CredentialNumbers) > 0
	BEGIN
		declare @credentialNumbersPersonUids table
		(
			PersonUid uniqueidentifier
		)

		insert into @credentialNumbersPersonUids (PersonUid) (select distinct(pc.PersonUid) from GCS.PersonCredential pc join GCS.Person p on p.PersonUid = pc.PersonUid join GCS.Credential c on c.CredentialUid = pc.CredentialUid
		where c.Parts like '%' + @CredentialNumbers + '%' AND p.EntityId = @EntityId)
		
		-- Add into the main #personUids variable
		if (select count(*) from @credentialNumbersPersonUids) > 0 
		begin
			if ((@QueryText IS NOT NULL AND LEN(@QueryText) > 0) OR (SELECT COUNT(*) FROM #personUids) > 0)
			BEGIN -- delete all personUids from #personUids that do not match the dob. This will treat the credential # and QueryText with an AND relationship
				delete from #personUids where PersonUid not in (select PersonUid from @credentialNumbersPersonUids)
			END
			ELSE
			BEGIN	-- IF QueryText is not specified, then add all persons who match credential #
			insert into #personUids (PersonUid) 
			SELECT PersonUid from @credentialNumbersPersonUids where PersonUid not in (select PersonUid from #personUids)
			END
		end
		else
		begin
			delete from #personUids where PersonUid not in (select PersonUid from @credentialNumbersPersonUids)
		end
	END
	
    SET @sql = @sql + ' ORDER BY '
    
    SET @sql = @sql + @OrderBy
    
	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @sql = @sql + @pagingSqlClause
	END
	
    print @sql
    execute sp_executesql @sql 

	--select * from @personUids
	--select '00000000-0000-0000-0000-000000000002' as PersonUid
	END TRY
	BEGIN CATCH
		exec [usp_GetErrorInfo] 0,1
	END CATCH			

GO
ALTER AUTHORIZATION ON [GCS].[PersonUid_GetListByPersonValuesWithParamsEx] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonUid_GetListByPersonValuesWithParamsEx] TO [public] AS [dbo]
GO



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'GCS.[PersonSummary_SearchWithParamsEx]') AND type in (N'P', N'PC'))
DROP PROCEDURE GCS.[PersonSummary_SearchWithParamsEx]
GO
/****** Object:  StoredProcedure [GCS].[PersonSummary_SearchWithParamsEx]    Script Date: 8/31/2020 2:22:24 PM ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER PROCEDURE [GCS].[PersonSummary_SearchWithParamsEx]
	@EntityId [uniqueidentifier],
	@QueryText nvarchar(255),
	@DepartmentUids nvarchar(1000),
	@AccessProfileUids nvarchar(1000),
	@ClusterUids nvarchar(1000),
	@PersonRecordTypeUids nvarchar(1000),
	@PersonIds nvarchar(1000),
	@Gender nvarchar(100),
	@DateOfBirth date,
	@IsActive bit,
	@ActivationStart datetimeoffset,
	@ActivationEnd datetimeoffset,
	@ExpirationStart datetimeoffset,
	@ExpirationEnd datetimeoffset,
	@WithCredentials bit,
	@CanToggleLock bit,
	@CredentialNumbers nvarchar(100),
	--@ExactMatch [smallint] = 0,
	--@AnywhereWithin [smallint] = 0,
	--@OrNotAnd [smallint] = 0,
	@OrderBy [nvarchar](1000) = 'LastName asc, FirstName asc',
	@MaximumResults [int] = 0,
	@PageNumber [int] = 0,
	@PageSize [int] = 0,
	@DateComparisonType [nvarchar](20) = '=',
	@CultureName [nvarchar](20) = NULL,
	@IncludeLastUsageData bit = 0
WITH EXECUTE AS CALLER
AS
DECLARE @sql nvarchar(max)

DECLARE @pagingSqlClause nvarchar(200)

	if @PageSize is not null AND @PageSize > 0 AND ( @MaximumResults IS NULL OR @MaximumResults = 0 )
	BEGIN
		DECLARE @pagedOffset int
		select @pagedOffset = dbo.[fn_CalculatePagedOffset]( @PageNumber, @PageSize)
		set @pagingSqlClause = N' OFFSET ' + CAST(@pagedOffset as nvarchar) + ' ROWS FETCH NEXT ' + CAST(@PageSize as nvarchar) + ' ROWS ONLY '
	END
	ELSE
		SET @pagingSqlClause = N''

CREATE TABLE #PersonUids
( 
	ID INT IDENTITY(1, 1),
    PersonUid uniqueidentifier,
	LastName nvarchar(65),
	FirstName nvarchar(65),
	InsertDate datetimeoffset,
	UpdateDate datetimeoffset,
	TotalCardCount int
)

CREATE TABLE #PersonUidsPaged
( 
    PersonUid uniqueidentifier,
	LastName nvarchar(65),
	FirstName nvarchar(65),
	InsertDate datetimeoffset,
	UpdateDate datetimeoffset,
	TotalCardCount int
)

    IF @OrderBy IS NULL OR LEN(@OrderBy) = 0
    BEGIN
		SET @OrderBy = 'LastName asc, FirstName asc'
	END

	insert into #PersonUids (PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount)
	exec GCS.[PersonUid_GetListByPersonValuesWithParamsEx] @EntityId,@QueryText,@DepartmentUids,@AccessProfileUids,@ClusterUids,@PersonRecordTypeUids,@PersonIds,@Gender,@DateOfBirth,@IsActive,@ActivationStart,@ActivationEnd,@ExpirationStart,@ExpirationEnd,@WithCredentials,@CanToggleLock,@CredentialNumbers, @MaximumResults, 0, 0, @DateComparisonType, @OrderBy


	if LEN(@pagingSqlClause) > 0
	BEGIN
		set @sql = N'insert into #PersonUidsPaged (PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount) SELECT PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount FROM #PersonUids ORDER BY ' + @OrderBy + @pagingSqlClause
	END
	ELSE
	BEGIN
		set @sql = N'insert into #PersonUidsPaged (PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount) SELECT PersonUid, LastName, FirstName, InsertDate, UpdateDate, TotalCardCount FROM #PersonUids ORDER BY ' + @OrderBy 
	END
	print @sql
	execute sp_executesql @sql 
	 
	-- -- For debugging only
	--set @sql = N'SELECT * FROM #PersonUidsPaged ORDER BY ' + @OrderBy 
	--execute sp_executesql @sql 

	IF @CultureName IS NULL OR LEN(@CultureName) = 0 SET @CultureName = 'en-US'

	declare @languageId uniqueidentifier
	select @languageId = LanguageId from GCS.gcsLanguage where CultureName = @CultureName

    SET @sql = N'SELECT'
	IF @MaximumResults IS NOT NULL AND @MaximumResults > 0 AND @pagingSqlClause = ''
		SET @sql = @sql + N' DISTINCT TOP(' + CAST(@MaximumResults AS NVARCHAR) + ')' 

    --SET @sql = @sql + N' p.PersonUid, PersonId, FirstName, MiddleName, LastName, NickName, LegalName, FullName, PreferredName, Company, Trace, VeryImportantPerson, HasPhysicalDisability, e.EntityName, d.DepartmentName, p.EntityId, ActivationDateTime, ExpirationDateTime, p.InsertName, p.InsertDate, p.UpdateName, p.UpdateDate, p.SysGalEmployeeId, [GCS].[IsPersonActive](p.PersonUid) as IsPersonActive' 
	  SET @sql = @sql + N' p.PersonUid, PersonId, FirstName, MiddleName, LastName, NickName, LegalName, FullName, PreferredName, Company, Trace, VeryImportantPerson, HasPhysicalDisability, e.EntityName, d.DepartmentName, p.EntityId, p.ActivationDateTime, p.ExpirationDateTime, p.InsertName, p.InsertDate, p.UpdateName, p.UpdateDate, p.SysGalEmployeeId, [GCS].[GetPersonActiveStatusCode](p.PersonUid) as ActiveStatusCode' 

	if @IncludeLastUsageData = 1
	BEGIN
		SET @sql = @sql + N', ev1.ActivityDateTime as LastUsageActivityDateTime, ap.PortalName as LastUsageAccessPortal, ap.ClusterName as LastUsageClusterName, ap.SiteName as LastUsageSiteName, ap.EntityName as LastUsageEntityName, pcred.CredentialDescription as LastCredentialName'
	END
	ELSE
	BEGIN
		SET @sql = @sql + N', SYSDATETIMEOFFSET() as LastUsageActivityDateTime, '''' as LastUsageAccessPortal, '''' as LastUsageClusterName, '''' as LastUsageSiteName, '''' as LastUsageEntityName, '''' as LastCredentialName'
	END

    SET @sql = @sql + N' ,CASE WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = st.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(40)) + ''')'
	SET @sql = @sql + N' IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = st.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(40)) + ''')'
	SET @sql = @sql + N' WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = st.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = st.DisplayResourceKey) ELSE st.Display END AS ActiveStatus'
	SET @sql = @sql + N' ,CASE WHEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = rt.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(40)) + ''')'
	SET @sql = @sql + N' IS NOT NULL THEN (select StringValue from gcs.gcsResourceStringLanguage where ResourceId = rt.DisplayResourceKey AND LanguageId = ''' + cast(@languageId as nvarchar(40)) + ''')'
	SET @sql = @sql + N' WHEN (select DefaultValue from gcs.gcsResourceString where ResourceId = rt.DisplayResourceKey) IS NOT NULL THEN (select DefaultValue from gcs.gcsResourceString where ResourceId = rt.DisplayResourceKey) ELSE rt.Display END AS RecordType '

	SET @sql = @sql + N' , ''All Records'' AS SearchField'

	--IF @SearchByColumnName1 IS NOT NULL AND @SearchByColumnName1 NOT IN ('RecentlyAddedOrModified', 'ByCredentialFieldValues', 'ByCredentialNumber', 'ByCredentialFieldValue', 'ByAccessProfileUid')
	--BEGIN
	--	IF @SearchByColumnName1 IS NULL OR LEN(@SearchByColumnName1) = 0
	--	BEGIN
	--		SET @sql = @sql + N' , ''All Records'' AS SearchField'
	--	END
	--	ELSE
	--	BEGIN
	--		declare @prefix nvarchar(100)
	--		set @prefix = 'GCS.PersonCredential'
	--		SELECT @SearchByColumnName1 = REPLACE(@SearchByColumnName1,@prefix,'pc');

	--		-- REPLACE ALL GCS.Person column prefixes with p
	--		set @prefix = 'GCS.Person'
	--		SELECT @SearchByColumnName1 = REPLACE(@SearchByColumnName1,@prefix,'p');

	--		SET @sql = @sql + N' ,' + @SearchByColumnName1 + N' AS ''SearchField'''
	--	END
	--END
	--ELSE
	--	SET @sql = @sql + N' , ''' + @SearchByColumnName1 + ''' AS SearchField'

    SET @sql = @sql + N' , COUNT(*) OVER() as TotalCardCount  '	
     
	SET @sql = @sql + N' INTO #TempTable   '	
    SET @sql = @sql + N' from GCS.Person p join GCS.gcsEntity e on e.EntityId = p.EntityId '
    SET @sql = @sql + N' left outer join GCS.Department d on d.DepartmentUid = p.DepartmentUid '
    SET @sql = @sql + N' left outer join GCS.PersonActiveStatusType st on st.PersonActiveStatusTypeUid = p.PersonActiveStatusTypeUid '
    SET @sql = @sql + N' left outer join GCS.PersonRecordType rt on rt.PersonRecordTypeUid = p.PersonRecordTypeUid'
	if @IncludeLastUsageData = 1
	BEGIN
		SET @sql = @sql + N' left outer join GCS.PersonLastUsage plu on plu.PersonUid = p.PersonUid'
		SET @sql = @sql + N' left outer join GCS.AccessPortalActivityEvent ev1 on ev1.AccessPortalActivityEventUid = plu.LastAccessGrantedAccessPortalActivityEventUid'
		SET @sql = @sql + N' left outer join GCS.AccessPortal_LocationData ap on ap.AccessPortalUid = ev1.AccessPortalUid'
		SET @sql = @sql + N' left outer join GCS.PersonCredential pcred on pcred.CredentialUid = ev1.CredentialUid AND pcred.PersonUid = p.PersonUid'
	END
    SET @sql = @sql + N' WHERE p.PersonUid IN '
	SET @sql = @sql + N' ( SELECT PersonUid from #PersonUidsPaged )'

--	PRINT @sql
 --   IF @ORDERBY IS NULL OR LEN(@ORDERBY) = 0
	--BEGIN
	--	SET @ORDERBY = 'LastName, FirstName'
	--END   
	 
    SET @sql = @sql + N' ORDER BY '
    SET @sql = @sql + @OrderBy
	
	SET @sql = @sql + N'; SELECT *, (select count(*) from #PersonUids) as TotalPersonCount from #tempTable ORDER BY '
    SET @sql = @sql + @OrderBy
	SET @sql = @sql + N';'
	SET @sql = @sql + N'drop table #tempTable;'

    print @sql

    execute sp_executesql @sql 
	
	DROP TABLE #PersonUidsPaged
	DROP TABLE #PersonUids
GO

ALTER AUTHORIZATION ON [GCS].[PersonSummary_SearchWithParamsEx] TO  SCHEMA OWNER 
GO
GRANT EXECUTE ON [GCS].[PersonSummary_SearchWithParamsEx] TO [public] AS [dbo]
GO








